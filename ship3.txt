e have
a b with x y one
and then let's output a little line and
do a b
with
x y
zero
so this gives us our arguments so this
these are simply
x one sorry a one and b1
a2
b
and 2
x1
x y 1 x 2 and b
and y 2 and the same thing in the at the
bottom
this encapsulates
a and b values together and x and y
values together and we really want to
consider them separately because the
condition is
that there are separately r overlaps
horizontally and vertically so the first
thing we'll we're going to do is we're
going to mix these to get
nice
matrices to work with
and then but we still have each row
being a mixture of horizontal and
vertical values we can fix that by
transposing
now that we have transposed we have
a1 a2
x1
x2
b1 b2 and y1 y2
we can start working on these and so
what exactly was it that was our
condition we're going to work on each
row separately so
let's use rank one
and then we're going to
start stating what exactly is it we're
looking for
so
for each row that means we're
considering uh the
horizontal component and the vertical
component and they're being run
separately because of the rank one so
you can just talk about one
um let's talk about the horizontal
component that's the x1 x2 a1 and a2
on the left we have
a1 a2 on the right we have y1
y2
so
the lowest sorry the lowest one
on the left
because remember we don't know what the
order is going to be so we can't just
say it should be
the first one which in our case is a1
and is the lowest one but maybe it's the
it's b
it's a two that's the smallest value
so we take the smallest one of those so
the smallest one of
of
a1 and a2
has to be
less than the greatest one
of the corresponding on the right which
is
x1 and
x2
so if the smallest one
on the left
is
below
the greatest one on the right then
then they might overlap
but that's not sufficient
because we also that they could both
both of them both a1 and a2 could be
below
x1 and x2 so we have to have an
additional condition which is
that
the lowest one
on the right
so that's the lowest one of x1 and x2
also has to be less than the highest one
of a1
and
a2
so now we know that
they overlap in this component and since
we're doing this for each row in our
matrices we're doing this separately for
the horizontal part and the vertical
part
and then
with the only thing we need to know then
is is it both true is there an overlap
horizontally is it an overlap
vertically so if both of these are true
then
there's an overlap and we can see here
that the a b x 1 x y 1
case gave us a 1 and the a b x y 0 case
gives us a 0 which is exactly what we'd
expect so this is one solution
but we can clean it up a bit
because think about it
we're using
we're doing things rank one on each row
and
after we transpose
so if we don't transpose
then we need to do things on each
column
instead and we can't do that with the
rank operator but we don't need to
because each
doing things down
so that's a reduction
vertically we can do that with reduce
first instead
so that's one simplification another
thing we can see is that there's a very
strong symmetry here the component on
the right of the inner end and the
component on the left of the inner end
in this fork
are pretty much identical
except one thing
this points to the right this points to
the left this points to the left and
this points to the right
so
they're doing the same thing but they're
swapping
their arguments
and so if we give a name
to this inner component
then
on the left we can just use it with
swapped arguments
and we can even get rid of
these parentheses here
so this is a very nice solution to the
problem
let's
go for an entirely different one
this time we'll start writing a
different
and again we just start off by
just opposing the arguments
oops
of course we need to put
g over here as well
there we go okay so here are our
arguments um again
and instead of doing this whole mixing
thing
now we're just going to use an outer
product
because we want to compare all these
values and see which ones are
um are
below each other
so this is this is an outer product
between the pairs
of
a1
b1
with
x1
and y1
so this is saying
so for each one of these comparisons
we get these two values one for the
for the horizontal component one for the
vertical component so this is saying
that a1
is less than
x1
and
b1 is not less than
y1
and this is saying that
a1 is
less than
x2
and b1 is also less than
y2
and then we go on to the next
a b coordinate so that's a2 is not less
than
x1
and y
and b2
is not less than
y1
and finally
a2 is less than
x1
2
and
b2
is not
less than y2
okay
now
remember that we want
edges to be in between
the edges from the other
um from the other rectangle
but it could be any of them so
since
less than shows whether or not we are on
the left or
below
and so we need to have one that is
we need to have at least one edge for
each that
is below and one that is above some
other edge in the same
along the same dimension from the other
one then the only thing we need to know
really is if they're different we don't
care which one it is we just need to
know that one is less and one isn't less
than
so by applying
a
different from reduction we're going to
again compare element-wise so we're
going to compare this element here
whether um a1 is less than
x1
with
this element over here which is whether
a1 is
less than
x2 which is exactly what we want right
if
this is if the a1
edge is the one that that is the
determining one that is in between the
other two then these two values would be
different which we can see it isn't here
and same thing here we go for the
vertical components that is the one uh
that's going to be different
and same thing here this is uh
a
two will be is different from
um so a8 sorry a this is a two versus
uh x one and a two versus x two and so
being that they are different that means
that the a
two edge does fall in between there and
then we can see that it is
here in the top right and the and the
bottom left those are the ones where
they are different so those are the ones
that will give a
that cause the intersection to be there
so because this is in the right side so
this is the vertical component this is
the left side this is the horizontal
component so this is saying that the
edges that are in between
are
b
1
which falls in between
and
y1 and y2
and there's also a2 which falls in
between
x1 and
x2
so the only thing now we need to know is
whether we have at least one horizontal
component and at least one
vertical component that's uh where this
is going to be true however
and this isn't enough we also want to
know whether this happens in what it
doesn't have to be
that it is uh
that it is the
uh the a b which is
uh in between
x y it could also be x y that's in
between a b
so how would we
know that well we just reduce in the
other direction
and then and we can see if any of those
are true
so we could write this as
one or
the other
however we can be a little bit clever
about it they're actually the same
except we could transpose first so we
can write
the
leading axis one
as
the reduction over the transpose
and now we just we want to know if any
of them of the one that's transposed and
not
and are going to be
true so we can do all the reductions in
one go
if we just concatenate along the first
axis
with
its transpose
its own transpose
then we get this
borrowed table and so really the bottom
two rows are the transposes of the
others of the first two rows
that means we can
just reduce across and then the last two
across reductions are actually
equivalent to vertical reductions
so now and we can
do our different from reduction across
to see if
there is a different relationship to the
and to the edges on the side
and once that's
done we just need to know whether there
is at least one
and vertical at least one horizontal
component and where this is true so we
can mix it all and then we so the left
side here are all the horizontal ones
and the right side is all the vertical
ones
which means we can get whether any is
true
with a vertical
reduction
and then we just need to know whether
both of them are true
and that gives us the solution which is
also very nice
and finally
let's start over yet again for another
approach
this time we're not going to do the
direct comparison the
outer product with less than but we are
going to
start with an outer product
this time we're doing a subtraction
why is subtraction because
we can actually see on the sign
whether or not something is less than or
not so if you get a negative value it
must be
that the alpha component here was less
than
the omega component and since we're not
actually interested in the magnitude of
their overlap we're just interested in
whether or not they're overlapping or
not we can take the sign of that
and here
this means that
a1 was
less than
x1 and a1 was less than
x2 and
b1 was less than
y1 and
a b 1 was less than
y2 and so on
now we need to think a little bit
so
we need to know
whether
there were any
that were
in between
in order
let's state the opposite let's say that
they were not in between
so if
if one component
was
so you say if if both
horizontal components of one rectangle
were on the same side
of the corresponding components from the
other rectangle then all of these
numbers that in that dimension would be
the same
so really all there's only there are
only two ways in which we don't have an
overlap and that is if you've got for
each dimension
four negative ones
or
four ones
if there's any
value which is of the other sign than
its companions then that means that it
has the other relationship and then it
lies in between
so
let's flatten that out
and then remember that the first element
in each of these pairs corresponds to
the same dimension so these are all the
uh
the a's
and
the
um
so the a's against
the x's and there are two and one of one
and two of the other so that gives us
all four
and now if we sum this
then
we get added all the
first elements together
and all the second elements together
giving us these two
and remember that the only case where
there's no overlap is if they're all the
same that means the sum
has to be
four times negative one meaning negative
four
or four times one meaning four
in other words the magnitude of the sum
is four
so if we disclose this because we got an
enclosure when we did a reduction over
these
pairs
and then take the absolute value
of this
then and
only in the case when there's four
there's no overlap
and we can see here that uh horizontally
and there's no overlap
but
vertically
there is an overlap
what you're interested in
of course
is that there is an overlap
so there is an overlap if the sum is
different from
four
and these are the horizontal and
vertical components and we have a full
proper overlap and if both horizontal
and vertical components are true
we just need to say that both of them
are true
which we can do with an
end reduction over them
okay now that we have
this
and all these different solutions
let's look at
um
some comparison of performance here it
can be quite varied
and for that we need some test data it
doesn't really matter what the values
are as long as we get a bunch of
different
values relative to each other so that
and their magnitude doesn't
really matter
what we're going to do is
we want to
to create some
abs and some xy's
and then
and
let's
make some random numbers
and so we have two variables here the
abs and the xy's
let's let them have a hundred pairs each
where um
so the pairs are the the
two element vectors of two element
vectors
so because we need the the two for the
uh for one corner two for the other
corner so two
with two in each and with zero here then
this would give us just some random
notes between zero and
and one but we'd want it all to be
nested so we'll
split it this gives us a two by one
hundred by two
array of
pairs we split it again now we get a 2
by 100 array of pairs of pairs
and we split it one final time and now
we get a
two element vector of 100 element
vectors of pairs of pairs
let's copy in cmpx from quad c
from
defense
and construct the expression that we're
going to run so this is the abs
joined up with each of the function
names f g and h
with
the x y's
let's check that this
looks good yeah that looks fine and then
look at the performance for that
and turns out that
our initial uh implementation
that was very much based on
how we phrased the problem is
significantly faster than trying to do
any of these clever tricks
that's all thank you for watchinghi
let's remove text that appears between
Pairs of double quotes in a larger text
we start with a test case
that needs to contain some of these
quoted
things
and a very obvious approach is to use
regular Expressions it's great for
matching and manipulating text
so we can write this directly we're
writing it as a derived function using
the quad R that's the regular expression
replace
operator it takes two operands and
derives a new function which we're going
to assign to R for regular Expressions
the left operand is the pattern that we
want to match we want double quote
followed by
any characters that are not double
quotes and we want zero more of those
and then a final double quote and we
just replace that with empty double
quote double quote
this works very nicely and it also works
in the case where when you have some
some text
with empty and empty double quotes
and this is important for the regular
Expressions if I had used a plus here
instead then we would have only matched
double quotes that actually have content
in between and this might seem like an
optimization but it gives the wrong
result because
what we'll do is we'll not match this
empty quote
and then we'll try to match beginning
with the next character and that will
match but now we are out of the parity
and we can see that here
this is with the star
and this is with the plus and that's not
correct
okay now we're going to do the same
a job in a bit more of an APLE way
before we do that we're going to define
a helper function just to let us see
what's going on
and it's a bit involved but not really
important for this problem so we want to
apply this function on each character
and we simply want to add put the
character adjacent to a space
we print that out without a new line and
we do that by assigning to the special
quote variable
and there is the pass-through result if
we use it of this assignment is the
value on the right which is the
character itself because we have applied
this whole Lambda to each character this
means each
um and so we're going to get the
character itself followed by a space but
we only want the character itself this
has the effect
of
printing out as a side effect
the spaced out text
but returning the original text
so we take this whole thing and call it
P for print
and now we can start working
so we're making a different a Lambda and
applying it to the text but let's print
it out
and in here we refer to the argument
and compare it with the double quote
this gives us a Boolean mask and as you
can see why I want
the letters to be spaced out so they
line up with the corresponding Boolean
and we can see we have a one a true
because API represents
true and false as one and zero and they
are just actually numbers
and every time we have a double quote we
have a one because the equality Maps
automatically from this one character on
the left to all the characters on the
right
and that means that every time we we hit
a one we need to flip state so to say
we're switching between being outside
the code to be inside the quote
um and we can do that with an xor scan
or a cumulative xor
xor just means when only one
argument is true not the other one that
is that the different
so we use in APL the unequal and scan is
the backslash so this is a cumulative
xor or extra scan
and this means
that we have we're outside of quotes
until here and then we're inside quotes
and then we go outside quotes again
there's a little bit of an off by one
error in that the final quotes are
considered outside and they should be
um outside and the leading quotes are
considered inside but they should also
be considered outside because we want to
keep the quotes but want to get rid of
the content and also the content that we
want to get rid of should probably be
marked as false because then we can use
compress to remove it
so we can start by and Flipping The
Chosen fonts so this is a Boolean nut
and then
we only need to
um
include the quotes as well but we
already created
a mask that indicates where the quotes
are
and it doesn't matter that it has zeros
for places and not codes if we do an or
so then so if
this gives true or
this gives true then that's what we want
so we can give this a name mask and then
we can do this mask or
this over the right note that APL it
doesn't have a precedence order for
these Boolean functions everything just
flows from right to left or another way
to look at it is every function
including a derived one like this XO
scan and takes this argument everything
to its right
so now we get the mask that we want we
can see we have zeros for the characters
that are inside the quotes and the ones
for the quotes themselves and characters
that are outside the quotes and that
means
um
that we can use compress
but before we do that
I just want to note this or not
that can actually be optimized a little
bit let's have a look how so if we
create the function that just does the
or not
then we can use the outer product which
is the all combinations between 0 and 1
which are all the possibilities in
Boolean algebra on the left and zero and
one on the right so this is like a
multiplication table
but only for zero and one so zero and
one and over here it's also zero and one
for the columns and there's that
multiplication it's or not
and that's reason about this a little
bit
we can see that there's only one case
where this gives false that's when we
have zero on the left and the one on the
right that is
it gives false if then less than it's
the only case when you in Boolean we're
restricted to only zeros and ones where
we have zero where we can give true from
less than
but we don't want true from this one
less than we want false from that and
true from everything else so we want
something that's not
less than or it's not less than is going
to be greater than or equal to
so we can go up here and replace the or
not with greater than or equal to
and we can see that gives the same
result
so now we have
shown that using the laws of Boolean
dungeon then we can replace the or not
with a greater than or equal to
okay we continue on our way
um
and we use this
to mask out
the
argument itself
and this gives us the result that we
wanted
however this but a single symbol on the
right of the compression function
whereas we have a whole expression on
the left that then needs to be
parenthesized because as I said before
we flow from the right to the left
we don't have a function that does the
same thing just with flipped arguments
but we can create that for ourselves by
using the commute operator
which commutes the arguments so now this
is a derived function which takes the
mask on the right and the data to be
masked on the left
and that means we don't need the
parenthesis anymore
because as a derived function it's a
function and takes everything to its
right as its argument
so this is a very nice solution and we
can call this
um let's say x because it uses the xor
scan
who can apply it to argument
and of course this works just fine when
we have adjacent quotes
because it just flips between the state
of being out of close to inside quotes
and then inside quotes outside quotes
every time we see a quote it doesn't
matter whether there's anything in
between them
finally we're going to implement a more
General solution an actual State machine
here we used xor to carry a state along
and this works fine for this very simple
type of coding but let's say we had
different types of quotes single quotes
and double quotes and Escape characters
and so on
then this method wouldn't work and we
need an actual State machine that
traverses over our string and keeps
track of and where we are and what state
we're in now we inside quotes every
outside quotes are we in the middle of
an escape sequence and so on now we're
not going to implement all those
features I'm just going to implement the
framework for the stick machine the
simplest form
so let's start again
with the mask
and print that with the argument itself
so these are our the the points where
we're going to switch state
and then we're going to start with a
starting state which I'll call
um l
for um it's a letter that we're going to
keep and everything else is like in
quotes
the state initial state is one
and Diamond separates the expressions in
the APL so this is the Lambda with with
two expressions in it we start off by
setting the state L to one and then we
produce this whole mask now this has
looks exactly the same because assigning
L to one it doesn't make any difference
however now we can start working our way
through this mask
so we want to apply to each one a new
little Lambda and that little Lambda
will update this initial State here of
course the first character could be a
quote in which case we immediately flip
it and the way we're going to do it
is we're going to use
um
a very nice thing we have which is
modified assignment right you might know
about augmented assignment if in other
languages often written like this this
will increment
like that now we don't use
equals for as I mean we use an arrow and
this works in APL but not only that we
can use absolutely any function to the
left of the assignment and then that
essentially means
um that function
um with the argument left argument of
the variable that's being assigned to
and the right argument whatever is on
the right
and as any other assignment the
pass-through value is going to be
whatever is to the right of the
assignment Arrow so the result of this
will be one even if L now has a
different value than one now we're not
going to use plus we're going to use
well xor again
because we want to say
um
this the state
if it's equal to one and it's already
one
then we want it to become zero and if
it's zero and we have
um
sorry this is this shouldn't be a one it
should be an argumentative so so we have
going over this mask and we want any if
we say it's different from zero
for Boolean
that just keeps their value
right because
if it's zero different from zero is
false so it becomes zero if it the value
right now is one different from zero
it is different from here so it produces
one so we so by doing different from
zero we preserve the current value
so as we Traverse over this we're not
changing State as long as this is zero
now if there's a one and the current
state is zero zero different one then
that's one so we change from zero to one
and if it's currently one is one
different from one no it's not so that
the answer is zero and then we switch
the state so whenever one here we switch
the state of L we can't see that
anything happened here because we have
just updated the state we didn't
actually use the state
for anything
however
this if we continue and return the state
value at every point then we can see it
and effectively we got this xor scan as
we had before
again we have the problem that the
initial quotes accounted as being inside
because we switched the state
immediately at that point
but luckily the argument here is
actually
whether or not the current character is
a quote and that means that we can
we can again say
um
the state
or
the argument whether or not the current
character is a quote
and this means that we get the quotes
always marked with one
we can however be a little bit more
clever about this because the
pass-through value of this assignment
is the argument itself
and by the time we're done with the
assignment then L has been updated
so this Omega over here is the same
thing as the expression over here we can
take the rest of the expression
and add
over here instead
and now we have the states as we
Traverse and of course this is Lambda
couldn't have a whole bunch of code that
decides what to do based on what
character we are in now and what one or
more different types of states that are
being updated as we go along are we in
an escape sequence are we in this type
of string are we in that type of string
are we inside braces and so on so this
is a
um a completely General system it can
decide what to do at that point and
update all the various states that we're
tracking we could have multiple states
that we're updating
um and so on
and this gives us our mask which means
we can proceed just as we did before
we'll
compressing filtering by this mask
and that gives us our result so this is
a state machine implementation it's
going to be much slower than using the
built-in Excel scan but it is a more
General solution
this is a state machine and it works
thank you for watchingwelcome to the APL Quest Capel Wiki but
details
today's Quest is the 8th for the 2016
round of the APL problem solving
competition
we're giving some numbers
and we need to return
a two element list
the first element contains
all the negative values
and the second element contains all the
non-negative values
we can do this
by filtering the values so let's start
with making some values
okay
APL
has implicit mapping
over
arrays that means if I make a comparison
like where 0 is less than or equal to
these values
then it automatically Compares all the
values
also
one and zero are used as
true and false
they are actually the same
we can use this to filter using this
slash we're filtering V
and similarly we can filter V with the
values that are less than zero
okay now we just need to put these two
formulas next to each other
this is an expression for the solution
let's make this into a function
we put braces around it and this makes
this an anonymous Lambda also known as a
defen
put V over here and inside this we
represent the argument
with Omega which is the right most
letter of the Greek alphabet because the
argument goes on the right
and so this is one solution that we
could use but it has a lot of
parenthesis it's an
even inside these braces and it's a
little bit hard to read like that so I
prefer avoiding the parenthesis
now that means I need to have something
like the slash that text the arguments
in opposite order that takes the mask
on the right
and the data being filtered on the left
there isn't such a function in APL
but any function can be modified by this
modifier or operator
called commute or swap which binds
together with the function in the slash
function
and
create a new function which is exactly
the same but with commuted or swapped
arguments
so now we can take this mask and put it
on the right
and put and take the
data on the left and since APL has long
write scope
in other words we start Computing at the
right end of an expression then we don't
need parenthesis around this part of the
expression anymore and we can do exactly
the same thing over here
so this is another solution
one thing is a bit of a Pity is that
we're comparing all the elements which
could potentially be many twice and we
could actually infer the result of one
of these computations from the other
so let's say we save this as the mask
and we can do that inline the result of
an assignment in API is always whatever
the values that's being assigned is
so now we have M available and we
continue to the left and we can use M
over here
um but we need to negate it because we
want all the values that are not those
so this also works
we can actually get rid of
this swapping simplify things a little
bit if we had a positive mask instead of
a mask we need to negate
foreign
but then that's not this then we need to
make the opposite
comparison over here and then we need to
negate it over here before we apply it
so this also works
we could also just take this mask and
put it in a separate statement first
diamond is the statement separator it's
strong like a diamond separating things
into parts and then we could write it
like this
foreign
or we could say that these are the this
is the negative mask and then we could
have a separate positive mask if we
wanted and then we could write it as
positive mask over here for symmetry
oops
open the negative mask of course there
we go notice how he appeal points me at
the name and tells me which name it is
and that's missing so I can do something
about it
and so this is an another solution to
the problem
which kind of looks nice finally and
let's make a little bit of a variation
on this based on set computations
so we're going to start by Computing
um the positive values this time
and we do that as as we did before
but now
um instead of saving the mask we're
saving the values themselves and the
return value of this assignment of
course is that value
then the negative values would be all
the values except the positive ones
and we can express that as all the
values
without
the positive ones
so this tilde when it's used with
arguments on both sides it means without
and when we used it with an argument
only on the right it means not so how
are these connected to each other we can
remember this by thinking of without or
set difference as but not
so we want all the values
of the argument but not the positive
values
whereas here it just means not
and that's our final solution
to the problem
thank you for watchingwelcome to the appeal Quest cap Wiki for
details
today's Quest is the sixth from the 2016
round of the APL problem solving
competition
we are to take a list of arrays specific
the list of vectors or possibly scalers
and sort them by that length the
shortest ones are in the front and the
longest ones at the end
this is really simple
let's make some test data
okay so this is a list or vector as we
call it and it has six elements let's
try printing it
and we can see that there are some
numbers that would have the length of
one and then there are some strings in
here that have the length of two and
five three and five and then there is
also a list of numbers which has length
four
and the way we get the length is by
using the tele function
and it looks kind of like a Telemark you
would make into a counting stick
but we don't want to tally D because
that will give us the number of elements
in D instead we want to tally each
element in D so we use the each operator
or higher order function which is kind
of like a map
so we are taking this function which
we're applying
to each element of d
and here we can see the length
what the number one has length one the
word two has links three and so on
and now we can use this to grade
grading is a it's a very apla operation
really but it's kind of like the more
fundamental form of sorting it doesn't
actually reorder the elements but rather
it gives us the indices of elements
as we would need to take them so that
they should become ordered we're not
doing the ordering quite yet and this
function exists like this because then
you can use that information to sort
something else which allows you
basically to sort some data by some keys
for example
so this gives us
that if we want it to be sorted by this
information the length of each
then we first take element number five
that's this empty string
and then element number one which is a
number and then element number four
which is this number four then element
number two because it has links three
and then element number six because it
has length four and finally
element number three because it has
things five
and then we can use this information to
index into d
so with square bracket indexing
which allows us multiple indices and
when we give it multiple integers it
just reorders the elements or picks out
those elements in that order
that gives us this
and that's the result that we want but
this isn't actually a function that does
the work rather it's just an expression
we can change this into a function
Anonymous function the Lambda and by
putting braces around it and then
denoting the argument with Omega because
the argument goes on the right just like
all the other functions we applied so
far
and the argument goes on the right and
Omega is the rightmost character of the
Greek alphabet so we put Omega instead
of the D's and this gives us a function
we can either apply it directly
or we can give it a name so this is uh
sort by length for example we use left
arrow for assignment equal sign just
means equality
so now we've given the name and we can
then call it on D
and it's Source it correctly for us and
that's really all there is to it thank
you for watchinghi today's Quest is to find the set
difference between two sets but the sets
are given as um any type of
arrays and um the difference has to be
symmetric so it's not just all the
elements from one element from one
argument that's not in the other
argument it's only those elements that
appear in exactly one of the arguments
but not in both of them
let's get
started we have here a character vector
and here's another character vector and
we can see that both of them have an A
and both of them have an L so those
characters should not appear and what we
should get instead then is a d a y and O
and G and P from this one over here and
let's make an anonymous Lambda a defin
um here in we refer to our left argument
as Alpha and our right argument as
Omega and we want to consider all the
elements and then remove the ones we
don't want and all the elements we can
get by using the
union of these two so the a set Union
we're treating these character vectors
as
sets and the ones that we want to remove
are the ones that are in both so that's
the intersection between
them and then we can use the set
difference uh between the
union and the
intersection and for symmetry we can put
parenthesis here that's not strictly
necessary
right this however is a really great
example of what is called a diic fork
notice that if we think of the functions
involved in the algorithm we have here
the Union function applied to the
argument and we have the intersection
function applied to the argument and
then the results of those two function
applications become the become the
arguments for the set difference or
without
function and for that we can use the for
construct which does exactly that for
construct is just three
consecutive functions in
isolation and it reads nicely the union
without the intersection and that's
exactly what it
does so this is a neat way to write
it um another approach that we could use
is to say that we have all the
elements from one argument it except
those that appear in the other
argument and similarly all the elements
in the other argument that are not in
the first
argument and then all we need to do is
to merge the two and that could be using
uh a union or just concatenation and
there's no really any reason to write
um a union because we know that they
must be all different so we can just
concatenate them
together here we have something that
looks like the for construct with the
same function on the right and the
left
and the trick is that we have the
arguments swapped otherwise it would
have been exactly the same on the right
and the left so how can we do this in
order for us to apply the fork construct
then we need to have the left argument
on the left and the right argument on
the right we can modify using a montic
operator the set difference function
which is not symmetric to swap its
arguments so this till the diis it deres
a new function which is the same as the
old one except its arguments are swapped
so now we can put the alpha on the left
and Omega on the
right and with that we can clean up to
get just the function in
isolation use the nice Fork syntax ahuh
but there is a catch and that is that we
not guaranteed that our arguments are
vectors or scalers they might have
higher rank for such a thing um let's
say
we we put in the comma bar function
which then applied to this argument over
here and it gives us a column Vector
let's try that for a moment so if we try
to do that then we get an
error and the same thing would be if we
use our other uh function over
here same kind of problem a rank
error so what we want to do is before we
start applying the main part of the
function we need to pre-process both
arguments to make sure that they are
just vectors and we can do that because
we have a um special operator thetic
operators it takes two functions
combines them and the comma when used
with just one argument which is what
this operator will do uh it is a
flattening operation or Revel it
destroys the outer uh shape but it keeps
all the elements intact so if you do
that it will work and the same thing
goes for our other function over
here this will also work so these
two are the two solutions we can give
them
names
and then we could apply them in line as
before like that thank you for watchinghi we are to take a multim
multi-dimensional array and
interchange the horizontally adjacent
elements here is an example
multi-dimensional array it is a
three-dimensional array with a two
layers and each layer has two rows and
then we've got five
columns and our task here then is to
Interchange adjacent element so Gela is
being interchanged with opton they
switch places Prospero with Lysa and
then uh there isn't anybody to uh switch
position with toaza so that just stays
in place there and the same goes for
every row and
actually note that we can really operate
on individual rows we don't have to
worry about the overall shape of the
array though we'll get back to doing so
anyway so just to develop our algorithm
let's focus
on uh just the first
layers and first row and then all the
columns from
there we have those
here and so we'll start by the finding
or wrapping our Anonymous function
de and we
can take advantage of the partition
inclose function to pair up these
adjacent elements and flip the positions
and merge everything uh back
again and the the petitioning close
function it takes a uh for our purposes
a mask have one when we are to start a
new section and then zero when we are to
continue a section so we want a mask of
one Z One Z onto the length of uh this
Vector um so we can get the length of
the vector uh with or the shape of it uh
with uh the shape function of
Omega and then we can use this to
reshape uh one Zer so we keep using from
this array one Zer uh cly until we have
the shape that we asked for and that
gives us this mask then we can use that
mask to partition uh the argument and
here we have the pairs that we going to
flip and we now can uh reverse each one
of these and notice that the last one
that only has one element it's still
Vector of of character vectors here but
it its reversal doesn't have any
effect and now what we need to do is
merge these back together again so we
use a concatenation
reduction but uh the concatenation
reduction uh has to reduce it is a
reduction and reduces then the the rank
number of Dimensions from one this is a
a list Vector of vectors to zero so this
is a an enclosure of uh the actual
Vector result that we want and we need
to then disclose that uh to get the
result we want this took care of
the simple uh case where it's just a
vector and we want this to apply to all
the vectors that can be found as
subarrays of our overall um array so we
had the entire n here and we can very
simply do this um that's we can we just
Define our function here e uh for uh
partition
inclose and specify that it should be
applied on rank one so it's not really a
specification It's actually an operator
that takes a function as left operand
and a rank specification as right
operand and saying this function must
never see any argument that has rank
greater than one so in effect the rank
operator will iterate over our given
argument and apply the function to every
subarray of rank no more than one which
is in fact always going to be present
because the problem specification says
that it will be a vector or higher rank
array so we can try this let's uh print
out the names again just so we can
compare them and then we apply uh the E
function to that and we can see that uh
we got exactly the result that we
wanted so this is one way to approach it
um but there are many others I'll go
through another couple um another way we
could do this is by indexing so we could
build up up the
indices uh of the elements reordered
such that we get the result that we want
and that takes um a little bit of an
algorithm so let's start again just by
the vector case and then we can apply
rank one to get the full uh thing so
here is our
vector and again let's define a uh
Lambda
a and and this time uh we again we have
the the shape of
that but now what we really want is to
find out which order should we put them
in in order to sort them but not just
sort them by say alphabetically but sort
them such that we interchange adjacent
elements and um we can start by
generating the norm noral indices right
so what we want here is the uh the
reordering but we need to adjust our
values because these are already sorted
so that two becomes uh less than one or
one is greater than two and three
becomes greater than four and so on and
we could do that by just adding two to
every other element so if we add two to
one we get three and that doesn't Clash
with the next three because this three
will also have two added to it and
becomes five and it won't clash with the
five because five becomes seven and then
and then the two and four stays and then
we just have to sort by uh that ordering
the ordering that would sort those
numbers enough talk and we can do this
in exactly the same way as before so we
uh we take the length and we use it to
reshape uh this time it's two and zero
and then we just need to add that to the
um to the indices that we computed over
here and for that um easiest thing is to
make a little train uh Fork so we do the
indices plus the reshaping of to
Z and we apply that whole thing to the
shape of uh the argument so we first
compute the shape and then we get the
indices of the shape and then we use the
shape to reshape to zero and then we add
those together they now have the same
length of course and that gives us uh
this we can see the one was incremented
up to to three and the two stays in
place the three became five four stays
in place and five became seven now we
can H we can grade this to find out what
indices elements should we take in order
to make this
sorted and so here we can see that we
want F the the smallest element is uh
the second one that's the two then the
next one is the first one the next one
is the fourth one and the next one is
the third one and then the fifth one and
that effectively gives us um these flip
pairs for indices 2 one then 43 then
then five All That Remains now is to use
these indices to index into the argument
and we have gotten um our reordering as
we
wanted so here we're using indexing with
grading um we can call this I and then
specify that this goes on uh vectors and
that means that we can let's just print
out our um example names here again and
then we apply our
function and we can see again that we
have the correct uh flipping of
Paris
and finally I want to show how to do
this uh using the stencil operator the
stencil operator is normally associated
with cellular automatons Game of Life
things like this um it processes Windows
of an array um it's it's almost an edge
case that it can have Windows of size
two and the movement the window moves
over by two steps and that effectively
isolates and adjacent pairs
this time uh let's do it tested and we
again we can start with uh the first
layer's first
row so we use run parenthesis instead
for a a train or a tested
function and um we can we start with a
stens operator and then the idea here is
that we use an Windows of size two with
a movement also of size two so we need
to make this into a matrix because every
row has serves a different purpose in
the right oper stens the first row
specifies the window size the second row
specifies uh the window movement if
there were additional Dimensions we were
traveling along then we would have
additional columns in this
table and we can and we can isolate
these so we
can uh this the oper end function to
stencil is given uh two arguments and we
don't need the left argument so we use
the the right function and then we
enclose
that and uh we can see that we got the
pairs but stencil cuts the argument
short if it can't complete a window uh
with the specified
movement so we will have to address that
but for now
um we don't have to necessarily enclose
this we could also increase the rank uh
by not
enclosing so that gives us this table
and that can uh conveniently
be uh
reversed and then and we can Revel it
and
again right
there now and there is missing something
and and then is the last column so we
can read that column but of course this
only happens when uh the rows have an
odd length so here we use a a right
reduction to get uh the rightmost
element and that add this back again if
we had an even number of elements then
and
our and code here would add one more
column that didn't need to be added so
we can do this by cutting short and our
argument to just four not five uh names
and we can uh see
that and we have an extra Delicia and
over here because that was the last
element before it was moved one step uh
to the left this is of course wrong but
we can counteract this uh by taking the
uh the
shape so we take using the original
shape and that ensures that we chop off
the excessive uh element if it
exists and then if we use the odd
numbers here five then we also get uh
the right
result so this works um again on uh rank
one and we can call this s for stencil
and we can try to apply that on and our
whole multi-dimensional array and we get
the desired result
result um it would be interesting to do
a speed comparison of these three
approaches so let's copy in the compare
execution uh facility from the defense
workspace and then uh I also have a
larger and here we only have 20 names we
have a larger many dimensional array uh
called a
uh we can see that
and a has
20,000 elements instead of um just 20
and it's distributed over five
Dimensions so it's a relatively large
array um and well we can also look at
the whole whole shape of this it has an
odd length and long last axis where
we're going to do all the the actual
computation so uh and we're going to
compare the execution and we've got e
with a as argument and we've got I with
a as argument and we got s with a as
argument and then we let it run for a
little bit to see how they stack up
against each
other and well those are some
significant differences we can see and
and if we reason about it we can also
see why that is
and the stencil operator and is
optimized for certain cases but not for
what we're doing here and so it goes in
and actually applies a function and to
every window and and moves around and
that is expensive to
do the partition inclose function
generates an intermediary further nested
array that isn't otherwise necessary
and the indexing just directly goes in
and computes how we want the result
reordered and that then ends up being
significantly faster than other
approaches
but that
said we can do this much
better because if we look at our
definition say we we look at s here we
are treating every row separately and
potentially there are a lot of
rows and even though rank is optimized
again for certain Primitives and
constructs and when we have a complex
function like this there's nothing The
Interpreter can do and it just has to
Loop through um all the rows
individually if we could treat the whole
array and in one go then that would give
us a significant speed up and uh this is
what array programming languages like
APL are really good at
so let's try to reformulate this s into
a uh a function where we do not need to
specify that the rank uh of the argument
is restricted to
one and here well we still kind of want
to do that but we don't have to do it on
the entire
function because we do want these
windows and on rank
one but we can do that all the way in
here
instead so this takes care of the
reordering of individual rows then we
might be missing a column we add the
rightmost column so to say that's the
last element of every Row in the entire
array to this potentially
multidimensional array that comes out
after running on rank one and instead of
doing the take operation on every row
individually we take the shape of the
original array the multi-dimensional
array and uh restrict along all X's
which won't have changed except for the
last one potentially um so that's just
one operation to cut short in our
array and now we can try to
compare uh our original s with our S2
and see if that made a
difference
so we can see that uh that became
somewhat faster um it still doesn't get
rid of this Loop for of the um the rank
one we could potentially get rid of this
one as well by specifying a window size
that is one and a movement of one in
every Dimension except for the last one
where we have a window size and movement
of two but it becomes a lot of
computation to get that uh window size
right and to then reform the argument
back again to the original so let's that
leave that there because as we can see
up here the stencil approach is anyway
much slower than the other one so this
will be more interesting and with and
our other approaches so then we had and
our function
e and let's try to define a new and
E2 that
and
does this on the whole array instead so
we want to get rid of the the rank one
here now this gives us the shape of the
entire array but we only want the
trailing uh element of the shape which
is
the um the number of columns so the
lengths of the rows and uh we can get
that for example like this to do with
get the less element uh the the
rightmost of uh the
shape then we reshape to the mask uh
that we want and actually this works out
very nicely because by default the
petition inclose Works along the
trailing axis so this is going to uh
split up our array into should we say
vertical slices of uh with two and so
everything else just works out we
reverse these two column and
multi-dimensional subarrays and then we
join them all together adjacent to each
other and since we use the reduction to
do that we disclose they should just and
work out so now let's try to compare e
and
E2 and we can see that just this little
bit of modification gave us some very
significant
savings okay let's see if we can do this
uh with the I function as well so we
want to have an a new I2
function and we don't want to apply rank
here now we end up in trouble
immediately because the square bracket
indexing requires us to know the rank of
what we're indexing so we have to
replace it with something else um and
for that there actually if you take
these two square brackets um and we we
merge them together uh then they become
the squad function which is then a
proper function
indexing but again we don't really want
to generate the indices along and every
dimension for all our elements so we can
use the slightly um unpleasant looking
square bracket access to say that all
the indexing that we are going to do we
are going to do and along the last
axis uh so that is the same thing as the
rank of uh the
argument and now and the what we're
indexing is on the left but it normally
takes it on the right so we swap that
and in order to just reorder and so to
have multiple indices along the same
axis then we need to enclose um the
argument over here and then of course
this is the entire shape so just as
before uh we want to get the length of
the last Dimension and the rest should
stay the same we get the mask we do the
grade and then we apply that there so
now we can compare and remember that I
was the fastest one before and now we're
doing I versus and I2 where we not going
over the individual rows with the rank
operator we are treating the entire
array at once and we get well similar
savings as we did with e so uh this I2
is by far the fastest solution to the
problem thank you for watchingwelcome to the EPL Quest
cap Wiki for details
today's Quest is the first from the 2017
round of the APL problem solving
competition
we're given a number and we're supposed
to generate odd numbers and that many of
them
this is a really simple problem in APL
we start off by creating a Lambda or a
different and let's say we give it the
argument five so that goes on the right
just like you could have say a minus
with a 5 on the right
inside the function we refer to the
argument with Omega because the argument
is on the right and it's the rightmost
character of the Greek alphabet
and this separates it from all
identifiers that the programmer makes
which are written in the Latin alphabet
okay now since we are supposed to
generate a sequence of this length then
we would use the index generator
function denoted iota
and this gives us numbers from one to
five but we only want every other number
so we need a multiplication factor of
two
multiplication
automatically applies to all the
elements generated by the iota
however we our values are too large we
need to subtract one or alternatively we
could add negative one
note the high minus which API uses to
distinguish between negative numbers
from subtracting and negation if I'd
used a low minus we would have gotten
this result instead which is
twice the indices
one added to that and then negate the
whole bunch which is not what we want
so while this is a solution
it follows a very simple pattern here
where we have a function that's magnetic
applied to the argument and then at the
addict function with a parameter on the
left and then at the addict function
will parameter on the left
and we could keep going like this as
long as you have this pattern that where
every other thing in the expression is
adiatic function every other thing is
either parameter or it could actually be
something else but not right around here
um then we can convert this very easily
to a tested function the way we do that
is by not mentioning the argument hence
test it and we can just put parenthesis
instead
around so this is a new derived function
which is negative one added to twice the
indices
and that works very nicely and we need
parenthesis to distinguish it as a
separate function but of course an
expression would work as well
if we want to give it a name then we
don't need the parenthesis either so
we could just write it like this
and that's it for today thank you for
watchingwelcome to the apl quest
today's quest
has us imagine two circles that are
touching each other
and
one of them
stays where it is
the other one
rolls on the first one's surface
or circumference
all the way around until it reaches the
place where it started
now obviously um
it
depending on the exact sizes of these
two circles
then it may not
end up in the same it might while it's
in the same position relative to the to
the stationary circle um it may not have
the same orientation may not be pointing
in the same direction again and so
today's problem which is the seventh
from the 2014
round of the pill problems on the
conversation
is to see how many times do it does the
circle who that's rolling need to go
around
um until
how many times does it need to turn
around itself so that until it has
rolled all the way around the stationary
circle
but also is pointing
um in the same direction
and i mean same orientation as the way
it started
there are different ways that we can
attack this um let's just start by
actually simulating
the problem
and we can use and since we have two
arguments here we have the the size as
left argument of the stationary circle
and then we have the size of the
um
of the
mobile circle one that's rolling around
um
they and officially they're given as as
diameters but it doesn't really matter
because the circumference of course is
just a a constant times the diameter and
that's the same for both so that kind of
goes out of the equation
and but what we wanted to see is whether
the amount of revolutions that we have
done on the mobile circle um
times its size
ends up with something that
that we can divide the stationary
circle by
sorry something that the
um
that can be divided by the stationary
circle
okay so the way we can we can write this
up
is we are done
if
there's no division remainder
when we are dividing by the state a
stationary circle
um and how far we've gone so far well
we're going to use an operand for that
so that's how many revolutions we've
done
of the diameter well actually the
circumference
of the mobile circle
and in if that divides
then we're done and so that's the number
of revolutions
otherwise
we are going to try again
but this time we're going to
increment
the
um the counter of
revolutions so we take one more
revolution of the
of the mobile circle
and then we feed that in to the same
operator so it doesn't operate another
function so the the arguments stay
constant
and the upper end stay
increments every time and then we just
need to
start with a1
so this is a recursive solution uh it
keeps
incrementing and calling itself
so
we can say a state a stationary circle
of uh diameter or that's it
circumference 10 and then we have a
mobile one that's five
so the five
after it has rolled one time around
itself and then it's on the opposite
side
and then it rolls one time again around
itself and it comes back to to where it
was
if we try to
flip the two
then
we only need one
revolution of the mobile one what's
happening is that it only needs to go
half away a half a turn to come back to
where it was
but it will keep going for another half
a turn in order to
come come back and face the same
direction that it
started with as well
and we can we can try all the
possibilities by making a table of this
so this is an outer product and then
all the
all the numbers up to 10.
and then this gives us a full table of
uh the revolutions and there's one
interesting issue um and that is
zero
now
it doesn't really make sense that the
mobile circle should have a diameter and
therefore circumference zero it's point
shaped because it doesn't matter then
how many times it will turn around
itself it's never going to get anywhere
so every time around it will move zero
it will not move at all
unless also the the left argument the
the stationary circle is
uh point shaped in which case nothing
can really move and it doesn't really
make sense to ask how many times i mean
any number of times would be good zero
one two infinite so you could say the
number the result is zero or you could
say that one or after zero times it's
also turned one full revolution around
uh the zero zero case doesn't really
matter however if the stationary circle
is zero
then
the result is most certainly zero
because we don't need to get anywhere
even though the
mobile circle has the ability to revolve
it doesn't actually need to revolve
so we can we can handle this additional
case by adding in an extra guard
so if
uh
the left argument that's the this
circular standing still is zero
then the result is zero otherwise we
just continue as before
and now we can go and
make a test case where there's even a
zero on the left
but not on the right as that doesn't
really make sense
and we can see you get the row of um all
zeroes there of course
right so this is one way to do it um
another so this and this was recursive
let's try to do an iterative way
here we just start off with a count of
zero and then and we we increment as we
go along and until it works out it's a
little bit it's much shorter but it's a
little bit more involved
so the way we can do it is
we start off with
with zero and then we need to increment
it and we want to increment it until
our condition has been fulfilled now
what is that condition that is that
the left argument
because we are comparing
the previous and the next
iteration and so that would be the left
and right argument of our comparison
function which is one that determines
when it's true then we have fulfilled
our condition
um so and
when that multiplied by
the circumference of
the mobile circle
evenly divides
the circumference of the
of this circle that's standing still
then we're done
and so we should get exactly the same
here
as well
but again we have a problem with zero
because if we start off with zero on the
left
then we're going to um
we can try it
if we have
zero on the left and say two on the
right then the first time around we'll
try to
to apply this function
so we add and add one so we get one and
zero
and then
we want to check
if it divides
division remainder so let's let's try
that so we can we can just do it like
this
right here
so if we start with uh with zero here
and say we have two and and
then
we get
zero and
then
we want to stop however once we
increment it
then we get the full remainder because 0
doesn't add up to anything
in effect
what happens is that
if we try to run this with a
with a zero
then
we'll go into an infinite iteration
we'll never get there
so let's interrupt that
and then we can and we can redefine i
to have the same kind of stop guard as
we did with the recursive version so if
there's a zero on the left then we stop
with a zero right away otherwise we can
start iterating
okay how do they compare in performance
to each other the iterative version and
the recursive version
let's copy in cmpx
from defense
and then and we can compare them we can
make the table a little bit bigger and
try them so let's say the stationary one
is zero and all the numbers up to 100
and then the mobile one are all the
numbers up to 100
and then we can compare
all the possibilities the requested
version
and all the possibilities with iterative
version
and the iterative version is much faster
and that's probably because
we're not entering into any new uh
functions trying calling again and again
not binding together an operand with
with the operator over and over again
which is staying in the same place just
running
the power operator
but we can do much better than this by
using some number theory because
think about the way that
we're describing this if
this multiple
divides so really and what we want to
find out
is
what is the
um
what is the smallest number
that we can multiply with
to
um to end to be divisible
and so we can express this in terms of
the greatest common denominator or
least common multiple it actually comes
out very much the same
so
um
we want to divide so let's say again we
have 10 on the left
and then
on the right we have five
and so
the least common uh sorry the greatest
common denominator between the two
is
five so that means we can uh divide both
of them by five
and then uh we can see well if if that's
the case then how many times five do we
need to get in order to get all the way
around the
stationary one so we just divide
the left argument by that
so that's one way
to state it
using the greatest common denominator
what's greatest common divisor
opposite we can also look at
look at the least
common multiple so here we are asking um
what is the
um what's the smallest number that we
can multiply up with these two numbers
in order to
to match each other so that's 10 that
would be 1 times 10 gives 10 and 2 times
5 gives
10 as well
and then we can
divide that by the right organ so so
this is saying that in order for these
to match up then we need to have
traversed 10 or to go all the way around
and since the right argument is this
actual size that of the moving circle
then the total distance divided by its
circumference will give us how many
times we need to go around
and so we can define this using the
least common multiple as well now
there's an interesting thing about these
two functions g and l here and that is
they are really really amenable to write
in a tacit
version
why is that
because let's look at g
we if we think of things in terms of
functions then here we have a function
application between the arguments
and
then we have a function that
takes that result as its argument now
the only problem is here on the left we
don't there's no function being applied
between the left and right arguments
giving us a full fork
however we could say there is one namely
the density function
of the left argument
so if we wrote it like this instead
then effectively this function would
select the left argument which means all
this we can
um we can remove all mention of our
arguments making everything point free
or tested
like this
oops
and then a parenthesis function it is
just the function itself and then we
have parenthesis around the fork that
gives us
this fork as well and we can do exactly
the same thing for the function l
here again it's
there's an
implicit and
identity function that selects the right
argument so we can remove all the
mentions of arguments and then we're
done
and now if we
compare these so we know that i was the
fastest one of two before the iterative
version so let's
compare
the fastest of
of those of
r and i
with
these two number theoretical functions
g
and l
and we should see that these sort of say
built-in functions where pretty much
everything we need to do is always built
into the language are going to be much
faster
if we try to just raise them against
each other
then we'll find that
it doesn't really make a difference
which ones
they that we use
they are all built on the same exact
principle thank you for watchingwelcome to the apl quest see apl wiki
for details
today's quest is the fourth
from the 2014
edition of the apl problem solving
competition
the idea is that we're given a text and
it may have spacing that we don't want
and we want to normalize this in the
sense that any training
spaces that spaces at the end of the
text
are removed any leading spaces that's
spacing
at the beginning spaces at the beginning
of the text
are removed and also if any words are
separated by more than one space and
that will be compacted down to be a
single space
so let's start with a sample
what we the basic thing that we want to
do here is we want to compare adjacent
spaces uh in order to remove those extra
spaces in the middle and then we need to
take care of the spaces at the very end
because they might not be addition to
another space if there's just
one space or rather if we don't do
anything but remove adjacent spaces then
we also reduce the leading and training
spaces into a single space
but and let's get started
so
the first thing we want to find out is
where are our non-spaces
and then and
what we can do is we want to make sure
to catch also the spaces at
the end
so we want to make sure
um
we want to make sure that as if the last
space is also adjacent to another space
and so that would be an extra zero at
the end
and now we can do adjacent that be a
pairwise reduce or two wise
reduce and we want to see if any of
those
are
none spaces
so a space that's next to nonespace is
something we'd want to keep
so that gives us
that gives us this we can see that we
we start off with a couple of two spaces
and then we have a space which is
adjacent to the t in this
and then we have the four letters of
this and then the the first space and
there is some a
and then
and we have the
um
and then we continue on with and we can
see that we have ones for num spaces and
also for the single spaces of between
the words and then we have the training
spaces
okay now we can use this
to
filter and
the text
and that almost solves the problem now
there are no spaces here at the end
because we made sure to add that extra
zero at the at the end but there is a
problem of a leading space
and we can drop this conditionally
if we know
that the text begins with a single space
and with one or more spaces that means
we also have to drop and one more space
that otherwise wasn't caught
so we can easily check that
if a space is equal to the first off
and
of the the argument text
then we drop it so this would give one
if it is we could also we could also
invert for me here just by negating
the vector credit here but this is very
very little work to do the only real
work that we have here is dropping that
leading space because that would mean
rewriting everything in memory
so
that solves the problem let's give this
the name a because we're going to have a
lot of different solutions here
okay
and
let's
then for our next solution
take this and generalize it i mean
and
and while we're making it also test it
just to see some some possibilities what
do you mean by generalize it is that
instead of taking space as this element
that needs to be removed from beginning
at the end
and deduplicate it in the middle and
we're going to
allow you to specify that character as a
left argument and then we can bind space
as left argument in order to make it do
our specific task so to make this tested
is actually
quite simple
because we're going to put out the space
as
as a left argument
and that means that this different from
is just going to be
a different from like this and then we
have to of course this is becoming a
test function another defense
and the rest of this will just work this
is a dyadic function here the static
function here there's one problem is
that
replicate or compress here doesn't
behave like a function when it is next
to
another function
and the right tag here but we can fix
that with a right tag top
and then here we have
uh the left argument and the right
argument and that means that we
essentially have it equal except we want
to pre-process the right argument of
equal with
a first and we can
write that just with a uh
with the beside the composition
so that's what the entire thing comes
out to here we can try it with our
sample text
and that means we can give this a name
and just remember to either bind a left
argument here or we could have put a
right tack on the right to make it
a fork
it'll be interesting maybe to see which
one is faster of these two so let's try
that and at the same time let's also
generate some
some test data and test data is going to
be a bit interesting um
because we want to
try all the different cases that may be
with
so there'll always be some internal
duplicator spaces but we also want some
with some leading spaces and some with
some training spaces and and all the
combinations of that
so how might we do that well
and there are different ways we can do
it but let's start by generating some uh
some spaces so we want no spaces and uh
yes spaces
and we can't actually see those but we
can
it helps maybe to do it like this
right so we got no spaces and and yes
spaces um and then we want all the
combinations of that so that be an outer
product
of all of those
and it's still not really going to
be very visible here
but
now we're going to use these as prefixes
and suffixes
so on the left we have the prefixes and
on the right we have the suffixes and
then we're going to have some
garbled text in the middle um let's take
4d overtake on the alphabet that gives
us the alphabet with a bunch of spaces
at the end and then we just want some
some random numbers
there
and let's say just for now for the
display we're taking 20 reshape
40
so yeah not again not very visible
um
this up oops
there and this helps a little bit
actually we should probably use display
as to to see it entirely
um so here we can see yeah it goes over
the edge of the of the screen but we can
see that
we have added spaces in the beginning
and the end
um but the problem is that our
randomness here it caused us to have
some space in the beginning that we
didn't want to so how can we make sure
that we have a non-space in the
beginning and the end well we can just
stick an a at the beginning and the end
right there
and actually let's turn rows on
as well so that we don't
so we don't run over the edge of the
screen
and maybe make these a little bit
shorter also so we can see it
there we go so now we have our test data
we have and
one that doesn't have any spaces
beginning in the end and one and and
then we have
uh one that has only beginning one at
the end one at the beginning and the end
and we can see we're getting some
internal space here of course uh in the
first three cases there are no multiple
internal spaces because they're very
very short but we're going to generate a
giant test data
um
so that's not a problem it'll definitely
be multiple internal spaces so that's it
so then we're going to to test things
when um for
speed comparison then we'll be testing
it all four of these
i'm copying in the
performance comparison from the defense
workspace and then we can run cmpx a on
each of these four cases and b on each
of these four cases
and we can see the a is
somewhat faster so maybe it wasn't so
good to try to test it after all
okay
another a whole different way of doing
this instead of
using this adjacent uh with the
difference from from a space we could
also rotate things around and that gives
us uh so if we compare the ebola vector
with it it's rotated by one step that
also gives us this adjacency but it at
the same time allows us to rotate uh
cyclically and that
lets us get rid of um
of
having to deal with it with the edges
so especially
so we can try this
um let's take our our sample here and we
start off with the exact same way
um
actually we can we can start even making
it general so let's just put it outside
so this gives us our
vector of
none spaces
and we have the same thing with adding
one at
the edge
now the important thing that we're going
to do next is we when we rotate this and
one step
here then
because we've added
a zero at the beginning we know that
when we rotate it one step to the end we
are now getting a zero at the end
instead
so if we um if we now take
these two together so we want the one
rotate and also the original and we can
write that
um like this
let's uh let's actually begin with well
so we want to combine combine these two
but let's just stack them on top of each
other first
um so we can do that with
mix up top comma over in close
we can see these are the two that we're
going to combine so now what we want to
do is we want
where to preserve anything
that
um is
true in either one or the other so
either it is a non-space or it is an
adjacent to a non-space
so these are the ones we want to
want to keep
and then we just need to to do the same
thing as before
and remember to stick an
attack on top of that
of that slash
now there's one problem here that we've
added one element and that means that
what we can't just do is compress
because it will be a length there we
want to
take the not the right argument but
rather the concatenation of the space
and the right argument
and that gives us this and because we've
added a space on the left then we need
to drop that and we can do that
like this
okay let's
give this a name this is going to be c
don't forget to
bind the argument here to the function
so that's one way of doing it uh
cyclically but there are other ways that
we could do it let's uh
let's look at this again
so uh we can we can optimize the
performance here there's a problem that
we uh are concatenating and with a big
argument on the right it's going to be
expensive having to write over the data
in memory um all again and we could
possibly um save ourselves and some of
this work
by working on the
on the boolean vector over here removing
one element from um from that
and instead then we don't need to
concatenate we can just take that
right argument and like this
only problem is then we're back to and
so that's uh
we are back to
another problem that we get that space
at the beginning um if the first element
is a space if it's not
then we don't get a space because now
we're not considering uh
the spaceness or not spaceness of the of
the first element in
anymore and the way we can we can fix
that is much like we did we did before
namely that
if space the left recommend is equal to
the first element
of the argument then we drop from there
so
that
then this works and let's give that the
name and d
okay um but
there are plenty of uh of ways to do
this we can also
start by the concatenation and and go
with that so
let's start by having this the left
argument here this the space
and then concatenate it in the beginning
of
um
beginning of the argument the right
argument the main argument that we're
working on
and then we're going to generate a
vector
the compression vector for this
entire thing
so we can we can start by saying there
we
which they're different
um and then adding a zero
on the front like we're doing before we
could say give that a name for a mask
and then rotate it and then use
um
or that so this is this would be just a
different
it's it's an explicit version of what
we've done before
um
this is of
c
and then
we're doing it doing one drop and on
that
so things look a little bit different
when we can assign temporary variables
like this
okay this is e
and now again we have a problem that
we're concatenating on the left and we
know that that's potentially slow
canceling on the right when the
interpreter will reserve additional
space for the array to grow and then it
can just write into that space so that's
going to be much cheaper than rewriting
the whole thing
so how can we
reformulate this
to concatenate on the right instead so
we're concatenating here on the right on
the space on the right
and then that just means that we have to
move our corresponding zero over um on
the right as well
and that and then similarly we have to
rotate the other direction
and then dropping
from the opposite direction
and then no more spaces here at the end
so that potentially should be faster f
should be faster than
than e
okay there are even more ways we can we
can play we've got plenty of ways to
write this so
um
let's
start off with again our normal
comparison
and now we're adding uh that
um that spaces as
as always
so it's it's a space indicator in our
boolean vector so
zero
and then we're going to to process that
in much the same way as
we've done before
we are
rooting it rotating it one step and then
doing an or with itself so so far
so good that's the same as what we've
been doing before we're just writing it
in line here rather than taking the one
um outside
but the trick i want to get here is this
gives us this gives us this
um
then
we also want to make sure
to
to not catch anything at the beginning
so if we start here with
um
well i'm going to explain this
this is a test
so the these are all fine
um
but if we have one space here
that's not right because it's adjacent a
a um
a space adjacent to a none space and we
want to get rid of that if we have more
spaces
then we start detecting that it's a
space addition to another space that's
not okay so
the cheap way of of fixing this
is
by saying that any space
any character that appears before the
first
none space
shouldn't be regarded at all and of
course any character before the first
nonspace is going to be a space
and
we can do that
by
taking the
running
and
i'm sorry no the running uh running or
and because we have we have our our
comparison vector here are the num
spaces so that means we start with zeros
for all the spaces and then we get a one
so
so this means as soon as going from the
left as soon as we hit the first one
then any character after that
will also have a one
and and similarly any
character up to
uh the first one has then a zero so this
is a strict condition we can then take
that and put it up here that we only
want
we only want the ones here but we have
remember we have this problem here with
this one
if it's also true that it comes after
the first one
so now this gives us a good mask that we
can work on
and then we just use this
to filter our argument
we can try that with uh with s we had
before
uh what am i doing wrong here oh yeah of
course um we have to drop
the
drop the zero from the end after we're
done with our with our logic
here we go
alrighty then
we could also
use this kind of method of this
cumulative or
or scan and to
in a way spell out all our conditions
so starting with that same vector here
let's spell out um our conditions and
then
we don't need to worry about this
cyclical thing
and the way we're going to uh to
spell it out
is again we're saying that it is
this is the adjacency to a uh to a
non-space
so it so it has to be
um a non-space
or
adjacent to unknown space
and we all and it also has to come after
the first non-space
and it
and
it also
has to come before the last
non-space so the last known space we can
write as as a little defend itself we
reverse the argument and then we do our
and
or
scan and then reverse it back again
so here we've just spelled out
with the conditions for keeping a
character
is that it is adjacent to a non-space or
it's a non-space
and it comes after the first one and it
comes before
the last one
okay and one final way that we can
you could potentially use this
is if we take this uh the non-spaces as
always
and then and we let's give that an a
name the mask
and then we
we use the less than scan it's a bit of
a a tricky one you kind of have to
know this but what it does is it turns
off
all ones that appear after the first uh
one so let's say let's say we have the
the mask like this
um
oh
yeah sorry uh here's our mask and we can
see that it it leaves only a one at the
first one and all the all other ones in
this whole vector are turned off so
that's uh that's what we're doing
now and then we can specify that we
some for something to be preserved it
has to be a non-space
and it's and it
now what we're going to do is we're
going to say a non-space
and not
but and not is only so we could write an
end
not like this
but and not is only true
if this is one
and
this over here is zero and so for
boolean that just means that it is
strictly greater than so that's a way to
write and not
so effectively what happens here is it's
exactly the same vector as before the
different from space vector except that
we have
forced the first one that's there to
become a zero
and now we can use this to cyclically
rotate and that is safe because we know
that the first element cannot be a one
that means that
when we rotate it one step we for sure
get a zero added at the end
and then we can compare that with our
mask
and
now compare that and combine that with
our with our mask so it has to be at and
on space
or adjacent to a non-space as before but
adjacent to does not
wrap around
so it looks much like what we had before
but we don't have the problem of
wrapping around and messing with uh with
the training
and
the training ones rather and
we we're wrapping a zero around there
and then we can use that to filter it
over here
and and
even and even if we use something that
doesn't have spaces at the end that it
doesn't matter they're not um
it does nothing interferes here because
they they are still adjacent to the neck
to none space that's being rotated one
step to the left we're not
nulling that out
okay
that's i
so now we for for comparison of all
these different ways of with using the
cyclic rotation
um that were all the letters from c to i
let's instead of having to spell those
out let's use another utility from the
defense workspace
and
it's the generalized iota and not only
does it handle non-numeric data it also
handles a start point and an end point
rather than starting always at one or
zero if you're using code i zero
so that means that we can write for
example
k to
iota
g
w we get all the letters
from k to j w
inclusive
and that means that we can say uh we
want letters from c
you would say uh iota g and we want them
all the ones to i
and then we want each one of them
concatenated to
an each
and
the t
that gives us all our the expression
that we want to run and then we can run
cmpx and on that
and it's pretty clear that it's our last
one here the the
clever one that avoids
the problem of this of rotating the
wrong data around that is and the
fastest one
good to know
okay hey how about regex we can pretty
much guess that right it's going to be
slow but there are different ways of
doing it they're interesting to to see
how we could do that
so
for regular solution
um
one way we can do it is by defining
exactly
which spaces to remove and which spaces
to condense so the ones that need to be
removed
are
in the beginning of
and our text
any number of spaces or
any number of spaces at the end of the
text
the only thing that leaves us is getting
rid of the multiple internal spaces so
now we can say once all of those are
gone
then we also want to remove
any
any run of spaces
with a single space
we could also say any space followed by
um by any number of spaces but it's
probably not going to make a big
difference so that solves the problem
um and let's call that j
another way we could do it is using a
single pattern just to specify all the
spaces that need to be removed
so
these this just moves
all of them replaces with nothing but
what exactly
is a space that we want to
remove well we can start off like we did
before
any number of spaces in the beginning or
any number of spaces
at the end
um but there's one more possibility
that's the internal spaces that are uh
that are redundant what does it mean
that there are redundant it means that
they're adjacent to another space just
like we've been using
pure apl to do before so we have a space
and then we want to look ahead and see
that
there's another space so if there is
another space coming up but not included
in this match
then we should remove that space and
that just leaves the last space in every
group of spaces
so this solves
our
problem as well
and finally
we can make a solution where
we
i call it like exception
pattern solution
and that's when i start off by
protecting certain things
in that i replace them with themselves
and then anything that's left over using
a different pattern and is then
changed
so what we want to and what we want to
keep
those are
spaces that are in between
two non-spaces so how do we and how can
we do that well
we could use a look behind and look
ahead and but that it doesn't really
matter
and so if we have
a nun space
followed by a space
followed a and an upcoming
so that's a look ahead
any number of characters
so
the problem here is that uh
this could be the last character the
last letter
in our text and it will be followed by a
space and then we say any number of um
of characters that come after that
and that will also match that there
should that um
a space at the very end
but we don't want uh we don't want to
keep that so and we need to to make sure
that something follows and after and we
can't
because consume a non-space because then
that we then uh you might have
non-space space non-space
space and we need that middle uh
non-space to be used to justify both of
the
of the spaces that are adjacent to it
but what we can say is that follows any
number of uh
of characters
look ahead
and and then there is something
somewhere after that which is also a nun
space
and then and
and those are the spaces we want to
preserve any other space that we want to
uh you want to remove
let's just try this out
like that
um
we could also say that
well you might think that we could also
say that that we want any spay any
number space followed by space by any
non-space
um but that would only preserve those
places that are
just a single space
but we don't want that we want to
preserve one of each of the spaces that
are in sequences of
of spaces as well but so this is this is
another way
of doing it with regex so three
different ways of doing it
the first one
was to
to do two different patterns to do the
two transformations leading leading
training and then we had and then
separately treat multiple spaces and
make them one there's the one where we
are specifying exactly which spaces to
be removed using
well it's an ore and three different
patterns and then there's this one where
we are accepting the spaces that we want
to keep and then removing all other
spaces
so
let's try that and we want
and
j
each of
uh
k a h of t and
k each of t and l each of t
three different ways of doing regex and
and to see which one is faster in our
case well yeah pretty clear that
using the two transformations would be
faster in our case this might not be
true in every case
okay now
here's a fun thing
because of our problem being very
specific we're only dealing with spaces
and none spaces and we want to get rid
of any runs or spaces other than them
being a single uh space inserted there
then we can use a little trick
um and that is using the classic way of
of splitting on spaces
or on any other character really so we
partition
by where we have none spaces
and
the
because
none spaces are indicated by zeros and
any element that corresponds to zero is
removed
um
using when we're using partition that
means that all the spaces
are removed
leading trailing all the internal ones
now we remove too much because we want
to
to have exactly one space between each
word
but that's not so bad
because what we can do then is join on
spaces adjoined with spaces
we could write that as
the left argument followed by space
followed by and right the right argument
but this will fail um if we have an
empty vector because that will attempt
to that will need the identity element
for this uh function of for which uh
there isn't one because well firstly api
can't figure it out for none primitive
functions but secondly there is no
argument you can give to this
on one side so that we preserve the
argument from the other side because it
always adds a single space
so we can see we get an error there
instead what we can do
um is we can and just add a space to
each one
and it we know that it's probably faster
to add things on the right so instead of
just doing
doing this space concatenated to each
one will bind the space on the right
side of congratulations so this just
adds a training space to each one we
could also use commute for this but but
this will work
oops yeah we should use our sample of
course
and now we just need to
flatten it all down
and and
then we have a training space that comes
out here and we just need because we've
added a space to each one so we
and
drop the last one we know that's going
to be a space
and that gives us
um our results right there
so this is one way to split and join
um
given it i didn't give a name to this
one this should be good and while it's
not really valid but it'll be
interesting to see if there's a
difference in in speed as well between
join on spaces and add a space to each
one
and then
flatten it all out and removing one so
we can still compare them even if we
know that it's not really valid
should be
okay
it should really be the other way around
the alphabet there yeah let's fix that
okay
fine let's uh let's
try to generalize this in a little bit
that's that's really trivial if we take
uh this one then
we can just
use the left argument here and a left
argument here
um so that would
um that would be a generalization of it
just to show how we can do that so this
is actually a kind of useful thing to be
able to bind an argument
with a function it's just what i want to
demonstrate
um but
this form also has a uh
an additional benefit and that it is
extremely amenable uh to uh
becoming tested
okay so how might we write this as a in
tested form
well this is just application between
the arguments and this is uh the right
argument so we could write this as a a
right tech here
but since we're just flipping and the
arguments of the partition and we have a
single primitive over here then there's
no point in writing it like that so we
can just in in flipping them around so
we can write that in the proper order
and now
we want to add and the left argument
concatenated
on each
but flipped around
and then we uh we
flatten this
and then we uh okay we need to to change
our
braces to parenthesis
and then we could combine this
um
so because this is a magnetic function
so we're just pre-pressing the red
argument to the negative one but instead
of that we can actually just let it be
on the top i find it on the top here so
we have this fork here which has a fork
right right argument a right time and
then a single function so that's on the
top and then we can just state the
negative one drop um outside as well
so it saves us from this
somewhat awkward
um we call it composition
of it
so we can try this
and this this works as well in a test
form
so these were all
based on splitting and
joining
let's
compare them with each other
so let's do
this was
m
g
p
and each one is with an
enclosed and each of t
so these are all the split and john
they're probably not going to be fast
but we can still uh compare them with
each other
oh something is wrong here and what i've
been doing oh yeah of course um the
reason um it's wrong is of course it's
not it's not actually wrong the problem
is
no is it hold on
um
oh
i miss missing something
ms up here
join on these
what did i mess up here
oh this this looks right you join on
this on the sample
oh of course yeah silhouette and we're
doing a reduction here so we and we
should so this becomes an enclosed
that's that's what it's trying to to
show us here with the extra space it's
been enclosed so we need to disclose
that of course
there we go
that's m
okay so this is a good feature of cmpx
that
it indicates that an
element an iron result is different from
the other
results
okay now the matches are there and now
you can see that
first one was very slow that's the one
that's doing the reduction and it wasn't
completely right anyway because it could
handle the empty argument so that's good
and the other ones are much faster than
that
finally
a function that's often overlooked is
the find function and the find function
and
indicates the beginning of any sub array
in them in a an array so we've got our s
here
and then we can say we want to find
places where we have doubled spaces
so this is we can see that we have three
spaces at the beginning
and that means there are two instances
of
double spaces here there's a double
space over here and then there are all
the trailing spaces that that cause
double spaces at the end
and uh we can use this
so let's start off with with something
uh that
just like we've been doing uh doing it
before
different from um
from space and then we're going to uh to
do something like that and then so here
when we have different space we are we
want to look at places where we got
zero zero so this corresponds to
and where to what we're doing over here
we just do it using it on the boolean
instead of using it directly on our text
okay now and we'll we'll come back to
this uh let's just do the basic thing
and first which is going to be
that we want to make sure that we so so
this will yeah this this thing will take
care of the double spaces eventually we
can we can see that already here so if
we negate this
then that indicates all the
and all the places except for a space
that is followed by another space which
are the redundant spaces so if you use
this already to compress here that gets
rid of our double spaces but doesn't get
rid of our
leading and training spaces other than
compressing them down to become single
spaces but we can fix this
and
leading a chinese spaces
we can get rid of by with the same
method we did before
with the scan so we want to find any
thing that that is
that follows the first one but not
anything before that and anything that
comes before
the last one
so
we can and
any we can do this reversal and then we
do it in or
on that and then we do
and reversal again that gives us a mask
show indicating ones all the way up onto
the very last one
and that's that takes care of all the
training spaces and then we can combine
it with a with a regular uh or scan so
we want both of these to be true it has
to be true this after the first one and
before the last one
oops
uh yeah we need to bind these together
as well so too because this is a
magnetic so we need to pre use
we do that by pre-processing the right
argument to end
and that gives us the internals there
and then the only thing we want to also
be true
is
that
it isn't
a a space which is followed by another
space
oops we forgot to bind by the argument
to that
and
um oh yeah this is um this is wrong
anyway because we want
this has to be false it has to be not a
space that's next to another space and
this has to be true it has to be in the
internal part so we so it's like we the
the end not but backwards so the mean so
this has to be on the right has to be
greater than what's on the left
and that gives us our and our mask and
then we can use that to filter the
argument and that gives us our result we
call that q
okay um another idea we can use now that
we know how to take care of duplicate
spaces
then we are free to explore other ways
of getting rid of
of leading and training spaces and now
there's this thing called idiom
recognition where certain phrases are
and are not actually taken at face value
but are um
interpreted as a single kind of are seen
as a single token and then the
interpreter internally
uses a very fast algorithm for doing the
same work that this function would have
done
and one of them is actually exactly this
to remove spaces apparently that's
something apls do a lot and they
and they want
and to run fast so if we type this up
notice that it turned a different color
here that is indicating that this is an
idiom and therefore going to run very
fast
and the problem is of course this only
removes leading spaces this is exactly
that mask on the leading
leading nun spaces
and we also want to do it from the
reverse but we can do that simply by um
reversing our argument
and then
applying this which removes leading
spaces and then reversing it again back
again to how it was before and removing
the leave space meaning that this whole
thing
just has to run twice
um
and once that's done so we can try this
on our sample so this gets rid of all
leading and training spaces then we can
apply atop that
this exact method that we had before we
want the argument where it is not true
that we have adjacent
a space that's adjacent to another space
on its right
that gets rid of that so this may be
fast because we're using this idiom for
the in
for the leading and training spaces even
though we're using find for the uh
for the
middle spaces that need to be removed
let's call this r
and then
finally let's
let's try to use an
a bit you work with if we'll find
straight on the bit mask
in a bit different way
what we're going to do here
is
we're going to start for once with
things that are spaces
so this is exactly the opposite of what
we what we did before
and but the good thing about it is that
we can then
do an
n scan
that gives us
all the leading spaces
and
then we can do the one one find that
gives us
um all the
duplicated spaces
and we don't want any of those
so neither this nor that
we can try this
in fact let's put it in here that's what
we're going to do
so
um
so all the
all the leading spaces
were removed and all and now we only
have training spaces it's a little bit
hard to see that we've got training
spaces here but if we use display
and then we can see that we've got a
training space there'll only ever be one
training space because we've reduced any
runs or spaces to a single space
that means that the only thing we need
to do is remove
a trailing element which is a very fast
operation
if
we the last character of our input is a
space
so how can we find uh the last character
of uh
of the input well if we reverse it
and then uh take the first that's the
the last and then we need to to drop one
if that's true so that since it's from
the end we can do negate
on top of that
now and
this might be a bit faster if we allow
the interpreter to use its idiom like
this
but we can't do that when it's uh when
it's tested
so let's just write it
like this instead
and now it should be and it should be
able to recognize it as an it's
interesting it's really not written
yeah
it thinks it's not an idiom when there's
a
an adjacent space it seems like a bug in
the syntax color
um okay so this finds uh the the
trailing space and
um
bit attack here just a piece oh
oh so interesting okay it wants a space
there
oh well this should be fast anyway
um so if we have an a the last element
being a um in this vector of indicating
where their spaces then we negate that
if it's zero it just stays zero and then
we drop that many elements on the right
and that should and we can try to
display here we can see that there are
no spaces at the end
and we'll call this s
and then we are
ready to test our find based methods
so this is cmpx and we've got a qh on t
and rh on t
and
sh on t
and we can see that r is by far the
fastest one of these which one was r
and that was the one where we were using
the idioms
to remove leading and training spaces
so that's interesting to know okay so in
each category we found out which one was
the fastest one
and if i recall correctly those were a
from the category of
um
adjacent characters it was i
from the cyclical rotation
um actually we can have a look at them
it was
k
from the regex it was p
from where we're splitting and joining
and now we had r here where we are using
defined
so that that's these
we'll take
these and compare them to each other
oops
missing a comma there
and
that shows us that a and i are fastest
but they're so close to each other and
that it's kind of hard to decide when
when it's being drowned out by other
things
so let's try to just do these two
and turns out that a very first solution
and
is actually the fastest one
very nice
thank you so much for watchinghi
our task today is to shift some Boolean
data
we are given an amount that we're going
to shift in from the left so if it's
negative it goes from the right
and then we're giving the Boolean data
as a vector or possibly a scalar so we
just have to end that as well
and there are many different ways that
you can do this
I'm not going to go through all of them
just one
if you want to get inspired by other
ways that this can be done go look at
the transcript for the chat event that
happened in preparation for this
presentation
so let's start with some data this is
the sample that we're given in the
problem description
and we're going to
shift it by three different amounts
we're going to shift it three steps and
then zero steps and also negative three
steps so that's the other direction
and let's do all of this at once so
we're doing we're writing a Lambda here
so we're going to Define
inline Anonymous and then we're going to
apply it to each we wanted to map over
these three shifting amounts but each
time we wanted to not apply to separate
elements of this Boolean data we want to
apply it on everything so this encloses
it and then apl's scalar extension it
takes when we have an each it takes the
one scalar on one side for example and
three elements on the left and then it
pairs them up appropriately
so by taking this entire thing and
making it into a scalar then everything
gets paired up correctly and we can see
that by having our function just create
a two element vector or list of the left
argument and the right argument left
argument is denoted Alpha right argument
is denoted Omega
and we can see it pairs up the left
argument elements with the entire thing
on the right okay so we're going to take
this in three steps
the first thing is we're going to
identify which data it is that we want
to keep so when we do the shifting to
the with a positive number to the right
then as if it were we're pushing in on
the left three zeros and the data moves
to the right and the last three elements
then drop off the edge on the far right
so that means that the data we want to
keep
is all but the last three elements
we can use drop
but
that gives us the drop from the wrong
end because three drop drops on the
front and negative three drops from the
rear
if we negate the number then it goes to
the correct way so we can see how these
are the initial five elements and over
here we have the training five elements
and for zero we didn't drop anything
we can save ourselves this parenthesis
if only we had a function that's like
drop but takes the arguments in the
opposite order so the data goes on the
left and the amount on the right that
doesn't exist but we can Define it in
line anonymously by putting this
confused frown called commute
next to it and that commutes the
arguments of this adjacent function so
the arguments are given the order
I like writing it like this
so now we are have the correct data that
we want
next step is identifying where we want
to put this data in the final result
so if we get the length of the right
argument
and then enumerate the indices there
then we can see that we when we shift to
the right with the positive three
we want these five elements to end up in
these trailing three positions
and when we're not shifting then
everything stays the same and when we
are shifting to the left pushing in
zeros from the right we want the first
positions
so in essence we could say if we look at
the indices we can take this amount and
drop
that many elements from the in from all
the indices and that gives us just the
subset of indices where we want our data
to end up
so that would be the left argument
dropping
the in indices from the right argument
but we also need somewhere to should we
say draw our our picture we have the the
data we want to put into the picture we
have the positions in the picture where
we want to put it but we need a canvas
where to draw it and that would be a
array of the same shape that just has
all zeros
and there are various ways we could do
it but a very simple way to do it is to
do a zero multiply by because these
booleans are just numbers or we could do
a zero end which also nulls it
um so
this works
and now we can take uh all the pieces
and put them together oh there's one
more step before we do that there we're
also given the case where uh the
argument is a scalar in that case we
want to normalize it to become a vector
which we can do is just by reveling so
in magnetic comma it Revels it's mix it
flattens the array into a
um just a simple list a vector which
means if it's a vector already it stays
that way if it's a scalar then we make
it into one element Vector so now that's
done then we take the data that we want
to put in
and we stick it in at
the indices that we computed by dropping
elements from all the indices of an the
length of the argument
now we can see how we have shifted in
three bits from the left
and three bits that have fallen off on
the right
and then we preserve these for zero
nothing happened here
and for negative number we're shifting
in from the right
and if we try this on
a scalar case and let's say a one
then we it gets normalized to a vector
and in the case where we are we are
shifting out too much there's nothing
left we still just have a single one
zero
and in the case we're not shifting
anything we preserve the one as it is so
this is
um our solution
but
just one of many possible solutions so
go have a look at the transcript from
the session
and
maybe you even want to join in on a live
event happening every Friday
thank you for watchinghi
where's your check which
of the given words contain consecutive
letters that are identical
let's start with a word that does have a
duplicated letter that is the lowercase
l
the easiest way to go about this is to
do a pairwise comparison so we want to
compare every letter with its neighbor
for that we use the dynamic form of
reduction so this is an equal reduction
and this is a pairwise equal reduction
we go over windows or size 2
and compare
so we can see that there are four pairs
one two three four and the third pair
has the same left and right so they
equal to each other
we're not actually interested in knowing
where they are or how many are there are
we just want to know whether there are
any so we want to ask are there any
which is an or reduction so you're
putting or between these so you're
saying 0 or 0 or 1 or 0. and that gives
us one yes they are
If instead we try a world
then we don't get any because there are
no duplicated letters
okay
this solves the basic part of the
challenge but
there are a couple of catches one is
that we need to be able to handle
scalars so this is not a string or a
list of one
character rather it is a single scalar
character without dimensions and since
this Paris reduction needs to Traverse a
dimension it fails
as there aren't any Dimensions to ruse
it's saying rank error a scalar has
ranked zero there are zero Dimensions
but we need at least one dimension a
vector in order to do a reduction
we can fix this however by reveling
reveling means taking all the elements
that are there and like a bunch of yarn
we are revolent or even a sweater where
you pull a loose thread and it becomes a
single dimensional list of the elements
and that is magnetic comma so
it will appear the same but this
actually has a dimension that we can
then reduce over
so I doesn't have any of course and no
one element and
word will ever have duplicate letters
because there's only one there
now that this is done we need to fulfill
the whole spec of the challenge which is
to handle multiple words so
I of course as we know doesn't have any
and Z doesn't have but feed has and
bookkeeper has multiple duplicated
letters
so we take this
function that we have created it just so
happens that we can just parenthesize it
and apply it to each one
and this works fine
one more catch is that we have to be
able to handle a single word so this is
the each
and if we try to do this on single word
then we get the wrong result and that's
because the each now traverses over the
word itself and adds and applies the
function to each letter
what we want to do here is if we have a
single word we want to enclose it but if
we have multiple words then we don't
want to enclose it to treat it as a
whole and for that we have a very
convenient function that is often called
inclusive symbol or just nest
is because it does exactly this it
encloses if the argument is simple so
this is a simple single word and it will
then enclose it but if you have multiple
then it will not enclose it we split it
like this all right it's the include
symbol with an extra underbar also
called nest because it guarantees that
your result will be nested if it isn't
already it will add an outer enclosure
so now we get the right result here and
if we try to do it over here
then we can see and which which words
are
have duplicates and which ones do not
and so this whole thing we can just go
and give a name
and now we can apply it on both
lists of words
and single words
thank you for watchingwelcome to this very last APL Quest
video see APL Wiki for
details today's
Quest is to
split a text on
spaces and there's a specification left
argument which tells us how many
segments to cut
into and basically
we want to be greedy and split at
leading um at the first coming spaces
until we have as many segments as
required and if the number of segments
required is larger than and what we get
just by splitting on Spaces then we need
to add empty segments at the
end so let's get started here is a a
sample text and um let's first try this
as a test it
function now there's a a couple of
classic ways to uh to split on
spaces and this is one of
them so what we can do is we can we can
start off with the argument and
concatenate another space in
front we can kind of make out the space
over here here the reason we need and
this additional space um is so that we
can compare with the
space and that gives us this mask that
we we can then use to
partition the right argument and this
gives us
um a a cut
off set here but um we're a bit off and
that's because we added an an a space at
the beginning so that we would include
the leading text so instead of splitting
the original we can split the
concatination
okay that looks more sensible to work
with here's a trick though uh since we
want to potentially add empty segments
at the end we want this nested array to
have a prototypical element which is
such an empty character vector and we
can do that by
injecting a um an empty one at the
beginning we could do this manually but
we can actually do this kind of what I
would call
automatically and how can we do that
well if we go back and to how we created
this
mask then we can say in we added a a we
concatenated a a space in front so that
we would get a
one but we can also
add a two manually or for that sake a
one but by adding a one that tells
partition function that we want two
segments to begin here so we get an
empty one at the
beginning and now we can use this to
petition the concatenation of that space
with the original
argument this has the benefit then that
if we take too many elements say six
elements
here then we pad with empty elements at
the
end if we didn't do this and we try to
take too many elements say um six here
it would actually be five to be similar
then we pair with elements that are not
empty because they're based on how long
the first element
is so this solves that
problem and now really All That Remains
is uh to take this and
merge as many trailing elements as
required so that we have the right
number um and then finally we need to uh
remove this leading element that wasn't
there and possibly we're going to take
more elements than they are and they
will be paded automatically so now uh
let's add the left argument let's do
three for
now and so we can take uh the left
argument and
take from here that gives
us the leading elements that we're
supposed to
preserve and then we can use a drop and
that gives us the trailing elements that
we we want joined together so we can
combine this by saying we take the
leading ones followed by the trailing
ones this is of course the whole thing
but before we do this concatenation
we're going to postprocess the drop with
joining them together that's a
concatenation reduction so we insert
concatenation between all these elements
we do that on top of the result of the
drop so now we've joined the
last and we get a total of three except
of course the leading one that we
inserted just temporarily to get the
right
prototype this means that we can strip
the leading one and we can drop the
leading element from each one because we
had that one
space um here that we don't want want
includeed now that we have split on
spaces so this works for three and for
four you get the exact fit and for five
we have the
take add and additional elements and so
to for any higher
number so this is one solution to the
problem here's another solution to the
problem we can start off the same way
Way by
concatenating a space on the left and
let's call that s for eding edit a
space and then we can make our mask
before we did that uh with a tested sub
function but now we can do that
explicitly like this the the pass
through value of an
assignment is the value that's on the
right of the assignment Arrow so we can
use that directly the first element of s
is going to be the space then we don't
have to repeat ourselves this gives us
our
mask and now we want to change this mask
essentially we want to get rid of ones
that are over here if we don't want a
new segment to start there so rather
than creating all these segments and
joining them together we don't want to
create them from the
outset how can we do that we let's run a
an addition
scan that gives us the running count of
ones here and then we have a left
argument which is the maximum number of
segments that we
want so if we
clamp here then all these fours become
threes but we actually wanted a mask how
can we get back to a mask well all these
numbers are necessarily unique since we
are always um increasing or staying the
same that means that we the ones
correspond to uh the first time that any
one of these elements occur so there's a
one at the beginning of the ones there's
a one at the beginning of the twos and
there's a one beginning of the threes
and we can do that using the unique mask
unique mask indicates the first time a
unique element
appears so now we're back to the mask
but the one that indicated where the
four we supposed to begin is gone if we
put in a four then we preserve all of
that and if we put in a five then
nothing more happens we're not clamping
anything okay with this we almost ready
to petition the problem is that if we
take this text and we try to petition it
it all works nicely for uh for this case
oh actually we shouldn't be using the uh
the original argument we should be using
the one that has an S at the beginning
so that we stay consistent but if we
have too many segments that we want then
we don't get
enough we want empty segments at the
end we can do that by telling partition
in close that we want trailing
elements we do that by adding a number
at the very end of the Mask that's uh
the one element beyond the corresponding
to the last element of the data which is
the count now we could compute how many
are necessary to add but they're all
just the same empty elements and it
doesn't really matter the maximum it
could possibly be is the number of
segments that we want at
all this is of course too many so we can
strip down the ones that we don't want
simply taking as many as we do
want and now all there remains is to
drop the the leading space on each
one thank you for watchingwelcome to the epl quest capl wiki for
details
today's quest is the fifth problem from
the 2014 round of the appeal problem
solving competition
it's a pretty simple problem we're just
to find out whether a given text is a
palindrome slight complication is that
we need to make sure to ignore things
like case and punctuation
let's start with some test data
okay
so we need to get rid of
of case differences so that for example
the first a and the last a in panama
match each other
and we can use quad c which is
case fold for that
now and
we just need to sort out the
characters that we need to compare and
get rid of those that we don't want to
look at at all and one way we can do
this is let's uh let's put this into a
function so we can try this
this is the case folded one and then we
should look
which characters are members of the case
folded alphabet
oops
uh
yeah of course it should be
omega here there we go
okay
and then and
we can
filter by that boolean vector
let's call this
just the letters
the last step is to see if the letters
match themselves when they are reversed
we can see that amanda plan and so on is
a palindrome whereas hello world is not
this works
but we can do it a little bit more
elegantly by making some observations
about what we've got here
firstly
filtering by membership
is the same thing as intersection so we
can actually substitute this whole thing
in
and say
then the intersection
between
the case folded
argument and the case folded alphabet
notice that we are applying intersection
after preprocessing both arguments with
case folding this calls fun over
finally we are comparing
this l to its reverse
an operation between
um the identity of some value and
some pre-processed
value and that we could call that a hook
construct
but really what is
another way to think about it
is that we are applying
the match function between l and l it on
itself
so that means we're doing a selfie
only that before we apply match we
preprocess the right argument of match
with
reverse
and then since we're only using this
variable once there's really no point in
assigning it so we can just put it in
line
there's also possibility of making this
a fully tested and function
it's quite simple here because we just
have a dyadic function applied between
the argument
and a constant
and then we apply another function
magnetically on that so clearly this
whole thing is in the top
one thing applied and another thing
applied
only that we have here a dynamic
function where the one argument is
constant so we can bind the alphabet as
a constant right argument to it
and that gives us
a very neat tested solution
let's call this a
it does have however a little bit of a
performance issue namely that we are
case folding a potentially very large
argument
all we need to do is we want to see
to to
only keep those characters which are
uppercase and lowercase letters and the
whole reason we're case folding the
whole argument is just so that we can
take the intersection with the letters
now
the input might be of an unknown size
but the alphabet is of a known size
and so and we can optimize this a little
bit by simply keeping
the intersection but instead of case
folding both arguments we only
case fold
the alphabet now this is a problem of
course because
this only gives us lowercase letters and
that we might also have uppercase
letters so let's just supply the
uppercase letters as well this is a
one-time operation when we define the
function generating an uppercase and
lowercase alphabet and then we just do
the intersection on that so that might
that saves us from doing the case
folding on the entire argument and that
might speed up things a little bit
so these are the basic solutions but we
could actually go a whole different
route and that is to compare ranges
so instead of looking for intersection
which is a set function
we can look at where in the unicode
character said
do the characters fall because all the
um in unicode and ascii all the
uppercase letters are contiguous and all
the lowercase letters are also
contiguous
and so if we look at
the values for the beginning of the
uppercase alphabet the end of the
uppercase alphabet and also
the
beginning of the lowercase alphabet
and
the end of the low case alphabet
oops sorry we need an each there
okay so we can see from 65 to 90 from 97
to 122. now interval index is what we're
going to use for looking up ranges and
it
made it is inclusive on the left and the
beginning and exclusive on the end so we
need to go one up at the end and then we
can look at what
what those characters are so this is the
these are the characters that we want to
use for cutoffs
and so we can see that um some
characters fall
inside this interval here that's number
one between these two and then zero is
before the first one and then some fall
um over here and then there might also
be something that falls in punctuation
the force here but that's pretty rare
um which means that it's every other
interval which
we want if it's zero it's outside we
don't want it if it's one it's it's an
uppercase letter if it's two it's
lowercase if a it's it's some
punctuation and it's if it's three it's
uh lowercase i mean if it's four uh then
it's beyond the lowercase and small
punctuation that we don't want so we can
take the division remainder when
dividing by two
and that gives us a
a one for all the odd ones which is
exactly where we have uppercase and
lowercase letters
and that is what we need to use to uh to
filter with
so that's another way of
of doing the filtering and then we can
apply uh
the actual
palindromic
testing uh as we've done before
oops
oh and we've of course been missing the
case folding that's once we're done with
that
there we go
let's call the c actually we can we can
make this one and test it as well
um
before before we give it a name let's
just try that
so there's an interesting problem here
with uh
with the slash which is a hybrid
operator function
we can we can begin by fixing that
within a top and then we have a dyadic
function with a constant left argument
so we can just bind that over here
and then we have
the argument over here
case folding
and then
comparison
so we could we could write all of it
like this
see
but since we are anyway post-processing
the result from uh the replicate or
compress
here then we don't actually need to use
an identity function to do uh
with the top to force it to be a
function we could take this whole thing
and move it in here as well
so let's call this c
but this whole business of uh case
folding and that means that you need to
consider every character whether that
needs to be case folded that is
potentially expensive and if we can
operate on raw code points we might get
a significant
performance advantage now how is that
going to work
so if we start immediately by converting
all the characters
to code points if they are all ascii
then that's really cheap because that
means we can we can because the code
points are
essentially
unsigned
um byte values on-site integers
if there are some characters that are
outside of ascii then we'll end up
having in
values larger than 127 and we'll have to
go to two byte integers because the
integers internally are
um are signed but still is going to be
pretty uh pretty cheap operation to
switch to code points
like this
and then uh we need to check whether
they are in this range that we used
before
and we can we can write this in a tested
way that i i really like for uh for
ranges
um so there are two ranges we're looking
at
and we want to know if it's in either
those ranges and so the way we can api
doesn't allow you to write
x uh or something like a a is less than
x is less than b because
less than is just
a function and it would bind wrong but
we can write
that
65
is
less than or equal to
and
the value is also less than or equal to
90 so that's the upper bound and this
kind of reads nicely right 65 is less
than or equal to and it's less than
equal to and to 90. so that's the upper
case and then lowercase is 97 is less
than or equal to and it's less than or
equal to
122. so this i like writing ranges in
apl like this
so this again gives us um
the
elements that we're interested in
and then we need to use that to filter
but we're not filtering the characters
now we are filtered because then
uh we need to case fold we're filtering
the code points so we give this a name u
and then we'll
filter you with that and that gives us
all these uh values now it might not be
easy to see what's going on here but if
we just temporarily apply
quad ucs to it we can
do each again
then we can see all letters that we
interested in
now here's the thing ascii and then by
extension unicode
because it's just a superset is
constructed in such a way that there's a
single bit difference between uppercase
and lowercase and that's the
that means that we can do a
division remainder with 32
and that since we're not it's it doesn't
matter that there are many other values
that would collapse to the same division
remainder with 32 because we only look
at uppercase and lowercase letters so
anything we need to do to know is like
the offset from the beginning of the
alphabet and 32 gives us exactly that
now this these aren't useful byte values
but we're not interested in byte values
we're just interested in these um should
we say labels on the characters and see
if they are
the same
and then we can
check using the exact same thing as
before whether or not we've got a
palindrome
so by working on on code points the
codis is significantly more involved
but we might potentially avoid some
expensive operations there
okay let's have a look at the
performance
we're copying cmpx from defense
and then we're going to uh
we need to
create some test data of course
so let's uh let's create some test data
say
we overtake from the upper case and the
lowercase alphabet much like we did we
let the application look
alphabet before
um followed by a little bit of
punctuation that might happen there so
because this adds up to to much less
than 70 that means we'll get some um
some spaces uh as well so it kind of
looks like natural text
and there are obviously 70 here and
let's just to do 50 of them for now just
to see what what this looks like
so this kind of looks like natural text
with a little bit of punctuation there
it's not really very important
and
so let's so this is a case so let's
let's put it over here
one
five should be enough
and then so this isn't obviously isn't a
uh a palindrome but we can we can create
one that that is a palindrome
uh and we can do that simply by let's
take
take half of this so this is
five e4
and then we can
just so it's the same kind of construct
this the hook contrast we are
self-concatenating it
um and then we are reversing it and
before we concatenate one of them so
this
concatenated to its reverse could be
read as competition it's reversed and
this is obviously a palindrome
and now we can say cmpx
on
a b c and d
each one of them
with the entire argument of t
so this is on a nonpalindromic
case
and we can see that um
our solution where we avoid case folding
the input instead of instead having a
both application lowercase alphabet for
the intersection that did save us
significantly and doing the intervals
with raw characters that's not worth it
however switching to code points gives
us a significant speed up in this case
and we can just for good measure you can
try this with the palindrome as well
we'll probably see similar
results
yeah that looks very much the same
so that's all for checking for
palindromes thank you for watchinghi we're giving an area and we're
supposed to make a
rectangle which could even be a
square that has that
area the Restriction is that the length
of the rectangle the size of the
rectangle must be integer and then if
there it's not a square then the
smallest side has to be listed
first so let's take 12 as an example
it's a good example because there are
many different ways to multiply two
integers together to get 12 say 1 * 12
or 6 * 2 and there's only one result
that's valid here and that is 3 * 4 it's
not a 12 not a square so we can't be um
well a square um but 3 * 4 are as close
to each other as possible another ways
other way to describe this is that we
want to make the rectangle as Square as
possible okay let's start by looking at
our candidates these are all the
integers that could come into
question um of course it can't be larger
than 12 there's nothing you can multiply
with to get 12 it can't be zero unless
our actual uh area that we need to get
to is zero as
well and then we want
to find out which of these numbers
actually divide 12 evenly um so we can
take the division remainder or
modulus and this takes the whole
range
and
dividing the number
itself and then we get these remainders
so we can see that 1 2 3 and four they
divide 12 cleanly five gives us a lift
over of two cuz 2 * 5 is 10 and then
missing two and so on
[Music]
um we are not interested in what the
remains are we interested in whether or
not it divides so 0 equal to that and
that gives us a mask showing the uh the
numbers indicating the numbers that
divide
12 the next step is then to find out
what these are and choose the middle
ones of these numbers so we can see that
there are six of them 1 2 3 four 1 2 3
four and six and 12 and if we were to
put them together then three and four
would be the middle two and that's the
method we're going to use it's going to
be a little bit inefficient to do it
this way but it makes it kind of
neat so the first thing uh we can do is
find out what these numbers are and we
can do that by asking where are the ones
which are the indices of the ones which
are the same thing as the numbers that
we started off
with so 1 two three uh four six and 12
and and the middle two are three and
four and now we could try to compute the
length and get the middle but there's a
much easier way to do that and that is
replicating all of these so we've got
two of
each and we also know the length of this
which was and which is
six and now if we remove the first six
from here that's a 1 one 2 to um 3 three
then we get to over here um so then if
we take the next two elements after
moving the first six we get four four so
all we need to do is either subtract one
or we could just insert a Dy element at
the beginning and then would get us 34
and it's a good way to do this as well
to not try to index in because if the
list is empty because the argument is
zero or if the list has too few elements
because uh well actually maybe that's
not problem but if it's zero then then
uh if you try to index it we get an
index error but if we uh if we drop some
elements and take the next ones then we
can overshoot and will p with zero which
is exactly the result that we
want so let's um pad with an element
that's going to be removed in a moment
so then and now we can remove the first
six from here 1 2 3 4 5 six and the next
two are going to be three and four how
do we get the number six uh remember
we're passing in The Mask here and
finding the indices here we don't need
to find the indices to get the length of
the IND es because we there are as many
ones in this list as the list of indices
so the sum of this is going to be the
length so we could take the
sum and
drop some number of
elements and then we just need to take
the first
two there you go that's our solution and
it works for um for zero as well which
is all nice
thank you for watching bywelcome to the apl quest c apl wiki for
dear sales
today's quest is the second from the
2015 round of the apl problem
solving competition
we're giving some numbers and we are to
find out
what the
longest run of intervals
are where the intervals are all
increasing in volume
let's start with some test data
so
we are to find which intervals that is
these spaces so to say in between
numbers and that are increasing
what we can do is we can subtract
any number with the number before it
this is an end wise reduce and because
of the direction we want we want the
rightmost element minus the leftmost
element so we can use a negated window
length to clip
the
subsequence backwards before we apply
the reduction over it
there's a little catch that if
and this is one of the the
example
arguments if
the input is a scalar then the invoice
reduction will fail
but we can fix this simply by reveling
the argument
okay so going back to our sample data
we got these
differences and we want to find out
where they are strictly positive so
that would be any of them that are
greater than zero
now we have a boolean mask
indicating and which intervals
are
growing
and then we can use
a partition
on any data really
but conveniently we can use it on the
same data and the way partition works
is
that
when the argument is booted left
argument is boolean is that any runs of
ones become
segments and any elements that are
zero get dropped out and that's also
where new segment begins
so we can see how we are getting these
groups of uh the first the one and then
the zero drops out and another one and
then the zero drops out and then we have
the three
and now that we have the segment lengths
these are the runs of
growth so we can simply
take the length of each one
and then
do the maximum over that and that gives
us our result
for this case which is
three let's put this into a function
like that
right
um there are some tricks we could do to
make this shorter
let's have think about this we're
finding a difference but we're not
actually interested in the difference at
all
what we're interested in is whether or
not we are growing so instead of
comparing elements
in size we can just compare them
directly so we want to know if the left
argument is less than the right or well
left element is left and then less than
the right element in this
two element sequence so we can just do a
two wise oops a two ways uh
less than reduction and that would work
as well
there are um
other should we say golfing tricks we
could use to make this shorter but that
doesn't mean it's better just for the
fun of it
let's try this
so
let's say we have this
vector of
vectors
if we
mix it
that is we make it we stack these
vectors on top of each other
to get a matrix
then we have to pad the short ones with
zeros but that doesn't actually matter
we can see what this looks like and then
we can see that the longest
sub-vector is the one that determines
the number of columns so if we transpose
then
the number of
rows is going to be the original width
and that's the length of the longest one
so we could just tell you that um
alternatively you could get the second
element of the shape but this is shorter
just not better because
transposing can be a bit expensive so
for code golf version
this works fine
but what is a good way of doing it see
the problem is that we are petitioning
into these sub vectors creating
potentially a huge amount of
vectors in a in a large vector that's a
lot of pointers and a lot of ways to
space for information that we actually
don't need the only thing we really need
is the length of each
and so let's think about it for a moment
let's start off again
with this comparison
what we want to find is the length of
sequences of
ones
okay
well
let's normalize
this by padding with some zeros around
it
now we can more clearly see these runs
of ones that we want the length of
um and now we know that we begin with a
zero end with a zero as well
what we want to find out here is
whenever we are switching from uh from
zero to one and one to zero that's a
cut-off point we just need to know the
distances between the cutoff points in
order to get the length of the runs
so we can attempt to do that um
the cutoff points the the places where
we when we switch from zero to one one
to zero that's when consecutive elements
are different from each other zero
different one one is different than zero
and of course one one is the same zero
zeros is the same
so it would seem that we can
we can do this and
the pairwise difference
and now already now we can kind of see
our result here that would be
this sequence here with three
so we can take the
indices where there are ones
and then
we can measure the distance between
consecutive ones
and then we can see our three over here
and we might think that we can then just
do a maximum here
to get the three
but
if we try that
then
we have pulled ourselves and the reason
for that is
that remember
here we're looking for the cutoff points
between consecutive between runs um but
you would find the the cutoffs between
uh
from from a change to from a one to a
zero and then back from zero to one just
as much as you will find what we're
looking for um from zero to one and one
to zero
so we can illustrate this with an
example that's not going to work well so
let's just have some descend lots of
descending numbers here but very little
uh
increasing numbers
and if we try this expression here
then we can see we get seven
and this is because if you go back and
look at um our differences well we can
start off with this actually
we can see that and here are our
increased runs
and if you look at the
where the differences are and sure
enough there's a difference here we go
from one to zero and then zero to one
over here
and then asking for the indices
of that and the consecutive differences
between them it gives us the length of
the longest run of identical items but
we only want the runs that correspond to
that are all zero runs so this approach
doesn't quite work but we can modify it
to make it work let's go back to our
boolean vector here
this indicates where we are growing now
um
instead
if we
if we look at the opposite of that where
we are non-growing
then we get a bunch of ones whenever we
have a streak of
zeros
that is none growing and we only get
zeros where we have a streak of ones
now if we ask
for
the indices
and compare
consecutive elements
then
since every time there's zero followed
by zero and there are complete adjacent
that gives us a length of two in between
sorry a length of one in between them
because it's just one element over the
next one
since we are counting
the intervals not the elements involved
in these streaks then we have
overestimated by
by one
so we'll just have to
subtract one
and estimate over over computed by by
one
and that gives us this one at the end
indicating
the uh this original sequence of zeros
which is our and
growth
and so we can put this into a function
and we can try it
on
each well we still need to take the
maximum here
um of that you can try it on each of
this n and x
and that gives us correct result three
for the first one and uh
one for the
uh example with a long decreasing streak
but short increasing streaks
then before we give this a name
we can
[Music]
simplify some things so let's just run
it again every time we simplify some
things to uh to make sure that we're not
changing anything notice here that we
are applying a boolean
nut
um and
that means we instead of applying that
nut we could just initially compute the
values in exact opposite so
not less than is the same thing as
greater than or equal to
and not on these
zeros would be one of course so we can
get rid of that and see that we get the
same result
and here is interesting we are flipping
around the subsequence before we're
applying minus reduction that is uh
since it's only an x2 so that's just
b minus a instead of a minus b
that means if we don't flip it around
then we get negated values
so if we're getting negated values then
we have to subtract them from here
finally we could move
this over because here is a reduction
over a bunch of numbers
all these numbers is being are being
processed with negative one minus that
and since we're just finding the maximum
then
we can do the addition subtraction
afterwards just have to remember that
these numbers have been negated so we
don't want to find the maximum anymore
we want to find the minimum
there's a negative at that point
so this gives us a very nice
solution that should be also efficient
did you assign remember to assign b yeah
i did assembly okay great so um so now
we've got these
uh three different
definitions and we've got the a which is
very much a the way we think about it
we're finding the
streaks we're finding the lengths we're
getting a maximum one um there is one
issue with a that we haven't taken into
account and that is what if there aren't
any streaks and that's so that's a bit
of an issue so let's try that on
some decreasing things like that and
that doesn't look right negative well
kind of infinity negative the smallest
possible representable number and that
is because
we um are finding these partitions and
if there aren't any that gives us a
length zero array getting the length of
each one so still an empty array and
then we are reducing with maximum over
an empty array and that would give us
the maximum functions identity element
which is negative infinity or as close
as we can get to that and we can fix
that simply by requiring that the length
is at least
zero
so let's reset that and now
we are ready for some comparison in
performance let's generate some test
data um i find it convenient to use
a thousand integers in some random
permutation
that should give us about five uh on
average as the
longest streak of
consecutive growth
importing cmpx from the defense
workspace
and then we're simply applying that to
our test case
right there and if my predictions are
right
then
the golfed version is being exceedingly
inefficient by creating this matrix that
we don't need so it's going to be a bit
worse
than
the original solution which was the more
intuitive solution and then there's the
entirely flat solution where we never
create
the partitions we rather do the
computation directly of them which is
going to be hugely more efficient
definitely the one you want to go for
for speed
thank you for watchinghi
let's use APL to make sure that all our
odd numbers become even numbers doing so
by incrementing them making them one
larger
that is three would become 4 and
negative 3 would become negative two
let's start off by defining an array a
and we're going to give it the numbers
from 1 to 16
um for now
and we can then take the array executed
we get this
and we can also
um
modify this assignment and subtract a
bit so let's uh subtract five
okay now we've got some negative numbers
and some positive numbers
let's further modify this by shaping it
into an array of shape four by four
here we go good this is some good test
data
we're going to write our first function
which is going to solve the problem
let's develop it
piece by piece
this is a function it's enclosed in
braces to markets limits and Omega
refers to the right argument because
Omega is the right most
letter
of the Greek alphabet
so this is an identity function it
doesn't do anything
now we can divide by two
um to kind of scale down
and we can see how
apl's arithmetic automatically maps to
all the elements of an array even a
multi-dimensional array like this one
if we now round up
that will add a half and we've scaled
down to half the magnitude that we had
before which means we can then scale
back up again to the full magnitude and
we will have added
um
a whole number rather than half to all
the odd numbers which gave us 0.5 as
decimals
of course the even numbers we divide
them by half by two it gives us a whole
number again and then rounding up is not
going to do anything
so here's the rounding up which uses a
function
um that's the same symbol as the left
side of the special brackets the
rounding up bracket ceiling brackets
um used in mathematics when they appear
every symbol it stands on its own it's a
function at its own and take everything
on its right as its argument so we don't
need any parenthesis here either they've
Roundup or ceiling function which kind
of looks like a wall with a bit of a
ceiling
takes everything to its right that's
Omega divided by two
as its right argument
and now we can continue
with multiplying by two
and this gives us the result that we're
looking for all the odd numbers became
one greater and all the even numbers
stayed the way they were so we can give
this a name f and we can apply F to a
and like this no parenthesis or brackets
or any sort necessary to apply this
function
so this is one way of solving the
problem
let's take a different way of solving
the problem
we mentioned briefly here that the odd
numbers they give a half as decimals
um when divided by two so that would be
the remainder when divided by two that
has already been divided by two it gives
us a half and we can exploit this
by taking the remainder when divided by
two we write that with the vertical bar
which is borrowed from mathematics as
divides right so instead of saying the
two instead of expressing the predicate
the two divides
um Omega we're asking what is the
remainder when two divides Omega
as you can see that all the odd numbers
they give one as a remainder and that's
great because what we want to do is take
um and add one to all that numbers and
add zero such as a leave them as they
are all the even numbers so we can just
take all the numbers and add their
remainder when divided by two
and that gives us the result that we
want
so let's call this G and we can apply it
with G of a
so here two really neat solutions to our
problem
thank you for watchinghi
we're going to convert a Gregorian year
number
to the closest matching Chinese zodiac
animal
and we have to be careful because the
prolactic regarding calendar doesn't
have a year zero
now there are various ways that we could
scrape the data off the website
however
um I'm not going to go into that now I
have defined a
Matrix which corresponds to the table
that is on the website including being a
little bit should we say dirty
so the first thing we're going to do is
that we're going to
clean this up a bit so we have some raw
data that we can work on
we don't actually need all the columns
so we're going to index into this and
choose columns one and four those are
the year numbers
but notice the spacing here they're
actually giving this text and then we're
going to take the animal names which are
columns two and five skipping the empty
column four which was apparently just
there for spacing
now that's all very nice but we can see
here there are at least spaces at the
end of the rooster
and there are also spaces at the end of
the years
that's not so much fun
so what we can do is we can do a without
this is a like a set difference function
on each of these with space so removing
spaces from them all since there are no
internal spaces we need to worry about
that looks better
now we can transpose it
and that gives us a the reading order is
a bit better
but we still have two rows for each
thing
so we're going to reshape this
we only want two rows in total one for
the years and one for the names so
that's going to be two row 12 columns
reshape so this is Greek Row for reshape
and that gives us a much nicer looking
table it's also in backwards order so
let's mirror it
and finally
um it's a matrix but we would rather
have two lists so we're going to split
this
into a vector of vectors and we can see
that we have this even though it goes
beyond the screen
um two vectors and now we can assign
this we assign the first one are the
years and the second ones are the signs
and now we have the year separately and
assigned separately but the years are
not numeric we could do something about
that but it's not actually necessary we
really just want
um
and the signs because it's very easy to
generate these year numbers as well you
can just do 2016
plus Iota 12 where Yota generates a
sequence of numbers from one onto that
number
and then we have the years
okay
let's get started
we're going on a 12-year cycle
oh it's actually not even 2016 it should
be 2006 but that doesn't matter we're
going on a 12-year cycle
and it would be nice to know where the
origin point is for these so we can see
say the 12
divides these numbers how much is the
remainder
and then we can see there's one where
there's no remainder so it's uh evenly
divisible we can identify that one by
comparing to zero
and there's exactly one and then we can
find its index
it's index 10. so it's an index 10 and
we start with index 1 that means there
we have a an offset by nine if we didn't
start with
um with this 2007 if you started nine
years later then we would be better off
so we can do a rotation so the same
symbol that means the mirror if you use
it with an argument on the left it means
a rotation a cyclic
moving of the elements
so we're going to rotate by
um for nine steps the signs
now we start off with the monkey so if
you is divisible by 12 then it's the
monkey and if it's divisible with uh if
you divide by 12 there's one left over
then it's the rooster and then if
there's two left over it's a dog and so
up until 11 left over
we need this data into our function and
it's a little bit awkward to have it
like this we could
transform it into an APL expression that
generates this Vector of character
vectors and we have a user command
called wrapper that would do that for us
it's still very verbose though so I
think it's more fun to pack it all
together this is the in list function it
just takes all the characters and jams
them into a single character vector
that can fit on the screen that linked
and once we have this
then we just need to know how to expand
this into our full Vector of character
vectors that we need to
to select from
notice that all these names begin with
an uppercase character and that's
actually really useful if we look for
membership into and here's a special
system variable called Quade or the
alphabet so this is just a character
Vector containing the alphabet and if we
look for every character here is
membership of this this is the uppercase
alphabet it should say then
we can see that we get a 1 for the
leading characters in each of these
now
we can transform this in this function
into a so-called train or Fork which
means that we are referring to the
arguments in just in terms of function
application
this is a membership and we want to use
this membership to Partition
the left argument so this points at the
left argument so this is the membership
partitions the left argument
and then we reconstitute this so every
time there's a one we start a new
section or segment every time it's a
zero we just continue the previous
segment so this is a
um more dense way of writing the same
array although we might need parenthesis
around it
like this
and now
um what we could do is we could rotate
then by the division remainder when 12
divides the year let's say 2018
oops what's going on
oh yeah of course
um the problem is that the rotation
takes the argument remember we had the
nine rotate it takes the argument on the
left so
and we need to swap the argument so this
higher order function or operator takes
this function and swaps its arguments
such that the rotation amount is on the
right and the data is on the left
okay so now we've rotated it to be dug
and
um if we
look at our original table
then we can see that 2018 is indeed the
dog so that that fits we got the right
right amount however
um we don't want an entire thing we just
want the first one so this selects the
first one
and that gives us our dog so this is the
solution for the basic calendar
um
here's a cool thing
we
took the remainder and divided by 12 but
there are also only 12 elements in this
list of animals which means if we rotate
12 times then we come back to where we
started
and it also means that any multiple of
12 gets us back to where it started and
the only thing that actually matters in
the rotation amount is the remainder
when divided by 12. so there's no reason
to even compute that
because if you just rotate it over and
over and over again then we get back to
the uh to where we started and then the
last remainder that's less than 12 is
what actually gets us to a new position
so
this works as well
and it's not even inefficient because
the API system itself will compute what
the final result will be we don't need
to do it for it
now here's one issue then
um and that is
that
when we get down to a the small numbers
when you get to one so that's the
division remainder
the four one if we subtract
one more we get down to zero but there's
no year zero so the animal that we
would give year 0 actually needs to be
given two year negative one
in other words if we have a negative
year number then we need to add one
so let's say we have some negative
numbers
and we don't have any zero that will
never appear but we do have some
positive numbers as well
then we can
compare this to zero so if zero is less
than that and then in order to make this
a single function we bind or compose the
left argument to the greater than
function
and this gives us
A1 or true for the negative numbers and
a zero for the positive numbers
if we then take the right argument
remember this is this pointing thing
just like we had a
um up here that we had little little
finger that points to the left for the
left argument so this is pointing to the
right for the right argument
and we add that to
the result of this comparison then
effectively we increment negative
numbers adjusting them back as if the
calendar had a year zero so if you use
this instead of the actual year number
then we've compensated for the lack of a
year zero
okay so we take this whole formula here
and we put it on the left
um
and that means that we have the year
number over here
and we don't even need parenthesis
because APL functions have long right
scope so this is the
negativeness added to the year itself
we use that to rotate this entire thing
which computes this 12 element list of
names and then we choose the first one
after we have rotated them into place
and this will be our function it's a bit
long to see here
but now we can say to 2018
and we can also say Year One
and we can say yeah negative one
and we can look at our table up here
that f is the rooster and the year
before that sorry uh year one we said
was the rooster and your negative one
should then be the monkey and that is
exactly what we got so this is a
solution to the problem
you probably don't actually want to
write it like this it would be nicer to
have this thing saved as a constant
so let's try that
we will
um save this as our list of signs
and then we can just go up and say
the list is this
and now we can use the function f
exactly the same way it will there's no
difference here it's just in fact the
definition becomes the same thing
because we take the value and substitute
it in but it's a bit easier to see
thank you for watchinghi
we are given two dates in vector format
and we are to determine what the
relationship in time
are
whether one is before the other one
that would then we have to give the
result negative one where the one is
after the other then we have to give one
or whether
they're the same in which case we have
to return zero
there are different ways to approach
this
but I'm going to go at it with um
date manipulation in order to show the
tools we have available
one fun thing we can do in dialog APL is
to use dot net
I've prepared some test cases here
is always the same date on the left but
three different date and on the right
and we're supposed to say that the first
one is
earlier because we can see here it's the
same date but it's an earlier time 12
instead of 16. these are exactly the
same and this one is a little bit later
um we
because it is a different year
so
in order to
use.net we have to set our using
statement let's put in our arguments
first and then we create a little
different or Lambda to compare each one
of these on the left with each one on
the right
we can try this
so this pairs them up
the first thing we have to do is set our
our using and we want to use the net
system so we write that
and this gives us access to a namespace
called date time
in that time we can do various things
there are some functionality that we can
use and we can also create date time
objects whereas these are just normal
APL vectors we can create scalar
entities which are times so we can
create
and new date time based on
say the left argument
so these are they're now formatted for
human consumption but they are just
scalars
we want to do that on both of them so we
create a little inner Lambda that we can
apply to each one of the left argument
and the right argument
now we have two date times
we cannot component directly but
we can in the daytime
Library we have something called compare
and this Compares these two
and this gives us the result that we
want
using.net is great but a lot of
functionality comes built into APL as
well
in this case we can use something called
quad DT
which converts between time formats and
it understands that we have a vector
format
and we just want to convert it to it a
serialized number which is which
progresses through time so that we can
do a comparison
so these are the day numbers actually
the number of days since the last day of
1899 but that doesn't really matter and
we could use any such format that has an
offset from an epoch
and now
we can compare these two
if we subtract them
one from another
then we find the number of days between
them
and all we're not interested in how long
this is we're interested in which
direction does it go is it before the
same or after so we can use the Signum
or sine function to get the result
so this also solves the problem in a
much neater way
we can restructure this function a
little bit
and make it test it instead of explicit
by observing that the main operation
here is actually a subtraction we don't
want to subtract the arguments we want
to subtract the
date time in format number one of each
one of them
so another way we can express this is
that we want
the subtraction over that is we
pre-process both arguments first with
the conversion of the entire Vector to
format number one
and then this
is a two train or in a top
and we can give it a name without the
outer parenthesis
thank you for watchinghi here we are to find the difference in
area
[Music]
between a square that's inscribed inside
a
circle and the Outer Circle so it's
actually the Outer Circle area minus the
inner squares uh
area and there's not much to figure out
here with regards to algorithm these are
known formulas so this video is going to
be a little bit different than usual in
that it's mainly going to be a symbolic
reasoning in tacd
APL so first a little bit of um Theory
we going to find out what are the areas
of these two components the circle and
the square and what the the input that
we're given is the diameter of the Outer
Circle so if that's the diameter of the
Outer Circle and the square inside is as
big as possible that means the square
inside is exactly touching with its
corners on the
circle also means that the diameter of
the circle is the diagonal in the Square
it's a straight line that goes from one
corner to the opposing corner
diagonally okay so with that in
mind we have the Pythagorean theorem
that states that the square of the
length of the longest side in a right
angle triangle is equal to the sum of
the squares of the shorter
sides however here we know it's a square
so the two shorter sides are identical
in length
now we're going to do this entirely
symbolically so let's do this with a
comment we're going to say
that the
square which is the same thing as the
multiplication of self so multiply by
itself um of
the
diameter of the circle which is the
diagonal in the Square
is equal
to the sum of the squares of the smaller
sides but since they're the same it's
then it is also the same as twice that
so if we take the squares of the smaller
sides and multiply that by the constant
two so this is a two that's made into a
constant function and and we're
multiplying that with the self
multiplication which is the square then
the equality
holds now we don't actually want to
compute it this direction we want to go
uh the other direction we want to to
find the um the smaller
sides such that we
can compute the area which is just the
small sides multiply by each other oh
but since they are identical then the
same thing as the square of the smaller
side and that's in fact what we're
getting here so in order to make this
work remember on the left we had the the
term that represents the diameter or
diagonal and on the right is we have the
squares for the smaller
sides all we need to do then is
eliminate this doubling on the
right so we can do that by dividing by
two on both sides that eliminates this
one and instead we divide by two
constant on the
left this equal sign is not to be taken
as a function here we just stating that
these two things are equivalent the
diameter diagonal and of the circle
square divided by the constant two is
and so the square of that diameter
divided by the constant two gives us the
square of the smaller sides the square
of the smaller sides that is the area
that we want so this formula is what we
need to apply to the original argument
in order to get the area of the
square okay now we need to get the area
of the circle here we don't use PR
Pythagoras we use Archimedes and
Archimedes says that the given the
diameter of um a circle the area of that
circle is going to be pi
times the
square so the self multiplication again
divided by four it could also be stated
simpler in terms of the radius but given
that we have given the diameter this is
what we
get right then the next step is going to
be
to combine these two areas we want the
area of the
circle
minus the area of the
square and now we want to combine these
two
things and we can observe a pattern here
but it's not exactly the same because
we've got here the square of the
argument divided by the constant four
and the square divided by the constant
two if we change this two into a four
then we have made it half as big as it
needs to be but we can compensate by
that by doubling it and while we could
write two times this we can also observe
the doubling just like squaring is the
self mul ation doubling is the self
addition right now we have these two
parts that are exactly the same so we
have for whatever this gives the squares
divided by four we have pi times that
minus the doubling of that so we can
break
out this part of the expression outside
a
parenthesis
let take that part and we put it here
and then we apply pi times
that minus twice
that and that gives us um our for our
finished formula which is very elegant
we can try
it and then we get the expected results
so very elegant formulation and an
example of reasoning entirely in tested
APL thank you for watchinghi this task is to group up a list of
integers by which other integer they are
divisible
by so here we start with two lists and
these on the left are their targets we
could say where that numbers have to be
divisible by and on the right we have
our selection of numbers that we're
going to test so the idea is we are
returning a vector vectors or you could
say list of lists the first list will
contain the numbers from the right that
are divisible by two so that would be
the even numbers 8 12 and
10 and then we the numberers divisible
by four that's 8 and 12 the ones by
seven that's just seven the ones are
divisible by three
which is just 12 and then one's
divisible by nine which there aren't any
so we need to have an empty list of
there so we're going to have a list of
uh five elements because we have five
elements on the left and each uh sub
list then can have up
to this many six in this case elements
but in our case there won't be any
because then we would have to have a one
on the
left and we can do this quite simply
actually so we want to do this this
looping thing we want to try for each
one so makees let's make a little Lambda
that we apply to each one on the right
but we want
to um apply it not pairwise that won't
work anyway because they have different
lengths we want to apply every time
around the loop with the entire right
argument as our right argument so we can
do that by pre-processing
the right argument with an enclosure so
this makes the right argument into a
single element which is then mapped with
each one of the elements on the left we
can try this and see it so if we just
refer to the left argument as Alpha the
right argument as
Omega then we can see how two got paired
up with the entire list and four got
paired up with the entire list and so
on okay now we're ready now we can start
by uh finding out if the ible or not we
don't have a direct test for that but we
do have a remainder um and if the
division remainder is zero then it's
divisible so this is commonly known as
modulus and so you can see here this
says yes uh this says the
remainder when dividing five by two is
oneing seven by two is 1 we're dividing
8 by two is zero and over here when we
divide 5 by 4 we get one left over seven
it gives us three left over eight
divides cleanly so if we just compare
these numbers to zero that will give us
a Boolean mask for the ones that are
divisible and all we then need to do is
filter the right argument by that mask
so this is a filtering function it takes
a uh a list of of ones and zeros on the
left and they take some data on the
right but this higher order function
flips the order of the arguments right
and left such that we get it um our
expression a clean flow from the right
to the left of the
data and this gives us uh the correct
answer we can see that the numbers from
the right are divisible by two are the
even ones the ones that divisible by
four are 8 and 12 and so
on however there's also a uh a very
clever solution that someone came up
with in the chat event leading up to
this
video and that used
and some unusual constructs let's have a
look at uh that as well so let's start
up with our numbers here and the way
we're going to do this is we're going to
to build up piece by piece
um first we're going to start with an um
a divisibility table for all the numbers
with all the numbers cuz we need to
check all of those anyway we can do that
in one swoop so we use an outer product
which is kind of like a multiplication
table but instead of using
multiplication we're using the
remainder so this is a remainder table
and we can see that we have two 4
7 3 and 9 going down and then 5 7 8 1 uh
and so on going across and then we can
see corresponding numbers whether the
divisible so we can see for example here
that
uh that if we have the third number
which is um seven and we are dividing it
into seven then the remainder is zero of
course and with eight we have one over
here and then we can do just like before
comparison with zero because a is rank
polymorphic so we can just do
comparisons between this scalar and this
whole
table and that gives us our divisibility
table rather than a uh modulus or
remainder
table okay now we need to take each row
here and use it to select the
corresponding elements from over
here and the way we can do that there a
couple of different ways we can do it um
but we can use a construct with
rank so the rank operator specifies What
sub arrays we want to be given to a
function so we use the slashes before
for the filtering and then we want to
filter using rank
one and that means we're going to
conceptually at least Loop over every
row of these and pair them up with also
a rank one that's a a vector from the
right which is just the right argument
oops uh yeah there's a problem here we
need to parenthesize this otherwise it's
not going to
work okay now we can see there's a
problem that in order for this to fit
into an orthogonal array
then and we pad with additional numbers
because the length of each of these
results isn't the same um so rather than
having this be an orthogonal array we're
going to post prod process the result
from each application of uh this
replicate function or compress or filter
if you want with an enclosure to make it
into a Scala make it into its own
Standalone
thing and that gives us uh the result
that we
wanted now we can be really clever here
and we do that by um
realizing that this is is actually
What's Happening Here is actually a
pairing up of
corresponding
um rows from the table on the
left
with everything on the
right and then a concatenation of the
individual results so that really makes
sense here because this is the first
result from the filtering and this is
the second results from the filtering
and they're just concatenated together
not joined but as separate elements
they're joined into a um a single list
and then we can write that as an inner
product so normally an inner product is
the sum of
multiplication some people like to call
this a uh map reduce we start off by
mapping with multiplication and then we
do a reduce which is a
summation but APL generalizes this
um as the dot it's also known as a DOT
product to any two operations that take
two arguments so here instead of
multiplication we're going to do the
filtering and instead of doing the
addition we going to do
concatenation this is a very clever
insight and uh you can look in the
description of this video and get a link
to the chat transcript where this was
discussed for even more details
and discussion of
it now we can simplify things a little
bit we don't actually need parenthesis
at all around this inner
construct and since we only have a
simple thing on the right but something
complex on the left then if we could
swap the arguments of this derived
function this
concatenation with filtering inner
product then we could eliminate the
parenthesis for a nice clean look so we
do that as we did before and this has
long left scope so it takes the entire
thing here and flips it which means we
can get rid of this uh Tech over
here and move everything on the from the
left to the right and eliminate the
parenthesis for a beautiful solution
thank you for watchinghi we given two specifications of
time and we're going to find the
difference the absolute difference um
between
them the twist to this is that the
specifications of time are not
necessarily consistent uh they may might
include just minutes or they could be
hours and minutes or they could be days
and hours or
minutes so we have to normalize that and
then figure out how many minutes we've
got so the example we given is uh 213 on
one hand and uh 515 so this is 2 hours
and 30 minutes and 5 hours and 15
minutes and we want to find the
difference between them the only problem
is that we need to figure out first how
how many minutes are each one of them so
before we do the difference and
let's just concatenate together so we
can see we pre-processing both arguments
with a little pre-processing
function um and that's going to be
referring to the argument as
Omega and then we need to make sure that
we've got three elements so we padding
we need to pad with zeros on the left so
we get the um the dat days hours and
minutes and we can do that by taking a
-3 take so this takes the last three
elements padding with zeros on the left
so and now we're concatenating them
together that doesn't make so much sense
of course but we can see that we added a
single zero on the
left and now we need to convert to
minutes and conveniently we have a an
ability in APL to evaluate mixed radex
number systems
so we specify the base that's why we
have this base symbol and we specify a
base where there are 60 Minutes to the
hour 24 minutes uh uh 24 hours to a day
and no higher unit than
that so this m zero indicates that
there's no overflow to any higher unit
we just stay uh with days counting up
forever so this gives us the number of
minutes and we can now replace the
concatenation with a
subtraction we can see that the result
is negative so we need to take the
absolute
value it's this one um and apply that on
the
result that gives us our solution thank
you for watchinghi
the problem of
taking a Boolean vector and leaving only
the very first true
while all subsequent trues become false
is conceptually really simple
and the APL solution to this is also
extremely short
the challenge is really to understand
how this works
so let's say we have false false true
true false
what we want to do is change the second
true into a false because only the first
true is going to survive
and the entire APL solution I'll give
you right away is just this these two
characters
but why is that
for this we have to understand what
exactly
the backslash is doing which is a scan
or a cumulative reduction
and then we have to understand some
properties of using less than which you
normally would associate with comparing
numbers
but it's being applied here as a Boolean
operation
okay so first scan
scan is actually
reductions over the prefixes
so let's say that we take the first
three elements of our data
we if we also want to take the first
four elements of our data then we would
have to take each and each one of them
shouldn't apply to individual elements
of our data but rather to an entire one
so we enclose it to become an entire
whole
so here we have the first three and the
first four
but we want all the prefixes
we can get the length
and we can get the indices of the length
and so these are all the prefix links
that we want to take
we'll compose these two functions
together and then we use them to take
each from the entire argument
okay so this gets us our prefixes
let's for convenience give this a name
right
and now we can do a reduction
over each one of the prefixes
so this is a less than reduction on each
of the prefixes here
and yes indeed that gives us the same
result because this is the definition of
the scan
but why is this and for that let's take
a bit of a closer look at the properties
of less than when used in a Boolean
context
so
there are only two possibilities for a
left argument for for less than zero and
one the false and true and there are
only two possibilities of a right
argument
zero and one the false and true
let's do all the combinations that's an
out of product so we do an outer product
but it's not a multiplication here it is
a less than
can be a little bit hard to understand
what this result represents so let's
decorate it with some headers I'm going
to put the less than character in the
corner and then I'm going to add a
header row on top with three columns the
zero and the one right next to the
symbol I'm going to put that on top and
then we're going to put a heading for
the rows as well which are also the zero
and the ones so they go on the left of
this and now
we get a kind of nice table
it's a like think of it like a
multiplication table but it's a less
than table so zero less than zero that's
zero
one less than zero is zero why because
it's true and false so is one less than
zero no it is not so false zero
and we can see that there's only one way
that less than can give us true
that's this one over here
and it happens exactly when the left
argument is zero and the right argument
is one
so in order to
get a final one result
we must have a condition where we at all
times have one on the right and zero on
the left
okay let's go back and look at our
prefixes then
so here
we remember that APL reduces
from the right because reduction really
means you're inserting the function in
all the spaces between the elements so
we start from the right
the first one is just a single element
which just stays the way it is there's
nothing to insert here here we get 0
less than zero which it's not so it's
false so that's a zero this is the one
is and here we have zero less than one
which is true
so in a sense this one
moves over one step it takes the place
of
these two elements and again we have
zero and one
and we get
A1 which fulfills the condition so this
prefix which is the third prefix results
in a one and if we look at our data
that's the first one we get a one
now for the next one we have two ones so
that according to our table at the end
that gives us false
so
the new value 0 takes the place of these
two elements and we've got zero zero
zero
zero less than zero that's also false
zero less than zero it's also false so
the result for this corresponding
element number four
is false
and over here we have a zero but again
it's the wrong way so one is not less
than zero that's false and then that
takes a place a zero takes place of
these two elements so again we have one
and then zero and that's again false and
then we're back to the same cases we had
before zero zero zero we get false
another way to think about it is the
only way a one can survive
moving towards the left towards becoming
the end result for this corresponding
prefix is if it has all zeros on its
left
if it sees any one they will clash and
we get zero and everything is canceled
out from then on
which means only the very first the very
leftmost one can survive
because the first one necessarily has
all zeros on its left
and what if there's nothing to its left
well that would mean it's the first
element if it would be a one then a
reduction doesn't do anything and we
just get that one back and so it
survives any subsequent one will hit
that first one and be canceled out
there's a lot of talking let's try to
illustrate this a bit so I'm going to
implement some a little bit involved
lambdas or defense
um but when we run them then we'll draw
a nice diagram so that we can see what's
going on and all I'm going to do here is
I'm going to write covers for the
built-in APL
so let's write a cover for the less than
function
and we'll start off by printing out what
is going on so we're going to print
and I'll start by printing a little bit
of indentation you'll see in a moment
why
then we print the left argument
followed by the less than so that we
actually doing a lesson operation
then the right argument and then we'll
use an arrow to indicate that this gives
us a result and then the result is going
to be left left argument less than the
right argument
so this just prints it we don't want to
return this nicely formatted thing for
human consumption we want to just return
Alpha less than Omega so left argument
less than the right argument and yeah
we're Computing it twice but performance
is not what we after here it's just
illustration
okay then we had the less than reduction
that we were applying let's define less
than reduction and we're going to do
very much the same thing this time it's
one level out so we're going to give it
a little bit less
indentation
and then we want
to print out that we're doing a less
than reduction and there's just one
argument and then we can print out the
result then less than reduction of the
argument
and then
we'll actually do the less than
reduction
but let's use our comma function
because this will have the side effect
of printing out every time
the reduction invokes the less than
function
and finally we'll write the less than
scan
in much the same way this time it's the
topmost level so we don't do any
indentation we'll write out that we're
doing it less than scan on the argument
leading to the result of a less than
scan of the argument
and now we're going to use our cover for
the less than reduction for each it
would be this
but we instead rewrite less than
reduction on each of the prefixes
of the argument
okay and now we can run this so we did a
less than reduction on our argument zero
zero one one zero
and now we're going to do exactly the
same thing but we're going to use our
cover function less than scan
on this argument
and we get a whole lot of text out
so what is this illustrating
this is illustrating that the overall
operation is like a hierarchy overall
operation is taking
this argument here
and applying a less than scan to it and
getting this result
and as part of that there were multiple
steps the first step was reducing the
first zero
that's the the prefix there
and that immediately gave the result
there's no indented line below this
because there are no further steps
there's no actual invocation of the
function less than we just directly
derive the result without applying
anything because there's nothing to
reduce
then we took the next prefix which were
the first two zeros
and got the result zero how did we get
the result zero well we inserted less
than between these two zeros which gives
us
zero
and then we go on to the third prefix
that has a one
and it gives us the result one when we
do the less than reduction on it how
does this work well we start off from
the with the right most two elements
0 less than one that gives
A1
and then this one becomes the right
argument over here with the Zero from
the left going over here
and with the lesson between them we get
a one and so this gives us the first one
in the result that we can see up here
that result there
and then we take the prefix with four
we start off with the two rightmost
elements
that gives us a0 according to our
truth table that we computed before for
lesson
this zero survives into the right
argument of the second invocation of
less than with a new zero on the left
that's the zero gives us zero that goes
into
here and we pull down the
leading zero
and zero less than zero gives zero and
so too for the last element we start off
with a zero on the right and a one on
the left
and then the result which is a zero
survives into here we have the same
situation and the zero propagates on and
on and eventually we get zero
and so we get the full result
where the first one is only one that
survives because any other one will
clash with that one when it hits it
being reduced from the right
and this is why
um less than
scan is an idiomatic expression for apls
when dealing with Boolean data and you
need to filter out so the only the first
one remains once you have some
experience with this then you stop
seeing this as a lesson reduction which
otherwise will require a lot of
reasoning why it exactly gives the
result we want and you just start
reading it as a whole
as keep the first one
in fact there are additional Boolean
scans like this that are really useful
for performing various operations but
this one is a very famous One
thank you for watchinghi
we're now going to figure out
or a set of years given as any type of
array
which years are leap years and which
years or not
leave your rules are quite involved
the rules are like this
every fourth year is a leap year
except
every 100th year
which even though it's divisible by four
is not a leap year
except if it's also divisible by 400
then
even though we just said it then it
wouldn't be because 400 if divisible by
400 it's also divisible by 100 and then
it wouldn't be a leap year then it is a
leap year nevertheless so it's an
exception to exception
and Rule
so we say
every fourth year
and then every 100th year and then every
400 is here
what we want to know is
R is the current year number that we're
dealing with divisible by
the these numbers here
we don't have an is divisible by
function in APL but we do have
a division remainder function and if
there is no remainder when you divide
then
it's divisible so let's take year 2000
for example
that was a very special one
we can see that it has no remainder for
any of these
and if we take year 1900
then
it was divisible by 104 but it wasn't
divisible by 400 and if we say 1904
then it was only divisible by four but
not by
the two larger numbers and 1905 of
course will not divisible by any of
these numbers
okay
so what we want to do here is compare
with zero zero means and that there's no
remainder and therefore it is divisible
and the rule is that if we have a one
here
then it's
um
then it is a leap year if we have a one
here then it's not a leap year unless we
also have a one here so it's a kind of
yes no yes thing
and that can actually
be expressed quite neatly using an xor
which just means this one is true or
that one's true but not both of them
so if we think about inserting a
different from that's what X1
represented as in APL
then we start from right to left
um and say well we have this one
but only if
this one is false if they're both true
then it becomes false again
and then we continue here
this has to have been true
but only if not
this one
has to be different from that so that
gives us that every time we proceed one
step to the left it's another flip as
but not if that one that gives us
exactly the exception rule
so we can do an xor
reduction that just inserts this
different from inside
the vector
and you can see that this says that 1905
is not a leap year 1904 is a leap year
1900 not a leap year and 2000
is a leap year
so this really solves the problem for a
single number
but we are told that we should handle
any array so
let's
um modify this a bit
we'll start over here
and we're going to have a an array of
these numbers 1905.
and we also had 1900 and 1904
1904.
right there and you can really let's
make them into a matrix so so this is
going to be our argument
and we want each of these to be paired
up with each one of these no matter what
the ship is over here that calls for an
outer product so
vertical style that's the outer product
which combines the axis here this one
axis with the axis over here uh two x
two x's and that gives us a
three-dimensional array
like that we can see the layers here so
this is
um
for the first one
and so this are the the remain just for
400 with each one of these so this the
entire layer
it corresponds to this Matrix that we
have over here
for 400 and for 104. 4.
that means correspondingly that which
which are the numbers that correspond to
1900 that's the top left corner of every
Matrix so the 300 and the zero and the
three are zero and for the 1904 it's the
one in the top right corner
of each one and in order to do our extra
reduction we need to go down through the
layers so that's along the first axis
the first axis enumerates the layers so
we want to go through the layers here
that means we need to switch our slash
which was the last axis reduction to a
slash bar which is first axis reduction
that gives us a matrix just like this
Matrix over here saying which years are
leap years now we all just need to make
this into a
sorry this is wrong in this missing the
the zero equal there there we go
um
this gives us a an expression but we
need to change it into a function we can
easily make this test it just by adding
um array attack here and then we can add
parenthesis around it or we could have
added an Omega and braces either way
um this tells us that the two right
column ones that's 1904 and 2000 those
are leap years but the two left column
ones 1900 and 1905 or not leap years
we could actually be even more clever
we've got here a scalar comparison and
then we've got a reduction and we could
combine these into an inner product
where the way this works then is if you
go up to
um to over here we say 0 equals
this one
different from zero equals this one
different from zero equals this one
um and so on and then we go through
um the whole array like this it's
slightly faster
um I think at least it can be slightly
faster because it allows The Interpreter
to know everything that's going on it
doesn't actually need to look at
uh first a comparison and then do the
xor it could do that total in one go if
it understands how to optimize that so
this is a quite nice way of expressing
it
but we also have a build way built-in
way of doing this there is a function a
system function called quad DT for date
time
and quantity is normally used to convert
between various formats
however and there's a special and it
uses format codes on the left
there's a special formal code which is
zero which doesn't convert to any
particular format instead it asks
whether this is a validate it's a date
time validator so all we need to do here
to test whether that date is valid is to
sort of say convert to
format zero and a normal timestamp
with year month day that is format
number negative one
so that means if we and we need to make
sure to enclose the argument so if it's
a one vector is one Element so then we
can for example say
um is the
um the 30th month and the 100th day in
that 30th month is at a validate
of course it isn't
um is the
uh January 1st is that valid
yes it is and what about in February 29
that's the one day that determines if it
exists then it's a if it doesn't exist
then it's not a leap year so in 1900
that didn't exist but what about in 1904
then it did exist
so all we need to do when we have an
array of years is to add 229 to each one
of them to make it a full date and then
we ask quad DT whether that's a validate
by converting so to say to
um
format number zero which is just
validation if we go and take our array
over here
then we can
start making a function for this let's
forget this part for now
um we want to concatenate with a
constant right argument to concatenation
and we want to do that on each one
so this gives us a matrix of these four
vectors and then we just need to say to
quantity which already handles arrays we
want to convert from the normal
timestamp
format to
validation numbers
on
all of these
and that gives us
our results from before so that's a very
neat way to write that as well
and that this works on anything and um
including on a single number because of
the each so it will go into so to say
this scalar and then the result will
still be a scalar and we have that
enclosure that we needed above so I'm
going to see that this works as well
thank you for watchingwelcome to the APL Quest
cap Wiki for details
today's Quest
is to find the mode
that's the most frequently occurring
element
let's get started with some test data
okay
there are many different approaches we
could take to finding the most common
element
however and we're just going to try a
couple this time
so one way to find the most common
element would be to remove one of each
of the unique types of elements that are
there
until there's only one of each left
that would then be the most common
element because any elements that occur
less frequently
will have been removed in the process
let's try this
the way we're going to do it is we're
going to start by writing a Lambda it or
a different little function
um and we're going to apply that to each
of the elements of D so these two dots
here that is like a mapping operation
if we have a an inside a convention that
says that Omega because the argument is
on the right Omega being the right most
letter of the Greek alphabet
Omega is a placeholder for the argument
that we're being fed or just the name of
the argument being fed
now we have a very convenient function
called unique mask or we could also call
it indicator first
it's denoted by the magnetic unequal
sign let's try running it
so for each element we get
um a mask and these are bullet masks
booleans in APL being represented with
one and zero for true and false
and it indicates for each element
whether or not that element is the first
of its kind so for the first of our
three cases here we begin with one six
one eight
and we can see we have one one zero one
indicating that the first one is the
first of its kind it's the first one
um and then the six is the first of its
kind then the second one is not the
first of its kind so we get a zero and
the eight is the first of its kind and
we can see there's a the last element
here is an eight and that gets a zero
because it's a a subsequent eight
so this is really nice this indicates
exactly one of each unique element and
if we then remove the elements indicated
by the ones here
then that's equivalent to removing one
of each element
now we have a function in APL called
replicate or compress denoted by the
Slash
and then we can it takes a mask on the
left and some data on the right and
keeps only the elements where there are
ones it actually keeps as many copies
of each element as there as indicated on
the left but since the left is Boolean
it will either keep it or discard it
so we can see this keeps exactly one of
each
but
and and the first one of each but we
don't want to keep the first of each we
want to remove the first of each so we
want to flip it around the ones that are
indicated with ones here we want to
discard the ones are indicated with zero
we want to
um to keep so we use Boolean negation
the tilde is Boolean the gate
and this
keeps exactly one of each so we can see
we uh sorry this removes exactly one of
each so we can see that there are no
more nines left in the first case
because there was only one in it got
removed same thing with the six and the
zero and that gives us actually our
result for the first test case one three
and eight are there
um
and most frequently occurring elements
occurring two times each in the second
test case
we can see that we removed the seven
and we kept the 281 but there are more
eights and two is one because we only
removed one of each she would have to
repeat this operation
and this that's the case because you
removed three four and five and one of
the two ones so then there's one left
and that's our result so we actually
have to apply this function
um multiple times
and we can use the power operator and
this is in traditional mathematics
written to a superscript number on the
function name and applying it that many
times but APL is all inlined so we write
it with this star there is this and a
number so we can apply it twice
and again on each of these and that is
good for the middle test case but
destroys the first and last test case
because there's only one of each and
left and we're removing one of each
there's nothing left after that and
we're still not even done with a middle
test case because there are now two
eight eight and only one two the modes
being eight the most common element here
and so we have to apply it three times
and that doesn't change anything for the
first and last they're already empty but
the middle one you get the result so
we don't want to apply this function
a fixed number of times we want to apply
it
um
a custom number of times when it depends
on where have we gotten so far
actually what we can do is we can apply
If instead of applying a fixed number of
times we could actually apply it kind of
like an infinite number of times what
actually happens is
if we give a function on the right of
the star diocese instead of a number
then that function will be applied
between meaning taking as arguments to
subsequent
iteration values from applying this
function over and over again and it will
keep doing so until the result is stable
that is until two subsequent values are
fulfill this condition that we give it
so the normal thing to do is to use
equality or
um
um equivalence as in this case so we're
saying keep doing this until the result
is stable and if we do that we get empty
all together
um empty list because we keep doing it
the only time that we keep removing one
of each occurring element and the only
time that becomes stable is when there
are no more elements
so how can we modify a function such
that it stabilizes when there's only one
left of each
before we get to that let's move things
around a little bit in our function we
have a parenthesize expression on the
left and we have just a value on the
right
APL functions have long write scope that
means they take a right argument as much
as they can going to the right until
they get stopped by either the end of
the expression or the end of a
parenthesis or bracket and so on
and so we can get rid of this
parenthesis on the left if we had a
function that was just like slash just
like replicate except it took the mask
on the right and the values on the left
now there isn't such a built-in in APL
but we can easily construct it
if we put this to there is this looks
like a frown because they're confused
about which side is right and which side
is left that modifies the replicate so
that it takes the uh the arguments in
opposite positions that is the mask on
the right and again we have long right
scope so everything on the right
of this derived function
um is its right argument
and then we take the value on the left
and of course this gives us the same
result but it makes it easier to
manipulate this mask
now let's say we put
instead of having
um
this mask which varies by what exactly
we have if we just had all ones then
nothing would change
we can actually use a single one and it
would work as well then it stabilizes
immediately because we're not changing
anything
so we want this mask
in the general case but we want a mask
of all ones or a single one for that
sake
um in the case where
there's only one exactly one of each
element
so how can we do that
well we have this mask here
oops
we have this mask and here indicating we
should get rid of this stabilizing or
we'll go to infinite Loop
um
indicating which elements are the first
of each
and we want to find out whether and
every element is
it's the first of its type and that's
very simple we just need to check if
it's all true
how do we check if it's Ultra in APL we
use a reduction we just need to reduce
with and
and so and we use slash again this with
a function on the left it means
reduction and this is logical end so we
just say this one and this one and this
one this one if there any zeros we get a
zero but if all of them are one then we
get one
so we want to combine this mask
with our previous mask
so that if this one is
a single one
then it forces this Max to become all
ones
and if it's zero
then it doesn't make a difference
and we can do that with an or
so
if you have
ones and zeros over here or one
then we get all ones and if we have some
ones and zeros over here and we have
zero here then it doesn't make a
difference because
false and something gives that
something
and so this is the mesh that we
um that we want we can try running it
and then we can
um we can try to use it to compress the
argument
and now if we apply this two times
we can see that this did not empty out
the first and last element so we can run
it as many times as we want and now it
stabilizes
so we can also say let's run this until
it's stable
and this actually solves the problem or
at least almost solves the problem
um because there's one issue here if we
look at
the original test cases
here we have first one and then the six
goes away another one here then eight
and then three
problem was that our result has three
then eight why is that
that's because we removed the first
occurrence of each element so the first
one goes away we keep this one that's
fine the first eight goes away the
second eight it remains at the very end
and the threes are next to each other so
we end up having three before eight and
we really want to preserve the original
order
how can we fix this
well see
this indicates the first element
of every type
if we reverse it then so this is a
reversal function remove and this
reverses the argument before we get
indicate the first of each
now we're going to indicate the last of
each but count it from their ear and we
really want to keep it from the front so
we can reverse the result of that mask
as well
and now we get the correct order and
this is a proper solution
albeit a little bit inefficient because
we are Computing this unique mask twice
so let's give it a name instead
like this and now we can use this over
here
and the flow again is from the right
so we compute everything from the right
reverse unique mask reverse again stick
that into M negate it do an or with and
then we compute this because it has
parenthesis around it
we can beautify this a little bit by
applying uh some laws of
of logic
but always a little bit hard to reason
about so because we want this to be true
or not this
let's change the or into an and using
the Morgan's laws so we can express and
or in terms of each other by negating
the arguments and negating the result so
we change it into an end here negate the
right argument negate the left argument
and negate the result as well
so this knot takes everything on its
right as its argument
okay clearly we can remove these two
this is just negation of negation
and so and here we have
not what's on the left
with yes and yes what's on the right now
booleans remember in APL are just zeros
and ones which means we can treat them
either as numbers or as booleans
whenever we want they are one and the
same
so
if we have a 1 on the right
and we have to have a zero on the left
because we want not this one that and
those are the only values for which we
get true that just means that the right
argument over here has to be greater
than the left argument so we can change
this to a less than
and now we have a negation of the result
of a less than well what's the opposite
of less than if it's not less than then
it's got to be greater than or equal to
so we can put everything together in a
very nice solution to the problem it's
iterative
but it's pretty elegant it's not the
most efficient way to do it and we're
reversing every time we could start off
by reversing and then at the very end
and finish up by reversing again instead
of reversing every time around the loop
but it this is my elegant
okay let's do a a better approach
again we'll start with mapping this
Lambda over the test cases
and here
um
we are going to use a special high order
function called key which is extremely
useful for and our purpose it takes it
takes a function on the left so we can
give it a little Lambda on the left and
then it derives together a new function
that's then applied to our argument on
the right
let's look at what it does how can we
look at what it does we just give it a
um it's kind of a dummy Lambda that just
returns a two element list of left and
right argument to see what are the
arguments that we're given
and key returns us as left argument uh
two so four it returns here a matrix and
each row of the Matrix corresponds to
one unique element of
the right recording by the way the
unique elements we can compute
like this
so you can see the unique elements are
one six eight zero three nine as we know
and we can see the corresponding numbers
one six eight zero three nine in the
leftmost table and then on the right it
tells us the indices
where these values occur so we had a one
at positions one and three and a six at
position two and the eight at positions
four and nine and so on we're not
actually interested in the positions
that they're at
however we are interested in how many
there are because we want to find out
and
which ones there are most of
so we can return
the count of the arguments together with
of the count of the red argument
together with the left argument which is
the unique value
so we can see that there's for the value
1 there are two for the value six there
are one and so on
and we don't actually need the value
itself we just need the count
so here it counts per unique element in
the order of their appearance
we want to find out which elements which
unique elements occur the most often
so we can find out what this number is
so we can see that the highest number of
currencies of a single element in the
first test case is two and then four
then two
we want to find out which elements
appear that often so over here we got
the counts let's call that c and we just
need to know which counts are equal to
the maximum now what's going on with the
maximum here is again a reduction like
we did the end reduction before but this
time we're reducing with the max
function which is a function that given
two arguments one in each side just
Returns the larger of them you can kind
of see the symbol showing a vertical bar
um and then
horizontal bar at the top indicating
we're wanting the top of the two values
so now we have a Boolean mask indicating
elements unique elements that
appear the most often
and we can use this we'll replicate that
we had from before so this is just a
mask and but not on the argument itself
rather on the unique elements of the
argument
so this gives us the modes and directly
again there's a bit of inefficiency here
because
we're Computing the unique values here
and then when key operates on the
argument it has to compute the unique
values as well
internally in order to be able to figure
out well how many there are in our case
so how can we fix this well remember the
key returns both the indices and in our
case we want the counts and the unique
values themselves so we just need to
mangle out this resulting array in such
a way that we can
get both the unique values and the
counts out
so here the unique values and the counts
in The Matrix for each test case
and what you want to do is we want to
combine these values here into a list of
and
of unique values and we want to combine
these values in here into a list of
counts
and so what we need to do is a vertical
concatenation so we're concatenating
this column together and concatenating
this column together
concatenation in April
is the comma and then we've used
reduction before but that was horizontal
reduction now we're going to use
vertical reduction which is the slash
with an extra bar
so we can see that we transform these
matrices into the individual column
vectors and now we can give them names
so the left one we're going to call the
values and the right one we're going to
call the count
we assign them here we use diamonds to
separate statements because diamonds are
Unbreakable
and now
we have we need to know where the counts
are equal to the maximum
of the count
that's the same mask as we had before
and then we can use that to compress
swapping the arguments of compress and
not not the right argument we need to
compress the the unique values
right there
and that's a very nice solution
but we can actually take this a little
bit further and if we look at this red
expression
let's think of it as a function in terms
of v and C
so what we've got here is
let's put this into braces as a little
Lambda so we got we got C on the right
we got a v on the left
and then we can use just like over here
we used Omega last letter of the Greek
alphabet and Alpha the first or left
most letter of the alphabet for the left
and right argument so we can do that
over here as well V is on the left
and C is on the right
now this might seem just unnecessarily
verbose and it still works
however notice this we have this little
function in between V and C
and on the left we have V and c as a
pair we just need to insert
this function
between V and C and inserting a function
between that's really what a reduction
does
oh but notice the extra boxes
that's because reduction needs to reduce
the rank of the argument
VC that's a list it is a vector it has
rank one it has one dimension and the
result we want and we get from that
needs to be a scalar but actually we get
a list of values which is a vector so
how do we have a vector which is a
scalar we enclose it in a scalar
encapsulation but we don't want that so
we just extract it with this close this
opens up
that enclosure
and now we can see we have VC and we are
playing something to it
this function the derived function which
is our little Lambda together with the
reduction takes as a right argument this
list of VC and VC is exactly what we get
over here
so we can just take this expression
because everything flows from the right
to the left like this we just apply that
on the left and we get a very elegant
solution
there's one more thing that I'd like to
do
and that is
this little
Lambda over here we can actually
simplify a little bit by using tacit or
0.3
and programming
we have the left argument concatenated
to the tally of the right argument
and that is something we can use a
function composition for
so
let's say we have 10 and 20 and we want
to concatenate 10.
to the negation of 20.
so this is a type of concatenation but
we want to pre-process the right
argument with
negation and there's a combinator for
that we call it beside because
it is as if the comma and the minus are
next to each other beside each other
and this makes a new function
which we can apply
and so too
if we had on the left a value and on the
right a list
then we can concatenate with the tally
note that this looks like a Telemark
and we can just insert that
into our expression here instead
so we concatenate with the tally and we
don't need to mention the arguments at
all
I think that's pretty elegant
thank you for watchingwelcome to the API Quest cap Wiki for
details
today's problem is the last from the
2015 round of the APL problem solving
competition
we are to generate Pascal's triangle
which is pretty simple but the catch
here is that we wanted to also look nice
for human readers and a triangle doesn't
fit nicely into a rectangular array so
instead of having it numeric as Pascal's
struggle consists of numbers we are to
create a character Matrix where the
lines are approximately centered
there are two steps to this problem the
first is generating the data and then
they're centering the lines so let's
split it into those two parts
Pascal's triangle has a classic
elegant solution
it is simply the binomial coefficients
an outer product on all the numbers from
0 to n
there's a problem though with this
triangle it's sideways and it's padded
with these zeros
we can do something about that of course
but it makes it a little bit less
elegant so first we transpose it and
that gives us the rows at least as as
rows
and then we need to remove the zeros
so
on each and row that is on each sub
array of Frank one we want to be without
zeros
but the problem is that we want to pad
again with zeros if we try to apply this
just like this
so that didn't get us anywhere therefore
we must immediately format it as a
character array and now the padding will
instead be done with spaces
and this gives us
um the first and flat approach to
creating
the data that we want and the next part
is then
to align the rows so that to be centered
and we'll come back to that
another approach is a nested one
we start off the same way by generating
all these indices
but instead of doing an auto product we
kind of doing half an hour product
so again we want the same indices up to
whichever end that we are at now
combined with that
number
and that gives us kind of a triangle
with each row getting longer and longer
and then since we're going to deal with
character data and have it equip the the
nested equivalent of the previously
previous shown flat result when we're
going to format each one looks the same
but these are actually character vectors
and this we can call n because it's the
nested solution
we can also
um avoid repeating ourselves we have
here zero comma Iota and we have over
here zero comma Yota so we could uh say
this is kind of like an inclusive
um Iota in here
and then we can use that name over here
it's it comes out and it represented
exactly the same but just the way of
stating it is a little bit shorter
and now uh that we have the data let's
look at actually centering it so let's
go back first to our flat Matrix
with the training spaces
so one strategy for centering it is
looking at how many training spaces are
there there are four in this line and
there are six on this line so if we take
half of those on each line and then
rotate the entire row so we'll remove
the training less training spaces and
put them at the front we'll do and here
we we have six we're removing the
training three we put it in the front
then we end up having something that
looks centered
how can we do this well we need to count
how many training spaces there are
if we make a Boolean Matrix of where we
have spaces
and then make sure that it is we do that
in the reverse so now it becomes leading
spaces we can do end reductions on each
line
to see to isolate the leading spaces
which are actually the training spaces
and then we can sum that to see how many
leading that is Trading Spaces they are
and then we want only half of that
so these are how many steps to rotate
um it could be that the number is is odd
not a number of spaces on and therefore
we get a half so to be safe let's just
round this off and the problem
specification also says that can be one
more or less so it's not important how
exactly we round it up or down
there's definitely no reason to run off
to closest because it's always going to
be a whole number or a half
okay so and now we want to rotate this
many steps but rotation the normal
rotation API rotates from the front to
the rear
but we need to rotate from the rear to
the front so we need to negate this
and then if we give a name or an
argument namely to the The Matrix that
we're operating on then we can simply do
a horizontal rotate using these values
as the rotation amount and that gives us
our
centered Matrix
so this is rotation using the flat and
this is the whole thing is one large
atop where the right function right time
is this F generator function that we
created before and then the left chain
is this in a centering thing and we can
even see this classic approach
um the ID is highlighting this to be an
a dialogue idiom which means it doesn't
actually go through each of these three
operations
um instead it recognizes this as a whole
idiomatic expression and computes the
trailing space spaces directly for some
extra performance benefit
foreign
we instead started with the the nested
array
now here aren't any spaces that we can
that we can count and operate on but we
can look at the length and remember that
these are character vectors so if we get
the length of each one of them then we
have those here
you can see that even though it's only
two numbers it's like three because
there's a space in between as well
and so
um what we want to do here is we we want
to rotate
around on the whole Matrix and we can
create the Matrix the flat Matrix simply
by mixing
so here we have it with the spaces so
we're still going to rotate but we're
going to compute the amount of rotation
based on the nested representation of it
so we have the length of each
and then on the length of each how much
do we need to rotate well the full width
is the length of the last one
and all the lengths are
it's just the same thing that's the
argument here
and we want half of the difference
between them to be the amount that we
rotate with
so this is the the length and this is
the length of the longest one and this
gives us these negative numbers
and I've done it negatively like this of
course we could we could if you subtract
the other way around we get the
corresponding positive numbers but since
we're going to do a negative rotation
amount we might as well just keep it
negative from the beginning
and then we divide that by two as before
and we can round it off again it doesn't
really matter how we we round it so this
is the amount of rotation that we need
to do on each one
and then and we use this to rotate but
not the argument itself because that's
nested we want to rotate the mix of the
argument
and then since this is a uh yeah so then
we have in the top over here and then we
just need to to
swapped arguments over here
we have it here and this is in the top
two pieces we can use the top operator
here because the left function is
complex
but ins since this is the post
processing on the result of the tally of
each it could also be the pre-processing
of the swapped and rotation so we can
replace this with a job over here and it
would be the same thing
so this is a way of using rotation with
a nested representation again at the top
this is the centering function and this
is the generation generating function
so now we used rotation but we can also
use a take so take has this interesting
thing that you can what I sometimes call
overtake so let's say we have ABC
if we take the nest five elements from
that
then that pads us with
two spaces at the beginning and we can
use this to our advantage
um if and the same as it goes if we take
from the beginning and then we get
training spaces right here
so for this to work we can't already
have the more all the rows be the same
length in the flat representation so we
have to use the nested representation
and now and we are going to start off
the same way we get the length of
of each one
and then we need to compute what is the
length that we want to take from the
rear of each one which is going to be
the next it already has plus half half
of the difference between the longest
one and the current one
that's going to add half of those
potential spaces on the left okay so
let's state that
the current length Plus
half of the difference between the
longest one which is the same thing as
the last one
um minus the current length
so these are the lengths that we need to
take from each one
of course this needs to be negative
and then we need to make sure that we
don't have any halves so we can round
that up as well
and then the only thing that's missing
is that we take
from each one with this amount
um and these are the nested things so
now we have padded them with leading
spaces so that they will fit each other
and then we can just mix and we get the
character Matrix that we're looking for
however we can simplify this quite a bit
actually
if we think about it
then we have the amount itself
Plus
half of the difference between
this constant value so to say the last
one
and the amount itself
in other words we
are here
um
removing
from the part that we are
adding
which means that we can also see this as
half of
the last element the longest one
plus only half of the value itself
because we're adding the whole thing
and then we're subtracting half of it
so then what we can do is just
add have to begin with
and not
add a whole one and subtract the half
one
and we can keep going
we are here negating
this half
will be include so to say this this sign
change in the division which is the type
of multiplication so if we divide by
negative 2 instead that's the same thing
but another way we could do it since we
only think we need to affect is a sign
change
then instead of adding so to say these
lengths we can add their negation
instead of adding
the last one we can subtract the last
one so that affects also a sign change
um on the whole thing
and we get the same result
and this is another very nice way of
of creating our Matrix
so we can call this
um the
the overtake
so it uses take on the nested
representation again and the top this
time we have a different on the left and
then our original generating function on
the right
okay so how do they compare to each
other well there's not really any other
limit to what we can do here but let's
increase the print Precision to the
maximum that our 64-bit floats will
allow and then we can do triangles up to
say order 50 or so
copy in cmpx from the defense workspace
and let's try everything for ends up to
50.
we can stick a zero in front as well
and then we want to compare
um this was the rotation using the flat
on each and we want the rotation using
the nested on each
and then we wanted to have the using
take on the nested
oh so we can see that the nested
approaches here are
well approximately half the runtime of
the flat approach and that's exactly
what we predicted to begin with because
we are generating only half the triangle
slightly more than half the triangle
because we need a diagonal
um and that is the overwhelming amount
of computations then two here and we are
using just slightly over half of the
runtime in the rest of the approach so
even though it's a good rule of thumb
that when you're doing APL you want to
stay flat you have to also recognize
when is flat actually flat in this case
we were processing each row separately
and that really negates all the benefit
of staying flat
thank you for watchinghi now we're going to be given a square
Matrix and we have to check whether it's
magic magic means that all its row and
column sums and the diagonal anti-
diagonal sums are the
same I've predefined a collection of
matrices the first one is trivially
Magic there's only one number so
whichever we sum it we get the same
number second one we can check that it's
magic 4 + 9 + 2 is 15 3 + 5 + 7 is 15
even diagonal 4 5 6 is 15 and so on the
third one is easy to see it's not magic
plus 1 + 2 is three but 3 + 4 is not
three so that one is out and for the
same reason we can see the last one um
we keep having increasing sums both
vertically and horizontally so can't be
magic either so first two are valid
magic ones and the second two uh are
not let's apply a Lambda on each one of
these we refer to the argument as
Omega and instead of trying to do all
the summing we'll stack together
everything we need to sum and do all the
summing in one go so here's the argument
concatenated with its diagonal how do we
find the diagonal well if we Traverse
the array and in order but every time we
go to the right we also go one step
down then we find the
diagonal effectively if we map both axes
of this uh Matrix to a single axis so
that we force walking along both axis at
the same time then we get the diagonal
and therefore we can do this with a
transpose the generalized diic transpose
Maps AIS to different locations and if
we map both X's to uh the first
one then we get the
diagonal so here we have the 456 it's
been concatenated on the
right next up uh we want to do the
summation of um the rows but since we're
going to sum vertically then we just
need to transpose the argument
to so that when we are going to sum here
4 92 that actually corresponds to the
original
row
and finally we want the an diagonal
which we can get by flipping the uh The
Matrix horizontally and then taking
diagonal so we can flip it
horizontally using the uh reverse
function so we can see that we got 294
instead of 492 and then we take the
diagonal just like
before so this gives us all the columns
that we need to sum so we do a plus
inserted
vertically and the only thing that
remains is to check whether all the
elements are the same so we can find the
unique elements and then count them and
then check if that's equal to
one so this is a very straightforward
translation of the problem statement to
um
APL but there's
some duplication of code we could say
this something seems very redundant we
we taking the diagonal here and we're
taking the diagonal over here and
flipping things around it's actually uh
a way to compress this a bit which is
rather neat so let's try
that let's start off by and combining
the
transpose
and the flipped
horizontally version of the um array
because if we if we think about
it this reversal
here allows us to take the diagonal if
we do a
transpose then it doesn't matter for the
diagonal diagonal stays the same so if
on each of these two we take the
diagonal that gives us the two diagonals
and if on each of these
two
and
we take the um the sum then if we mirror
it horizontally then this the vertical
sums are just in a different order but
it's still the same vertical sums and
the vertical sums of the transpose that
gives us the horizontal sums so all we
need to do is do all the combinations of
uh
transposing um sorry of of taking the
diagonal and taking the vertical sums
with the Trans uh combined with the
transposing and the mirroring in order
to get all the four different
combinations that we want so we're going
to uh combine these and we're going to
take the the union of them because we
need to get that final set of how many
different sums are
there um we need to be careful not to
have any duplicates uh because they
would persist in the Union uh but before
we take the union of course we have to
actually find the sums so we pre-process
the argument to the union with a little
function an inner
function and that function is going to
be taking the
diagonal and we concatenating that
to the array
itself and once we've got that that
means we've got one more column which
consists of the diagonal and then we can
do the vertical sum and take the unique
of that it's important that we both take
the unique here and take the union over
here because if we didn't take the
unique and there were multiple on the
left multiple sums they would persist to
the end um but they could
be all the same even though they're
multiple right because if our array is
larger than just a 1 by one there will
be multiple sums um actually even if it
wasn't because we had
both the diagonal and the r sub so
always have two but this will make sure
that in the case where it is Magic in
this halfway respect we only get a
single element and then we get if it's
magic we get a single element from the
left and the single element from the
right and then the union of them will
either be a single element or not if
they don't uh match um in case there are
any uh other elements than any other
sums then it doesn't matter where they
appear here we'll always have something
that has length more than uh than one
because the union will not be able to
take away any duplicates from
here
so this gives us um all the different
sums and then Remains the thing that we
did before of 1 equal to uh the count of
that but since we're doing things tested
here we we still want the diadic the two
argument form of equality but we want to
pre-process the right argument with the
counting with the
tally so this is a very neat compressed
solution without any duplication going
on thank you for watchingwelcome to the apl quest capl wiki for
details
today's quest is the 9th from the 2014
round of the apl problem solving
competition
we are computing how far an object
reaches
based on
the angle at which it is
thrown
and
how fast it is being thrown
now that doesn't actually matter because
we are given
the formula
ready to use all we need to do is
translate that into apl
so the distance
is well we use 9.8 we're given as the
gravitational constant so we need to
divide by that eventually it's the
square of the
velocity
times
the sine of
2 times and then we need the angle but
it needs to be in uh in red the ends for
sine to work correctly and we're giving
it in degrees so we just need to
translate that so we multiply by pi
and
divide by 180
now and we can simplify this a little
bit i like to get rid of parentheses and
multiplying by a square of a number same
thing as multiplying by that number
itself we're multiplying by two over
here
um so and we're dividing by 180 and
there's no we need to do both we can
just divide by 90 instead
that makes it look kind of nice with the
two circles
some test
velocities and some test angles
this doesn't give us quite zero for the
90 degrees angle
but that's due to floating point
inaccuracies of course if you throw
something straight up then it comes
straight down and it didn't move from
the origin at all
so this is very simple
to spice this up somebody came up with a
challenge of doing this without the
circle function we're using circle
function twice here for the sine one
circle and for multiplying by pi just
magnetic circle
and it's a bit more of a challenge to do
it without circle
but
we have some ways we can do this
first let's do the sign
so we can use a taylor series
for the sine function
that's
the alternating
and sum
and then we start off with the odd
numbers
we don't even need very many terms
before we get a very accurate result
and then on those
odd numbers
we
raise
the
argument
to those odd numbers
and divide them by
the factorial of those odd numbers
and then and alternating some of that
should give us a correct result
let's try this out
and compare with
the native
sign
that looks very accurate indeed
okay so we've solved that part
now as for um
pi
so if i we could start with earnest
identity
that's in the apl
0 is equal to
1 plus and then we need e to the power
of that's the exponent just magnetic
power and then
pi times the imaginary
unit so this holds and we need to break
out the circle from here so to say well
let's start by
removing that so subtracting one on both
sides of the equality
and then we can we have a
e to the power of
uh so we can change that by removing we
can get rid of that by taking um the
logarithm on both sides so that cancel
each other out
and we just need to take the logarithm
on the left
and now we have
i times
the imaginary unit so if we multiply by
imaginary unit again then we get
negative one
and then we can multiply by that over
here
and then we just need to negate
and we can for example do that by
negating this over here so now we've
broken out pi and that means we can just
assign
this
and
you might consider this a bit of
cheating because
the building constant pi is of course
hidden inside this formula inside the
whole arithmetic implementation of uh
logarithmic negative numbers and and
dealing with complex numbers
so how about using a series instead and
then we have some might have a series
and the very simplest of those
is not very accurate but it's very
simple
it computes a quarter of pi so multiply
by uh by four it's the alternating sum
simply of the reciprocals of negative
numbers
beginning with one
and even if we take say a thousand of
those
it doesn't give a very good result i
mean it looks kind of okay but if we
compare it with
the actual value of pi you can see that
it's it's quite a bit off
there's a a little bit more complicated
formula which gives is much better
converges much faster
and and and here we are computing
pi
divided by the square root of 12 so we
start off by uh
taking multiplying by the square root of
12 to get actual pi
again it is an alternating sum of
reciprocals
this time we have to start with 0
and then we just do
natural numbers and 100 is actually
enough even much less than that would be
enough
rage one of these we take three and
raise it to
that power
and multiply it by
the incremented
two times that number now two times in
this number same thing as
adding it to itself
so this is one plus two times okay
and then
times three to the power of k
and this looks really good
if we
compare it to the number
let's build in
then it says it's equal
and if we try to subtract them to see
what is the actual difference
within the floating point accuracy that
we that we have here 64-bit floats then
they're actually equal so that's that's
very nice now we have signed that and
that means that we could um
substitute these into
our formula
so
9.8
divided by alpha times alpha times the
sine
m of
pi times the argument divided by 90.
of course we could compute that constant
of pi divided by 90 but it doesn't
really matter
and then we can try we need to use um an
each here because
and we're using a series
computation
oh well this was the wrong one this is
deep it doesn't matter and then e is the
is the new one
and we can see that we get pretty good
values um
for
the numbers that are
zero or far away from zero and a good
enough value
um
even for the one that's supposed to be
zero
thank you for watchingwelcome to the apl quest see apl wiki
for details
today's quest is the ninth from the 2015
round of the apl problem solving
competition
we're giving a word
which is a character vector
and we are to swap interior letters two
and two so the first and last letter
always stays in place
the second the third gets swapped around
and then the fourth and fifth gets swept
swapped around
if there's a final interior letter which
doesn't have a companion letter next to
it
to pair up with then that just stays in
place
and there are a few different approaches
we can take to this
here are some simple test cases
i'm
going to uppercase
the letters that are go they have to
stay in place the casing doesn't have
any significance it's just for us to be
able to see easier if things are
happening the way they're supposed to
and then so here
oh
actually i wanted this one to be like
this um here we have two fundamental
letters that stay in place
let's also make sure that
a single letter case works it's easy to
end up writing code where that doesn't
work 