welcome to the apl quest
see apl wiki for details
this is the first problem of the 2014
set from the apl problem solving
competition
we're given this left argument
the two supposed shorter sides of a
triangle and this right argument the
longer side
we are to check
if these three numbers together
can work as length of a right-sided
triangle
a right angle to triangle
it's of course natural to use the
pythagorean theorem let's put in some
test cases here two shorter sides two
and four another case with shorter sides
three and four
we're going to try this with a longer
side that's four and a half and five the
first one is going to be false and the
second one is going to be
true the pythagorean theorem states
that
the sum of the squares of the left of
these two shortest sides
matches the
square
of
the longer side
we can write this in various ways
if we
observe that the square is of the same
thing as multiplication by itself
then we can see that we are summing over
in the application of a
scalar function
all right with a scalar reduction over a
replication of a
scalar
function application is
the same thing as an inner product
and here we have
the same argument being used twice on
the inner product which means we can use
the selfie or commute
operator we can do the same thing with
the commute for
the multiplication
there's the different way of stating the
same thing
we can also make a tacit
we want
this inner product applied on the left
argument
and we want
the self multiplication applied on the
right argument
same thing just in a test form
we can also break out the multiplication
because we really start with
squaring both arguments and then we're
summing one of them
so by using the over operator we can
preprocess both arguments with
self-multiplication or squaring
and now we only need to sum the left
argument so we could write this as
the sum of the left argument matches the
right argument
or
we could use normal equality but
pre-process
an argument we can't represent the left
form but we can't pre-process the right
one and we're going to pre-process it
with
summation the problem is of course it's
the left argument we want to deal with
but we can fix this by commuting
swapping around
the two arguments
we could also start off by commuting
then we preprocess with squaring and
then we have
the summation on the right
however
observe that
a reduction over a single element
doesn't actually change it so the fact
that we're preprocessing only the right
argument with the summation
could
we can use that
to fold this
reduction into our preprocessing of both
arguments because a summation of a
single argument doesn't matter
here we have equality where we
preprocess both arguments
with the summation of the square we
don't need to compute anymore because
we're treating both arguments exactly
the same
and of course we can combine
this plus reduction over the
multiplication
and into
an inner product if we prefer that style
a whole different way to approach this
is by using complex numbers
so in the complex plane
we can
we can look at the two shorter sides as
the two components the real
and the imaginary
and then
we have the diagonal being the magnitude
the whole length of that vector in the
2d space that the complex plane forms
so now we just need to
combine these two parts into a single
complex number and it doesn't matter
which one becomes the real part and
which book and becomes the imaginary
part because we're going to take the
absolute value of it anyway
so
um we can start off by saying the last
element of the
left argument
we multiply that
by the imaginary unit
and then we take the first element there
and add to that so this combines the two
now we can take the absolute value of
that
and compare it to the right argument
we can also make this test it
we
all this thing that we're doing
is really pre-processing the left
argument so as before we can swap our
arguments around and pre-process the
right argument instead
the last element we multiply it here and
then the
the first element take the absolute
value of that that's how we preprocess
another way that we can
write this
is using negative 11 circle that's
simply its definition
it just multiplied by the imaginary unit
then someone came out with a clever
thing using
four circle
if we apply four circle we get back to
what exactly that mean on the ratio
between the two elements in the left
argument
and then we multiply by the second
element
then that should match the right
argument
and that holds for our test cases let's
prove that that is in fact
the case
for that
let's try to make a test it again we are
preprocessing the right argument
so we can
we can write it
the ratio of these two the four circle
on that and then we just want
the last argument in the last element of
the uh
of the original left argument so we can
write that we can either combine these
two they take the um the first
um of the reverse but we can also just
use
um a right tech reduction it's a right
reduction
and we preprocess the right argument to
the equality with that
and we just need to commute things
around so this is the tested form um of
that alternatively we could use first
and we could and
commute the elements
of the sorry commute the arguments of
the division and that would also work
but how does it actually and how does
this actually work let's go go back to
our and our defense form
with uh let's see before circling right
here
this one
so the definition of a four-circle is
the square root
which we don't have in
this apl
but we're using this as a placeholder
we're going to eliminate it later so the
square root of and one plus
the square
this is going to be a little bit and
complicated using the elements of the
left argument so let's give them names
a and b
now we this is the last one is b
and the fraction
bond random is just a divided by b
here's the square of a fraction that's
the same thing as the fraction of the
two squares
we have a b outside the
square root we can get it into the
square root
by squaring it
now we have 1 plus this fraction
where the
denominator is b squared that means that
we can
we can add on top of the
of the fraction a b squared instead
and now we can observe that we have this
whole thing this sum is being divided by
b squared
and then it's multiplied by b squared
those eliminate each other
we have a square root here
and we can and we can just square on
both sides of the equality
and now we have the sum of squares here
so we don't really need these names
anymore it's just the sums of
um of a b squared
and a and b together they are the left
argument so we can get rid of our
temporary names and this is exactly the
pythagorean theorem so we've proven that
the solution using four circle
is exactly the same thing
okay
now for the last solution which is a bit
involved and it uses a rarely the rarely
used uh
domino
function
which is a matrix inversion although
we're using it here only on vectors and
scalars so
it's a bit of a misnomer to call it
matrix conversion maybe extra inversion
or just
inversion
and it's very clever it is
the
ratio between the inversions
of
of both arguments so this is using over
we check if it matches
the ratio
between these
the arguments
okay what's going on here how does this
work it does actually work for our test
cases but let's start to
to unpack this a bit
and so first we have a division here and
we're pre-processing both arguments
using
this domino
here's the right argument
and
here is the left argument
and then we are checking if it matches
the ratio between the arguments of all
now um
this inversion function and we'll apply
it to a scalar is exactly the same thing
as just a normal reciprocal so we can
replace that
and we can also see that we're dividing
by a reciprocal that's the same thing as
a multiplication
so far so good
what does it actually mean
to invert a vector
what it does is
it finds a vector for which the dot
product with the original vector gives
one
so it's in a sense it's inverse
just like
five and a fifth multiplying by each
other you get one
so the vector is going to have the same
direction
but this reciprocal magnitude
this is
the in
this means that the inverse vector
would need
to be multiplied twice by the magnitude
to get the original uh
vector
right what's
since uh
multiplication once by the magnitude
gets us um half it gets us
to the middle to one
so that's the same thing and that means
that multiplying twice by the
magnitude gets us all the way back
to the original
let's
test this out a bit so we invert
3 and
the 3 4
and then we can multiply that
twice
by that supposed magnitude
and we can see that we're right back
where we started
if we try to do this for and
for arguments
that are not
forming a right angle triangle
then we're going to see that it's not
going to work to
add up
close
but not quite
nope this isn't even right it's supposed
to be
two even closer still not right
have our example from um before
so if multiplying it twice gives gets us
all the way there multiplying it once
gets us halfway there kind of
meeting uh in the middle
where do we so if
multiplying the inverse
by the magnitude
twice gets us all the way to the
original argument if you only multiply
it half
halfway there or you multiply it once
then it would be the same thing as
starting from above starting from the
original and dividing it once by
uh by the magnitude
hence what we have here
so we multiply so this is the diagonal
the order magnitude and we're
multiplying it once by the magnitude is
the same thing
as dividing
the original by
the magnitude and that only holds
if
it's a right angled
triangle
so we we need to test if they meet in
the middle if the
if the inverted vector
times the supposed magnitude matches the
original divided by the supposed
magnitude then they met in the middle
and then what we've supposed is them is
the magnitude is actually the true
magnitude
okay so we said that the inversion
of this vector
is the same thing as scaling it down
twice by its magnitude so let's
let's test that let's write that out
so we're scaling it down we're dividing
it
by its
magnitude twice
and its magnitude
is of course
the square root
of the squares of this component
next out
next up we see that we have a square
root here
but it's squared
so they cancel each other out
oh sorry did i
let's go back a step
we had the square root
of
the sum of this of the squares of course
to get a get diagonal and that was
um that was being squared yeah so these
two cancel each other out
and we have the sum of uh the squares
that we are dividing um
the original by
now we can see that we have alpha
divided by something over here
and then multiply it by something
and over here we also have alpha divided
by so if we divide both sides of the
quality by alpha
we can eliminate that
now we have a reciprocal of this
times
the right argument
so a reciprocal multiplied by something
that's the same thing as that something
divided by the value
then we can take the we have a
reciprocal of the right argument over
here and let's take the reciprocal
of both sides of the equality that
eliminates this and we just need to swap
over the arguments over here
we divide by
the right argument over here and here we
just have the right argument so let's
multiply on both sides of the equality
by
the right argument
that eliminates this division
and this self-multiplication is of
course the right argument squared
and therefore
we have here the pythagorean theorem
again the square of the long side
equals
the sum
of
and the squares of the
the two shorter sides
so that's how
this very impressive five character
solution works and inspect the whole
the exact same thing but just in a very
disguised way and then with one caveat
since we're doing all these divisions if
we have any zeros
then it will fail so it doesn't actually
work if any if sides are zero but then
that it's very clever
thank you for watchinghi
we're going to count how many of each of
a given set of letters appear in a given
string
so let's start with some sample data
and we can see here that there are three
A's
two C's no G's and two T's so let's see
how we can compute this
because we're only returning the numbers
for each letter one number for each
letter and not say some kind of
dictionary that Maps the letter to its
count then it's very important that we
preserve the ordering
of the letters
so we want first the count of the A's
then the C's then the G's and then the
t's
and the way we can do this is with an
outer product an outer product Compares
and or combines
every element from the array on the left
with every element from array on the
right using
a given function
in this case it is equality that we want
to use
so we write this in a special syntax jut
Dot and then we put the function on the
right
and this gives us a table and we can see
how the a c g t formed our the
individual rows and then the letters of
a t t a c c a formed the columns and we
get true which is one in APL whenever
they are equal to each other so the
first one is an A and then we get a t
and another T and an a
in order to find out how many there are
of each all we need to know is how many
ones are there
in each row and we can do that by
summation
so
this is the reduction operator
also known as reduce and when it's
written like this then it reduces along
the rows which is exactly what we want
here
we can see that this gives us the right
numbers that we have three A's
twozies no G's and two T's
this is an expression for the solution
but we want to package this up as a
function and there are a couple of ways
we can do that the simplest way to do it
would be to
take the formula itself substitute an
Omega with the hard-coded value and that
represents the argument and then the
braces are the function definition
now we can apply F directly to the
argument
however
since we're only referring to the
argument here
so the at the very right
and only once it's very simple to
convert this to a so-called tested or
point-free function
that is one where we don't mention the
argument specifically
however
um there is a system to this if we
remove the braces and the Omega then we
end up with a new derived function which
is the outer
equality or out of product equality
with
a left argument but no right argument
and that's a bit of a problem
so we really want a placeholder for the
argument here and that we can do by
putting in
the
density function so in a tested function
we always refer to the arguments in
terms of function applications and in
this case we just want the value of the
argument itself so that is the density
function applied to the argument
so this works exactly the same
we could also combine things in other
ways in order to show kind of the
grouping between things
so the summation here is really
it really forms a pair to go with the
outer product
to form this sum of the equality table
and if you want to indicate that then we
can put it over here and group them
together with parenthesis and this will
work as well
whereas before this whole part formed a
single derived function
and then its result was being fed to
this derived function the summation now
it is
a combination of these two functions the
table and the summation and this whole
new derived function which is the sum of
the equality table gets as left argument
these four letters and as right argument
the identity the result of the identity
function applied to the argument
instead of doing that we could also bind
or Curry an argument
using the bind operator which uses the
same symbol as the outer product but
they're not always related
and this binds a left argument to this
General function which is just the sum
of the equality table
so we can
use this function as well it gives the
same result
we could also Define a general purpose
function say counts
which we'll just Define as that middle
part
and now we don't need any parenthesis
because it's just the two functions with
no arguments or anything else around
them
and this would be a general purpose
function in that we have to give it the
vocabulary as left argument
and then
the main data argument on the right
and we can then use that in turn
to create a derived function based on
the general accounts function
then we can then apply
thank you for watchinghi
we are given a bunch of scores and are
to convert them into grades represented
as letters
here are some scores they are arranged
in a table a two Row three column table
and the shape doesn't matter
we need to be able to handle any array
but as we'll see that won't be a problem
let's start off with a little Lambda or
a defen and then we refer to the
argument with the letter Omega the
rightmost letter of the Greek alphabet
now we use the the interval index
function
it gives us the indices
of the elements on the right
in a lookup array on left
but it's not just finding those elements
there it is the intervals so the array
on the left has to be sorted and we
figure out which interval with the right
side elements fall into
on the left let me illustrate this so we
write our cutoffs from the table
and now we go and look up
71 it's not in the list of cutoffs
instead it would fall in this interval
and the intervals are
inclusive on the left and exclusive on
the right the last
cutoff goes for Infinity after that
and and this is interval number one
which Falls between after the first
cut off
we can see that by 59 which falls in
that first interval so which ends before
65 begins at zero if there were any
elements that would go before zero that
is negative number then
we would get a
interval number zero but by default
that's not a proper index and we don't
want that so therefore we begin with
0 which is the cutoff for the first
element APL supports
multi-indexing that is when we index
into an array or a string in this case
then we can index using multiple indices
the result is all always has the same
shape as the indexer so here
we get an array of two rows and three
columns of indices and each one of those
indices will then be applied in turn to
the lookup array this effectively
translates the indices to this alphabet
and here we have it these are the letter
grades thank you for watchingwelcome to the apr quest capl wiki for
details
today's problem the eighth from the 2015
round of the apl problems of
compensation
asks us to replace
instances of the number 13
with the number 12.99
but only numbers not where it's written
in text
however um
while
the test case is given in automated
testing system on problems.trypill.org
only our fully numeric
and flat arrays
by extending the
the domain you can get quite some depth
to this problem
without further ado let's get started
so let's start with
a very simple test case the type of test
cases that we might see in the automated
testing system
and for this we can use a mathematical
approach
so
we can say
the argument
minus
0.01
times
a boolean mask
the argument
so here this will give us ones where
there are 13s and then we multiply with
this which is a difference to
that we need to make when we have a 13
and then we subtract that from the
argument itself and that works fine for
arrays
like this
however
if we
say
take it very literally what it says in
the problem specification that we only
need to concern ourselves with uh
with data that is uh there are numbers
and not uh 13s that occur in text that
would seem to indicate that there could
be text so let's throw in some
characters
so this is a flat array still but it's
mixed type
and of course
this is not going to work very well when
we try to apply the f
function
on it
and that is because
and
we
are trying while we can compare to 13
and it will give us 0 for the d and the
e
we cannot subtract zero from d and e so
we get a domain error in this case
and we had to go with an entirely
different approach
so
let's write a different function here
and
one way we can do this is to use
um selective assignment to change the
value or we could use
modify this and select the assignment to
do the subtraction
for that we need a variable which we are
allowed to change uh the omega in a d
fin is a constant we're not allowed to
uh to change that so we'll take that and
we'll
use the name r instead
we don't need
this value right away so we'll defer
that instead we want
12.99 and we want to put that into
uh
into r but only into a subset of r
selected by the mask where
13 is equal to
the argument or we could put an r as
well here it would give the same result
now the r has been updated we just need
to
ignore the result of this assignment
which would be 12.99 anyway
and then return r
and g can be used in this
variable and it just ignores the d's and
e's and even the 11 because we're only
interested in elements that are
13.
okay
what happens if
we
change things up a little bit let's do
let's take
these numbers and letters from b and
make them up and make them into a matrix
instead
so now we've got a matrix with numbers
in one column and characters in
the other column and if we try to use g
on
on this then we get a rank error
because we cannot use compress
with a matrix left argument it has to be
a vector a mask over the columns or
elements in this case but
we can of course
fix this
so if we um
if we take
this g
and make it into an h and then we ravel
the
argument values first
and then we ascending to the reveled
argument
and then but we didn't actually revel
the um the array r and then we're
returning that there so let's try that
hnc and that works as well
but we said text before and
that might be even
more than
this
before we go there and let's just see
another way of doing this which is
very similar in what it's doing
but
much more concise
that is to use that operator so really
what we're saying is that
not considering the shape of the
argument
we just want to replace with 12.99 at
the positions where 13 equals that
and that's exactly what the after
operator does
so you can write 2.99
at
where 13 equals
the argument
um and that's
all we need to do really
and that works as well okay back to the
text
and the text of course can be more than
a single character so let's
have a new array
which again let's stick to a matrix so
that we make sure that we don't have any
regression on that
and this time
we're going to use a character vector as
one of the elements
so it looks like this a nested array
this time because one of the elements in
the array is itself a vector
if we try to apply this function and i
on d or for that take if you were to try
to apply h which works exactly the same
way
then
it's not going to work
i would give us this
and h
so you get a domain error here and that
is because
um when we're doing this comparison
we're creating the boolean mask
and so we said 13 is equal to the
argument
on d and when and equal is a scalar
function which means it penetrates into
our structure
and so we get an array of the same exact
structure but with boolean values inside
however such a nested array is not a
valid argument and not for
replicate
and
not for
that operator either
so what can we do about this
well
one thing we could do
is
not to use equal because we don't want
to penetrate instead
and we don't want to penetrate into
the arrays
so if instead we look at
whether these
elements individually are members of
13 that would consider them as a whole
so we have a collection which is just a
single element 13
and then for each element in the
argument we look at whether or not they
are members of that collection we call
that single element and then we can see
we get
an array of the same shape as the
argument
and it doesn't penetrate into all that
structure
so if we modify our i function and
just changing that one little bit
then we're able to
use our function
successfully
okay
but let's
complicate matters even further
so we had
a
d here with a character vector which as
one of the elements but let's say we
have a more complex structure so we have
a still matrix
but
and still the same
elements
but this time
we we bunch together
these two
elements into a single element so
they're actually three elements and
we're going to
reuse the 11 because we need a fourth
element so we can see that here
and now the 13 is hidden deep inside
so while we can use
the function
j here
it didn't actually work because
inside it it had a look
are the elements members of 13
and it said that
the two element vector of dd and
13 well that's not a 13 it's a two
element vector
but that kind of defeats the purpose
because we would want this 13
to be replaced
so one solution to this
is to use recursion
we only want to consider the simple
scalars and replace those
now simple scalars they have a depth
of zero
if we don't have a depth of zero any
other depth
then we need to recurse we need to go
one step in so on each element
whether it's just an
a scalar enclosure or whether it is a
vector or any other rank array we go
through all the elements in turn
and consider them a new calling the same
function
otherwise which means we do have a
simple scalar there are only two cases
either we've got a 13.
in which case we replace it with 12.9 or
we don't
in which case we leave it unchanged
now we can apply the function to e and
we recurse through the whole structure
and replace the deeply hidden 13 with
12.99
we can actually use a method that we had
before
this
function h
we were reveling
the data
to find the elements so that
we could use compress
and we could do exactly the same instead
of rambling we kind of do a super
reveling which is in list still we're
not
changing the actual structure of this
temporary variable r
we are just assigning to its
corresponding
completely flattened version and the
same thing we are comparing 13 to the
completely flattened
data in r
and then we can
oops i should have
should have named this not k it should
have been
l
that's better
and then we can
we can use l on
uh on e and that still works
finally there's actually a pretty neat
trick
that we can
use in here and that is to combine
this ability to assign to
the enlist of a variable
with the neither notation of using an at
so
again we make a copy of our argument we
enlist that
and then change 12.99
where we have got
13
equal to well you can write the way
we've done before
well actually
i like writing 13 first um because it's
more i find it more idiomatic in apl to
write what we're comparing with
on the left as i see functions as having
a left argument which is kind of
parameter and the right argument is the
data so i'll write it like this
and now we've got we replaced all these
values of 13 with 12.99
um
but we have it all flat and we just need
to stick it back into the structure it
came from so we're assigning this
to the list of r
and then discarding that and returning r
and now we can finally run this
and
that also works
so that's all for today thank you for
watchinghi
this may look like a very complicated
specification
but all is really asking for
is cutting it a
Vector into two parts
and we specify the length of one of the
two parts the other one is just the rest
of the elements
we want either the first
n elements
grouped and then the rest of them in the
second group or we want the second group
to be the last n elements and then the
leading elements up to that
form the first group
and the way we determine if we want the
first to last
is by the sign of this number
so a positive number we specify the
length of the first group and the
negative number specifies the length of
the last group
this kind of specification
is parallel to apl's take and drop
Primitives
so the take primitive can take the first
three or take the last three and
similarly we can do
drop the first three
and
drop the last three
this pretty much gives away how we can
solve this problem
so if you take the positive case first
and make a little Lambda
where the left argument is Alpha and the
right argument is omega
we can see here that we want the first
three elements
and then we want the second group to
have the first three elements removed
however if we flip the sign here
then our groups come in the wrong order
we can fix this by
reversing
but we don't want to always reverse we
want to conditionally reverse
one way we can do this is by using the
power operator
power braid it takes a number on the
right
and that number is the number of times
we want to apply this function on the
right on the left
how many times do you want to do it well
we want to do it zero times if the left
argument is positive and one time is the
left argument is negative
luckily
APL comparisons return 0 or 1 for false
and true
so if 0 is greater than the left
argument that gives
zero in this case we reverse zero times
and if it is
true then it gives a one a reverse once
which solves our problem but we can make
it a little bit more elegant
by observing that since we only have two
elements in our array reversing is the
same thing as a one step rotation so we
can try this
the dyadic form of the same symbol is
the rotation so here we've rotated one
step and if we
have a positive number the number on the
left we want to rotate zero steps
and that means we can use the same
expression
where the zero is greater than the left
argument in order to find out the
rotation amount
this function
can be converted to a tested or Point
screen form
we can observe here that we have a
pattern we have these two arguments that
are applied
with one function and with another
function and then there's an invisible
function that binds them together which
is the stranding into an array
but stranding into an array is actually
concatenation of the enclosures
so if we do a concatenation but
pre-process both arguments with an
enclosure we get get the same exact
thing
and now we can make a proper Fork
so what happened here is that we
removed the explicit mention of the
arguments
to outside this little function
and so these are three functions one two
three the arguments are used on the left
and the right function and their results
are combined using the middle function
which is the stranding together
functional pairing function
concatenation of the enclosures
here we have zero is greater than the
left argument
so now we can go through and convert
this whole thing to a tested function
zero is greater than the left argument
left argument here
right argument here and we finish off
that tested function
however
this inner function is being applied to
the result
of taking the left argument and the
right argument that doesn't add anything
so we can strip off that outer level
and here's our final function
thank you for watchinghi and welcome to the apl quest
c apl wiki for details
today's quest is the sixth problem from
the 2013 round of the apl problem
solving competition
it's a very simple problem uh just
finding out the numeric range of an
array that is uh the highest value minus
the lowest value
um but we'll see that there is a special
edge case that we need to take action
for and we'll look into some
generalization as well
without further ado
and let's generate some data we can work
on
okay so here's a numeric vector and the
highest value is the maximum reduction
of that vector and this
lowest value is the minimum reduction
over the vector
and then we can take those two values
and subtract
the smaller
from the larger
and we get the full numeric range so
that's really all there is to the basic
problem
let's put this into a function and we
can write
the max reduction of omega minus the min
reduction of omega there's a redundant
parenthesis here but that's mostly just
for clarity and
to make the expression symmetric
so we can try this on v and that works
great now there are a couple of problems
with this
one is that it has to work on any array
so let's make a matrix which is two rows
and four columns containing the same
numbers as v it looks like this
now if we were to apply our function
here
on m instead then it doesn't work
because it gives us the numeric range
for every row we want the numeric range
for the entire array
and we can solve that
by
raveling the array first
so we revel it here remember it here
um and
this gives us the full range
as we can see here we are reveling twice
which is quite unnecessary and we can
actually in a neat way break this
reveling out of the parenthesis
so let's get rid of the ravel from here
and the rev from here
and we can actually switch to a tested
form quite easily so we just say the max
minus the min
off the ravel of
the array
here we go
and we can get this even further because
now we can observe that we actually have
a full tested function and a top simply
wrapped in a different wrapper so we can
completely get rid of that syntax and it
still works we can give this a name then
see how that works
of course still works on our vector
it also works on
a scalar where the range is zero because
we revel in the largest
minus the
smallest is and it's the same number so
it gives zero
so this is a good method
and one method that isn't so good but
it's kind of fun to look at if we take
our
our vector and do an outer product
but instead of multiplication we're
doing an outer
subtraction so that means it's a
subtraction table that gives all the
possible differences
between values and then the full range
is then the largest number in this table
so we can take the maximum of the level
of that and that gives us also the range
not a good way to do it but it works so
we could make a function out of this by
saying
um
the maximum over
and
ravel of
the outer
and
subtraction
selfie
and in fact this will work on our matrix
as well it just generates an even higher
rank array as an intermediary step
but there's a catch
according to the example cases in the
problem specification
the function also has to work on
empty arrays and that doesn't work why
doesn't it work well we can try our um
original function
um let's go up and define that again
we have it right here this was this one
if you try that on say the empty vector
we get a domain error
and uh we're supposed to get a zero
instead as it to say there is no range
the problem is
that the maximum
over
an empty vector
is the smallest representable number in
the current numeric system
so these are 64-bit floats and this is
the smallest representable 64-bit float
why is that
that is because the reduction over an
empty axis gives the identity element
for that operation so for plus identity
element is the value that you can plus
with
without changing anything that would be
zero for multiplication what you can
you can multiply with is a one
and for max the only number that you can
do a max with
and make sure that your original numbers
becomes the result so it's an identity
operation
nothing changes is the smallest
representable number or a negative
infinity if that's
available and similarly if we do a
minimum reduction we get the max
representable number and trying to
subtract
this very small number from this very
large number goes beyond the range of uh
the floating point system that we are
using and we get the domain error
so this system doesn't quite work
how can we solve it well one simple way
to do it is simply to say is our array
empty
now we can't just compare to the empty
vector because there might be multiple
x's say we could have a
a
zero row
two column matrix of numbers
which
isn't visible but it sure exists
what we can do is that we can take its
shape and there is a zero there and if
there is a
zero anywhere in the shape of an array
it's called an empty array and then the
range has to be zero so we can write
this function as if zero is a member of
the shape of the array then return zero
otherwise
we take the maximum
minus
the minimum
of the ravel of the array and now we can
apply this on each of our arrays the
vector the matrix the empty
vector and why not our zero by
two
matrix as well and now it works so this
is a valid solution and it's very clear
it's probably the clearest
solution that there is
but we can be a bit more
clever about this first for a fun
solution but not an efficient one
and that is if we sort the array first
so we let's say we start with our matrix
and then we revel the matrix and then we
sort it
then we know that
the
range is the last element minus the
first element
so the last element can be written as
the pick atop
reverse
minus the first element which is just a
first pick
and and that works and the reason i'm
using this method for getting the first
and last element is because if we try to
pick the first element of an empty
vector
then it coerces out a number so that
means that both of these terms would
become zero so we get zero minus zero
which is zero and that's the correct
result for the empty array even
of course if we have something like this
a matrix because we revel first it will
work the same way so this is a solution
but not a very good one in order to make
it a full function there are a couple of
different ways we could do it um
we could take this tested function here
and put it inside the parenthesis but as
you can see the color changes that is
because it ceases to use the sorting
idiom so things will run a bit slower
but it works if you want to preserve
the
speed of it then we can just string
things together
using in the top either way it could be
in the top here or you could be in the
top over here or we can use all three of
them all of that works
all three are topped together
there are uh
clever ways that we could do this
and for that we need to think a little
bit okay so we have a matrix
and we need to ravel it
and
um
then
we want to have a zero
if
the array is
empty okay how could we how can we do
that so we can we can tally the reveled
array
and then
we can
have a maximum
with one
so if the array is length zero then we
get one otherwise we just get the length
of the array
and then we can use this
to take from the reveled
um array again
okay so now here it doesn't make a
difference of course we can see that
that gives our data as we expected if we
do it on an empty vector
then we end up overtaking by one
and that pads with another
zero at the end and then the rest of the
procedure will be the same so we can say
the maximum minus the minimum
of
the revel
let's say we can write take this whole
expression here
we can
write it like this
and then we can go and simplify
things a bit um we can turn all of this
tested actually
so we could ravel first
and then we could apply a function to
that where we
use this value which is the length
except it becomes one and we can take
from
that same thing
so this is a possibility and now we
don't need the braces anymore
but we have three functions here so we
need to atop at least one place
so now we can this works and it works on
empty arrays as well
um and but there's actually
more we could we could do firstly for
the syntax here
and we instead of since we have three
functions that we want to avoid we
because of we have to do the explicit at
the top we can take
this which is a magnetic function
and put inside the parenthesis as a left
carriage on the strain so here is
the original function we're applying it
becomes a fork right here and then
another fork
and then finally in the top with this
function here so that works as well
and it gives us our results as we expect
what else can we do well
observe
that the ravel of an array
gives us all the elements in a single
vector
how many elements
well that's the product over the length
of all the x's in that array so for our
matrix
the shape is this
and that means that the product
is how many elements we have
very good
so if we
say that there are none
so if there's any zero inside
the shape then the product is going to
be zero
so we can take that the maximum of that
will one
and then we can simply use that to
reshape their array itself
so here when the array is empty we
reshape the empty array into a one
element
vector giving us just a one element
vector with a zero and if we used it on
say our matrix
then this would be equivalent to
reveling it
so we can put all this together and
again say
the maximum minus the minimum
of
the array itself
reshaped by the maximum of
one and the tally of uh the array when
that entire thing is reveled
and this works
so that's one way to do it
another thing we can do is since we're
raveling anyway then we can
selectively append a zero which will
then be picked up
by the maximum minimum or it could
actually be any other number that we
that we add
because it will be that same number
minus itself and then that the range is
zero
so how do we do this well we have the
condition zero is a
member of the shape of this array and
you can see that here
and then we can use this to
replicate
a zero or any other number
so here we get a zero but if the array
isn't
empty then we get nothing and we can
then
append that to
the ravel of the array
so now we can write
the revel over the array
concatenated with
this
as a tested function
so here we do not add any zeros
but in an empty array
we
do add it to the revel
so now we selectively add a zero when we
need it or any other number it would be
we can use any other number as well and
then we can say the maximum minus the
minimum of that and then that gives us
zero let's put this vector right here
there's no reason to find any other
number
so this is another solution
and can we be even clever yes because
think about it
we want to add a zero
if
there is a zero in the shape
and any other number in the shape
we're not interested in only zeros
we could even be multiple zeros it
wouldn't matter because the maximum and
minimum is not going to change just a
bunch of zeros or actually any other
number but the important thing is that
we add a number
or more numbers when there's a zero in
the shape
so how about just adding
all the zeros from the shape
okay let's say we have this array two
zero
zero two reshape zero this is this
invisible matrix and then we take the
intersection
of zero
with
the shape of this
that gives us the zero if our array
wasn't empty then there would be nothing
there if our array had multiple zeros in
its shape
then
we have the intersection of
and of a single zero
with
and
all these numbers here including the
zeros and so we get that single zero
so we can use this
and concatenate this intersection
so we can write the maximum minus the
minimum of
the ravel
concatenated with
zero intersection of the shape
and that works
this is probably the most concise and
way and a tested way of writing it
um
now for going a little bit beyond
the original question
uh quest which was just in a given a
numeric array um you we could choose to
understand it as giving any array that
consists eventually of atomic numbers
how would that look well and we could
split our matrix into a vector of
vectors
and
um and now our method is not going to
work anymore we're going to get
something completely unrelated to what
we're looking for and because our
function just travels it and that
doesn't un
open up the structure but we do have a
function called enlist which is just
like gravel but more powerful in that it
completely takes any array and flattens
it out to be a simple vector so if we
take our old solution of the maximum
minus the minimum
of
the
argument
and we overtake with
one maximum of the length
and all of this
applied not on the rebel but rather on
the list
now it will work
and we can do exactly the same thing
with our function up here that uses the
intersection the only important thing is
that instead of
just using the shape directly we
get rid of this ravel
and
move outside the whole expression this
in list
so this is in list
if the is any
zero in
the
intersection with the shape of that in
list then we concatenate that to the
argument which is the enlisted argument
and then we compute the range as normal
however at this point when we've already
made the enlist
we don't need to
to take the shape at all we because we
already know that this is a vector
so
and if it's a vector and it's empty
then it must be the empty numeric vector
so we can actually say that if the
argument
is
the empty vector so if the argument is
equivalent to an empty vector
um then
we
add another number so this is another
way to do it
and we can but of course it it works
just fine to say the intersection
with the shape or even with the tally
would be just fine as well
and that's it thank you so much and see
you next weekhi we are to take a multim
multi-dimensional array and
interchange the horizontally adjacent
elements here is an example
multi-dimensional array it is a
three-dimensional array with a two
layers and each layer has two rows and
then we've got five
columns and our task here then is to
Interchange adjacent element so Gela is
being interchanged with opton they
switch places Prospero with lysia and
then uh there isn't anybody to uh switch
position with toaza so that just stays
in place there and the same goes for
every row and
actually note that we can really operate
on individual rows we don't have to
worry about the overall shape of the
array though we'll get back to doing so
anyway so just to develop our algorithm
let's focus
on uh just the first
layers and first row and then all the
columns from
there we have those
here and so we'll start by the finding
or wrapping our Anonymous function
de and we
can take advantage of the partition
inclose function to pair up these
adjacent elements and flip the positions
and merge everything uh back
again and the with the petitioning close
function it takes a uh for our purposes
a mask have one when we are to start a
new section and then zero when we are to
continue a section so we want a mask of
one Z One Z onto the length of uh this
Vector um so we can get the length of
the vector uh with or the shape of it uh
with uh the shape function of
Omega and then we can use this to
reshape uh one Zer so we keep using from
this array one Zer uh cly until we have
the shape that we asked for and that
gives us this mask then we can use that
mask to partition uh the argument and
here we have the pairs that we're going
to flip and we now can uh reverse each
one of these and notice that the last
one that only has one element it's still
Vector of of character vectors here but
it its reversal doesn't have any
effect and now all we need to do is
merge these back together again so we
use a concatenation
reduction but uh the concatenation
reduction uh has to reduce it is a
reduction and reduces then the the rank
number of Dimensions from one this is a
a list Vector of vectors to zero so this
is a an enclosure of uh the actual
Vector result that we want we need to
then disclose that uh to get the result
we want this took care of
the simple uh case where it's just a
vector and we want this to apply to all
the vectors that can be found as
subarrays of our overall um array so we
had the entire n here and we can very
simply do this um that's we can we just
Define our function here e uh for uh
partition
inclose and specify that it should be
applied on rank one so it's not really a
specification It's actually an operator
that takes a function as left operand
and a rank specification as right
operand and saying this function must
never see any argument that has rank
greater than one so in effect the rank
operator will iterate over our given
argument and apply the function to every
subarray of rank no more than one which
is in fact always going to be present
because the problem specification says
that it will be a vector or higher rank
array so we can try this let's uh print
out the names again just so we can
compare them and then we apply uh the E
function to that and we can see that uh
we got exactly the result that we
wanted so this is one way to approach it
um but there are many others I'll go
through another couple um another way we
could do this is by indexing so we could
build up up the
indices uh of the elements reordered
such that we get the result that we want
and that takes um a little bit of an
algorithm so let's start again just by
the vector case and then we can apply
rank one to get the full uh thing so
here is our
vector and again let's define a uh
Lambda
a and and this time uh we again we have
the the shape of
that but now what we really want is to
find out which order should we put them
in in order to sort them but not just
sort them by say alphabetically but sort
them such that we interchange adjacent
elements and um we can start by
generating the nor noral indices right
so what we want here is the uh the
reordering but we need to adjust our
values because these are already sorted
so that two becomes uh less than one or
one is greater than two and three
becomes greater than four and so on and
we could do that by just adding two to
every other element so if we add two to
one we get three and that doesn't Clash
with the next three because this three
will also have two added to it and
becomes five and it won't clash with the
five because five becomes seven and then
and then the two and four stays and then
we just have to sort by uh that ordering
the ordering that would sort those
numbers enough talk and we can do this
in exactly the same way as before so we
uh we take the length and we use it to
reshape uh this time it's two and zero
and then we just need to add that to the
um to the indices that we computed over
here and for that um easiest thing is to
make a little train uh Fork so we do the
indices plus the reshaping of to
Z and we apply that whole thing to the
shape of uh the argument so we first
compute the shape and then we get the
indices of the shape and then we use the
shape to reshape to zero and then we add
those together they now have the same
length of course and that gives us uh
this so we can see the one was
incremented up to to three and the two
stays in place the three became five
four stays in place and five became
seven now we can H we can grade this to
find out what indices elements should we
take in order to make this
sorted and so here we can see that we
want F the the smallest element is uh
the second one that's the two then the
next one is the first one the next one
is the fourth one and the next one is
the third one and then the fifth one and
that effectively gives us um these flip
pairs for indices 2 one then 43 then
then five All That Remains now is to use
these indices to index into the argument
and we have gotten um our reordering as
we
wanted so here we're using indexing with
grading um we can call this I and then
specify that this goes on uh vectors and
that means that we can let's just's
print out our um example names here
again and then we apply our
function and we can see again that we
have the correct uh flipping of
Paris
and finally I want to show how to do
this uh using the stencil operator the
stencil operator is normally associated
with cellular automatons Game of Life
things like this um it processes Windows
of an array um it's it's almost an edge
case that it can have Windows of size
two and the movement the window moves
over by two steps and that effectively
isolates and adjacent pairs
this time uh let's do it tested and we
again we can start with uh the first
layer's first
row so we use run parenthesis instead
for a a train or a tested
function and um we can we start with a
stens operator and then the idea here is
that we use an Windows of size two with
a movement also of size two so we need
to make this into a matrix because every
row has serves a different purpose in
the right oper stens so the first row
specifies the window size the second row
specifies uh the window movement if
there were additional Dimensions we were
traveling along then we would have
additional columns in this
table and we can and we can isolate
these so we
can uh this the oper end function to
stencil is given uh two arguments and we
don't need the left argument so we use
the the right function and then we
enclose
that and uh we can see that we got the
pairs but stencil cuts the argument
short if it can't complete a window uh
with a specified
movement so we will have to address that
but for now
um we don't have to necessarily enclose
this we could also increase the rank uh
by not
enclosing so that gives us this table
and that can uh conveniently
be uh
reversed and then and we can Revel it
and
again right
there now and there is missing something
and and then is the last column so we
can read that column but of course this
only happens when uh the rows have an
odd length so here we use a a right
reduction to get uh the rightmost
element and that add this back again if
we had an even number of elements then
and
our and code here would add one more
column that didn't need to be added so
we can do this by cutting short and our
argument to just four not five uh names
and we can uh see
that and we have an extra Delicia and
over here because that was the last
element before it was moved one step uh
to the left this is of course wrong but
we can counteract this uh by taking the
uh the
shape so we take using the original
shape and that ensures that we chop off
the excessive uh element if it
exists and then if we use the odd
numbers here five then we also get uh
the right
result so this works um again on uh rank
one and we can call this s for stencil
and we can try to apply that on and our
whole multi-dimensional array and we get
the desired result
result um it would be interesting to do
a speed comparison of these three
approaches so let's copy in the compare
execution and facility from the defense
workspace and then uh I also have a
larger and here we only have 20 names we
have a larger many dimensional array uh
called a
uh we can see that
and a has
20,000 elements instead of um just 20
and it's distributed over five
Dimensions so it's a relatively large
array um and well we can also look at
the whole whole shape of this it has an
odd length and long last axis where
we're going to do all the the actual
computation so uh and we're going to
compare the execution and we've got e
with a as argument and we've got I with
a as argument and we got s with a as
argument and then we let it run for a
little bit to see how they stack up
against each
other and well those are some
significant differences we can see and
and if you reason about it we can also
see why that is
and the stencil operator and is
optimized for certain cases but not for
what we're doing here and so it goes in
and actually applies function and to
every window and and moves around and
that is expensive to
do the partition inclose function
generates an intermediary further nested
array that isn't otherwise necessary
and the indexing just directly goes in
and computes how we want the result
reordered and that then ends up being
significantly faster than other
approaches
but that
said we can do this much
better because if we look at our
definition say we we look at s here we
are treating every row separately and
potentially there are a lot of
rows and even though rank is optimized
again for certain Primitives and
constructs and when we have a complex
function like this there's nothing The
Interpreter can do and it just has to
Loop through um all the rows
individually if we could treat the whole
array and in one go then that would give
us a significant speed up and uh this is
what array programming languages like
APL are really good at
so let's try to reformulate this s into
a uh a function where we do not need to
specify that the rank uh of the argument
is restricted to
one and here well we still kind of want
to do that but we don't have to do it on
the entire
function because we do want these
windows and on rank
one but we can do that or all the way in
here
instead so this takes care of the
reordering of individual rows then we
might be missing a column we add the
rightmost column so to say that's the
last element of every Row in the entire
array to this potentially
multidimensional array that comes out
after running on rank one and instead of
doing this take operation on every row
individually we take the shape of the
original array the multi-dimensional
array and uh restrict along all X's
which won't have changed except for the
last one potentially um so that's just
one operation to cut short in our
array and now we can try to
compare uh our original s with our S2
and see if that made a
difference
so we can see that uh that became
somewhat faster um it still doesn't get
rid of this Loop for of the um the rank
one we could potentially get rid of this
one as well by specifying a window size
that is one and a movement of one in
every Dimension except for the last one
where we have a window size and movement
of two but it becomes a lot of
computation to get that uh window size
right and to then reform the argument
back again to the original so let's that
leave that there because as we can see
up here the stencil approach is anyway
much slower than the other one so this
will be more interesting and with and
our other approaches so then we had and
our function
e and let's try to define a new an
E2 that
and
does this on the whole array instead so
we want to get rid of the the rank one
here now this gives us the shape of the
entire array but we only want the
trailing uh element of the shape which
is
the um the number of columns so the
lengths of the rows and uh we can get
that for example like this to do with
get the less element uh the the
rightmost of uh the
shape then we reshape to the mask uh
that we want and actually this works out
very nicely because by default the
petition inclose Works along the
trailing axis so this is going to uh
split up our array into should we say
vertical slices of uh with two and so
everything else just works out we
reverse these two column and
multi-dimensional subarrays and then we
join them all together adjacent to each
other and since we use the reduction to
do that we disclose they should just and
work out so now let's try to compare e
and
E2 and we can see that just this little
bit of modification gave us some very
significant
savings okay let's see if we can do this
with the I function as well so we want
to have an a new I2
function and we don't want to apply rank
here now we end up in trouble
immediately because the square bracket
indexing requires us to know the rank of
what we're indexing so we have to
replace it with something else um and
for that there actually if we take these
two square brackets um and we we merge
them together uh then they become the
squad function which is then a proper
function
indexing but again we don't really want
to generate the indices along and every
dimension for all our elements so we can
use the slightly and unpleasant looking
square bracket access to say that all
the indexing that we are going to do we
are going to do and along the last
axis uh so that is the same thing as the
rank of uh the
argument and now and the what we're
indexing is on the left but it normally
takes it on the right so we swap that
and in order to just reorder and so to
have multiple indices along the same
axis then we need to enclose um the
argument over here and then of course
this is the entire shape so just as
before uh we want to get the length of
the last Dimension and the rest should
stay the same we get the mask we do the
grade and then we apply that there so
now we can compare and remember that I
was the fastest one before and now we're
doing I versus and I2 where we not going
over the individual rows with the rank
operator we are treating the entire
array at once and we get well similar
savings as we did with e
but wait there's
more let's think a bit about these
indices that we generated with the
grade let's do it for
five and for
six we were thinking about this
transformation as a positional one
flipping pairs but actually we can think
about it as a mathematical
one originally we had 1 2 3 4 5 six
and in order to get the one into a two
we just need to increment it and the two
becomes a one by decrementing the three
becomes four by incrementing and the
four becomes three by decrementing so
instead of adding two 0 two 0 if we add
one and negative one that pretty much
gives us the result that we're looking
for The Only Exception is when we have
an odd
length here the last element becomes too
big
but we know that the last element can be
no larger than the limit of the
series so we can clamp it using a
minimum and we don't even need to do a
minimum on on all the elements we can do
it just on that very last element
because we know that's the only one that
can be too
large and with that in mind let's go and
change this I2 into an I3 now we need to
give this a name let's call it alha last
and change
the um changes into one and negative 1
instead of two and zero we don't need to
grade anymore but we do need to clamp
the last
element and with that we can try running
I2 against
i3 although even though a has a lot of
elements the last axis that's the
important one is quite short so we don't
see a whole lot of speed up here if
however we make B be a flattened a such
that there are 20,000 elements along
that last axis that actually
matters then if we try comparing the
performance when we now need to grade
20,000 elements instead of of just 600
and something we get a substantial
performance benefit so sometimes
rethinking how we um construct our
indices and doing it in a less costly
way can make a big difference thank you
for watchinghi we are to find a reduced fraction for
a given
number so let's use an example of
1.2 I'll start with the actual full
solution because it's really short um
and then I'll explain how it does the
trick right so here is one .2 is
65 and the way this works is that we
have this is called a fork and where
this binds a left argument to the
Fort so the fork itself it
says and it looks like n symbol but n is
extended to be the lowest common
multiple so it's the low lowest common
multiple divided by the concatenation
what does it mean to take one function
divided by another one well we can
expand this to an explicit def instead
we have a left argument which has been
bound and that's called Alpha we have a
right argument which is called
Omega so here we
take the arguments and use them for both
these outer functions so this is the
lowest common multiple of the left
argument and the right
divided by the concatination of left
argument and the right
argument why does this compute the
reduced
fraction well what does it even mean to
have the lowest common
multiple this isn't the whole number
it's not usually how we think of lowest
common multiple but let's substitute in
this bound argument into the function as
a literal
now what does it mean here the lowest
common multiple of
1.2 that is also divisible by
one so we have to if it's divisible one
that means it has to be a whole number
if it's a whole number um then it can be
part of our fraction so let's try 1.2 *
1 1.2 * 2 2.4
3.6
4.8 and finally
Five Point well they become
six so if we multiply it with five then
we get six so the lowest common multiple
of one and 1.2 is
six so over here we get a number
six and here we concatenate the right
argument 1.2 with one so we have six
divided by one and by 1.2 now six
divided by one of course that's six that
gives us our left argument and and 6
ided by 1.2 why are we doing that
because we want to find out
um the
the other Factor we could say it's a
division we have six divided by
something is supposed to give one 1.2 so
that something we can find by dividing 6
by 1.2 because 1.2 times that other
thing will uh will give
six so this really becomes 6 divided
1 and 6 divided by the
argument and 6id one of course is six
and then we have 6 divided by uh the
argument and this is how uh the function
works
thank you for
watchinghello and welcome to the apl quest ca
bill wiki for details
today's quest is the second problem from
the 2014 round of the apl problem solver
competition we're given a text
and have to find the words in those
in the text and remove any vowels from
the words except if the vowel begins the
word or the vowel ends the word
let's get started with some test data
okay
we can identify where we have spaces
and non-spaces
in our text
then we can use this to partition
the text
because partition will take
elements that is letters here
that correspond to
runs of ones and group them together in
a single element
any
letter or character that corresponds to
a zero
will be discarded and at this point
we'll begin a new segment
so
we partition
using this mask
now it's a question of processing each
word separately
because we need to be a
case insensitive we have to
to handle all kinds of vowels upgrades
in lowercase we can start by uppercasing
our and
our words
and we can then find out which words
which letters are vowels
this gives us one mask per word
there's a problem however you can see
that in the third word the last letter
is a um is marked as a vowel and we
really
don't want to consider the vowel that
can be removed
also
and our masks are inverses of what we
actually want since we're going to use
compress to remove vowels then we should
have zeros for the characters we want to
remove and one for those we want to keep
that part is super easy to fix
we just negate it
and then we need to take care of the
issue of putting a one always at the
front at
the end well that we can do we can amend
this vector with one at position one and
also at the position of the length of
the word
now we're ready to do
the compression
looks good and we just need to join
things together with spaces
since we're already processing each word
we can just stick a space in front of
each word
enlist the whole thing
and remove the leading space
this solution is nice in the sense that
it expresses an appeal very much how we
think about the problem
let's call it
c for cut
there are other ways to to address the
problem however which avoids
splitting up the text
and processing in each word one at a
time rather
the ideal when doing array-based
programming is
to process the entire array in one go
let's see how we can do that
this time we're going to
start with uppercasing everything
and then
we need to
match up
the previous letter and
the next letter with the middle letter
in order to identify whether or not we
are at a word and word boundary
of course the first letter doesn't have
a left neighbor
but we could possibly supply that
now in order to
to match up the left neighbor the letter
itself and the right neighbor we can
drop
so
here's the left neighbor
left neighbor of the
h
in how is that space
we drop one
we get the h itself and if we drop two
then we get
the neighbor on the right
we want to drop all three possibilities
zero
one and two
and we want this dropping
to be done on the entire
vector
so we can say we want on
and
we want to drop using rank 0 every
single number scalar from the left and
we want 1 because we want to treat the
entire vector on the right
now we can compare
these
this whole matrix to spaces
for example and
like this
we can put it inside the parenthesis
and we know that
uh a letter is internal
if
all the
all these three the left neighbor
this letter and the next uh letter all
well if this the left character the
middle the current character and the
right character all are um
are none spaces
so and we can
combine
this
uh not equal with
a vertical and reduction
the only problem we have now is that
and since we added a character we have
one character too many and that we used
this
to
to push things
to the right and when we didn't drop
enough
then
one character from the end got pushed
too far we can see this above here
the last character we have is the u
and its left neighbor and his right
neighbor and here is another space
that's been added which we don't
actually want
we can fix this however just by dropping
the last element
another way we could do it um
is by
not adding the space on the left
um
because
that will just give us all the
information for all the characters
except the first one
we know that the first
character
is not one that we that we should
consider a an interior character because
it's right next to the beginning so we
can just add a zero on the left and that
will give us
the same result exactly
now the only thing that remains is
to check if
and
the these the letters are also vowels
so we can do this by simply saying
member of
aeiou the vowels
that gives us this mask and so these two
masks are the ones we're going to
combine if a letter is both interior and
it's a vowel
then
that's a letter that we can remove so
let's combine
the two parts
and this points out which letters we
have to remove but again we want to use
compress so we want to mark instead the
letters that we want to keep we could
negate it but we can also just combine
the negation with and into an end
now we are ready to do the compression
that works very nicely
let's call this one
drop
d for drop
because we're using drop in various
places
we talk about these neighbors and we can
we look at these triplets another way to
do this is by using nys reduce
so let's start over
with our text and uppercasing it
we can and we can look at triplets
initially we can try just concatenating
them together
so these are the triplets
but instead of applying and
this invoice reduce on the letters
themselves let's com
let's do it on the boolean mask of
whether there are none spaces
and now we just need to reduce each one
of these with an end reduction just like
we did before
we don't need to do this outside of the
nys reduction because analyze reduction
is indeed an introduction on each
sliding window of the size three in our
case
and that gives us
the mask for which letters are
interior
letters
which means
we can just combine all of this with
um our way of finding the um
the vowels in exactly the same way
oops
oh yeah of course
since we have sliding windows that don't
uh
that begin at the very left edge and we
have sliding window size three that
means that we don't have a corresponding
element for the very left most and very
rightmost letters but we know that those
are boundary letters and so we can just
supply those
that gives us our mask and we're ready
to do the compression just like we did
before
let's call this one r for reduction and
voice reduction
another way to look at neighborhoods is
using stencil
so let's try this again
uppercasing that
and this time we're going to use
stencil
and
stencil with a window size of three and
applies its operand
on each sliding window
at the edges
if necessary it pads and it is necessary
in our case we want window sizes of
three and every element gets a chance to
be the center of a neighborhood of size
three
stencil with pad with appropriate
padding which for text is spaces and
that's great that's exactly
what we want
what operand are we going to give to
to stencil we're not interesting in the
left argument to the operand which is
the padding information
we just want the right argument
and we again we want to know where it is
all true
that
the letters are different
from space
that gives us our mask including the
zeros so this is exactly what we had
before with the end wise reduction and
we can just copy the rest of our code in
this is our stencil s
function
now it will be interesting to compare
the uh performance of these wouldn't it
let's do that um but for our test case
is tiny we also need to generate some
larger test data so
now i'm going to copy in the cmpx
utility which measures performance and
also
for convenience i'll have the delete
extraneous blanks in order to generate
our test data copy those from the decent
workspace
okay for our test data and let's have
some uppercase characters and some
lowercase characters
and then we need to have some some
spaces as well and in a nice proportion
i'd say if we take about 60
and overtake then we get and a bunch of
spaces at the at the end
then then let's choose some random ones
from this
so random and we'll take
a thousand of those
from all of them the length of that
so this gives us a
a bunch of
letters if we just take the first
hundred of those to have a look at what
they could look like we can see here at
the end we have some
some double spaces so that's why we need
uh to apply delete
external blanks
and then that won't happen
no more double blinks
okay then we're ready to assign this
it's not even though i asked for a
thousand it's of course not exactly
going to be a thousand because we're
deleting some spaces here and there but
it's close enough
for purposes
and let's generate some apl expressions
that we're going to compare the
performance of
and we had c for the cut
method and d for the drop we had r for
reduce and s for stencil each one of
those is going to become
called on the entirety of
this
test data here so these are our three
api expressions
and now we're running the timings on
those
see what that looks like
all right
well
that's pretty significant differences
we've got there
and the cut method which is our baseline
is not very good compared to uh
to using drop and
reduce
that's because uh draven uses are
entirely flat
uh solutions
whereas uh when we cut into individual
words then we get a pointer array and
one pointer pro word and that's going to
be very expensive to traverse
so that one's basically out there's
nothing we can do to fix that stencil
that doesn't look good at all
and the reason is that we gave a rather
complex
operand to stencil and there are just a
few
common patterns
that when addressed when expressed as
defense
have been optimized
very heavily and they will give us way
better performance
so
let's see if we can
use one of those instead
so i know that
one thing we can do with stencil that's
super fast is just getting uh getting
the right argument
now since we have neighborhoods of three
and from a vector that means every
such neighborhood is a vector in itself
and stencil will collect them into an
array where the major cells are
these vectors so an array that consists
of vectors is a matrix we'll get one
neighborhood per row
and all we need to do now um
is the exact same thing here we're just
comparing two
spaces and then
we are reducing across
the rows
so all this
should just work in exactly the same way
and let's try it on our small test case
oops yeah i made a mistake here
i am
missing a space
nope not necessarily i made i haven't
parenthesis that could be missing or we
can just remove this parenthesis over
here that's why it was read before
okay let's try it again there we go now
it works
right
so and
let's do this comparison again with the
new updated stencil version
but this time we're going to skip the
one that that cuts using petition
because that's hopeless
stencil is still the slowest of the
string
but
uh it's not bad right they're all very
similar to each other and if something
is convenient to express using stencil
then by all means it can work very
nicely
and then you don't have to worry about
how much padding you need for various
sizes which you didn't need to worry
about for the anyways reduce
but there's another problem
and that is let's update our uh our
small test case
with some punctuation the problem here
is with the final letter
since we are detecting whether the
characters that are non-spaces then
question mark is a non-space and u will
be considered an internal
letter so for example using this s
we can see that
o and u
get removed which is of course wrong
so
how can we fix this
well here are our definitions
the problem is that we are using
the property of being a non-space
to identify which
characters are eligible to be uh
be removed and
which ones are have
non-space neighbors
i really want to turn it upside down we
want in order for a character to be
considered an interior letter
it's it's
the determining factor there is that its
neighbors
are also letters not just non-space
characters but letters so we just need
to turn things around a little bit
for the dropping method
the only thing that we need to do
is to check
if
and
characters are
in the set of uppercase letters and
membership goes the other way around so
we can swap that
and if
they are letters
all of them
then
and
we have an interior letter
and actually
the exact same thing applies
to all of these solutions
so here
with
an invoice reduce
instead of checking whether we have
taken whether we have none letters we
just look whether or not they are
members in
uppercase
alphabet
and so too
with stencil
instead of checking whether or not
and we have none letters we just check
whether or not they are members of
topics alphabet
and now we can generate new test data
so this time we're going to have
uppercase letters and lowercase letters
and also
some punctuation
let's say 65 overtaking that to get some
some spaces there and then we just use
the same formula as
before we want
random
about a thousand
of
the length of the argument
and this time we don't need to remove
extra blanks
right
the comparison we're going to do is
exactly the same as before
and the performance is very similar to
what we had before but this time
we are correctly handling all of these
so we can see it
for example
with the dropping
on t
and
reduce on t
and stencil
and t you can see that the u
remains right there
so these are good solutions aple
solutions there's another approach
though and sometimes it's more
convenient
and that is to use regular expressions
and
we found
two
interesting ways of doing this using
regular expressions
what we can do is we can we want to look
for
some characters and then we want to
remove them and we want to do so case
insensitively
the letters
that we want to remove are the vowels
but we don't want to remove all the
vowels
we want to make some assertions about
these vowels
what we want to assert is
that
this question whether on the left
we have
a word character
if there's not a word character on the
left
then
we're not interested in this vowel that
also means is the first character in
this
in the input then we're not interested
in it we also want to to make sure that
on the right we have a word character
if it's the last character in the whole
input then there are no characters to
the right
and we're also not interested
it's important to note that these look
arounds or look behind look
ahead
are not part of what's being matched
they're just something that's being
checked when we try to match them
so that works as intended
it can be hard to think about these uh
assertions
i personally find it easier to think
about
things in a different way and that's
with what you could call exception
patterns to detect things
and let them go through so again
we
we do want all the vowels
and we want them removed but we want to
preserve some
which ones are that we want to preserve
we want to preserve any any letter that
is preceded by a word boundary so that
means it's on the left edge of a word
or
at the right edge of a word
so those will replace with themselves
and any vowel that remains after that
that hasn't been consumed by the first
pattern we're going to replace with
nothing
so let's call
this one b for word boundaries
and the one we had before we'll call it
a
for
look around
and then we can compare the performance
of these so now we have a
drop we have reduce we have stencil and
then we have look arounds and
word boundaries
each one we're going to run on the
entire expression of
an entire argument of t3
and we'll we can oh we didn't get the
exact same result uh why is that
this is
look ahead
oh well that's interesting
this works
well let's do some debugging and see
what uh what's happening here
we can start with some of our
string so if you take a hundred
from t3
and then
we can oh so we can even do it like this
we can say is d
matching a for a hundred of t3 nope is
it so for 50 of t3
how about for 20
yes
25 no okay so now we can look at 25 take
t3 and see what is it that's uh
oh this is at the very first space
at the very first space so
d removes the internal vowels like
this o for example
and a
we removed one
more thing than d where they different
oh did i simply forget a
an i oh d didn't remove the i
that's interesting
this eye doesn't get removed
but we clearly have an eye here
removes it
uppercase i gets removed
so what's going on here why is d not
removing this
oh i see
it's because i've did i put in digits by
mistake in our test test data
that's what it is
so
oh yes i'd put in a one over here that
should have been an exclamation point
so much for that there was some
troubleshooting right there
let's try the performance again but it
shouldn't really make a big big
difference in the results that we get
there we go now we can see it finally uh
so
the performance using regular
expressions is not good compared to the
api solutions and with multiple patterns
it's even worse than with a single
pattern with with look around but hey
sometimes
regex is the way to go especially if the
smaller amount of data or it's something
that's very complex to express or it's
something you just need a one-off and
not running
times then it could be quite fine
but
we should definitely prefer an array
oriented solution if at all possible
thank you so much for watchinghi
we're going to do a very simple test of
validity of some XML it's not a full
test at all we're just checking whether
the angle brackets
are matched
here's some test data that we can work
on the first one is valid and the second
one is not valid and that's because when
it says 2 is less than 3 it uses an
angle bracket there which messes up the
balancing of the angle brackets
there are three rules really that we
need to keep here
one is that every opening angular
bracket has a closing angle bracket that
is every less than sign is has a
corresponding
um greater than sign
another rule is that they cannot be
nested
and and
well finally
the meaning we can't have less than less
than and then greater than greater than
and then well you could say it's not
really an extra rule we have to finish
up with everything closed it can't be
shifted around
okay let's get started
we're going to Define this entirely
tacitly from the beginning
so let's apply this function to each one
of the test cases
and what we're going to do is note that
the only thing that matters for our
problem are these angle brackets we
don't care about any of the other
characters
so we can start by filtering so we only
have these angle brackets and none of
the other characters
and one way we can do that is by doing
an intersection
so we're treating the arguments as sets
and we're going intersection between
that and the angle brackets
so now we can see we've isolated out
only the angle brackets that makes it
much easier to work
the strategy we're going for here then
is to identify where we have such pairs
because the entire argument now must be
made out of entire pairs of open close
open close open close when we get here
we get open open and that's wrong
foreign
so one way we can do this
is by searching for angle brackets so
we're now going to change the
intersection function into a compound
function a fork
where we're going to find so this finds
the locations of what of the right
argument so this function here has a
very interesting structure
it is
bound with a right argument which are
these angle brackets which means that
when we apply it to some text it become
that text becomes the left argument and
then it's called a fork because it kind
of branches out and applies the two
outer functions to the arguments and
then the middle function
to the results of those two outer
functions so this is the intersection of
the left argument which is going to be
the text and the angle brackets which
have been bound on the right
this is the right side identity function
it ignores the left argument and Returns
the right argument so we again get the
angle brackets and this returns a
Boolean mask
same length as our argument with a one
every time what we're looking for starts
including overlapping matches but that's
irrelevant in our case
so here we have the Boolean mask and we
can see that we have open close open
close open close and so on down here we
have open close open close and then we
have one character that doesn't belong
there and then we continue with open
close
what we can do now is check
that the entire mask that we got out
consists of uninterrupted one zero one
zero one zero and so on
until the end and it has to also end
with
one zero
if the final character
is not or Define the characters are not
open close then we wouldn't get a one
zero at the end
if the final character isn't open we
won't get a one at the end because we're
not finding the entire open close and
then the find function will not say we
get a partial match
so we don't need to check for any of
those
and extra rules we could say whether
they're they actually match the knot
whether we're closing at the end we have
all boiled it down to this subset of the
input consisting of
open closes which are then mapped to
ones zeros
so we can apply another
tested function to that where we take
the argument length
and use it to reshape
1 0 as a constant so this operator takes
the one zero and makes it into a
constant function it's again the same
structure with the fork as we had before
but this time only with one argument so
we apply this constant function to this
mass that we got out
that gives us one zero we apply the
tally function so it looks like a
Telemark which gives us the length of
the mask that we got out and then we use
reshape which is a Greek row R for
reshape to reshape the result of the
constant function which is one zero into
the full shape cyclically so one zero
one zero one zero until we get the full
length
and then the only thing we need to do is
to check whether this mask matches
this mask that is whether this mask
matches
this mask as well
and we are given the mask as argument
here we indeed we used it to get the
Telly the length and we have this right
density function that we can apply so
this also corresponds to the mask we
asking whether it matches exactly
element for element the master we've
generated here
we can see the first one is good and the
second one
is not
and that's actually our whole solution
we can assign it like this
and apply it to each one of the elements
of t
thank you for watchinghey
our Quest today is to compare two given
character vectors or scalars
that is the economic strings and see if
they're anagrams of each other with the
definition here of an anagram being that
they have the exact same letters we only
have to care about one letter case at a
time
and that we ignore spaces all together
we don't have to worry about case
differences we don't have to worry about
other types of punctuation
okay let's get started
I have prepared a couple of left
arguments
and a couple of red arguments that we
can use
we are going to start by pairing them up
correctly so we got the left arguments
on the left and the right arguments on
the right
now we have an anonymous Lambda or divin
and we're going to pair up each
element from the left argument with the
right argument
the name of the left argument inside
this divin is Alpha and the red argument
is Omega left and right most letters of
the Greek alphabet
and we get pairs
obviously they're not ready to be
compared yet we need a couple of
pre-processing steps
so
the over operator preprocesses both
arguments before the main function is
being applied
the first step to pre-process is to
remove spaces we do that with the
without or set difference function
now what we're removing is constant so
let's bind this function with a constant
space so this becomes a derived function
a new function which is the without
spaces function
next step is to make sure that the
ordering is the same and an easy way to
do that is sorting
we use a little helper function where we
take the argument
and find the elements in the positions
of the grade of the argument
now the grade is exactly this the
indices that would put this array into a
sort order if we use those indices to
index and that's exactly what we do
now we can compare the two
and find out which ones are anagrams
we can simplify this a little bit by
observing that we have a Lambda or a
different here with a single primitive
inside that just takes the arguments
that's entirely unnecessary to wrap it
like this and instead we can just apply
the Primitive as it is
this looks good
let's give it a name
and now we can compare
left arguments each
now in the right arguments
and that gives us our result
thank you for watchingwelcome to the EPL Quest see APL Wiki
for details
today's Quest the fourth from the 2016
round of the EPL problem solving
competition asks us to take two vectors
and mesh them together
now that's really simple if they have
the same length but if they don't then
there's a little bit more work
okay a test case would be for example
these two character vectors
since they don't have the same length
then the trailing part of the one on the
left log will have to just be as it is
at the very end
so what we want to have is D and then a
from over here and then Y and then the P
from over here
Locus a from the left
of L from the right and then L from the
left o from the left G from the left
let's do that with a little Lambda a
different in between them
and what we can do is we can start by
just simply concatenating them together
now we have all the elements that we
want but we need to reorder them into
the correct order
so we want from the left from the right
from the left from the right and so on
now here's the thing and
if we have such a
um such a list we can sort it
in API the normal way to sort things is
by using
grade
so
here we're grading the same thing and
this gives us to it gives it to us in
escapedical order of course this is not
what we want but what I want to
illustrate
is the use of grade what does grade
actually do
Let's uh
let's try it like this
rain gives us the indices that we will
need to use in order to reorder into
sort order
so here in order to reorder this
um sorry in order to reorder this into
short order we first want element number
two that's a one then element number
four the other one
then the three which is in position one
then
the third element number the four The
Fifth Element which is five
and so if we do this
we get it sorted
but we don't have to sort by the data
itself we could sort by something else
so this is saying whatever would be
necessary to sort this vector
is used to reorder the letters in hello
so we have that result over here so you
want the second element that's the E the
fourth element that's an L the first
element that's the H and that's what we
have down here
if we can construct something that will
sort
in in such a way that it puts the first
element from the left and the first
element from the right and the second
element from the second element from the
right then we can use that to reorder
the concatenation into the order that we
want
well
if we start with a one from the left
and then and on the right a one on the
right
and then a 2 on the left and a two on
the right and we concatenate these
together three on the left and three on
the right
then if we ask how would we sort them
then we say we need the first element
from and then the fourth element that's
the one over here
and then the second amendment that's
this one and The Fifth Element that's
the one from over here so if you think
about these corresponding to the left
argument and the right argument
then this would actually put them into
red order and this works even if we have
trailing elements because first we'll do
pairwise the one from the left one from
the right one two from the left two from
the right three from the left three from
the right and then just the sole for
five or six whichever side those would
come from
this is the result that we want
so how can we generate this
this vector or these two vectors
together well these are just all the
indices in the left argument and the
right argument concatenated together
so if we go back back up here
and we
find out how many elements are there in
the left and how many elements are there
on the right Alpha is the leftmost
letter of the Greek alphabet should
mentioned Omega the right most so they
refer to the left and right arguments
six and three
now we can use Iota Iota is like an i i
for index generator to generate the
indices from 1 through this length
oops
those are the exactly the ones we need
now we can concatenate them together
and that's
the vector that we need to grade
in order to
sort
the concatenation
and this solves the problem
but we can actually clean this up a bit
notice the duplication of code
we are concatenating together the
indices of the tally of the left
argument and the indices of the tally of
the right argument
which means we're actually concatenating
together the left and right argument
just like before but just before we
concatenate them we pre-process both
arguments by converting them into their
enumerations
and we can write that
as
um the left concatenated with the right
with a special combinator called over
which takes a function on the right in
this case this function is
um
a juxtaposition of index generation and
tally which just we also call that in
the top so we're applying the tele and
then after what you're applying the
index generation on that
and that works the same
next up
we can instead of using the the indexing
syntax with the square brackets we can
use a functional form you see a moment
why that's a good idea
so there's a function which very much
looks like these two brackets put
together
or we can leave this parenthesis for now
so it's this squad
and it takes the indices on the left
except we need to enclose it for some
technical reasons but this works exactly
the same as the above
of course because of apl's long write
scope every function takes everything as
far as it can see until we close off
with some bracket or the end of the
um of the statement we don't need
parenthesis on the right
and now we can switch to a uh to a fully
tested mode tested 0.3 is a type of
programming where we don't mention the
arguments
and it can work really elegantly in APL
when we have three functions
that
where
two of them are being applied to the
arguments and the other two and and the
and one of them
is applied between the results we call
that a fork
let's pause for a moment and see how
that works let's say we have 10 on one
side and three on the other side and
three functions in the middle
the middle function is concatenation the
left function is plus and the right
function is minus so then the outer
functions are applied to the arguments
and
the middle function is applied between
the results so this is the concatenation
of addition and subtraction
and we can use any functions for this in
our case what corresponds to the
concatenation is in fact an indexing and
what corresponds to the plus is the
enclosure of the grade of the
concatenation of the indices of the
of the tally
and on the right the minus is the
concatenation over here
so we can substitute things into this
pattern
um
we can take this
over here and make it into a little
function instead put braces around that
oops
and then we can change the comma into
the indexing function and change the
minus into a comma we just need to put
our arguments back
we can go one more step by using and
actually a couple more steps by using
some combinators because this is a
single function and we Sorry up to here
and we want to apply the grade
on top of that on the result of that and
we want to apply the enclosed to the
result of that
and we can actually specify that using
the circle a little a little circle
there is this or chapter assist this
just means this function over here
um
well followed by this function
technically speaking it's actually this
function applied to the result of this
function
where the arguments are pre-processed by
this function of a
and the same thing we want and
this year the enclosed applied atop the
result of the grade so this is enclosed
of the grade of the concatenation of the
indices of the tallies of the two
argument and now we don't have to
mention the arguments anymore because
this is a single derived function a new
function that's being made by combining
old functions
and there's a final step we can do and
that's mostly just for the fun of it
is break up this compound function
we are pre-processing both arguments
with the indices of the tally
that would really be the same thing as
previously in both arguments first with
Tally
and then pre-processing them again with
the index generation so we can spell
that out
using this over we call it so this is
the enclosed of the grade of the
concatenation of the indices of the
tallies
of the arguments
in the indexes the concatenation
thank you for watchingwelcome to the APL Quest see APL Wiki
for details
today's Quest is the 9th from the 2016
round of the APL problem solving
competition
we are taking a text in and we're going
to split it
but there's a catch
we're splitting and are not just one
delimiter but on any of a set of
delimiters
let's start
by having a sample text
right so what's going on here is we have
two different types of delimiters we
have both comma and semicolon and we
also have consecutive delimiters which
we must respect so we have to have an
empty segment coming out here
that means as left argument we're going
to have a comma and semicolon
and so these are our two arguments and
APL has these uh infix functions
user defined functions this is a Lambda
type function known as a definite and in
here the left argument is denoted Alpha
as the leftmost letter in the Greek
alphabet
and the rightmost letter is an Omega and
that denotes the right argument so we
can see this just puts them next to each
other
and what we want to want to do here is
first identify where we have delimiters
in our text
so we can use membership for that and
that vectorizes so we're looking at
every element of the right argument to
see if it's equal to any element of the
left argument
that gives us a Boolean mask
and this Boolean mask
indicates where we're going to start our
segments and we can see the two ones
here after five characters corresponds
to the two commas over here
however there's a problem
and we we could start splitting here
um so
if we use this partition function
then using this mask as left argument
and using the text as write argument
then we lose
the hello
because it begins a petition
every time there is a one
we need to
um
we need to start off with a position
right from the beginning so we need to
insert
a delimiter at the very beginning of our
text first
before we do that I just want to go my
uh Crusade against parenthesis I really
don't like using parenthesis for
ordering execution
and the problem here is that apl's
functions are all uh and they all have
long write scope so everything towards
the right of a function
um is the right argument and what's
immediately to the left is the left
argument and so because we have a
complex left argument that's the whole
expression to this partitioning function
then we need to parenthesize it if only
we had a function that was exactly like
partition but with swapped arguments
then we wouldn't have this problem
because the right argument is not a
complex expression and it's just a
single array value and we don't have
that kind of function but we do have a a
modifier or a magnetic operator we call
it in APL terms which goes in the media
rate of a function
and then modifies that function
to
have swapped arguments so now I can take
the Omega on the left
and the Omega member of alpha on the
right and we get the same effect as
before
okay so far so good but we still have
this problem that we need a delimiter at
the front so there really there should
be
an extra deliver to any one of them of
course would do and that will solve our
problem
so how can we do that well we can
substitute
um the Omega for a variable that we
create
so let's create it first and we use
Diamond to separate statements in APL
because diamonds are Unbreakable
so this should be the normal Omega but
we want to prepend
a
um a delimiter so we can use the first
function that's this one
um applied on Alpha that gives us just
one of them of course any one of them
would be good but there's always a first
one and if we concatenate then that's
going to put it at the end but if you
swap the arguments then we put it on the
front
so this gives us all the say oh we need
to go and remove this comma here that I
inserted this gives us all the segments
that we want but they all have the
delimiter included so we need to drop
one so from each so this is the again a
modifier which is like a map that
modifies the drop function which
otherwise would just drop one element
um so this drops one element from each
and that shows our problem
however we can write this a little more
in a little bit more compact way
we can combine these two statements and
if we had T at the very end of this
expression then we could just do a
random expression because this
has t
um as the final result and we can do
that because by swapping the membership
here this is T member of alpha so we can
say
the membership swapped with t on the
right so this will still give the same
result but now that we have an
expression over here that has t on the
far right and we have expression here
that has t on the far left then we can
just move it over
um to here we still need the assignment
because we're going to use T later
but this allows us to write this as a
single expression like this
we could also give it of course a name
and then we can write
like this
or we could choose to split on vowels
thank you for watchingwelcome to the EPL Quest
see APL Wiki for details
today's Quest is the 10th and last of
the 2016 round in the EPL problem
solving competition
we are given the bunch of prices and
we're also given how many of each item
that were bought and we are supposed to
calculate the total
amount
that's this purchase sums up to
so here we have the number of items that
were bought and over here we have the
prices for each one
and this is mathematically really really
simple and we can multiply and APL will
automatically vectorize so
5 gets multiplied by 299 0 gets
multiplied by 499 and 2 gets multiplied
by 199.
these are the total prices per item
type per type of item and then we can
sum
sum is a plus reduction so we write a
plus and then the slash means insert so
there's a the Plus in between the
elements and that gives us our total
amount
so the problem can be solved this easily
but
um we could also try to make a single
function out of this that solves the
problem so for that we're going to use
braces like this that makes an anonymous
Lambda we could give it a name but we
can also just use it inline like this
and in this the left argument is
represented with an alpha and the right
argument is represented with an Omega
the left and right most elements of the
Greek alphabet
in here we can then multiply together
and that gives us exactly the same thing
this is basically a cover function for
the multiplication and then we can add
the summation as well and that gives us
and the solution
but a neat thing you can do is called
tested programming or points free
programming where you don't mention the
arguments explicitly so here we have
left and right arguments mentioned by
name
and we actually able to combine these
without mentioning the arguments
changing these braces into parenthesis
this makes a single function tested
function which we call an a top or a
true train there are two functions here
the summation and multiplication and
when you stick them next to each other
like this in isolation there are tied
together by the parenthesis here
then
the right side function
is given the arguments of the overall
function
and its result is then fed on to the
left side function
so this also works
this is called the two train or
a top a train because it's a sequence of
functions after each other train the
functions like a train of thought
but we can also be explicit about this
at top
we have an operator which is a higher
order function and it's infix it takes
the sum on the left and takes the
multiplication on the right
and
it combines them error com in a way that
the right function is applied first with
the arguments to the overall derived
function
and then the result is fed on to as a
post processor the left function which
is applied just one argument so this
also works but because we don't have a
train anymore we don't need to show that
these two carriages belong together
instead it's the higher order function
the operator that is binding them
together then we don't need parenthesis
here and all and this would still work
however there is another higher order
function or operator in APL which is
called Dot
which does the dot product and this is
exactly equivalent to doing a DOT
product on two vectors
so this will also work
and then you might ask well what's the
benefit of using this why can we not use
some over the multiplication well there
are a couple of reasons for that one of
them is Technical and one of them is
practical
technical reason is that an interpreter
instantly recognizes this combination
the um
and it has optimized code to do this so
instead of doing two Loops the
multiplication first and then the
summation then it confuse the loops and
make it run faster
however there's also practical reason
something we couldn't do is let's say we
um
instead of these amounts here we have
two sets of purchases so the prices are
the same in the store but customer one
buys five of these and two of these and
customer two
buys 50 of the first and
20 of the last so that should give us 10
times the price now we reshaped this to
um
two rows and three columns this is a
Greek Row for reshape and this will give
us
a matrix so we can see here we have a
matrix of
um two rows and three columns and this
it's like a database with records per
purchase so in this purchase or this
customer
um
but these amounts and this purchase a
customer report these amounts
and now if we
um if you then combine this we need a
parenthesis here so that we don't
um
end up multiplying directly by this
Sixth Element Vector which would be a
length error and now we can multiply
like this and we can see that we got one
sum per record in the database and if we
had only tried to multiply them directly
that would not work we cannot multiply a
two by three Matrix with a three element
vector and then sum it up afterwards
so that's why you really want to use the
dot operator or also known as inner
product whenever possible
thank you for watchinghey
what is the percentage of characters in
a given
character Vector that are either the
uppercase letter C or a place uppercase
letter
G we're about to find out
so let's say we have a DNA string here
we apply a function to it and the first
thing we want to know is which letters
are C and G we do that with a membership
where one argument is pre-filled we bind
an argument to it to look which is our
lookup array C and G and that gives us a
Boolean one bit for each character
which means we could sum this
and then we could divide it by length
and multiply it by 100
but
notice here that we are
and we are both dividing and summing so
we can actually combine these to an
inner products we could write
plus dot divide so it's actually these
bits divided by the length and then sum
all of that up
and this gives us a fraction which we
can then multiply by a hundred giving 37
and a half percent uh C's and
G's this isn't especially uh efficient
because we're going to be dividing these
booleans we really should be summing
them first so there are other ways that
and we can do this well that's slightly
less elegant and we could have sum this
first and then divide it by the length
we can also of course
multiply the length by a hundred first
and then
we can multiply the sum by 100 first
here and then divide and again we can
now
do the
plus the times for an inner product
and because of this parentheses here and
with a single thing on the right if we
want we can move division over on the
left
um and
commute its arguments and just another
solution in many ways to phrase this
these are just a few
thank you for watchingwelcome to the apl quest c apl wiki for
details
today we're going to compute the
fibonacci sequence note that we're
computing the first first n
elements of the sequence and not the nth
element which is a more usual task
so the fibonacci sequence is usually
defined as being recursive
the way it's defined is that we start
off with some seed values and then we
compute the next value by summing the
last two values in the sequence
we can express this
as with a stopping condition so if we
start off the sequence with zero and one
for the fibonacci sequence and and that
in that case we
say that for the
zero for the first
um
zero elements we just we don't need
anything at all
and we could just return zero
um
and for the
element number one uh which we want a
one
and when we sum them together we get the
zero and the one and that gives us a 1
and then 1 and 1 gives 2 and so on
so
if
the argument is less than or equal to 1
that means it's 0 1 and then we can
return the element itself otherwise we
want the sum of the function itself
applied to
each one of the argument minus 1 and 2.
so we can try this on
on one
two
three
and so on
but we don't want the nth element we
want
all the elements up to end so we can
apply this on each
of in
of the numbers here
and while this works
it is exceedingly inefficient not only
do we
compute the same sequence over and over
again for n minus 1 and n minus 2.
for every element of the sequence we're
also doing this whole thing over and
over again and this
becomes ridiculously slow
very quickly
so that's not a good
way to do it but it very clearly
expresses what the sequence is about
instead we're going to
focus on computing the entire sequence
at once
and the way we're going to do that is by
using a fundament what i call a
fundamental
fibonacci transformation function let's
call that delta
the fundamental function is that we are
extending the
currency generated sequence with one
more element by summing the last two
elements of the current sequence so the
current sequence
concatenated to the sum of the last two
elements taken from
the current sequence
and so if we start by applying this to
we can do it to a 1 because taking the
last two elements will give you a zero
and a one
and then
we can
apply it over and over again
so
how can we actually use this and how can
we define things in terms of
this function well now we can
write a
recursive function
where
we are looking at the element
at the argument
if it's less than or equal to one then
we know exactly what the sequence is
going to be if it's zero it's going to
be the empty numeric vector if it's one
it's going to be a vector
one and so we can transform a one into a
vector one and zero into a zero element
vector simply by letting the argument
reshape itself
and then and
and we
want to extend the sequence otherwise
and what sequence are we going to extend
we're going to extend the sequence that
we got for
uh
one less than the current number we're
at
and then we just need to extend it
so let's call this a recursive version
and this works but it has one problem
and that
approaches the field of tell call
optimization telecoil optimization is a
method where
we do not need to keep track of
the caller when we are recursing
[Music]
by not having to build up a stack
because the final result value is not
going to be
post-processed in any way
and the problem that we have up here is
that after we're recursing we're taking
the result value and modifying it
essentially we're building up a um
a sequence on the stack which is just
waiting for a value that can be extended
more and more
and we really should try to avoid that
both for
efficiency and not to run out of stack
space either
um
so if if the interpreter and this one is
is still called optimized then it will
detect that we're not using the result
just returning it
um and then it will not build up a new
stack frame we'll just replace the old
stack frame with a new one
um and for that we're going to
we want to know when to stop rather than
just
returning a value which is then used and
the way we know how to stop is when
we've generated enough of the sequence
meaning when the generator sequence is
long enough
so we'll feed every iteration of this
function
the stop condition in the form of a
length
how long we need to
to make it
and that's going to be
a left argument and that left argument
then is is given in the initial call so
our argument is 10 means we want to keep
going until we've got 10. of course we
can't make a function that just takes a
left argument so we'll use as argument
the seed value and that we're going this
the beginning sequence we're going to
start with
so if the cutoff point
is
uh
less than or equal to the length of the
currently generated sequence then we
either done or beyond done
and so we would in principle just return
the sequence but the problem is it might
have been too long and it only really
happens if
the argument is zero and we begin with a
seed value of of a one
then we need to chop it down just like
we did before
so we can do
a take which just caps
the sequence to the correct length
and now
since we know we're not done yet then
it's safe to just extend the sequence
and then we need to check again that
means we need to recurse
and the limit
for
for the sequence length is still going
to be the same so we feed that along to
the next iteration and here we can see
that the last call
is go is the recursive call
with the left argument but the result
isn't being used
a for further computation therefore this
is still called optimized
then we just need to start off with the
seed which is a one it doesn't matter
it's a scalar because we're going to do
the take on it so it's going to become a
vector anyway and we're going to extend
it in all other cases
so this is a
telco optimized version
there we go
and another way we could
see this use of the fundamental function
is by applying multiple times
and we can express this
using the power operator
so if we
use the power operator
with a number
on
some seed then we're going to extend it
problem is we're just generating a
little bit too much
but we can
use take again to chop it down
we don't want to start with 0 1 either
because then we get a 0 at the beginning
so we can express this
just by using argument over here
so this is using
the power operator
and
with two beginning values so we're
appending to the first two
oops
there we go
it's a bit
it feels a bit
silly to
make the sequence longer than it needs
to be and we only do that because we're
starting off with the seed value of 1 1.
problem is
if you want to start with an empty
sequence and append to that
then
when we try to try to take the last two
elements will be of an empty vector
we'll be padding with zeros and that's
going to be
zero
zero zero sum together zero and we add a
zero and the sequence will stay zero
forever so how can we ensure that we
always get at least one
well we can do that by a clamping
to be above one or doing a max with a
one
so um if we start with empty sequence
and then we apply the basic
transformation function on that
n
times we
max will a one
we need to bind these together so
essentially here what's happening is the
power operator is applying max over and
over again always with the constant one
as left argument but right before it
applies it in the next the next time it
pre-processes the right argument with
the fundamental extension function which
just then adds one more element to the
sequence
and that does the job so this is
appending to the first zero elements
oops
same mistake there we go
so that's another way to do it another
way we can
iterate is using reduction
and
there's a bit of a trick here going on
if we look at
at our definition of delta it's a
different and it it doesn't have an
alpha in there so it doesn't use the
left argument doesn't mean we can't give
it a left argument that works perfectly
fine
therefore we can start off with
our
with the sequence
and then we can apply
with some random value here
it doesn't actually matter
and this
is a reduction we have a sequence 42 42
1 in this case but the all these values
except for the last one don't matter
because only the right and right side is
going to be used as our seat value
and then we're just inserting
this delta in between them so we just
need to generate a sequence that
um
ends with a1 it doesn't matter what it
is we might as well just use
um all ones for that
and then we can reduce using delta
and that gives us this notice that it's
in enclosed because reduction has to
reduce the rank from uh one vector to
zero scalar so it encloses that but we
can just
disclose that and come back
so
this is a very short way and of defining
it and using a reduction
there is one problem however and that is
if you try to run this on zero so zero
ratio one that's an empty vector and
then we're trying to reduce over m to
vector right that requires that the
operand
has a known identity element
and we don't have that because it's a
user defined function and in fact there
isn't
one anyway
um
so we can't do that we have to extend
the sequence by one and then remove one
element again and it will be a little
bit ugly to do that but it can be done
so instead of using omega to reshape the
one
let's use one plus
or a one max and omega
that just means that if you have zero it
becomes one all the other numbers stay
the same and then finally we'll have too
many elements just in that case of zero
but we can fix that as we've done uh
before
by just taking the first n element so in
most cases it's not it's going to be a
no up but just for zero it's going to
chop the one down to a
zero
and now that works
and it works still for larger numbers as
well
okay that's it for using this
fundamental and fibonacci extension
function but there are other ways to
compute it
and and one is
by using a pairwise sum
so a pairwise sum is is we can see how
it's related to what we're doing because
we want to add the last two elements in
order to build up the next and
next element
but we want to extend the sequence not
shorten it down and a pair wise some
that's an otherwise reduce with with n
being two
it always removes
reduces the length of the argument by
one because it's taking two adjacent
elements and combining them into one
so we need to extend we need to pad with
an additional
numbers
so that means we could uh if we have a
pairwise sum
um of
zero and one that gives us the next
element but we need to have and
more elements
added up
so if we
if we add more and then we can use this
again
um
so if we if we add more elements so we
need to to extend with one element every
time around the loop and we and pairwise
reduction removes one so we need to add
two
so if we do this
oh no no this isn't working
um oh yeah of course the the problem is
that we need to have more we need to
have more ones here
uh
we need to make sure that the minimum
value is a and is a one
so we can do the same trick as we did
before with
with the maxwell one so let's try that
here so now now we don't actually need
any any start values
anymore
and we can apply this
again
and we can see how the sequence is
building up
so we just need and we just need this
transformation here to be applied and
over and over again
so we take
the argue the sequence as far as we've
built it up so far
and
put two more zeros on the left
pairwise reduction make sure that we
start off generating and generating ones
and we do that n times
beginning with an empty sequence
so this is a pairwise sum
another way to compute
the fibonacci sequence is by using a
transformation matrix
and that matrix
is a
tiny little
matrix looks like this
and if we multiply that by itself
and keep doing that
then if we look at the generated
matrices along the way we can spot the
fibonacci sequence in there for example
in the top right corner we're going down
one one two three five eight so on
and so again we have here m all over the
place and we have a matrix
multiplications in and in between them
this means
that we can define a
a vector of
m's
and then we can reduce those
using
the
matrix multiplication to get the tenth
element
however we want all the intermediate
values instead of using reduction we can
use a scan
and then we just need to have
the top right element
of each one
and that gives us uh the fibonacci
sequence
if you try to use it on a 0 it works
fine because we have a
we have
an empty vector with a no with a
reduction
and
with a known so we can try this
plus dot
times reduction over an empty vector of
and of matrices doesn't really matter
what their values are
and
that doesn't work
but a scan
and
scan just gives us the intermediary and
values beginning with the first one
preserved but when there aren't any
there's nothing that needs to be done we
don't need to curse on any value out we
don't want need an identity element
which would have been the identity
matrix um anyway but it would have been
relative to the argument and that hasn't
been defined
but this is using matrix multiplication
um
and we can we can hard code our
vector in our matrix inside here so it's
standalone
okay another way to do it is by
the only information is remember the
only information that we we need to
compute the next value in the sequence
are the last two elements
and so what it means is that
when we're going from the last the
current letter elements to the next last
two elements
then the last elements become the last
element becomes the first element and
the sum of the two becomes the last
element
so
consider here two and three let's say
those are our last
less elements
and
if we do a scan on those
then and
we preserve the first element
and the second element becomes the sum
of the two that's very close to what we
wanted we want to preserve the last
element
and then have the sum
and we can do this simply by reversing
the two
so
and now the three became the first and
the sum of two and three became the last
which means we can
if we do this again we get the next
values
and then we can we can
if we extract every time around the loop
then and one of the elements
the first one for example then we can
build up the sequence we just need to
store them somewhere
so we can define a function where we
have a result
variable
we're not going to use it initially but
we're going to
apply this transformation here
the plus scan on the reverse of the
current pair
and then we want to
take the first element from that and
and
append that to the result variable
and then we want to
return the new
the new pair which is
which is this whole thing
so here's a trick instead of
taking the first element let's leave the
whole thing
the whole
and when we do the concatenation to the
result variable we pre-process the new
value that is being added to the result
with
first
but still this whole function is the
modifying function in this
modified assignment
and the assignment is here and there's a
principle that the assignment always
returns whatever is on the right
so even though we're only actually using
the first value
the result of this whole assignment is
going to be this whole pair and that's
the whole pair that we actually
interested in
so now we can do this and we want to do
it n times
and we just need a starting uh
pair which is zero and one
so the first time uh so if we do this
zero times we have r already set to an
empty vector if we do it one time then
that means we are adding them
up we're getting one one taking the
first value that's one adding to that
then the second time around the loop we
do one one and adding up is two so we
get one two and we get another one and
um
and so on
and once we've done that n times then r
has accumulated all the values that you
want and we we're not interested in the
last pair which would be the result from
um from this application with the power
operator we just want the resulting
value
so that gives us our sequence
using
accumulation
and that's it for and
all the methods we're going to look at
for building up the results slowly we
can actually
compute the entire result
in one go
and there are uh because it's possible
to compute the nth fibonacci number
directly without building it up to it
and there are various ways of doing so
and one way is by using approximations
of the golden ratio
so if we have a bunch of
ones
so
for this series
and then we can reduce
using
um
addition to the reciprocal
that gives
so this gives us an
approximation of the golden ratio if
this value is large enough then we get a
very good value for the golden ratio
but as we get there um all the
intermediary values which we can get
with the scan are
approximations and these approximations
are exactly ratios of two uh adjacent
elements in the fibonacci series
so if they're fractions of the two
adjacent elements that means if you can
get either the numerator or the
denominator then we can get
the sequence
and we can do that with the
least common
divisor with a one
although you can see here we are we're
missing one we want actually the other
number in the pair
and we can just flip the uh the ratio
upside down
taking the inverse or reciprocal of that
and that gives us
the series directly computed
however we're both using a scan using a
custom function here and we're using a
number theoretical function on the
floats it's so the performance is not
going to be great
it is neat looking though
we can also use the sum of the binomial
coefficients to compute the nth
fibonacci number
the way it works is that
we start with the numbers from 1 to
n minus 1.
so
and then
we can give those a name and reverse
them
and then we can pair them up
with themselves in the normal order so
this pairs up 0 and 9 1 and 8 and so on
and
doing the binomial on that
and then we've sum that
and that gives us the nth fibonacci
number and in this way
notice that we have a
scalar function reduction over a scalar
vector application we can combine that
to be an inner product
and we want the same argument on both
sides i goes on both sides
um we only want just want to preprocess
the right argument to this inner product
with reverse so it can be stated like
this as well
and that means we can make this into a
tested function
apply it on 10 to get the 10th fibonacci
number
and we can therefore get and all the
numbers up to 10
by applying on each on the energy just
like we did in the very beginning with
the recursive version
of course this is hugely inefficient
both because of the expensive functions
that we're using
and the binomial and also because we're
recomputing it and
over and over
for every number
but it's kind of fun and short so this
is based on the coefficients
and finally we can use be nice formula
it's rather long and involved but it's
not using any difficult math and it's
all scalar functions and that has the
benefit then that we can just compute
the nth fibonacci number directly on the
whole sequence just by feeding it
the
all the indices that we want
i'm going to type it up um there's
nothing really to explain other than
this is a formula you can look it up
online
it can be stated in in various ways
because of some equivalences but it's
not really important
and so we want that on the entire
sequence and
that computes the sequence directly okay
on to
the finishing stage here which is going
to be performance comparison
let's copy cmpx
from diesen's workspace
and then we need to build up um all the
expressions that we want to run we can
get all the functions that we have
defined
like this but there's actually a feature
that maybe not so well known and that
quadranele can take a list of
uh
of letters
that it will then uh filter its result
with um to only include functions that
begin with any of those
of those letters and notice here that
all our solutions begin with an
uppercase
letter cmpx begins with a locus letter
and delta isn't a normal letter at all
so if you give it uppercase english
alphabet that filters and out
and each one of them well we we want to
apply to some argument or arguments
and
in order to get some balance in it
should it be a large number a small
number so let's apply to all the numbers
up to some limit
so we're applying it to
each one up to say
um iota 20
and we are doing that on each
so these are all the uh expressions
we're going to run
and then
see impacts on that and
this might take a little while
so i might cut this out of the video
and there we go here's our result
and and we can see that using venice
formula to compute the values is the
clear winner here um and even though
there's cute the binomial coefficients
is not going to
be able to compete with anything
thank you for watchingwelcome to the apl quest capl
wiki for details
today's quest is the third from the 2015
round of the apl problem solving
competition
we are to generate the fairy sequence of
order n
fairy sequence
is
the sequence of
fully reduced fractions from
0 to 1
where
these fractions only consist of
enumerators and denominators that are
between 0 and
n
and they have to be given in ascending
order by their value
and so we can see here an example for n
equals five we start off with zero which
is zero holes and a fifth a quarter a
third
not
a half yet because two-fifths comes in
between
a third
and a half
and there are various ways to
generate the sequence we'll have a look
at a few of them
so
let's indeed start with this example of
five
and
one way we can generate
the sequence is by generating all the
possible fractions using the numbers
between
one and five the zero is a little bit
special and then
we can
get rid of the ones that are not what we
want
so one way we can generate all these
all these pairs of numbers that
represent fractions is to think of an
array of the shape five by five
and so all the valid indices in such an
array
are all the different pairings these are
all the combinations of numbers between
one and five and this contains all these
fractions that we are interested in
plus some that and we don't want because
they are invalid so for example um
2 2 and 3 3 represent the same value as
1 1
but they're not fully reduced and some
of them are larger than one like four
halves or
and
five thirds and so on
so
we start off with this we don't need it
to be a matrix so we can start by
reveling that
and then
and we need to
and figure out
what uh quotients they represent so if
we divide
we do division reduction to dividing the
first element by the second element in
each one of
these that gives us our quotients
and now
we
want to find out which elements are the
ones
that are valid and unique we don't need
duplicates so we can see for example
here that one divided by one gives one
and two divided by two
also gives one
and we only want the first occurring one
that's the one that's the most that's
fully reduced as it uses the smallest
numbers
so we can use a unique mask this gives
us exactly what we want we a a boolean
vector with a 1 for the first occurrence
of every value and 0 for all the
duplicates
which we can then use to get the indices
of
the elements that we want to keep
that's one criteria
the other criteria is
that the fraction is represents a number
that is less than or equal to
one
so we can say one is greater than or
equal to this values and that gives us
this boolean mass and then we can find
out
the indices of the elements that we want
and they
so we can see that many of them are okay
to begin with but here we've got
element number six is valid in the sense
that it's not a duplicate
but it's not valid in the sense that
it is less than equal to
one so here third fourth fifth sixth
that would be
two wholes that's two and indeed that is
invalid so what you want are just the
indices that are in both groups that is
the intersection
of the indices
for the mask indicating which ones that
are less than or equal to 1
and the unique mask
so this is the subset
the intersection of
these two
and now
we can use these
indices
to index into our question so let's give
our question the name
and then we use that to index into
the quotients that gives us just the
quotients that we're after and then we
can grade that
this gives us the order that we want to
put the fractions into the fractions we
generated over here
let's give that a name
and then
we want
just
the fractions that are
by by these indices that we generate
over here
and we want them put into
this order
and the only thing we're missing now
is
the zero
so
we can stick that in front and and
have that
and separately either way we do it we
can say
zero one concatenated the only problem
is that we have a nested array on the
right and a simple
two element vector on the left but if we
do this
over
the nest function this function make
sure that the result is nested if
possible
so this is going to enclose the left but
not
the right it's also known as enclose if
simple
and that gives us
this function that's able to run all of
this and we can even do it with zero
and that gives us just the zero as the
problem statement states so let's give
this a name
and this is we'll call this
i
for
we generated all the indices and then
another i because we were using
indices to select subset that we want
we can also create a very slight
variation in this by making an
observation
that the
intersection of indices
between these two masks
that is
the indices
where both of these masks are true so we
both want them to be
that one is greater than or equal to
and
the unique
and we can actually see
the relationship between this set
function
and
the boolean function and they both have
the same
kind of general shape
just like or and
union do
and so instead of finding the indices
first we can find the combined mask
where both of them are true and then we
find the indices that are true for both
of them
and such a slight variation in code can
actually make
quite a difference in performance as we
will see
copying in the cmpx utility for
comparing execution
time
we're going to call it an ii on a
thousand
and i j on a thousand
and then we can see that we got a
tremendous speed up from this very
slight variation where we just prefer to
work on boolean masks instead of working
on
indices and that is in general true for
apl
so we are still
and using indices after we use our
boolean masks we might think that we can
get even better performance
by eliminating the use of indices as
much as possible so over here where
we
get the indices in order to select a
subset of the quotients we could also
just use the mask directly to filter
the quotients
we need
an indexing in order to do the sorting
but now that we don't have i anymore for
in the indices we instead can use the
mask to filter also
the
fractions
and so let's call this i using
masks all together
and then we can compare the performance
of our best
indices type
solution and the one that's using only
masks
but we see that that doesn't really make
a significant difference so it's not
always that eliminating indices and
using masks
or better
um
but for some cases and it's good to do
these performance comparisons
okay
a different approach
let's instead think of about this in a
more number three right equal way
so we are beginning with the indices
from one to five
and then and we'll
do all these combinations the same way
that we generated all the combinations
using iota omega omega
we can do an outer product using the
same argument on left and right
and in here we state our criteria
for
being
chosen
and so what are our criteria well we
want our fractions to be fully
reduced and we want them to represent a
number that's less than or equal
to
one
so fully reduced what does that mean it
means that they are relatively co-prime
um
or relatively prime
that is there is no number
that we can use that we divide the
enumerator and the denominator by to
reduce the fraction further that is to
say that the
greatest common divisor
is just one
so that we don't get any further by
dividing it
so that has to be true
and also it has to be true
and that
one is
uh oh it also has to be true that the
number that is represented by this
fraction is less than or equal to one
and that's only true if uh the
enumerator
is less than or equal to
the denominator so with this outer
product we're having enumerators on the
left and denominators on the right and
so we just need to make sure that they
are the left side is less than or equal
to
the right side
and that gives us this
boolean matrix
and here we can go in and find directly
what the pairs are with where
so these are all the ones where and it
is true
now what's missing is that we need to
sort them so we can sort them in the
same way as before
so we can
do the division over each one of them
and
grade that
and this gives us
the order we want to put these fractions
into
all the fractions are given
here
and so we
sort the fractions by this
and that gives us the proper order
and the only thing that's missing
as before is the one for zero
and we add that in exactly the same way
as before
so um
let's call this one
um
g for we're finding the
greatest common
divisor
and then and there's a trick we can do
here we're having an
out of product
but it's a custom outer product it's not
just using a primitive like uh
times and just less than equal to
and by
unrolling this into
a s into simple
and other products then we can take
advantage of optimizations in the
interpreter so what's actually happening
here is we're combining two things
with an end
we have the outer product with less than
or equal to
and we have the outer product with the
or
and so this is unrolled g into
two outer products
and that can actually make quite a
difference so if we compare
g on a thousand
and g two under a thousand
we can see that
that little change of unrolling the
complex
outer product into simple outer products
gives us
tremendous performance
advantages
okay
here's an entirely different way of
doing it
so far we've been generating all these a
enumerate enumerators and denominators
only then to
reduce with division over them all to
get our
our quotients what if we started by
generating the quotients
so here is an outer product
of
the numbers themselves so this gives us
all the quotients
right away
and then we can rather that into a
simple vector
and now we just need to eliminate all
the invalid ones so what does that mean
that means
anything that is greater than one needs
to be eliminated
we can do that by clamping it to 1. so
we take the minimum of 1 and
all these values so we can see that the
2 now became 1
and 3 become 1 as well 1.5 also became
one so you get a bunch of ones there
then we want to get rid of the
duplicates and we can do that with
unique
so here are all the uh the quotients
that we want but they are not in the
correct order yet
now the only thing we need to do with
them is to sort them we don't need to
grade one thing and use that to reorder
something else so we can use the short
idiom which is going to have
an performance advantage as well
now they're
sorted
and we just need to transform them into
into their
corresponding
fractions
and we can do that quite
cleverly
because
we can
use the greatest common
divisor
on
non-integers
to
find the number
that
would
that we can divide with and still get it
to be the result to be an
uh integer and so if we just divide by
that number that gives us um our integer
and we want the greatest common divisor
with
with one
on each of these and what we want to
divide
is
both
these numbers
themselves
and one so that will give us the
enumerator and the denominator
so these are our
and our fractions
and then the only thing as
as always is where we need a zero as
well
um now we could stick in zero and like
we did before just concatenating that
but since we're anyway converting two
fractions we can also just put
another zero over here on the left and
that takes care of the zero case
as well
so this is the one that uses quotients
right away
now
even here is a bit of a trick so
everything up onto the sorting looks
very nice and flat
but then we have a very explicit loop
we're doing each we're applying this
derived function on each element
and we can avoid that by thinking of it
in higher rank arrays
so
we still want the one and on the right
but let's instead of doing for each one
of them we generate a pair like this
let's generate a two column
matrix
so
one is the right
right argument to this
train the fork
but we need to
make this vector into a
column so we
concatenate rank 0. we want every
scalar in our
list
over here concatenated with another
scalar to become a two-element vector
with a scalar one
and that give means that every cell
which
every major cell and also every cell
which was before a scalar becomes a
vector and the result becomes a matrix
now we get a
a two column matrix we can we can try
this
and then we need to
divide these
rows
by
the corresponding
greatest common divisor so we can still
do the greatest common divisor like like
before and we just need to divide the
rows
of
this matrix
so the rows have rank one
with
the scalars
of
the
let's go this is upside down the scalar
is of the greatest common divisor
and that gives us this matrix and these
are in fact our fractions with one
fraction on each row however the problem
statement is it should be a vector of
vectors so the last thing we do is to
split that
and that gives us our vectors of vectors
so we we try to stay flat
as long as possible
um only changing to a nested
representation at the very end so let's
call this using quotients as before but
the flat edition
and then
let's compare the performance
of the quotients on 1000
and the quotient flat edition on 1000
you know it's a little bit more involved
using
rank over doing the each but
well the result speaks for itself
okay
finally
in all these cases we generated
too much we generated
all the different combinations
in order to filter them down to the ones
we wanted
maybe we can
instead
generate
exactly
the
fractions that we want
and turns out
that
there is in fact
a formula
to go from
um
from
existing
sub part
and the leading part of the sequence
to the next element so much like
fibonacci numbers are constructed by the
sum of the last two elements
generated
so far
so too
the ferry sequence can be generated um
by looking at the last two elements
before so we only every ferry sequence
begins very simply we begin with a zero
and then we begin with 1 over n 1 nth
that so in our example with 5 we start
with zero zero whole and then one fifth
that's always going to be the smallest
possible fraction
and then if we look at
um
or we can name our fractions in sequence
so the the next to last one that we have
so far
will be a
b's or a over b
and then
last one we have so far is c over d
and then the next one coming up is
p over q
and these p's and q's can be
computed where they're not too difficult
formula
just in terms of
a b c and d
and the n which is the type of sequence
that we are generating right now and so
we can do that right from the start we
know that the first two elements are
have a a equals 0 and b equals 1
and
c equals 1 and d equals n
and that allows us to compute
the next
term the third one and then the fourth
one and so on until we're done and the
stop condition for the sequence would
then be
when
uh
they are the same when we've reached one
hole
so
let's try to state this
it's it's going to be a bit of a bose
but
it's not really very complicated in
itself
so first we want to generate the start
sequence
let's say for
for five so we know that the first one
is going to be
0
1 because it's always 0 1
and the second one is going to be 1
and n which is our argument here
now there's since this is what we're
starting with and then we're going to
add more elements there's
one issue
which is when we have when n is zero
then
um
we don't want to have the one and n
that will give us one zero
[Music]
so we want to eliminate
the second element only take the first
element of this
when an n is zero
so what we can do is
we can take
how many elements
from this well there are only two
um
and we so we want to uh
or we can drop the last one when n is 0
or we can add 1
to n
so for 0 this gives us 1
and for 1 and this gives us 2 and for
any number higher than 1
that gives us more than two and then we
can clamp that down to two by taking the
minimum
so for five
this will give us two and for every
number it gives us two except for zero
where it will give us one so this is one
way to to restrict it like that
and then we want to apply the
transformation
um over and over again until our stop
condition is met
so we're going to write the
transformation eventually let's just put
in the stop condition so we use the
power operator
for that
and
we want to continue applying this
transformation of adding one more
element to our sequence one more
fraction to our sequence of
fractions
until
the
what we have generated
the last element
it is
uh it is true
that
um
the fraction
is
is finished
so it is the last last one so
it should be
one and
one over
one or we could even say if it's more
than that if it becomes uh positive
that's then we are also long finished so
if the
numerator is greater than or equal to
the denominator
then
we're done
now
there's yet another problem
the power operator will always apply the
function at least once but what if
our n is zero in that case we don't want
it to apply at all
so this derived function which is and
apply until a
certain condition
is fulfilled
we can say we want to apply this either
once
or no times depending on whether we have
n equals 0 or not
so we want to apply it
once
if
n is greater than
oh it's not even just one even even
not even just zero for zero we don't
want to apply it at all for one we also
don't want to apply it because we
already have
the full sequence zero and 1.
so for any number that is greater than 1
this evaluates to 1 and then we apply
this whole derived functions
once and for 0 and 1
this value is 0 and we don't apply this
function
at all and that gives us our secrets we
want
this is an array
this is also an array so we just need to
separate the two of them
okay and now for translation of
of this whole
sequence
we also have to remember that in that
formula that we had
you can go back and
look at it for a moment
we are using the last two elements
of the sequence
and we're using n itself
so n itself that was the right argument
here we're feeding it in as a constant
left argument
to this transformation function
then we take the last two elements of
the sequence that we've generated so far
and then let's
pick that apart into these names a b c
and d so
a and b
is the second to last fraction and c and
d
is the last fraction
so we are unpacking that
and then
and we just need to translate
all the mathematics and that's pretty
much an um mechanical translation
so we take
n plus
and b goes the formula
and then we're dividing
that by d
we need to
run that up
off and multiply by multiply c and
d by that
and then we need to subtract
a and b
and that gives us our new
term in the sequence so we can take
the existing sequence and concatenate
this new element to that
so
we run it
and we got the sequence that we want so
we now we generated
just the fractions that we were after
without generating anything else
just in order by computing the next term
in terms of the terms that we already
have uh created
so let's call this p for power
we're using power to iterate over it
and then uh we'll make one little
enhancements to this for performance
sake because here
we were
again dealing with nested arrays we
started off with a two-element
vector of
vectors that's already nested and then
we kept
appending more
nested elements to that
and we should really avoid doing so as
much as possible so let's try again to
generate this two-column matrix that we
saw before
um and then only as a very less step
split that into vectors of vectors
and so uh we want these four numbers in
a matrix two by two
however um if
and so we can we can reshape that you
could reshape it into a two by two
however if our n
is
0
then we want it to be a 1 by 2. we only
want the very first
ones as a single row
matrix so we can use that same formula
as before and
we can clamp
two with one plus
omega um
and that gives us in all other cases
then zero it will give us um a
two and then for the zero case it gives
us a one
and now we have a two by two matrix and
we're going to add
more rows to this and so all the
conditions everything is the same
here
we were looking at the last element we
don't want to use the last element
anymore now we want to use the last
major cell other than that it stays the
same and the formula here is all the
same
instead of
concatenating an enclosure we we just do
a leading axis concatenation we add one
more row
and over here where omega is
a matrix with two columns
negative two take will give us
a a two by two matrix again
we can just revel that and assign
to
all these four names in a flat way so
this is the same power based
solution
but
the flat addition and then we have to
remember to split at the end so that we
get a result that is a vector of vectors
we can try this on five and see where
you get exactly the same result so
ever so slight variation to make it use
flat arrays as long as possible how does
the uh compare
how does the comparison
how does the performance compare um we
have p and i'm not going to run it on
1000 because i happen to know
already that this is not a fast approach
in apl
so let's just do it on
100
and and
we can see that staying flat as long as
possible
was a really good idea that saves us a
lot of performance um but on the other
hand um
we can see that if you compare to the
queue that we have above that they don't
uh
the way we were doing is for a thousand
instead of
uh 100 it doesn't look very promising
and let's take the best of every
category and put them against
each other
so
and we'll just do it with 100 this time
so the best we had was
from was using indices
and we wanted to use the mask whether we
use the mask all the way through or
whether we only use the mask initially
to select which elements was not very
important but we can
we can use the one that uses the mask
that was the one that had best
performance
then
we had the version that used the the
greatest common divisor
and we found that by
splitting our
outer product into two outer products we
got significant
performance improvement
then we had
the solution that did the quotients
right away and of course staying flat
was a good idea
and finally we have
the power approach where we keep
extending our sequence and again the
flat one was the fastest one
let's compare all of these
and so we can see that and computing the
quotients
was
indeed the fastest way by far
although and using the
two outer products with a
number theory the greatest
common divisor was not a bad approach
and either
thank you for watchinghi we are given
the the
scores from people who have played
golf and then uh we are to give them
it's kind of a a grade give them a a
place in the
sequence and in the golf you want to
score as low as possible now that's very
easy
however there um The Twist here is that
if people score the same then they need
to get the same
place and all the slots that would be
taken if they were different are still
taken so then instead there are certain
uh positions that don't
happen and instead everybody gets the
average of what they would have gotten
had they been
different so here's some sample scores
and notice here that there are two 68
and they they're given in uh ascending
or n descending order and there are
three that got
70 so clearly 67 gets first place then
this would be second and third place but
since they're the same they have to
become the average of that which is the
two and a half place so they both need
to get two and a half then this gets uh
number four this is five six and seven
uh which need to share place so the
average of 56 7 is six and then we get 8
n over
here and there are a lot of different
ways that we can um attack this
problem
so one simple way is that we start by
grading so grading means uh telling us
what what position element uh we should
take in order to
sort so here we say well first you want
the first one then the second one then
the third
one um and since they're all in in order
already and since we be doing a stable
sorting here then we it just becomes
really the sequence of um indices so we
could actually
um
just replace this with with indices as
well here's the length and then we've
comput the indices like this and that's
going to be much faster because we're
just generating the indices right away
whereas this actually needs to do
comparisons of
everything okay now we need to uh group
them and there are again a couple of
different ways we could do this but
since they already in ascending order
and they are nonone zero integers then
we could actually just use those values
as left argument to the partition
function uh partion spell
this and that gives us our groups that
because this is exactly how the petition
function
works so now we have these groups some
of which only contain an single element
we can take the average of each one and
we can do this with a tested function
there's a FEA spelling which is the sum
divided by the tally
that gives us the average for each
one um but we also want uh repetitions
here so we want to take the shape or the
length of each segment and use that to
reshape this average so we take the
Telly and use it to
reshape the
average now we're back to having groups
but they have been smooth out so every
value in every group is the same now we
just need to join them which we can do
with the in list
function and that gives us our result in
order for this to be a proper function
which you can give a name f then we wrap
it in braces and replace the argument
with Omega which is the rightmost letter
of the Greek alphabet so that indicates
the right
argument and we can apply that right
there um we were doing grouping and
group really calls for the key operator
so this is a alternative way of doing
things let's take the argument
here
and we are going
to use the key
operator and we're not interested in the
actual values we just want to operate on
the indices so that's the right argument
in the to the upper end to key ke's an
operator takes this function as
operant that applies it in a certain way
and on that we're going to apply another
function which is going to be pretty
much what we had
before the only difference um is that
key will mix together the results and
make it into a single table that is
every such application here becomes a
row and they might not have the same
length so we can have that so we enclose
it and that gives us the same result as
before and then we can enlist it and
we're done so we can give this a name
g
now um there is
a um a little bit of a complication here
and that is that if we try to apply F on
just a single
number that works fine if you try to
apply G on a single number number that
gives us a rank error because key cannot
group a scaler it has no Dimensions
along which to group them so we need to
amend g a little bit by
um applying this whole thing that we
did this grouping to the result of a
reveling so this first makes it into a
vector and then uh we have apply the
rest and now we can do G otherwise it
gives the same results only to handle
the scaler
case Okay so this works as
well now we can go into a completely
different way of of solving
this and that is in order for us to get
the average positions
here if we go back to um to just the
indices let's look at uh let's stack
this on top of s actually so we can um
put s here and we put the indices here
that gives us a two element vector and
then we can mix them to make it into
rows of a matrix and that gives us this
um so now if we look at um at these
values let's look at the 70 we don't
actually need to take all the values
five six and seven in order to get the
average we could just have the smallest
value and the largest value and then add
those together and divide them by two
that would give us the average because
it's a contigous uh range of adjacent
indices so um how can we do this well we
already looked at how we can get the
indices
themselves and we
also
and we can also get the opposite we did
this with grade before but we could we
also have so this is
grade we also have a grade that goes the
other way and that wants to sort from
the largest to the smallest so let's
stack these on top of each
other and we can actually let's put in
the the grade up as well so we have all
three of
them okay
so here you look at the
268 then and this says this is the
second largest and we can see that eight
is the second largest number before
nine so we are going down instead but of
course uh we don't want actually to have
these large numbers here we want to go
from from low to high so we can
reverse the
grade and now we can see how everything
lines up except where the numbers
are the same so here's two and three
which is exactly what we need to average
three and two over here by 70 again we
have five six and seven and we got 7 six
and five so if we are to take the
average of these two that gives us six
these of course give six as well and
this gets six as well so that means we
can solve this problem um by taking the
grade of s or say the indices of X so
these are the um the indices and we add
them to the reversal of the
grade that gives us double uh the score
now we just need to divide it by two so
and we could use parenthesis and do
division by two but we can also flip the
arguments so the division symbol so it
takes what you divide by on the
left and that gives us uh the result
that we want so we can call this
H and um we still have the problem that
if you try to apply it on a single
number then the grade will
fail so we can put back in this
parenthesis and just put a revel outside
so this function is applied to the
result of this
function and there's one more way that's
interesting to look
at and that is um self indices so if we
look for the first occurrence of every
number in s in s
itself so then we can see uh let's let's
do the same same thing again let's stack
them on top of each other we can see
what's going
on we can see that we find a 68 in
position two and this 68 we can also
find in position two because they're
equal to each other same thing all the
7s are found in position
five there's a different function in APL
which is the interval
index interval index tries to find the
slot wherein a number and can fit so
let's say we wanted to find
um where can we fit in say
um
69 and a
half it says slot four 1 2 3 4 we can do
this because our numberers already
sorted so we can find that slot there if
we do 69 itself It also says four if you
do 68 it says
three so it it wants to place you can
see here it wants to place 1 2 3 and a
value that's identical to an existing
value after the last of those values
kind of first come first
serve and that's very convenient because
now if we use the interval index on of s
on
itself then we can see that the 68s they
with the noral index of they want to go
to the first
position and interval index wants to go
to the last position same thing here
five and
seven which means the average of the
index of and the interval
index is going to give us the score that
the position that we want so let's do
that
this is pretty neat how can we make this
into a a proper standard loone function
we could replace all the SS with omegas
and wrap it in braces but there is a
need a way and we can make it all test
it by saying that this is a self
application of the in uh index of and
this is a self
application of the interval
index um which means we can then
um apply
this and now we just have some redundant
parentheses we can
remove this is in my opinion a beautiful
solution um again you order to handle a
scaler case we need to
Ravel but other than that
and this
works
now it would be interesting to know
which solution is the fastest
one let's import the compare
execution and facility from the defense
workspace and we probably want to
generate some sample numbers and as well
so let's say that we are generating
um
five uh
th000
numbers in the range of
10,000 and so these are the upper limit
and we apply the r to that to get a
whole bunch of um of
numbers we can take the first 10 and and
look at them oh look at that they're not
sorted so let's sort
those and we can do this by indexing
into t with the grade so this exactly
what what grade does it
sorts okay it would also be interesting
to know how many unique numbers are
actually there we can do this by taking
the uh unique mask so if we try this on
the first
turn it indicates with a one every time
we have a unique number for the first
time and then uh with a zero for any
duplicates of that which means that the
sum of this is going to be how many
unique numbers we have so this is the
plus
reduction and we get there 10 seven out
of these and what about the whole big
collection so we can see that there are
about 4,000 unique numbers out of the uh
5,000 so there are some duplicates uh
here and
there uh and they're all in the range 1
to
10,000 now we can write
cmpx F on t g on t a h on T and I on
T and we let it run for a little while
it will apply the functions many times
to get an average of the execution
speed even
out oh look at that that's a huge
difference here in fact so much that we
can't really tell which one is faster H
and I so let's try those
again
and uh well I guess for this size
argument uh then H which was using the
grades up and down was uh the fastest we
can look at at what we've got
here thank you for
watchingwelcome to the apl quest the apl with
keeper details
today's quest is the fifth from the 2015
round of the apl problem solver
composition
it's a straightforward problem of
computing the standard deviation
only little catch is that it has to work
on an array of
any rank not just
a simple vector
now i didn't have a pleasure to work
together with
ken iverson but i did have the pleasure
of working with his close student roger
huey and roger used to say what would
can do
i can say what would roger do
and
well i can't be sure of course um i have
seen roger huey write
fantastic code and i think this is how
he would do it
suddenly he defined the mean
to be
like this
as that we've seen many times do and
then he might define the deviation to be
the argument
minus the mean so that's how far away
from the uh from the mean every element
is
then you might define some helper
functions small utilities like
uh square
to be
power with a um preset right argument of
two and also square root
to be
same thing with a half
and now with these
tools in our toolbox we're able to write
the standard deviation quite nicely
the standard deviation would be the
square root
of the mean
of the square
of the deviation
there we go
now since we have to have this work on
an entire
luxury and then
then this is not quite going to work
um because we need to revel that array
first
we can easily define in our function as
a standard deviation of the rebel
and now if we
try to say take this and
we can concatenate it with its own
kong vector
so that looks like this and then we can
do an f and that we get the same
standard deviation because the same
number is just duplicated
that's uh that works and however this is
defining it on these small
portions and i think that's what rosie
would do
we can however change to a more compact
style where we try to integrate the
various parts so let's have a look at it
and this is tool com called bracket devs
and we do that for f and it takes
because we have um
early binding then the actual definition
of standard deviation here uses all the
pieces that we use to define it we don't
remember the names for them and so this
is just the corresponding formula
with all the pieces put together
and we can try to see how we can um
how we can make this
um
more
collected together if you start looking
here we have the square
of the deviation we can just combine
those here
and also continue it might be helpful to
make this into a dyadic function
application which we can do by using
power and commute
the argument so we can put the two on
the left
similarly over here we have the square
root
we can also put that into um the
parenthesis here with the
with a mean
and we can make this into a daddy
function just for symmetry um by putting
the two on the left or we could put we
could put a half on the left and then
commute
but if you want even more symmetry with
what's going on over here then we can
pre-process the right argument of power
with a reciprocal and put a 2 instead
and now we have again these form in the
top we have this function here and this
function over here um and since we're
already having parentheses here we can
take
this function and just make it an inner
function
over here
well coincidentally
if we
ask apple card for the standard
deviation
then we'll find something that is well
identical
and with the little thing extra that we
are raveling and the argument before we
apply it so it works on high rank arrays
as well
that's the first way that we might want
to write this and this is something i'm
sure
so here we would have been happy with it
as well and that's using the under or
dual operator so let's define that since
it's not supplied out of the box in
dialogue apl
um and we since we're only using here
for magnetic applications we can have a
fairly simple um
definition for it so it's the um
we start off by
pre-processing the argument with
the right operand
and then we do the main action
application and then we undo the
application of the
the preprocessor like that
and this allows us to write the standard
deviation
call this is a version that using under
and then we can write it's the mean
under the square
m of
the deviation
and then we could um
so this works as well
and then of course we could
define in terms of that um
with the rebel as well
and we can we can have a look at what
that looks like when we put it all
together
oops
of course there's no u it is h
and similarly um
we could
try to integrate things if we really
wanted to but
it doesn't make so much sense here
because the the beautiful thing is that
we're using the under um but we could
so
um
we have
this this part over here this whole
thing is just a post processor on on
this parenthesis over here so we can
take the whole thing
and put it inside
oops
let's try that again
put that inside here
and now and there's no point in turning
the arguments around on the on the
square but we could replace it with say
self multiplication which is another way
of writing a square
and then uh i think it actually got it
wrong here that
it's supposed to be parenthesized
otherwise this is not going to work
so we want the mean
um and that done while we have
uh the square over here
and then we un undo the squaring so that
becomes the square root and then the
whole thing on
um
on the rival
still works
so that's
it for this time
thank you for watchinghi
we're going to split a list of words
into those that have an even number of
letters and those that have an odd
number of letters
and the ordering is important we want
the other ones first then the even ones
I'm going to go through three different
ways to do this but there are many ways
that this could be attacked
here's some test data
so we have for some even words and some
odd linked words and then some mixture
after that
we can start by using Telly to count the
number of letters in each word
we're not actually interested in the
real number of letters we're just
interested in whether it's odd or even
and an easy way to do this is to look at
the remainder when dividing by two so
this is the two remainder of these
numbers the length of each one
this means if you're dividing by two and
the number is even there's nothing left
over so you get a zero and
if it's odd we get a one left over that
we can divide evenly in two whole
numbers
and this pattern we're going to use in
all our Solutions this is the basics
right
um at this point let's make a Lambda or
a decent that takes an argument outside
of these braces and refer to the
argument with Omega
so this is the same and then we want a
pair
who want basically two masks you want
one mask for the odd numbers and one
mask for the even numbers
so this mask that we have here that is
for the odd numbers and if you want to
get the even numbers then we can do a
Boolean negation a nut
that gives us this mask
so how can we get both masks well we
could use a variable and uh so for one
mask and then compute the other masks
based on that but we can also be a
little bit more clever
um
there is a an operator higher order
function called over which allows us to
take a function and apply it to two
arguments but pre-process both arguments
first
this will allow us to concatenate the
enclosures
of
two
masks so
let's say that we have this mask over
here and we use the commute
or selfie operator to also place the
mask on the left that means we are
concatenating the enclosure of this mask
with itself that gives us two identical
masks
of course we don't want that we want the
original mask as we have it here and
it's negation and Boolean negation so we
can use the beside operator to
pre-process the right argument to this
derived function with the nut
and this gives us the mask
and its negation
each one of these masks we then want to
apply to the argument which is the list
of words
so applying it we want actually to
replicate we want to or also known as
compress we want zero of the first word
zero of the second word one of the third
word and so on that's used to this slash
now we always want the data that's being
replicated to be the right argument so
we bind the right argument as a fixed
constant
right argument to this function which
would take two arguments but now only
takes one argument which is the mask
which then conceptually goes on the left
but if one argument functional magnetic
function it always takes this argument
on the right we apply that to each one
of these two masks
and that gives us
a solution there are many ways that this
that the components we have here could
be mixed and matched but this is a very
nice straightforward flow solution let's
call that f
okay
in the specification for this problem
there's actually a hint saying that we
could use the key operator so let's try
that
we start off the same way as before with
the two remainder of the tally of each
on the sample texts
and all we want to do here with the key
it keep groups things by a certain
characteristic so we want this
characteristic this being even on it to
be the keys and the values that we are
grouping is just the original data so we
could do it by putting parenthesis
around this which becomes a little Fork
here
um and then we use the key operator and
the data the values goes on the right
and we need to choose a function
and the function we want here is we
don't want to ignore the left argument
and just enclose
the the data so we want the enclosure of
the right argument to that
and this almost solves the problem but
notice that the ordering is wrong and
ordering depends on the appearance of
odd and even numbered
and
words in the argument and since the
first word we encountered had an even
number of letters then the first group
is the even number so how can we force
the ordering that we want
well there are a couple of different
ways and I think the simplest one
is to just inject
words that have the right length and
then we remove them afterwards because
they're not actually part of the
incoming data so here this identity
function refers to the right argument
this whole thing actually is one big
fork this means we apply this function
on the left and this function on the
right and then this function in between
them which is the grouping so instead of
having a density function applied we
want a function that prepends and even
an odd numbered word and an even
numbered word now the shortest odd
numbered word would be a A Single
Character it could be the right text
that sake but just the space is fine as
well and the shortest odd numbered word
is a zero length word
so we bind those to as left arguments
just like we were using bind uh before
as for right argument to the replicate
function we're now using bind to bind a
left argument to the cousinate function
so this will prepend two words so called
words
um to the argument and then similarly
over here we we already know
whether they are or even the first one
is
um is odd and the second one is even so
we can prepend that to a result there's
no reason to compute that
over here
and that gives us the correct ordering
and this gives us all the odd ones first
and then all the even ones but there's
one element too much
for each one of them
so we can drop one from each
now because we only have a single
function here which is an argument bound
to the concatenate and we have a whole
train here this is a fork of a fork
then we need the parenthesis on the left
side here we can also move things around
we can swap the arguments of this middle
time function and then just move
the outer functions around
and this will allow us to remove the
parenthesis on the right for those that
prefer to do it like this and we don't
really need these spaces either
so this is
another nice solution
that we can apply
so
there we go
and finally
um something one might not think of at
first and that is to use grading or we
could say sorting by extension to solve
this problem the idea is that we sort by
the even oddness that puts all the
putting all the other ones
first and all the even ones at the end
and then the only thing that remains is
to split the result into two at the
right point where we transition from odd
ones to even ones
and so the way we can do that let's
create another Lambda with the test
cases over here and we begin exactly the
same way as before the two remainder of
each
of the length of each and this time
let's give that a name so we can
we can call that
n
it's kind of like the number but that's
a auto even
and then
we can sort by that so let's uh let's
start by sorting and we since we want
the odd ones first
then and the odd ones have the N equals
one then we want to sort descending
so descending on
um
on n
so you can see that this puts all the
odd numbers words first and all the even
numbered words at the end
now we can call this s
we want to know
and how many are there that are
that are odd numbers
well since we get a 1 for every odd
numbered
word in the list of odd events for for
these words that means that the total
count of ones is just the sum of the
Mask
so we can and we can find the count of
odd numbered ones as the sum that's the
plus reduction of n
which is then going to well we can we
can try it out first we get there are
four of those so that's all oddly and
great
and then of course there's going to be
also four we don't need to compute that
because we can then use this let's let's
call that c
we can now say uh the number c take off
the sorted list
and we can do
and see drop of the sorted list to get
the rest of them
so now we can
make a two element Vector C take of s
and C drop of s
and that gives us our result
this is very much broken up into tiny
little steps and we can you can try to
compress this a bit combining things and
there are some cute ways that we can do
this
here we have C and S and we have them
um in the same position C on the left s
on the right and then we are joining
those two together
which means that it's kind of a fork
right we have other arguments here
and and then the results are joined
together although we're not using an
explicit function here but we'll get
back to that
okay so let's try to put things together
here
if we have S
so this is our expression for S we want
that on the right
and then we want the expression for C
on the left
then we all we need to do is
have a fork in the middle so we want the
take and we want the drop and then we
need to have the concentration of the
encloses so that's that
Nate
over the enclosure of the two
so
here's a partial putting everything
together but we can actually do better
than that
the thing is that we need to
um
we need this enclosure and we are
Computing this expression separately if
we put them both on the right instead
like this
then we can use now we we only want
magnetic function so we want this one
applied and this one applied and what we
want to apply is actually
we want an insertion here of a tick
function an insertion of a drop function
we can use the reduction
for that and it's so lucky that when we
reduce from a vector to a limit Vector
then we get must get a scalar because we
drop the rank down reduce the rank and
we do that by enclosure so that
automatically encloses on both sides
we can write this and it's Fork like
this
and now and we can
substitute in this expression for n
in the rightmost occurrence so this puts
everything together with an inline
assignment however we can also be a
little bit more clever
um and make this a fork so we can see
the argument as one argument and
the the group number if you want or the
even odd number as the other argument
so we can make that a fork all the way
out here
so we say the whole argument we feed in
as the original argument feeding as left
argument to the inner function
and then we can use this as a train a
fork just like we did in the key
solution as right argument so now
whenever we want to have the the mask
which we called n here we refer that to
that as the right argument and whenever
we want the original data refer to that
as the left argument and this space
isn't needed either
so we can write it like that and and so
on and so on we could move the bits and
pieces around but these are just some
possibilities of how this could be
written so we can write this whole thing
as a as a nice Fork that uses a
different Lambda inside as the middle
tine
thank you for watchinghey
we're given a list in order to chunk it
up into chunks of a given size
there are multiple ways to address this
problem but I think the simplest one is
to use petition in close
here's a test case
the way partition in close works is that
it takes
one element as left argument for every
element on the right
that element
is a count the number of new sections or
segments that begin with this element
if we restrict that to Boolean
then it is just a true false indication
of whether we start a new segment here
or continue the previous segment
so we have seven elements here let's
start a segment with the
continue with cat in the same segment in
goes there too then the with lowercase t
is its own segment because we
immediately start a new segment with
head
and will include a sep in that same
segment but Pat gets its own segment at
the end
partition in close on that list
so our real problem is just to construct
a Boolean vector
that
given our chunk size has a 1
every n elements
let's create a Lambda or Anonymous
function we call it addition the list
goes on the right according to the spec
and the chunk size on the left
inside here Alpha refers to the left
argument because it's the leftmost
character of the Greek alphabet
we can use this to take elements from
A1
the way take works is
to pad with an appropriate fill element
if there aren't enough elements
foreign
here we have
a 1
in a group of three
Boolean numbers
we just need to repeat this pattern
until we get the full length of our list
the list itself is Omega the rightmost
character of the Greek alphabet
and the length of it is this tally mark
now we can
take this length and use the reshape
it's a Greek row which is like a letter
r for reshape
and we use that to reshape that
one zero zero pattern that we created
before APL functions have long write
scope so we need to parenthesize the
left argument to the reship function but
not the right argument
finally we need to take this Boolean
vector and use it to do the partitioning
so we can again we have long left scope
sorry long right scope and
uh short left scope so we need to
parenthesize the left argument and then
we use this to do the partition in close
on the red argument
I like to reduce the number of
parentheses that I have and
therefore when I have a
um a very straightforward argument on
the right it's just a single token here
that wouldn't need parenthesization if
it was a left argument then I like to
swap the arguments of the function in
question so partition in close it takes
the mask on the left the data on the
right
but there's a higher order function or
something we called an operator called
commute
which looks a little bit like a confused
face because it gets confused about
what's right and what's left it modifies
the function to its immediate left so
that it takes its argument in the
opposite order
this means we can move the partition
over on the left remember to commute it
and then put the right argument
um reference as left argument to
partition in close
and now we can try this with various
lengths if we go down to two
we get Pairs and the last one stands
alone one we can see we get an extra
enclosure of each element
um if we go to six then almost all them
elements are in the same seven we also
get an additional enclosure just a
single element and if we try to go above
that then there's no difference because
the specification is we just shorten
and this is what the mask indeed does
thank you for watchinghey
we're going to take a list of elements
and fit it into a square
now the number of elements might not
exactly be a square number so it won't
fill the square array results exactly
and in that case we need to pad with
appropriate padding
so let's for example
start with the numbers one two three
four and five
so they can't fit into a three by three
they uh
sorry they can fit into a three by three
Matrix so that would give us one two
three on the first row four five in the
second and then the rest is petting f a
zero and then a whole row of zeros they
cannot fit into a square that's two by
two because the five would be left out
obviously we need to base ourselves on
the number of elements here's a function
at even a Lambda if you want
and the argument is denoted by Omega the
right most element of the Greek alphabet
for the right argument this is a
Telemark counting how many elements
there are there are five
and we need to find a square number that
can fit here so we can take this
count of elements and take the square
root of that which is the same thing as
raising it to the power of f so raising
it to the power of a half APL functions
have long write scope so this power
takes everything on this right as its
right argument and the Magnetic one
argument form of the division symbol is
this reciprocal you could also say that
division symbol has
one as its left argument default just
like minus has zero as its left argument
default
okay so this gives us the square root of
5. and obviously not a whole number so
we need to round up because we need to
need the square to be at least fitting
or bigger
that gives us three we can give this a
name
so that we can multiply it by itself
and that gives us nine nine will then be
the number of elements that we will have
in our final array
so we need to pad with additional
elements and we can do that using the
take function but the take function
takes the number of elements on the left
and the data on the right so we swap
around the argument and have the
argument over here
now we have the nine elements and the
only thing that's needed then is to take
the shape which of the final
array which is going to be S rows and S
columns
and reshape done
but we can refine this definition a
little bit
um
so one thing that we can do is we can
see this whole expression here
as being in terms of s which is the
result of the expression over on the
right
so we can express this instead using a
tested function
where we
um
multiply
s with itself
so this is the S the comes in this
argument so this is self multiplication
that's the square and we need that to
take from the outer argument which is
the Omega constant so we use the same
symbol here three different ways first
we used it to swap the arguments and
then we use it here to apply a function
with the same argument on both sides and
finally we're using it as to generate a
constant function from a constant
so this gives us the square number of
elements that is 9 in this case and we
take and pad on the original argument
from outside
and then we just need to reshape and we
need to reshape into the shape of the
concatenation with itself it's just like
we have the self multiplication we'd
have the self
concatenation
and
here we go
this is just a style thing really
whether you want to express it one way
or the other but note that we have a
self multiplication and also a self
concatenation here which means if we had
s on out here we could Supply S as a
left argument and then we don't need to
do this self thing it will pair up S
from the left with s from the right
for the concatenation and for the
multiplication over here
um so this is another way to do it and
finally we already know that we can
apply a function with the same argument
on both sides by using that frowny
symbol until the derus is so we can use
that instead of using the name s
and
this is a very neat way of writing it
thank you for watchinghi
now we're going to
compute how far it is to go around a
path that is given as a set of points
including looping around and back to the
first point from the last one so it's a
going around in a loop it doesn't
actually matter where we start
doesn't matter the direction either it's
just the total distance
let's start off by having some points to
find that we can we can work on we know
from the problem description that this
is supposed to give 12 as a result so we
have a little bit of a senate check here
okay
we can
start by making a Lambda that we're
going to apply to
the points and the right argument
argument on the right side is referred
to as Omega
and we're going to go through and
follow very closely how the problem is
described
so we want to
connect the
last element with the first element
so
we can get
the first element with the first
function extracted but we need it to be
enclosed to be fitting into our format
of enclosures here little vectors of
vectors
and then we want to append that to our
original input
okay so now we've got the same point
over here
as we have over here
this means we can just consider adjacent
elements so we've got these two
iteration elements we want to measure
the distance from between them and then
these two elements and we want to
measure
the distance between these two elements
and then we add it all together and
that's going to be our result
so adjacent differences
um that is a windowed reduction so this
is a a subtraction because there's a
difference and reduction and but not on
the whole thing just over Windows of
size two so this should give us
three results
okay
now we need to use a little bit of
trigonometry
you may know that
if we have a right angled triangle then
the diagonal so to say
is the square root of the sum of the
squares of the sides of the triangle so
if we look at this as a a triangle we
moved three steps in one dimension and
four steps in the other dimension
um and those dimensions are orthogonal
to each other that means the total
distance traveled is the sum of the and
the square root of the sum of the
squares so it's going to be 16 and 9
that's 25 square root of that is 5 and
so on
so for each one of these pairs we'll
make a new Lambda and we call it on each
one that's the each operator which is
like a map
we want to take the first element so
that's the same first function here and
we want to take the last element last
element is the first element on the
Reversed argument
so this is the first and last this is
not going to make any difference at all
um so far but now we can do the math on
them individually so we're going to
um to take
the square of this one so it's so this
is the exponentiation function but it
takes the exponent on the right so we
use the commute operator to put it on
the left we want to do that
over here as well
and then we can add them together like
this
so now we get
25 here and 16 that's 0 squared is 0 4
squared 16 square root and so on
and now that we have these then we can
take the
square root of that whole thing
so square root the same as raising to
the power of f
and finally we can sum up everything
with a plus reduction
this is all very well but I think we can
do a little bit better let's give this
one a name this function a name for
later so we can do some speed
comparisons
and now we go up and and edit this
so our first observation here is going
to be that we are picking apart an
argument
that has exactly two elements
we could also
insert this function
between the two elements so this is the
only two elements then this is the same
thing as a reduction so if we reduce on
a two element Vector that's the same
thing as inserting that function between
those two elements
this means that what we have on the
right the last element is
the right argument and the left element
is
the first one so Alpha refers to the
left argument
fine
but we can further observe that all
we're doing here are some scalar
operations we're doing
a square
of both and then we are adding them
together and then we are doing the
square root of it
so before we get to that square root we
could just take the entire argument the
entire pair
so go back to removing this reduction
the entire pair as a two element vector
and using apl's
um array capabilities to do the squaring
on this list of two elements
and then we can
combine everything afterwards so let's
illustrate this for a moment let's
remove this
here and remove the summation
okay so now we can see that we squared
each pair
okay
so that means we can now do the
summation of them
and then we can do the square root
and with ready to sum again
right
what else can we do
next what I would do here
is move this square root over on the
left avoiding the parenthesis and we can
do that by commuting with the
exponentiation operator function again
so we're using compute
operator for that
and the reason I like to do this is not
just to save the parenthesis but also to
show a certain symmetry
we've got the commuted power here and
we've got the commuted power here and
they have inverse left arguments we can
see it's a this transformation and then
undoing that transformation
and I'd actually like to take this even
further let's try to link this first by
I want to show the symmetry of this 2
over here
and we can do that by
remember that that this 0.5 actually
goes over on the right because of the
commute operator so we can pre-process
the right argument to the power function
with the reciprocal
so we have a pre-process combinator
operator
and then we have
a reciprocal function so this is the
division symbol but when you recall it
with one argument to pre-process things
then it's going to be 1 divided by or
the reciprocal which means we can State
this as a 2. and now we can see a very
nice symmetry here in our code
okay
next observation is that this is a
scalar operation scale operations also
penetrate into all structure but we have
an outer explicit Loop here
and we don't need to have this scale
operation done piecemeal on each pair we
can do that outside before we
before we even go into a looping mode
then we sum each and pre post process
again with a scalar operation which is
the square root that doesn't need to be
inside the loop either so let's take
that out and
have the looping just be the summation
and now the only thing we have
in our looping and Lambda is a wrapped
derived function the plus reduction the
summation so there's no reason to wrap
it in a Lambda in itself we can just
apply it directly
this side over here I want to have a
look at as well
because
what is a pairwise
difference it is just comparing in this
case subtracting
um every element with its neighbor
so if we take all the elements and we
shift them around
One Step rotate them cyclically then we
get the neighbor element and then the
first element becomes the last element
and gets paired up there as well
so instead of
explicitly
adding another element and then doing a
pairwise
difference we can just do a subtraction
which goes on the entire array with the
one step rotation of the right argument
so this is the rotation Function One
Step we take the first element and put
at the end so now the elements here
occur are the neighbor elements of the
ones over here
right
let's call this G
and we'll get to a speed comparison
between these two in a moment because I
want to go one step further
notice these points that we have
the reason we need to Loop over them is
because they are enclosed we have
vectors of vectors but APL excels at
operations on entire arrays we can make
this into a simple single array using
the mix function every Vector here
becomes a row in in a matrix
and now if we were to
um
find the neighbors it would be the next
row over so we can rotate this time
we're rotating vertically to get the
neighbors
and from here on everything would be the
same
so we can take
the mixed points
and subtract them from our points and
then we want very much the same formula
as up here
we're going to do the the squaring
and now we need to sum the rows so no
need to to any explicit looping here we
just sum and this goes along the rows
and so on the rest of it is the same
this gives it the same result the only
difference here is that we start off by
mixing so we get a single flat array and
then we do the rest of it of our
computation on that flat array
so we can give this a name
and this is an a top right two train two
function suggestions to each other
there's our main computation function
and then there is a pre-processing
function which just starts by mixing all
these points into a single Matrix of
points with one point in each row
okay now for performance comparisons
for that let's generate some test data
we can take 10 rows and two columns
reshape a zero
and throw in the random role function on
that that gives us a bunch of numbers
between
0 and 1 which is fine these are floating
Point numbers good for our our purposes
here
it doesn't actually matter what the
values are because whenever you're
subtracting and squaring sun it's just
the same operation
now the specification is that we're
getting a vector of vectors so we split
so before we're using mix to join
together vectors of x's into a matrix
now we're going to use the opposite down
arrow to split the Matrix into a vector
of vectors
and let's give this the name Q for our
quality assurance
but we should also not use just 10
points let's use a thousand points
right now we copying in the compare
execution tool copy that from the
defense
workspace Library
and then we give it expressions
to compare so we have F on the on the
points and G on the points
and H on the points
and let that run for a little bit to see
how we stack up against each other
and well that's pretty impressive isn't
it so just doing some cleanup work
not really changing anything in the in
how we're computing
that got rid of a good 20 of uh almost
80 leaving only 20 percent
left of the computation time and
therefore resources
but switching to doing things in an
entire array
manner by starting off with some flat
data not nested data that pretty much
eliminated all the work that we needed
to do
so bear that in mind you want to go fast
stay flat
thank you for watchinghi
this time we're going to compute the
zodiac sign approximately
we're given two numbers one for the
month and one for the day
it's given as a table on the problem
description website
but I've imported it here
I'm not going to go into how we get it
in there are various ways to do that but
know that what we have here is a matrix
representation of character vectors
which is exactly like the table is there
including some strange spaces that we
really don't want and we're going to
clean all that up
so our first problem is that while the
table is laid out for human consumption
it is not really very good for machine
consumption we can see that we've got
four columns but it's actually a
database table of two columns the sign
and the date range the date range as
well is formatted nicely for humans but
not really very nicely for computers
so we've got two columns that are
actually the same column
um twice
let's start by cleaning that up so the
First Column and the third column Belong
Together
and the second column and the fourth
column belong together so we're going to
permute The Columns of the table
now we want to get
the the cells in the table that belong
together
to be together in sequence because the
the reading order here if we just
flattened our data is Aries Libra and
then March 21st and then September 23rd
and then Taurus and that's awkward
but if we transpose our table
then the reading order has all the signs
first and then all the date ranges
now the only problem is that we have two
rows for each one of these I only want
one with of course 12 columns so
two rows and 12 columns reshapes this
transpose table
and now we've got two rows one with the
signs and one with the date ranges
another problem is that strangely this
table begins from March 21st and since
we're going to look for dates in the
Gregorian calendar that begins with
January then we'd want to rotate this
around so this is a
negative 2 steps
horizontal
rotation of the table
so the normal rotation takes elements
from the left and sticks them over on
the right now we're doing the reverse so
that's what the negative number is for
and now we begin with January
instead
it's a table and it's much easier to
work with this data having it separately
one list of signs and one list of dates
so let's split the table into two
vectors and we can actually see the
dates but they are out there to the
right and then we assign them to S and D
for the signs and the date ranges
like that here are the signs and here
are the date ranges
and now we can see that the signs have
some training spaces which we should
probably get rid of immediately so the
signs and then we're going to use
um
especially syntax let's first try to
remove the signs so we want to this is
the a set difference so without we can
read it as without from each one of them
a space
and that works this removes them but
this didn't update the variable and we
could assign it just to to S but
more fun is to use something called
modified assignment which is something
you see in other languages as augmented
assignment you might see things like
plus equals so you have some some
variable name V and then you increment
it like this or decrement it or have it
in APL we allowed absolutely any
function
on the left that function is given the
original value on the left and this
parameter a new updating value on the
right
and then whatever it computes is then
assigned to the variable
so in this case our function is a
derived function which is the without
each
function
and then we just stick the assignment
Arrow over here
and then this parameter is given as
write argument and the variable's
current value is given as left argument
and the result is put into that same
variable
now this has been cleaned up
next step is to parse the dates
we could go and pass the uh the month
names but we actually know that there's
one month for each so that's just the
range
um Iota 12 that's the integers from 1 to
12.
the only thing we should extract then is
the the day of that month and we only
want the first number in each cell
because it's actually redundant
information the last day of one sign is
the day before the first day of the next
sign and we're going to go with
beginning dates rather than end dates
so a really nice way to do this is to
use quad vfi
and this means verify and fix input
and it's called verify and fix where
verifying make sure that a token is a
proper number and fixed actually
converts that text to a number
and so we can try this with the first
one
so the first one of d
it's if we just run this by itself then
by default it splits on Spaces it uses
them as token separators so we can see
it saw three tokens here this generally
there's 20 and dash February and then
there's 18. and the very far part is on
the left and the fixed part is on the
right the very first part is a Boolean
mask saying that this token was invalid
this token was invalid and this token
was valid as a number and these are the
values with zeros substituted for
invalid values so we can see we only got
the 18.
however we can also tell
GFI to use one or more field separators
so we want both space
and N Dash as
field separators
and now if you try running this we can
see that it's split it up and we got
both the values 20 and 18 out recognized
as numbers and then there was the
February and the January that were
considered invalid tokens they're not
actually proper numbers
and since we know exactly what kind of
data we have here this is good enough
for us to parse it fully
we can then
well we can we can take it one step
further
um we know what this mask is going to
look like so we can ignore that and we
know what this one is going to look like
so we can just go in and take the second
element of
the second element
and we can do that with the pick
function
2 2 means go into the second element of
the overall structure and then inside
that go into the second element again
and that gives us the 20. now the only
thing we need to do is wrap this in a
little Lambda where Omega represents the
argument and apply that to each of the
that gives us our cutoff days of the
month
we can make this into a matrix
so now we have a column vector or column
Matrix single column and then we can
take those indices from 1 to 12 and
concatenate horizontally to that Matrix
and that gives us a lookup table for
where the cutoff dates are
let's call this
C for cutoff
so here is our cutoff table
okay
now if we have to come up with a
strategy for actually finding the signs
and if you look at our table again
then we'll see that
if we go and look for December here
the
we're going to end up with the end of
the year
here
being Capricorn
and that's that's fine that's the 12th
one but there's also a part of the
beginning of the year
which is a bit of an issue so any dates
before the first cutoff should really
end up with Capricorn as well
one way to do this would be to add
another element to our lookup table
another one is by doing a cyclic lookup
so we could use modulus and compute the
indices but even easier is to rotate
cyclically
like we did before and we we rotate
technically the whole
um the whole table of signs
and then
we can have indices or positions between
zero and 12.
so we'll we'll call it zero when we are
before the first
cut off date that is from January 1st to
January 19.
and then we'll call it one when we have
from January 20 and onwards and two when
we kept that and so on and then we have
the 12th one
when we have December 22 and onwards to
the end of the year
so this means that we want the Capricorn
to be in front because that's going to
be the zeroth step
and currently we have the signs arranged
with
Aquarius first
but we can do the same kind of syntaxes
before we do a rotation but rotate takes
the amount on the left and the data on
the right so we need to commute or swerp
the arguments negative one step
now we have Capricorn first
so if we have zero rotation of
of the signs
then we get Capricorn first and if we
pick the first one then it becomes
Capricorn
if we rotate it one step that is after
the first cutoff date
we get Aquarius at 12 or 11 let's do
that first
we get Sagittarius and 12
we're back to Capricorn
so this works really nicely
we then just need to do some lookups
into our table so here's the table of
cutoffs and we have something called
interval index
interval index it looks where do things
fit with every major cell or Row in this
case
being the beginning of a section so it
will look this something belong with 120
and further or 219 or further and then
this is the first interval here between
these two is called interval one before
the first one is called interval zero
and then the last one defines the
interval 12 which is exactly what we
want
so we can try it 223
interval 2. so this is this works with
lexicographical ordering meaning we
first we look at the first element and
then we look at the second amount which
is exactly what we want so 223 a three
it falls in here that's interval number
two
and we can try it with 10
31. the example K is given
that's over here now we can try it with
January 1st
you see we get a zero
so that's before the first one
so for a date like this
we can take this and rotate
the signs
and then we pick the first one
the remaining step is to make this into
a proper Standalone function
we will
we could put in an argument here
and then
wrap everything in the Lambda
foreign we could even save our
parenthesis by commuting the arguments
of the rotation
so this is one way to State it
or we could make a tested definition
where that's one where we don't mention
the arguments by name
instead we say that
we bind
as in fixed left argument two interval
index to the lookup we bind this lookup
table
and then we use that to rotate the signs
and pick the first one
that's another way to write it however
the reading order here with the swap
the arguments is not actually we don't
need to do this swapping because we
could instead write the rotation
and then use
the the sine Vector here but make it
into a constant function so this Returns
the signs
it gets rotated by the interval index
into the cutoffs so this is another way
that we can write it and now we can try
on each one of
223 and 1031 with this example cases
and we can try that with G as well it's
entirely equivalent
thank you for watchinghi
we're going to take a sequence of bytes
and cut it into pieces so each piece
represents
a single
code point or character
if we take this sequence of bytes to be
a utf-8 stream
okay so what exactly is it we mean by
this let's
have a sample text
so this is a normal d
and
this is a Yen symbol
here's an alpha and a down style circle
and a normal nine
if we look at the Unicode character set
code points for these
we can see that some of them have
relatively low values
some have
medium high values and some have very
very large values
and youtube8 is a variable with encoding
that means that when you have a sequence
of bytes that represents text each
character doesn't correspond to a fixed
amount of bytes
we can
ask
APL
to give us those bytes
and so we can see here that the number
of bytes is not something that directly
translates to what we have over here we
can see that the 68 is the 68 and the 57
stays 57
but that's where the obviousness really
ends the 165 became more than that and
then we have a bunch of numbers
representing these large values in the
middle namely in this case three for
each
okay let's call those the bytes
and then we can convert back again so we
can say utf-8
quad UCS on the bytes
that converted them back again
if we wanted
each character to become its own little
sequence of and of bytes then we can do
utf-8
we we bind this argument to the quad GCS
function and apply it to each so this
entire thing gets paired up in every
invocation of what GCS with each
character that we get from this
and this is the result that we want to
get to
given these bytes
the rule is
that when we have numbers here
that are larger than or equal to 128
and less than or equal to 191
then it is a continuation of the
previous byte so
68 is outside that range
194 is also outside that range so each
of these begin a new character the 165
is between 128 and the 191 so that
extends
the previous bytes to create a single
character then we have 226 that's
outside the range so now we begin a new
one but 141 and 186 they're inside the
range
and so they continue the previous one
and so on
it could be up to four bytes together
but we don't have an example of it here
it's mostly used
for emoji and and traditional Chinese
so how can we do this
well we can start by checking for this
range let's do everything here in tested
form that is without mentioning our
arguments explicitly we've got the bytes
and we want to do a comparison so the
upper bound is
191
we can bind together a fixed right
argument to
the less than equal function so it
becomes a new lesson or equal to 191
function then we can then apply that on
the bytes
really we
could keep going like this but it's
slightly difficult to see which bit here
a true false value corresponds to which
byte in the input
so
it would be nice if we could stack them
on top of each other to align things
and we can do that
by
making a vector of these two
and then we do what's called mix let me
change this Vector of vectors into a
matrix with two rows
as a notational nicety I'm going to
write in an operator a higher order
function that does this for us because
we're going to use it all the time
so if you look at the pattern here we're
going to call this operator with an
underscore because it will look nice
like this but it doesn't really matter
and we want the mix of the argument
and
a function
applied to the argument
that's all there is related to it
now we can go and say we have this less
than or equal to 191 function with this
higher order function we're applying it
on the bytes
now we have the stack here so we can see
that these are the byte values and these
are the corresponding bits so we can see
here that 68
is less than or equal to 191 194 is not
and so on
okay that's one half of the
of the by the the range the other part
is that it has to be greater than or
equal to 128.
and I like to put it on the other side
for this
because now we can combine this very
nicely as a fork so we have this
function so that has a magnetic function
derived from a diadetic function and
we've got this function which also we
say test it
and derived function from with diadic
function to a magnetic function
and we can make a so-called fork or
three train where we have a middle tine
which is the end function
this means that these two other
functions are applied to the argument
and then the middle function here is
applied to their results to get our
final result
and then our higher order function here
the the underscore operator Stacks the
original argument on top so we can see
what's happening
foreign
we can see that the ones here indicate a
continuation byte and the zeros indicate
a new character begins here but
but in order for us to use the partition
enclosed function
we need to flip things around because it
takes A1 wherever we want to begin a new
segment and a zero when we want to
continue a segment
but we can simply negate that with the
not function
now notice we have a not and we have an
end we can combine those into a nand
and this shows us where we begin a new
character
and the rest are continuation bytes
then we can take this
and use it as a mask for
cutting using the partition enclosed
function but the position in close
function takes its mask on the left and
the data to be cut on the right here we
have the mask on the right and the data
with the identity function on the left
so we use the partition in close
with the higher order functional
operator commute
that modifies this function to take its
arguments in the opposite order so the
grouping here goes like this we
start by binding these two
together to create magnetic functions
rather than applied to the arguments the
results are
combined with a nand function that
becomes the well left argument to
partition in close and the identity
function's result becomes the right
argument to partition in close
so this doesn't make sense to do the
stacking anymore so let's stop doing
that
and now we have the solution to the
problem and we could give this a name if
we wanted to
and then we can apply that to the bytes
however
this looks a little bit messy
we can use the Morgan's laws which is
these laws of formal logic that allow us
to manipulate and
the an expression
by knowing that and an or
duels under not to each other what that
means is that if you negate both
arguments and negate the result then you
get the other one
so if we instead of using end we then we
want to negate the result so that gives
us end and then we switch to an or now
we just need to negate the arguments so
what is not less than or equal to well
that's greater than and what is what not
less than equal to that's greater than
so we can write it like this as well
so these are this is one approach to the
problem
another one is you notice we're looking
into ranges
we have
a function called
interval index
it gives us the index of the interval
where a value Falls given some cutoffs
so
the cutoffs are left inclusive that
means that if we have 128 and
191 then 191 will belong to the next
interval we want it to be in this
interval so 192 Begins the next one that
means everything from 128 to just before
192 is in this interval here
and there's one interval on the left and
there's one interval on the on the right
so we bind this to the interval index
function
and this gives us the interval numbers
but let's use our underscore utility
here
to stack things and see how it looks so
now we can see that 68 Falls in interval
number zero that's on the left
94
for 194 falls on 2 that's to the right
165 Falls in between the two that's
interval number one
remember that we want ones where we have
0 and 2 because those will start new
characters and zero where we have a one
that means
all we want here is to know whether or
not these indices are different from A1
so one is different from then it is zero
or two
and this gives us our argument for
partition in close that we can then use
on the argument and remember to get rid
of this utility
and that gives us the same result
we can give this function the names as
well and apply it on the bytes
so this is a different way to do it
thank you for watchinghi this Quest is based on the game Risk
if you're not familiar with the game
Risk then I suggest you pause the video
right here and read through
this now we are going to generalize the
rules of dice throws in risk and so we
have two integer
vectors and and uh the left one is the
attacker and the right one is the
defender and we have to find out how
many armies the two players
lost so we're going to have a large
example where the attacker attacks with
five armies as if that was allowed and
throws five
dice
and the
defender uh defends with three
Dice and so uh we want to find out how
many uh each player loses so we can see
here that uh the attacker matches over
here so the attacker
loses and
then the attacker has more than the
defender so the attacker uh wins that
means the Defender loses and then the
third one the attacker has less than the
defender so that clearly uh the attacker
loses an army here so all in all we only
considering the first three the attacker
loses two and the defender loses um this
one now let's compute that um the rule
is that the attacker wins if uh the dice
show if the attacking die shows more
than the defending
die uh we giving given our um throws
here already sorted so that makes things
easier but we need to take care of this
discrepancy in length potential
discrepancy in length between them um
and it's an inefficient but elegant way
of doing this is to Simply compare all
values so this isn't out of product it's
not really a product it's really a
comparison we are comparing all the
values here with all the values over
here even though we actually only want
the corresponding values
compared and that gives us a comparison
table and
where uh we have the rows here
correspond to the six uh and six and
four 2 1 and then the columns here
compared to the uh six five and five and
so we can and this is one for true and
zero for false so we can see here that
uh this is the right comparison with the
six and the six and it's not greater
than this is the six and the five it is
greater than and this is the four and
the five that uh is not greater than so
we want the
diagonal um and we can get the diagonal
in APL by using a transpose a
generalized transpose so a normal
transpose
um that just flips the
axis but the generalized transpose we
take a mapping as the left argument to
the to the transpose function and we can
say where we want the particular AIS to
go so uh if I want the first axis to
become the first axis and the second
axis to become the second axis that has
no effect if I want the second axis to
become the first uh the first actually
to become the second one and the second
one to become the first one um then we
get that normal
transposing however if I M both of them
to the same axis that means as we
Traverse this
array and instead of traversing first uh
along a a major uh the major a leading
ax the rows and then along uh The
Columns every time we take one step down
we also take one step right so
essentially we're collapsing the two A's
into one and taking the diagonal between
them and that gives us this diagonal
that we were looking for now this is uh
who wins but we're actually interested
in who loses so we want the opposite of
uh the greater than Which is less than
or equal
to okay now we want to know how many
there are so really what we want to know
is um how many ones are there and how
many zeros are there because the on
indicates that the attacker lost and the
zero indicates that the uh Defender
lost
and we can do this in in various ways
and you can see the uh description for
this video to go to the chat the event
that happened and it has other ways to
do this but I'm just going to show you
uh one way to do that here I'm going to
make this uh list this Vector into a
column and then I'm also going to negate
it and I'm going to concatenate them
together so this is a function
of the result of uh this function where
we're taking the uh colonized form and
concatenating the negated
form so this column represents the
attacker's losses and this column
represents the defender losses and now
we can see all we need to do is sum The
Columns and that's exactly what we're
going to do with the leading first X's
uh plus reduction
and that gives us 21 which is exactly
the result we were looking for so we can
take this whole
construct give it a
name and then we can go in and
substitute it in here then the whole
thing reads a little bit
nicer thank you for watchinghi
we're going to simulate
casting dice
and then figuring out how many different
ways of each total result there are and
then
drawing a diagram
that shows the frequency for each one
so first let's start by throwing the
dice and this is actually interesting
because we can think of the dice throws
as
um indices
so each die represents one independent
dimension in the full
set of possible outcomes
and so if we have three dice then each
one of them can contribute with a
magnitude along that its own dimension
which means that throwing dice is
actually the same thing as creating
indexation vectors and if we want to
make all the different possibilities
that's the same thing as creating an an
index a temple of contents of an array
that has the dimensions of the number of
sides in the dice
so for a normal
six sides then the Iota function which
generates indices does exactly what we
want
so there are six possibilities the
numbers from one to six and if we have
two days with six signs each then we can
get this collection which is a
six by six
array of Two element vectors into the
space
each Vector representing an outcome
and then we can sum each one so this is
a plus reduction on each
and that gives us all the outcomes as a
two dimensional array because there are
two dice and if we do this with more
dice then we get a whole lot of numbers
like this in the Scrolls by
Let's uh try instead of normal six-sided
dice to have a two-sided die that is a
coin flip a three-sided die that's a bit
difficult to build but it can be done as
a kind of weird Twisted piece of
something that can land in in three
different ways
um and then
a uh
we can even do a six-sided normal die
yeah
so here we see the uh the full space
it's a two by three by six array and
then we have summed all the
um
the numbers and these are all the
outcomes which means we can Revel this
that is remove the shape we just get a
flat list back and that gives us this
very long list of possible results and
since that we start off with the lowest
possible value and then we increment by
one going along the
um at the
in the Revel order that means we already
have our possible outcomes in sorted
order we'll never get a smaller value
after we've gotten a larger value
therefore and we can take this and throw
it at the key operator it's a higher
order function that takes an operand
that is a function in this case we'll
write it as a Lambda and it calls this
function
as many times as they are our unique
elements so we will call it on three
four five six seven eight and then
eventually a 9 and so on
up to the top value
which is 11.
and for each call it will give a left
argument represented by Alpha and a
right argument represented by Omega left
and right most
elements or letters in the Greek
alphabet
and the left is going to be the actual
value and the right is going to be the
indices where that occurs so we can see
that we here have all the outcomes and
we and here the indices where this
occurs are 300 occurs in the beginning
four appears in position two and
position seven so we can see the second
four over here and also position 19
is the one over here
but we're not actually interested in the
indices themselves we just want one
asterisk for each index and we can write
that by
taking an asterisk and making it into a
constant function and applying that to
each
index
and that gives us
um
our
possible outcomes for these three types
of dice and we can try and try this for
two six sided dice then we get this
and for a single die we yeah that's just
one outcome for each possibility
however this has an issue and that is
that we in the process
of
Computing like this we
have
created an array of the number of
dimensions of the count of the dice
um
and this is problematic because there is
a limit in dialect APL to the number of
Dimensions you're allowed to have in an
array which is at 15. so if we have say
16
coin flips
so this is a reshape so we're reshaping
two into length 16. then
we can see that the result array would
have too many dimensions and that's not
allowed
so we need to solve this problem in a
different way
so how can we do this
we can still think about it as indices
into an array
but this kind of
um indexing
is also a mixed based system actually or
in this case if they're all the same
that's the same base system what does
that mean it means if we look again at
this array then we can see that it's
like a number system where we're
counting up we start one one one one one
one two so this is the the ones place
and this is the sixth place we can see
once we reach
um
to the end here after the six so this
corresponds to
a digit zero a digit one digit two and
so once we reach the digit five then
there are no more digits in this in the
ones place because it's the final base
six and then we continue
by incrementing the next number over so
this would correspond to the number one
zero in base the mixed base two three
six so this looks a little bit funny
because we start with index origin one
but if we subtract one
notice API uses a high minus for
negative numbers
then we can kind of see the numbers as
they progress so zero one two three four
five and then one zero
one one one two and so on
um
and over here we can then by the time we
get to 2 5 then since the middle one
only has is is base three the digit is
only base three we need to progress to
the top digit which is not the hundredth
place but rather the three times sixth
place that is the 18th Place
and then we progress to that and this is
the last number before we need to add
one more digit
Okay so
how many are there here remember how we
did the the sum reduction
um to get the the addition reduction to
get the sum so two we can do a
multiplication reduction to get the
product
so there are 36 possibilities
um when we have
a specific ordering of the dice here and
we have to because they're all set
different here
and we can generate all these numbers
again we need to subtract one
and now we just need to express them in
this mixed base
so we can say two three six
encodes so a base looks like this or
this evaluation in a base and this kind
of looks like a t so it's
it's converting to that base so we're
taking these normal decimal numbers and
we're converting to the mixed base 2 3
6.
and that gives us this one number per
column notice that so this is number
zero number one number two and so on
then we get number one zero in base two
three six and so on
and here we never exceeded rank two we
are just dealing with low uh rank arrays
and it's also beneficial because we
don't have this array of arrays a
multi-dimensional arrays of little
vectors we're keeping everything flat
and that's going to be a much more
performant
now that we have this we need to add one
back again because dice they start with
one two three and instead of zero one
two
and then we just need to sum vertically
so we're using the plus but this time
we're using reduction with a bar on it
which means we're reducing vertically
actually along the leading first axis
it gives us all our outcomes so this is
the same thing that we had from before
with the reduction on each of
the indices of an array that has the
shape 236
where we then Ravel them so we can see
that
this is the same but this time without
any issue that if we try to use 16
coin Flips For example that just works
no problems there
okay
then we can go in and put in our
function from before where we use key
left argument and an asterisk constant
for each of the indices
and then we can see we get some huge
thing for for this very big conflict but
it works
um and if we try to do this on our 236
case
we got the nice curve from before if you
try to do it on two dice
then
um
oh this uh what is the problem here this
doesn't quite look right
um that's because we're using we should
go back again try this one this
constantly appear we need 16 reshape two
over here
there we go that's better of course if
you have 16 coins and they they both
contribute
um one and two then the Lower Side you
can get there's one for each one so
that's 16 and then going out from there
and then and we can try our six six case
have a six six over here
um
there is but one little problem
and and that is if you only have a
single number here then
expressing it as in the base here is
going to just give us a flat Vector but
we want to explicitly make this a
vector rather than a scalar which gives
us a matrix and it doesn't actually look
different but it will make a difference
when we use the key part so this is
correct whereas if we didn't do the the
Revel into
a vector from a scalar then we get a
rank error
so that's important and there are
different ways we can we can do this but
now let's make this whole thing into a
proper function
we put bases around it substitute an
Omega for the argument
and now we have a function that we can
use and that doesn't hit any issues with
the maximum rank
and it works as well on
a scanner
thank you for watchingwe have to find the longest run of ones
in a Boolean vector or scalar let's keep
that in
mind so let's first have some sample
data and here we can see that we have a
run of length three of length two and a
run of length four so that will be the
answer
four um let's make a Anonymous Lambda we
can always name it later and take the
argument s in here we refer to the
argument as
Omega and we can go directly and cut
this into pieces well there is a
petition function which takes a mask
like this on the left and some data on
the right corresponding
length and it keeps uh runs of that
correspond to ones and it discards any
elements that are that correspond to
zero and then begins a new Partition at
that point it doesn't really matter what
our data
is so we can use uh the same bu and
Vector for the data and as the
mask and then we just need to uh count
the length of each one so this is the T
mark appli to each mapping over
those we could also State this argument
only once by using the selfie operator
or commute so this derives the new
function that's the same as this one but
takes one argument and uses it as both
arguments of the original okay next step
uh then is to take the maximum and that
is
four there's one tiny issue that is if
there aren't any runs of uh of
ones then then this gives us an empty
list of lengths and a reduction a
maximum reduction over an empty list
should give us the identity element
that's the argument to the maximum
function that will not affect the
outcome for any other
argument so that has to be the minimum
representable value and what we're
seeing here is indeed the smallest
possible
64-bit uh binary
float
so how can we fix this well we can make
sure there's at least one value at all
times so we just inject a zero in front
of
that and then it
works however injecting a zero this
seems like a simple thing it actually
can have an impact on performance so
let's
first um give this a
name and then we are going to import the
compare execution facility from the
defense
workspace let's generate some Boolean
test data so we want it to be in the
range of two we want there to be 10
million elements of those and we want
them to be random and then we get random
ones and twos but we actually want
booleans so we compare them to a one
that gives us so the ones give one and
the twos gives give a
zero
and then let's think about how we can
solve this problem a different
way the problem is that
um this is a potentially very long list
of lengths and when we inject a one uh
one element at the front a zero then
even if we were able to do the
transformation in place in memory we
would have to move over every element
one step to the right that's a total
rewrite of all the data and a
potentially expensive operation compared
to everything else that we're doing so
if we didn't do that then we could end
up with this very large negative
value however any other uh argument to
the maximum reduction would have
positive values in it that is if we have
runs of ones so what we can do is we
take the maximum of the result of this
maximum reduction and zero if it's a
very large negative value we get zero if
it's a positive value then the zero is
not going to affect
it how big of a difference does this
make well let's try it we apply F on
this Boolean and G on the
Boolean and we wait a moment to
see which effect this has that's about
twice as fast for 10 million elements it
will vary according to how many elements
there are so this is definitely Ely a
good
technique that said we went as we can
see here in the top left corner by a
nested array that was strictly
unnecessary we
could compute the lengths of runs of
ones directly rather than actually
generating pieces that have these
lengths and then measuring the lengths
so how can we do this let's start over
with our sample
data and have a
think if we can find the location of
beginnings of a
run and we also find the locations of
the ends of the
run then if we subtract the index the
location of every beginning from its
corresponding end that will give us the
length so
how do we do this let's go to our to an
anonymous Lambda
again and we want to compare adjacent
elements if the left element is less
than the right element and the whole
domain is just zero and one then we know
that we have a zero and a one and that's
the beginning of a
run so we can do a two wise less than
reduction of the
argument
and that gives us the indication where
we
have this run and this run why are we
not finding the first one that's because
we never went from zero to one there's
no zero on the left but we can inject
that okay and similarly if we had
been let's go let's go look at the uh
the
ends and this tells us that we we have a
um the end of a run at uh coming up to
this zero at the end but of course let's
say there was no zero at the
end then we would fail to find the
end so let's put in a additional zero
over
here okay so with this we have our
um
ends and we also had our
beginnings now we just need to convert
these Boolean masks to be
indices and we do
this with the indices function or
where so this gives us the
beginnings and uh this let's change that
to the S again gives us the ends and if
we just
subtract the corresponding elements then
we'll get the
ls oh yeah it has to be the opposite
order o