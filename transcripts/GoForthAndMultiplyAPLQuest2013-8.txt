welcome to the apl quest c apl wiki for
details today's quest is called
gothforth and multiply
it's really simple we just need to make
a multiplication table
it's the eighth problem from the 2013
round of the eppl problem solving
competition
for once we're going to go straight to
the obvious solution
well we can generate the indices from
one to
a certain target number
and then
we simply need to provide the outer
product
using that argument
both on the left and the right side so
both vertically and horizontally in our
table and this gives us our
solution
so just get rid of the argument and we
can give it a name
and now we can apply it
as you want and it works even on zero
okay now let's go to have some fun
because this problem is already sold
the first thing we're going to do
is try to solve this without using the
outer product which is otherwise the
obvious solution
and a couple of different ways that we
can do that
the first thing is to use the definition
of the outer product the other product
pairs up
every element
from
the list on the left with every element
from the list on its right
now we can actually use a property of
the multiplication
that it
maps or distributes over
multiple arguments so if we pair up
every element from and our list of
numbers with the entire list of numbers
then that will be the equivalent so
let's say we have
the numbers here and then we multiply
using
sorry we should not use our product we
should multiply using a rank and we want
every element so those are scalars rank
0 from the left
and pair them up with the entire vector
rank 1 on the right
using this iota 7 as both right and left
argument and that gives us
our solution
so this is just using outer product in a
hidden way because this is the
definition of outer product for scalar
operands
we can do one more fun thing
i think a lot of people are not aware
that if you give a vector argument to uh
iota
then it generates all the indices of an
array with that shape
this actually holds true even for a
scalar one element vector
as well
and now since
these are the indices
those are also the corresponding numbers
that need to be multiplied together in a
multiplication table
so we can simply say
that we multiply
and across these or we reduce each of
these
pairs of numbers
and with multiplication
and that gives us our solution as well
and there's even more fun we can have
let's start again with these numbers and
this time we reshape them into the shape
of our
multiplication table
so this just gives us repetition
and now what we can see is
that
multiplication is just a series of
additions so on the first row we we need
our original
numbers from one to seven on the second
row we want the numbers from one to
seven added with
the numbers from 1 to 7 again and in the
third row we want it added again so this
is simply the cumulative
addition going down
and we can easily write that
as
the plus slash bar
so this is uh class
backslash bar this is a cumulative
vertical addition
and that gives us our multiplication
table as well
and we can then write this as a function
wrap it in braces replace the sevens
here with the argument
and that gives us our
solution as well
we can even make this test it
we can observe that this is a function
application of iota on the argument and
this is duplication on the argument
duplication is could also be written as
self-concatenation
because we could
express this as omega comma omega
so now we can write this testedly as
self-concatenation with iota on the
right
and
then this is our tested equivalent
let's have even more fun let's eliminate
the iota how can we eliminate the iota
well if you take seven and use it to
reshape one we get seven ones
and now we can do the same thing the
cumulative addition on those
that gives us the equivalent of the iota
and then we can proceed as before so we
can write this testedly using the same
technique as before you want the
cumulative
vertical sum of the self
concatenation
reshaping
the cumulative sum
of
reshape with the right argument of one
so now we can apply this and we get our
multiplication table yeah i know it's
silly but it's a nice exercise and can
give some insights into the relationship
between
the functions
and we can even take this uh one more
step
we can
by saying that instead of one here we
can observe that a scalar has a total
count of elements which is
one
so we could
use this as well
let's do
this step by step
we take the self concatenation and
reshaping the one and then gives us all
ones
and then we just need to do the
summation
and row wise
and then we can do it column wise
like that and we can all we can put all
this together to a single tested
function as follows
we just
this one stays as at the top at the end
and
the horizontal summation becomes on a
top on the reshape
and there we go we've got
no iota and
uh you're not even implement yeah and
then
just defining everything in terms of
cumulative additions
okay so we can see that it's not a
problem to
implement this multiplication table
using
other functionality than out of product
let's take it one step further let's get
rid of all apl operators now we're only
allowed to use functions
okay
how can we do this
well what we can try to do is we can
start by generating our numbers
and now we can
recycle these
until we have enough numbers for them to
fill the entire multiplication table
so this just repeats them over and over
again
and then we need to multiply them with
the corresponding numbers which means
the first seven numbers here need to be
multiplied by one the next seven needs
to be multiplied by 2. so if again we
start off with the numbers from 1 to 7
and we now replicate them by 7 each
and now we can put these two things
together
and those are the numbers in our
multiplication table the only thing we
now need to do is to reshape them into
the right shape and we've got a
multiplication table
we can write this whole thing as a
function simply by replacing all the
sevens here with the name of the
argument
and there we have it
multiplication table
implemented only using functions no
operators if you don't like operators
there are other fun ways that we can do
this and we can take again
reshaping
the numbers over and over
and then we can try transposing that
and then we can see that all we need to
do is multi now we have the
corresponding vertical numbers as in
when we had the outer product and the
cars and and the horizontal numbers as
we had with our as the right argument in
the
uh for multiplication in the outer
product and then we only think we need
to do is multiply these two together
so in other words we can say that we
take this and multiply
with its transpose
and we've got a multiplication table
right there if we wanted to make this
into a function we could just wrap it
again
alternatively we could give it a name
but there are even simpler ways of doing
this
and that is by relying on apl's scalar
extension
you can always scale or extend
by using a scanner function together
with an enclose
so how is this going to work well we've
got our numbers from one to seven
and then we can enclose that it makes it
a scalar
now if we pair up these two
then then the scalar one two three four
five six seven gets paired up with one
and paired up with two and paired up
with three
so we can simply write iota seven
times the enclose of iota seven
and that gives us the rows of our matrix
the only thing that's missing
is mixing the rows into a proper matrix
and we can write this tacitly
simply removing the arguments so here's
we have a fork we have enclosed iota
applied in the argument and the yodes
are applied on the argument so we can
get rid of the mention of the argument
and make it
0.3
and we need to enclose off the iota
and there's our tacit equivalent
solution
now what you can observe here is that we
are computing the range the iota first
and we can actually break that so to say
out of the expression
by making it in the top
of
an iota so we want the enclose of iota
and
the identity of the iota
and then we mix that and that's applied
on the iota itself so this is a more
efficient silly solution
finally for the ultimate
challenge
is to implement the multiplication table
without any arithmetic at all so by
arithmetic we need to we mean things
like plus and times
and of course this might seem impossible
but we can actually implement
multiplication in the old-fashioned
counting stick
way and there are different ways we
could do it
here is an example let's make it a bit
smaller so we can see what we're doing
we know that iota can generate the
numbers that we need to get multiplied
together by using two of the same
but how do we
how do we actually multiply them
so what we can do is we
each of these pairs themselves can be an
argument for iota
and this gives us and
this gives us and for each one of these
pairs gives us
the indices of an array of those
of those dimensions
but of course
that implies actually some
multiplication say if we have three and
two that gives us an array that has
three rows and two columns and that has
six elements which is because it's the
number of rows times the number of
columns
that's where we're going with it so the
one the only thing we need to do to know
now is how many elements are there in
each one
well if we ravel them
and then we can count how many elements
are there in each one and we just
implemented multiplication table without
using any arithmetic whatsoever
so we can make this into a function
and that works or we could make it test
it
by observing that here we again have
the
um self-concatenation
and we are applying iota on that and
then we have these three loops the three
eaches that we can fuse together
and we've got ourselves a tested
solution
there are other ways
let's look at the numbers again
and now we use outer product and we're
going to write a custom function for the
outer product
the function that just returns a value
the value i'm using here is a hash or a
reference to the root namespace it
doesn't matter at all i'm just using it
as a placeholder value just to show that
i'm not using any numbers or any
characters any values whatsoever it
could have been any array whatsoever as
long as it's just a scalar
oops sorry i needed
the selfie here
so now this gives us a multiplication
table but missing the values we just
have a scalar in each position
however we do have the numbers as
arguments
so we can write
the arguments in here
and what we need we can then do is we
can replicate using this
so we just instead of having a single
reference to the root namespace we now
are going to have one reference two
references three references and so on
and then we can replicate again using
the left argument and effectively
this is a multiplication
it's the replication of a replication
and here is the multiplication table in
unary
we can convert from unary to normal
numbers simply by doing a
tally we've got a multiplication table
so this is another solution
here here's another fun one
we can take
the numbers
and do an outer replicate
on these
so here we have
one ones two ones three ones one two two
two two three two and so on
we can already begin to see where we are
going with this
now what we can do is
that we we need to know how many do they
add up to in total and this is where
where the function where comes in so if
you do a where on each
as what does where do it normally gives
us the indices where where there are
ones in a boolean array
however
so for the first column it will give us
in this index one
and then index one and index two index
one and two and j3 if the but actually
what it does is it gives us this many of
the corresponding index so in the second
column we're going to get
two ones and then the next row
two ones and two twos
etc
and now
we're done
because this is the multiplication table
in unary completely ignoring
those actual values so if we just fuse a
tally on that we have a multiplication
table
it isn't quite a valid tested function
but there are various ways around it
we could
fuse these two together and then it
would be would be valid or
we could
compute iota twice
give it this left argument and right
argument to the outer product that would
also be valid
and finally
maybe for the most basic of
counting on fingers type way of doing
this
let's
try with
with these numbers and we're making an
outer product
on that with a custom function
and we are starting off with the empty
vector
so this gives us
one empty vector for every result these
are placeholders
and now we are going to take a value i'm
using the reference to hash again as
just a
placeholder value
and we're going to concatenate that to
the empty vector so that gives us a
one limit vector for each one
but we're not going to concat it with
cardinal catenated just once
we're going to concatenate it as many
times as the right argument shows so for
and for the columns in the first column
we're going to concatenate it once in
the second column we're going to
candidate it twice and so on
as we can see here
but we're not going to just do that
either we're going to
use to do this whole thing also as many
times as
the left argument says so the first row
we're going to
to
concatenate
this reference to the empty
vector
and we are so the first one we're going
to concatenate it once
once
in the second row first column we're
going to concatenate it twice
once
in the first row second column we're
going to concatenate it
once
but doing so twice
etc
and this gives us our unary
multiplication table and as before we
can insert tally
to generate our multiplication table
of course these are all silly and what
you should be doing if you want the
multiplication table is just the regular
outer product with normal multiplication
thank you so much for watching