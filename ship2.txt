f
course want to
subtract the beginnings from the ends
there we go of course this has a lot of
duplicated effort we are uh generating
this zero followed by the argument
followed by zero
twice there are a couple of different
ways we could uh we could solve this but
actually a neat way is to start with
somewhere else we are doing a
subtraction and we're not subtracting
these masks we are subtracting the
indices of the ones in the masks so
that's the same thing as subtraction
where we pre-process both arguments
using the indices and we have a higher
order function function an operator for
doing exactly
that so this isn't any shorter overall
but it will help us later um so this is
a subtraction of the indices that means
we don't need to explicitly compute the
indices over
here and now we can see that this is
lends itself nicely to a fork because we
have a shared left
argument and we have a shared right
argument and the only difference here is
we have two functions being applied the
lesser than reduction and the greater
than reduction So This lends itself very
nicely to the fork construct so let's
remove everything
here and
this now we have a right argument a left
argument two functions that are being
applied and the result of those become
the arguments to the minus that
pre-processes its arguments with finding
the
indices
and from here on it should be simple we
do the maximum but we also want to catch
the zero
case so we do the zero maximum like
before otherwise we would have the same
problem and um performance issue if we
inject a zero in the data
itself let's compare these two
approaches
then so we had uh
oh did I just overwrite this one let's
go up and rescue that one it's this one
and this one should be called
H and now we can compare our
fastest of the original algorithm which
was G on B and this one h on
b wait a moment to see so these are the
two approaches of uh creating runs and
measuring the length
and Computing it directly from the
indices and we can see that makes a huge
difference so that was a nice
Improvementhello and welcome to this fourth apl
quest check apl wiki for details
today's quest
is called keeping things in balance
here we take a character vector
and
it has parenthesis in it
we need to check whether the parentheses
are balanced so it looks like a normal
mathematical expression or
whether things are wrong say we begin
with closing parentheses that aren't
there or we end with some open
parenthesis
let's get started
let's start by
having a test
data just to see how this works
so we create a character vector
and let's put in some expression there
for example
something like this
okay this is a balanced one
and the approach we're going to start
off with today is that we're going to
find out where the depth of the
parenthesis nesting changes
and there are a few different ways we
can do that then later we'll move on to
actually
finding out whether or not the
parentheses are
balanced or not
a very simple approach and a classic one
in apl
is to convert
the input
into a normalized form
so
we can look up
every character in this test case
the indices of its characters in the
open plan and closed paren
and apl does this that if an element
isn't found in a lookup array then we
get the next index so one and two are
the open and close and three is any
character which wasn't found
now we need to map these
to indicate when the parenthesis level
changes
so
and we
use this to index into
a vector
and we say when we have open parenthesis
then we increase the parenthesis level
when we have a closing
pan then we decrease the parenthesis
level and any other character we map to
zero as it doesn't affect the level
let's stack this together with original
input so we're going to
mix
the concatenation of
the enclosures
with the original
and we can see how when we have open
parenthesis the parenthesis level
increases closing parenthesis decreases
and any other character leaves the
parenthesis level unaffected
so we can make this into a function
let's call this the
parenthesis
depth changes
using indexing
and so it's going to take this formula
but there are other ways that we could
do that you do this
we can in a similar manner
but instead of lookup we can do a
comparison so if we take the character
vector consisting of these parentheses
and do an outer product
with the characters here we get a table
and we can do the same trick as before
to stack up
on top
oops
oh it's a
yeah
that's not what i should have done i
increased the rank which is just
sticking up it's already a matrix there
we go
and we can see here that
the
first row of this boolean matrix
indicates whenever the parenthesis level
increases and the second row indicates
when it decreases
and then the other row is of course zero
and then we can do this clever thing
that we can subtract the top row
from the uh subtract the bottom row from
the top row so the top row minus the
bottom row that's a vertical minus
reduction
and that gives us the same thing now we
need to stack them on top of each other
there you go
all right now we get the same thing as
before so this is a different way of
doing it
and we can call this the parentheses
depth
changes
uh using the outer product over out of
product
um so we can we can even do this as a as
a tested function because it's so simple
and the argument is just the identity
right there
okay but there are more ways we can do
this we can also do the two comparisons
each by themselves
so let's say we take
the comparison to the left
parenthesis
and the comparison
with the right parenthesis
and put them next to each other that
gives us these two vectors we could of
course stack them on top of each other
and then we get just like the other
product but since we're going to
subtract them from each other we can
just put the minus in between and that
gives us
the parenthesis depth changes right away
we can
give this a name and we can again make
it into a tested function because it's
really simple
so we can and it looks very nice as well
symmetric like this so we can bind
this to
equal making equal
equals and left parenthesis
in a magnetic function and subtract
the same thing we can we can put the
because equal is computed so we can put
the argument on either side i'd like to
put it like this because it looks really
cool
so this is the depth uh using a fork um
with the two outer tines equality to the
two parenthesis and then subtracting
the
the two from each each other
um now this is on a tiny little test
case let's get some real data that we
can try this on and then let's do some
performance comparison before we move on
to the second part of the problem
because we haven't solved the whole
thing
yet we need to find out are they
balanced or not
so for that
i'm going to copy in some functions from
the defense workspace and we're not
going to use these functions other than
just their source as example data so
there's a turtle function there's a joy
programming language interpreter
and then we need the comparison and
performance comparison
as well we copy those from defense
right and
they are large functions these turtle
enjoy but not really large enough so
let's create some data we have some data
i know that uh turtle has parentheses
that are well balanced and joy has
parenthesis that are not well balanced i
looked that up before um so this gives
us these two test cases let's call it
yes and no and whether or not they are
balanced
um i'm going to
take the source code of each one
so the vector representation
of each
of turtle
turtle and joy
and then i'm going to make them a little
bit
bigger so we're going to take that
source code and reshape it using 100
times its current shape
and this gives us
some
large test data we can see here that
y
is a bit a bit of a million and
um
n is a couple of million
so now we can compare them but instead
of typing out the expressions with these
three different functions let's use an
apl expression to generate the
expressions that we're going to time
a little bit of meter programming here
so every function begins with a d
and we concatenate that to each of these
suffixes i o and f
and then we concatenate each of those to
the entire
argument y so this gives us
these three expressions
and we can run cmpx on those
and we can see that the df
the one that just that is the fork just
compares it to one parenthesis and the
other parenthesis and subtracting them
is by far the fastest one for these
cases and what if we do it on something
that isn't balanced
and again um interestingly enough here
the i and the o are approximately the
same speed but df still wins out
so this is the first part of the problem
determining when the parenthesis level
changes goes up and down
next we're going to use this
to compute whether or not they're
actually balanced or not
so we can use df that was the fastest
one on our test case that gives us
these ones and zeros
and now
we have to think about what does it mean
that it's
balanced
so
there really two things to it one is
that when the whole input is finished
when we reach the end we have to reach
down to parenthesis level zero
and when we
go along we're never allowed to dip
below zero because that would mean that
we have closed more parenthesis than
we have opened
so we want the
running total the the
of the parenthesis depth that's very
simple we can do that with a
with a scan
and this is then the parenthesis
parentheses depth
and and we also want to know what is the
um
what is the left element whether or not
it is zero that would be the sum
of them and that's zero so now we can
just put together these two
conditions
the first condition being
that it is always true it's true for all
that they are greater than or equal to
zero in the running sum
and also
it has to be true that 0 equals
the full sum
let's give this a name and we'll call it
ba
because we're using this and condition
both this condition has to be true and
this condition has to be true
but we can also do it a different way a
little bit more succinct
at least the first part
if we're saying it has to be all true
that's the end reduction that all of the
elements
have to be
greater than or equal to zero
now the parenthesis level can only
change by one step at a time there's no
double open parenthesis there's only
single open parenthesis and they can
only
go down one level so the first condition
which is to check that we never reach a
negative level
it would have to pass negative one in
order to become negative it might
continue further on but it's a
sufficient check
to see whether or not we have any
negative ones
so we can say
negative one is a member of
the running sum
means it's invalid
and the second and then so now we're
doing it in reverse we're using a
negative conditions and similarly we
have to say that
0 is different from
the sum
so these are things that are not allowed
to be
to be present
and therefore if neither of them are
present
then our expression is well balanced so
instead of having an and we have to use
a nor
so we can call this
balanced using nor
let's compare the performance of these
two and similarly we can create the
expressions that we want so
we start off with uh
ba and bn we could
we can just spell it out since the only
two of them
bn
um and each one of them concatenated to
the entire
yd here uh so we have we haven't
assigned this yet
we should go up and
assign this
so this is the depth
for
y
and we should do the depth fun
for n as well
and then we can get these two
expressions
and cmpx
on that
and yeah it's about the same
you can do the same thing for the nose
and that's a bit faster
and we can probably reason our way for
that
because
in ba
we
did the comparison of everything
in the running sum and then we check
whether they're all true
whereas
in bn we're not doing any comparisons
and
for we're not doing comparisons for all
of the elements we just start looking
for negative one and as soon as we hit
any negative one we're done so the
membership function will just terminate
right there it doesn't have to look
through the entire array so in some
cases that can be faster
and so here bn
in some cases can be faster than
ba and that means we can potentially put
together a whole
solution here
based on these so we take
df from before
and
we
supply its results to bn and that should
give us
the answer and so we can do
f on each of y and n should give it one
and zero and that worked we can we can
also spell it out
um
so
but
we'll come back to that
because there's one more step we can do
let's go back for a moment and think
about what we're doing
the running sum
and the full sum
you can then observe since we're adding
the elements from left to right that
means that the last
element of the running sum
is equal to the the full sum
and so we're actually doing a little bit
of unnecessary work we're summing twice
one once we're summing a cumulative sum
and the other one we're summing
everything again so the last step of the
cumulative sum is the same thing as
doing the entire sum it might drown in
the mass of the cumulative sum but still
it could be a little bit of performance
gain
so being that we found that bn was the
fastest let's rewrite that and so to say
break out
the
scan and just pick out the right element
from this scan the cumulative sum
instead of using a new reduction
so let's break out the scan here
um and we do that
put the scan outside
and that means that the
um
this scan is already just
the identity
but since we now have just a single
argument with a dyadic function we can
just glue those together with a bind
operator
and then we have zero is different from
and this
is the last element so the last element
of the
of the scan we can also just write that
as a right reduction
so this is bns
and now we can try to compare them
so we can say we're looking at
bn
and
bns
each one concatenated to
the yd
and we got a bit of a speed up there
and we can try it again with nd as well
and we got a bit of a speed up there
again
so while it's not all about performance
this was fairly easy to to
go from one solution to another and you
got better and better performance
so
we can put all of this together
and a final solution
we define f
and then we take the definition from b
and s here
and then we also want
the
parenthesis
comparison
like this
this was the df
now there's one problem we want to apply
this function which is
a fork and then we want to apply this
function which is at a top and this
gives us sort of say three parts it
becomes would be a fork and we would
call this the adequately
the scan that's not what you want but we
can fix this by taking the scan
and moving it
to
be in the top on top of the
um
of the subtraction
and now we have a fork as the right part
where we have uh the two comparisons and
then the scan of the subtraction as the
middle time so the scan post processes
the
result of the subtraction
and then we feed that over to where we
extract the
nest element so we can check that it's
in non-zero and then we can
and also we look whether or not there
are any negative ones in that and then
we do the nor at the end and that is our
solution so this is a really good apl
solution
to the problem
and that's what i would use
now that that's done let's look at some
alternative solutions that are not going
to have good performance but they're
interesting to look at nonetheless
something that would be nearer to many
people especially if they come from
other programming languages and
especially if they come from pearl is to
use regular expressions
and we can do that as well so let's go
back to our test case here and observe
it
we're only interested in the parenthesis
so we can do the set intersection
with parenthesis
just to get the structure that's the
only thing we're interested in
and now we can go in and remove pairs of
parentheses
so here's a set of parentheses with
nothing in them here's a set of
parentheses or nothing in them here's
another one
and then repeat the process until we are
done and if there's nothing left
that means that they've been balanced if
anything is left any parenthesis is left
hanging whether it's opening
at the at the end or closing at the
beginning then it's
unbalanced and that means if the result
of this repeated transformation is the
empty character vector that means it's
balanced
okay how can we define this
so we start off by applying the function
of
intersection
with the parenthesis
and then we can write a regular
expression
now we have to escape the parenthesis
and replace
with nothing
so we can apply this on our test case
and then we can see it removed the first
parenthesis and the last parenthesis and
the inner of the middle parenthesis
and then we just need to do it again
and check whether or not
it is
the empty character vector
we don't know how many times we're going
to do it
therefore we have to say that
we are doing it until nothing more
changes
also known as power match
so applying it until there are no more
changes
and that allows us to do we can try this
and
but it's probably a bit much to do it on
the large case well we can try it
oh that worked okay and we can do it on
the uh on the last case of the no as
well and you can see that that worked so
let's call this
regular expressions
and we can just put it up here
that's our regular expression solution
this is not going to be performant for a
apl but well
oh i missed
missing the right argument
that is because oh yeah of course this
is because this is a magnetic function
we want to apply to our argument and
this is a magnetic function we want to
apply to our argument we need to glue
them together to become a top
right there
but regular expressions are very
expensive we have to spin up an entire
regular expression engine and possibly
transform our input to a format you can
understand and get the result back
collect the information extract
information from there we can actually
use quad r it's a fairly new feature
that was added to use quad r it's for
replacements of plane
text from this character vector to this
character vector as well
and we do that
by applying the variant operator where
we switch regex
off
and now we don't need to escape the
parentheses anymore because now it's
just plain text replace from these two
parentheses to nothing
so let's call this well it's not really
regular expressions anymore it's replace
but well
no regex i guess
however
keeping this method in mind we can also
try implementing it in apl and that
might give even better performance
so
now we have to think a bit
we have to find
places where we have an open paren and
close brand and then remove those
well let's look at our test case
we can easily use the find function to
find a oh find we need to remove the
all the characters that are not
paranthesis first
so let's take this and
compare
with this
you can see how it matches every place
where we find open brand close brand we
get a one bit indicating so
however our problem is that we want to
find
to to remove those parts
so we need to indicate
also
where
the closing parenthesis corresponding
closing parenthesis is
let's space this out a little bit for
readability
and what we can do here is we can do a
rotate
so we can do
both this mask that we just computed
and
or when it's rotated one step
and this indicates both the opening
paren and the closing paren
but we don't actually want to preserve
those we want to get rid of those the
way we do that is just by flipping the
the or to a nor
and this gives us a mask indicating just
the characters that we want to keep
so
now we
can say we want
this
just the the text that has the
characters
from an open print close paren
and then we
glue this together so we have a function
here and then negative one and that puts
it all together and we then we can
filter it using that
so that gives us this now it's not
useful to look at
the original anymore
and then we just need to repeat this
process over and over but we don't need
to repeat removing the parentheses
everything that's not parenthesis we
just need to repeat this squeezing of
away open paren close paren so we can do
the same thing with
power match again and then
we can compare
to
the empty character vector like that so
we can put all this together here we've
got
we can actually put it
atop and glue this together again
and this is using find
so we can try
uh find on each of y and n and it gives
us one and zero so now we basically
implemented the same transformation that
we used regular expressions and then the
quad r just for text replacement and
we've now implemented that same
transformation in raw apl
we can do
a comparison
of the performance of these so we have
re
and re0
and fi
and we're comparing them to
y
so
and we can see that
the regular expression engine it takes
is very heavy weight it's much faster to
do it either with replace without regex
or implementing it ourselves
and we can do it on end as well
and a similar thing so
it's probably easiest to implement it
just with the
text replacement that's built in
but if you implement it yourself you can
get a little bit
more performance right there
and finally uh some kind of joke
uh solutions that we can kind of
circumvent the problem because this kind
of parenthesis matching is already
happening in well in mathematics in most
programming languages as well when apl
evaluates an expression it has to do
this kind of thing as well
um
such an expression as this can of course
be evaluated as apl
if our parentheses don't match
then
april will tell us that there is
unpaired parenthesis
that means
the apl interpret itself somehow has
this
same functionality built in and we can
leverage that
and the same thing happens we if we use
braces that are not
in in defense that are not paired up
correctly then
ap let's tell that they're unpaired
braces
let's see how we can abuse this
we can start off
using the braces
and doing the same mapping as we did way
in the beginning mapping to 1 negative 1
and 0 and here we'll map the input to
braces instead
so we look up the in open and close
parenthesis
and then we use that to index into open
and close phrase and a blank
so this gives us an expression
which doesn't do anything useful it
won't be able to actually run
but apl's parser will protest if it
doesn't look right
how in order to force apl to actually
use this function we have to
execute it and that returns a function
with a strange display form that's not
very interesting
the only thing we want to see is whether
or not this errors are not
now if it does error then we can catch
that error if it doesn't error we need
to apply this function in a way that
won't error
and how can we apply a function that's
completely meaningless and doesn't do
anything it will just result in the
value error
well
we can take this function
and reuse it to reduce over a scalar or
one element vector reducing over a
scalar doesn't change that scalar at all
so apl will never actually use the
function it just registers that it's
there and will error if the function
doesn't work
so
this should work fine and if we try to
do it with an expression that doesn't
work like what we did before
then we should get an error
so the only thing that's left here is to
transform this into a function
we wrap it in a in a defend put in an
error guard
if we get any error
then
it's not balanced and otherwise uh we
it's going to reduce over the one and
reducing one doesn't change the one so
that's the one that we want for result
so this uses
nesting
depth of defense
we can try
try this but i think we'll run into a
problem that the test case is just too
big for the parser to to deal with
yeah this isn't working
why isn't this working
given giving the wrong result
oh yeah of course um i know why it's not
working because the test is cases are in
fact too big so let's just try it on
the
vector representation of turtle
and joy
okay now it's working um the the reason
is giving it a zero is because the error
guard is catching the air condition that
the expression is too complex for apl to
parse
so this is working
um
and here's another approach using
stranding
of parentheses so let's say we take
we start off the same way
by extracting just our parentheses
and then we
concatenate a one in front
of each character
and we also concatenate a one
in front of everything just in case
the expression is empty
and now we should be able to to run this
we can we can execute this in apl it
gives some nested array
but this will force apl to check whether
the parenthesis level is uh working so
we just need to we can format it to
flatten it
um and then we can we can try executing
it and then we just need to see whether
or not that will work so if we hit any
error return a zero
otherwise
we
ask for the first element of this which
is of course going to be one because uh
we should maybe flatten it as well
just in case it's nested
because it's all once everywhere and
this is using nesting depth of
parenthesis to parse this and we can try
it
and what we had before
so this is for joy
and it's okay and for turtle
oh this is not right
this is not working
so
see here oh of course we put a t here
instead of putting an omega was silly me
okay
turtle and uh joy yeah so those you give
the correct result and of course the
performance of this is going to
absolutely hurt i'm not going to bother
you with this these are just some fun
solutions of abusing the system
thank you very much for watchinghey this Quest
is
to take arguments that would be
arguments to the dyadic transpose
function
and see if the left argument is valid
given the red argument
I have prepared some test list arguments
and some tests write arguments
we can use the example function that is
outlawed
to try these out
What's Happening Here is that we have a
Lambda a function
and we set up an error guard that says
if any error happens then we return 0
meaning it's an invalid left argument
otherwise we're going to return one we
do that by actually trying to do the
transpose
discarding the result and then returning
one so if this works out without giving
an error then we return one
and so we can see that
um in this two by five table of test
cases
the entire top row are the ones that are
valid and the ones at the bottom row are
invalid now the actual content
of
the right argument and even the size of
the
or shape of the right argument isn't
irrelevant the only thing that is
relevant is how many dimensions it has
and that has to match up with the left
argument so let's try putting these next
to each other
we put the left arguments next to the
right arguments but we are going to take
the
shape of
the right argument
oh sorry it should be the shape of each
one of the red ligament here we go
okay
so
we can see here that in order to be
valid
then the left argument must have the
same number of elements as the shape of
the right argument
so that's one Criterion the other
Criterion is that the left argument
must enumerate X's that we want to map
the existing X's to and the X's had to
be consecutive counting up from one but
in any order and we allowed duplicates
so we can see some example of valid ones
this is of course just a permutation
Vector so here we're just changing the
order of the X's
this one we are mapping two x's the
first and the left axes to X is two here
we asked we are mapping both X's to a
single axis
down here
this is almost okay but we're not
mapping anything to the first axis and
there has to be a first axis in the
result so that's invalid and here the
problem the left argument isn't is valid
but only for a Rank 2 array a two
dimensional array but the actual right
argument has three dimensions
over here we're not using integers so
that's invalid you can't
enumerate the X's with fractional
indices
here we have too many and here we have
two
uh to few
because the red argument is empty it has
length zero but it's empty along that
one axis that it's empty along but we
don't have any
X's
on the left
we could also combine this with the the
tally of the X's
and this just gives us the count the
number of dimensions in the right
arguments we can see here that this is
this has is a Zero Dimensional array but
we're trying to pair it up with a list
of x's that has one element so we're
trying to map an axis that doesn't exist
just as an example
okay now let's get started so there are
two parts to this there is the part
about being a kind of permutation Vector
but possibly with duplicates
and then there's the the part where the
number of elements in the left has to
match the number of dimensions on the
right
foreign
the first part whether or not the
argument is a preventation vector
possibly with duplicates so these are
all our left arguments and we're trying
to compute something on each one of them
so we have the Lambda and the each
now
again two parts to this sub problem
there's the permutation part and then
there are the duplicates part
the easiest thing is to get rid of is
duplicates
that we can just do with
the unique function on the right
argument so this gives us rid of all the
duplicates and then we have to check
whether or not it is a permutation
for that we have to go ahead go explore
the grade primitive a bit
so this is grade up let's try some
argument for that what grade does is it
Returns the indices that you would need
to use in order to sort
so what this is saying is in order to
for this to become sorted we need the
third element first then the first
element then the second element and
finally the fourth element
we're not going to saw it
but what is interesting here is that if
you grade again
this is already a permutation vector and
asking for the indices that would sort
implementation Vector is the same thing
as asking instead of
um which element should I take in order
in order to get things sorted then where
we're getting instead where should I
send this element in order to get things
sorted
so if we try this it says send this
element to the second position send this
element to the third position this one
goes to the first position and this one
stays in the fourth position
why is this relevant well even actually
we already have a permutation vector
so
this is a presentation of extra because
it contains all the numbers from 1 to
its length for
and we grade that
so
this gives us again
which element should we take in order to
get this to be sorted so we want element
number two element number four element
number one and element number three
now if you do the grade again which is
the inversion of the permutation
notice that we get back to where we were
before
well it makes sense if this is invert a
permutation and we invert the
permutation twice we should get back to
where we were
that means we can write a function that
checks whether or not a given Vector is
a permutation vector by comparing the
original Vector to the grade of the
grade
so we can write this as the argument
matches the grade of the grade of the
argument and we can try this
this is a permutation vector
this is not a permutation vector
the only thing we're now missing is that
we want to look at the unique elements
not just all the elements if we try this
first on x
um oh right uh some of the
um some of the elements of X are
scalar
but we can fix this by reveling the
argument
right so here we have some that are
valid according to this Criterion and
some of the invalid ones are also value
to put this criteria it's going to fill
the other one but some of the valid ones
are invalid
marked as in value because not being
permutations let's look at X again
and we can see that that's because they
have duplicates
now let's try to compare
with the uniques instead and we don't
need to Revel anymore because unique
itself would Revel if the argument is
scalar
this works
we can beautify this a little bit and
make a little bit more efficient we only
need to compute the unique elements once
let's assign those to U and then we can
just use U
right this takes care of the one
argument
is the one criteria which is that
the left argument must be a permutation
Vector although it is allowed to have
duplicates the other criteria is that it
had to match its length to the length of
the shape of the right government
argument that is the rank of the right
argument
now let's include the right argument
we want the length of the left argument
to be equal to
the length of
the shape
of the right argument
this worked right away but we can
beautify this as well
notice how the quality is between two
lengths
this calls for the over operator which
pre-processes both arguments to a
function
with some other function before the main
operation is done
foreign
now we see that we have two arguments
being given to this main function
but one of them is being pre-processed
by the shape
that we can use the beside operator
which pre-processes only the right
argument to the main function with a
preprocessing function
and finally we just have a single
derived function
which is wrapped in a different Lambda
now that means we can just take away the
wrapping
this is the other part this checks
whether the left argument
is has equal length to the shape of the
right argument now all we need to do is
combine the two
criteria we want this one to be true
and we want
the unique elements
matching the grade of the grade of the
unique Elements which are
the unique of the left argument
this is our solution we can give it a
name
and now we can write
using this name
thank you for watchingwelcome to the apl quest cap wiki for
details
today's task
is the fourth from the 2015 round of the
apl problem-solving competition
we are to implement what's traditionally
called progressive dyadic iota or
progressive index off
it's just like normal index of
but
instead of finding the first occurrence
of
every element on the right in the array
on the left
it consumes
the elements on the left so it's like
without replacement index of without
replacement
and this is a classic problem in apl and
it has been
discussed and documented for decades
the most commonly used traditional
formulation for this
is very well explained in the apl
cultivations
and there's also a link there
to a video where i explain this
so i'm not going to spend too much time
and energy on this just to show that it
works and
how we can update the traditional
formulation to the modern times
let's have some sample data
we got landon and finnegan
and our task is then to find the indices
without replacement
so f isn't found and there are six
elements in london
which means that it should get a
b index seven because that's how iota
works same thing goes for i
n finds this match in
position is three but that means this n
is consumed and the second end has to go
all the way to element 6.
e and g are not found so they're going
to be 7 as well
a goes to the a in london and the final
n while there are ends in london both of
them have now been consumed by the
previous ends and it will be as if there
are no more ends and we also get seven
so the traditional formulation in
question um
goes like this
and if we try it
um on the arguments
oops
made a mistake here
oh um yes
it has they're missing and
no another and um
reshape here here okay um
then we get these results as we uh as we
said seven seven for the f and i
three and six those are the two first
two ends consuming the two ends in
london seven seven the e and g two is
the a and seven is the final end which
cannot find its match because the two
ends have already been consumed
and this all works very nicely
however if we change our arguments into
matrices
by applying table to both of them
and then we get an error
and this is because this traditional
formulation is using trailing axes
and other inappropriate functions
for such a thing but we can quite easily
update it to handle such cases the
problem here is we're consistently in
the wrong way we want to add more major
cells so we need to concastenate first
and then we are taking indices here from
this
vector of indices and but this uses the
shape of
the right argument and we only want the
number of major cells from the
arguments
and that solves our problem for higher
rank arrays now we can notice some
symmetry here it looks almost identical
what we have on the right and of the
left of the middle
iota
and so we could express this in terms of
a single function with that with slight
multiplication becomes the same
for
or the equivalent for these two sides
the only difference here is that we have
swapped arguments on the concatenation
and then we switch which
argument
is being used for the telly
so let's express it like this we have
the right argument
and the left argument and the right
argument we want to do this
preprocessing on both arguments
but that doesn't work because it's not
exactly the same function
so instead we're going to make it into
a train
and the train is going to
we're going to create a function on the
right
which we are then going to
use in commuted form on the left that
commution
takes because that's commuting takes
care of flipping the arguments of
the
congratulation here
but this one is always already backwards
it's right argument on left left
argument all right so we commute it here
and it's going to be commuted right back
again when we apply r over here
then
we have two grades that are magnetic so
we apply those with our tops
and then we want
the tally off the right argument and
then of course when we flip the
arguments it's going to be a tally of
the left argument which is exactly what
you want here on the left side of the
omega
so
this is our solution
a
somewhat shorter
modern solution
so this is the uh the modernized fin ipl
solution let's call that f
and there's also an alternative
formulation listed in the field in the
api's
idiom list
which is much the same and if you go
through the explanations for for this
one
then you will probably be able to go to
have a look at this one and reason about
why it's
the equivalent so i'm not going to
explain that one in detail here either
it goes like this
and then we have something very similar
to what we have here on the left which
we're going to put on the right
but we have some the right argument
indices being generated over here and
swapped arguments of the congratulation
over here this alpha stays constant it's
always the left argument i mean let's
try this
the basic principle here is that we are
using
left argument as a constant um
lookup so that
the indices that we are generating for
the cells are corresponding to each
other and then we are pairing them up so
we have unique identities for the
indices in each array
being paired up
gives us the same result
and just as before it doesn't work on
high rank arrays and just as before we
can fix this by replacing
shape with tally
and
last axis of concatenation with first
axis concatenation
and just as before
we can
get rid of this
repetition of very similar code
by using the reversed
function from the right
the function on the right
is
we have to make it
fit into the the syntax of a train here
so here we have
the tally of the right argument and then
that's going to be the left argument
when we're on the left as as we want up
here
and then we want the indices of that so
we use another top
and here we have the backwards
concatenation do the swap there
look up into the constant that's an agh
train and then we have
a top will grade
over here
some people and i myself included prefer
not to have too many parentheses and too
many nested levels of parenthesis and by
observing that we have a single though
derived function on the right here of
the iota and
a
function that is
a 4 train on the left so there's an agh3
train with another train that's a
fortran on the left
and then
we can see that if we swap it over swap
the arguments of this middle iota we get
a single function derived on the left
and that doesn't need parenthesization
and we can avoid the parentheses
parenthesis
of here as well
so let's swap that over
and remember to commute the arguments of
iota and put this fortrain in problem is
of course that this is a magnetic
function so
we can pre-process the
right argument of
the middle ioto commute with that
another way we could do it would be to
do a post-processing um
of the result of iota but i like the
other style a little bit more because
this iota is going to use this argument
and
the grade atop is just in the way it
just separates the the function here
from its its arguments so you find it
easier to read
like this and that works as well and we
can well if the other one is f let's
call this one g
and we can even do a performance
comparison between these two let's
generate some test data
um so
alphabet uh let's take
a hundred letters from here
or yeah let's do a thousand for now um
to see a proper effect
and we do that make a right argument
which is another random thousand
letters there
and then
we can copy in cmpx from the defense
workspace
and run the two against each other
well
in this case and
f was significantly faster than g and
i've tried all kinds of cases turns out
that
in general f is either somewhat or
significantly faster so that's the one i
would recommend
using
okay with that practical thing aside
let's look at some and
other approaches to this that i'll then
explain fully
one way to go about this is to start
with um
a comparison table
between these two names
so here we have uh one row for every
letter of um
landon and one column for every letter
of
finnegan let's turn this on its side one
way we can
we can do that is by just putting in a
different flipping arguments alpha and
omega so alpha is on the right and omega
is on left
and what's the significance of this
table well it maybe becomes a little bit
easier to see if we stick and
landon on top
and we stick finnegan on uh left we just
have to
make sure that we add another element
which is going to go up here in this
corner
and where they meet so just put a blank
there
so what's happening here is that
finnegan is and has the letters that
need to be given positions in landon
and these vectors here
they represent kind of an identity for
our the letters in finnegan in relation
to the letters in london so this is
saying f in finnegan does not find any
match anywhere in london
and so to i and that's right because
both f and i are going to eventually get
a 7 not found
the ends
identify with
these two ends here these are the ends
that they want to consume and they both
want that so they're going to get
eventually um
distributed these two ends here need to
be distributed to these two ends
then e and g are just like f and i
a
will take
one of the a's which is only one and
then we have another and here down down
here which is a contender for the a's
for the ends in london but it's not
going to get any because they're going
to be consumed by the first
two ends
okay
so
we want to put all the all the ends
together and we want to put all the
letters together that are um that are
not matched so that we can
we can start matching up the available
letters with the ones that are looking
for them
and for this kind of grouping that's
where key comes into the picture
so let's just do a simple application of
key just to see what are the arguments
to the operand um for key
no we're missing an uh an a on the left
here we go so these are the uh these are
the unique rows so this this row is the
not found row this is the n row this is
the
um
this is the a row
and there are four letters
the letters in positions
1
2
5
and 6
that are of the not found type and then
there are three letters in position
three four and eight
that are of the
type where this mask indicates the
letters that they can consume in
london
um
for now we're not so interested in the
in the mask but we want to know where
are those letters and how many of them
are there so let's replace
the alpha with the where of alpha
this gives us the indices that
will need to be distributed
so these are the letters in finnegan
that are asking for these letters in
london
these are the letters in finnegan that
are asking for well there aren't any
these letters in london etc
let's move things around a little bit
and
look at the count because we need to see
how many there are
and if there are enough
so you can still put an
omega here and
this this table here
says that there are four that's the
count of these and there are four
letters that need
to
consume these letters over here there
are three letters that need to consume
these there is one letter that needs to
consume these
and so we can use
take here
to take as many elements as we need
those are the ones that are
corresponding now when we do that
then we and we don't have enough we're
padding with zeros
so this indicates that
three
the the third letter in finnegan is
going to get the index three
the fourth letter in in
um finnegan is going to get index 6
that's the last n in
london
and the 8th letter in finnegan which is
another n
won't be matched
so we can already kind of see our
solution and the result here is already
in here all the information for it let's
make it a little bit easier um to access
so what we're going to do is we're going
to take and pair up so this one
corresponds to this 0 and this 2
corresponds to this
0 over here
if we make what we have on the right
here
into a
into a matrix and one column matrix and
concatenate it to what's on the left
then we get a two column matrix
um
if we just do it like this then
key is going to pad with a lot of
elements because they're not the same
shape so let's enclose it just so we can
see what this is we're doing
see we can see that
um element one gets not found element
two gets not found
element three gets a three element four
gets a four limit five gets not found so
we need to combine these tables and then
we need to
just put them in the correct order
combining them
we can do by concatenating them along
the first axis
that's going to also enclose them so we
disclose them
and now we have all the information that
we need we just need to put it in the
right order we need to sort it by the
first column
so let's do that
we could do the first column sort we can
also just sort by the whole table
because it doesn't matter when the first
column are all unique elements we're
never going to look at the second column
at all
now they're in the right order and
here's our result actually just we need
to adjust these zeros to sevenths
eventually and we don't actually need
the left column either we just needed it
for the sorting so this means we're
getting all the columns and we just want
column two
and then we need to transform our zeros
into
into sevenths so seven meaning one
beyond the last element
position
in
the left argument so one beyond
the length of
the left argument
replaces the values
at
those values where they are
where zero equals them
and that gives us our solution
now
there is an additional problem that is
again high rank
comes to haunt us a bit
um
right what's happening here things are
going very wrong and this would also
happen if our rays were nested and that
is because we're using a scalar function
equality here this tries to compare all
the elements rather than compare the
individual major cells
not only that if they were nested it
would also dig in and create a nested
structure of booleans assuming
the length would be matching everywhere
and we this could even error
so we need to
to write this out a product but in terms
of
match and we can do that um so what we
want is
we want
every major cell from an omega here
com and needs to
be compared to all the major cells
from an alpha
and
so
we can pair up first the major cells
from
from omega
so that's rank negative one with the
entire alpha so we give it 99 as a big
value that's bigger than the rank of
of alpha
so now
what match would see is um in our case a
row on the left and entire matrix on the
right and now it needs to again traverse
that and compare um
the major cells
so on the right
need to be paired up with the entire one
cell which is a corresponding cell
on the left
and then we get our proper result
so let's call this
k for key because it's the keybased
approach the key is doing the heavy
lifting here
okay um a final
approach to this
um it's not going to be an aple approach
but
it's a different way of expressing the
way we might think about this problem
and for this let's use london as a left
argument but i'm also going to use a
different argument which is just going
to be nine for now and it will
expand on that later so nin
the first n consumes here that becomes a
three then we should get a
two and then we should get a
six at the end we can confirm that we
can try that with uh with k that we've
just defined
so three two six
right
what we're going to do is we're going to
literally
go through and consume letters the way
we've been talking about it now we are
not allowed to change anything in the
left argument of a defense so let's make
instead a copy of it that we are allowed
to change in whichever way we'll call
that a
because it's like
alpha um
and now that that's initialized we're
going to
traverse
all the elements in the right side
and for each of them
and we're going to
consume an element of a what does that
mean consume well let's change it into
something that won't match so
the first n in landon which if you
change that into something that's not a
n
then when we get around to the second
end in then
it won't match that end anymore you'll
have to go to the second one so then it
has been consumed
and
how do we find which element to consume
or we can just look up
the element the first match
because once we have consumed it it
won't be a match anymore and we change
that into some kind of symbol that
indicates that it's been consumed
this is an assignment so everything here
is going to be be very quiet
but
we can
discard these assignments every
assignment here is going to result in
the symbol so that's not very
interesting
instead we discard that and instead we
return
this modified array
a
and we can see that the
a and the n and the n have been consumed
we can even
look at what exactly is going on every
time around the loop by printing this
current state of a before
it gets updated
and here we can see the evolution first
we've got the pristine landon and then
we're consuming an n consuming an a and
consuming the final n
however we're not actually interested in
what london looks like when it's being
consumed we're interested in
the indices instead
and it is a well they're they're the
ones right here so we can
print that instead
and uh
we can see that we're getting our three
two and six and then these are the ones
that are being consumed now we don't
want to print them we want to return
them so let's give them a name
and then
every time around the loop here we have
a new value for i so we let the
the function return that instead and
those are the values that we want so we
don't need
our a being printed at the end anymore
and that gives us
our result
but there are some issues that we're
going to fix what happens if i add an
element here that's not found
we get an index error the reason is
because already this
lookup
we
we're going to get
and not found which is one element
beyond which is one index beyond the
last index and one index beyond the lens
index is not a valid index for a
what can we do about that
well we can create a new position in a
which is like a sacrificial position we
just we're going to override it whenever
we need to overwrite something that's
not in a
so let's just add one more element we
can use the same symbol for that doesn't
matter it's probably going to be
overwritten anyway
and then when we look up here we have to
watch out because now a has one more
element and we can we'll get an index
that's too large so we'll
um drop that before we do the lookup
you can see that s got a seven as it
should
further complications well what happens
if this element that we have chosen
as our um sacrificial element or or a
marker for something have been consumed
what happens if that itself
appears
in the array
that does not look right what's
happening
we remember how we when we are consuming
things we overwrite that element
with the special symbol
and so by the time we have consumed n
and a and n our landon looks like this
now we come and look for that same
element we're going to find that in this
position too
so we need a value that's not going to
match
itself at all
and here's a special trick
a kind of nasty one
and namespace we can create a new
namespace
and though a namespace is equal to
itself
even two namespaces that are created
under the same circumstances and are
otherwise identical regards to their
content
they are
passed around in apl by reference and
they have an identity so they don't
match each other
this means that we can use namespaces
that are being
generated
we will make a new namespace um
we could make a new namespace every time
and then we ensure that this namespace
that we are generating here
will never appear in any array because
every namespace has its own identity and
this one has never existed before
we could actually
also just use a single namespace as the
as the
namespace that we're blurring out with
but this itself would work
if you wanted to use a single one that
then we could define it outside and say
put it here
we can use that here as well it doesn't
matter
because that we have it in the lookup
array because we never have any um
any array coming in where we want to
look for this nice space because
namespace doesn't exist yet we're only
creating it once here so this would work
as well
and then
as the error lasting trouble and
it would be a problem if we had high
rank arrays
there are multiple problems here
and
with the first problem we're hitting um
apparently but there's actually
something going on before that is uh the
lookup
um and the problem is that we're
consuming elements one by one rather
than going and
major cell by major cell so we should
change this into a rank negative one
over here
and another issue is that we're
concatenating the wrong way we should
add another major cell which would then
be filled with uh with this element
and finally we're doing uh indexing over
here with square brackets which isn't uh
general we can't index into a general
array using a single call with square
brackets because we would potentially
need training semicolons over here
and that doesn't work so we'll change it
into using the index function instead
right
here
like that
and now we're getting the result we want
um
using high rank arrays as well
so let's call this
n
for using the namespace
and
if we look at
these solutions we found that f was
the
the fastest ones of f f and g and we had
the
the one that was based on key and then
we have the one
the user's namespaces
this over here was an outer product and
that's going to be problematic for very
large
very large data let's say that both
arguments have a thousand elements that
gives us a million elements a million
comparisons
there so that's going to be very
inefficient so we should
change our test cases to something
smaller
let's just do a hundred then
and a new y as well
and then we can
we can
compare them all
so we have x f
y and x
k y
and x
and y
and well it's very clear that
the right way is the old way
so
when you want to do this kind of
allocation which can be used for example
to
con to
[Music]
fulfill orders or warehouse with a limit
a limited amount on a first-come
first-served basis or allocate seats in
the airplane with various classes of
seats then
use the modernized expression from
the
finae pill idiom list and for the full
explanation of that have a look at
the links in the description for the
video
thank you for watchinghi
we have to move elements of a numeric
Vector that have a certain value to the
front of that vector
a traditional way to do this in APL
is to use sorting
but not sorting the vector itself that
wouldn't work rather sorting by a
certain criteria
let's have a little Lambda here
and compare the left argument to the
right argument
now we have indication of where the
threes are
and if it were to sort so all the zeros
came first well all the numbers that
correspond to zeros then
we would have all the threes at the rear
let's
flip the ones and zeros by using unequal
instead
now if we were to sort such that the
numbers corresponding to zeros came
first
then the threes would come first
how can we do that
the grade function
gives us the indices that we would need
to select elements from such that the
argument would be sorted
this says in order for it to sort this
numeric Vector we need to get element
number three first that's the zero then
element number six that's the other zero
and then one two four five and so on all
the ones of course we don't want to sort
the Boolean Vector we want to sort the
corresponding numbers in the actual data
Vector but this will still work because
the third element is the 3 and the Sixth
Element is three and then comes element
number one two four and so on
so instead of reordering the Boolean
Vector we are reordering the right
argument
this indexing square bracket can take
multiple indices and then we just get
all the elements selected by those
integers
and this solves the problem using
grading and reordering based on that
grade
this might seem like a very neat
solution but there's actually something
even shorter and I like this one better
and that's using set functions
let's think of these two arguments here
as sets
what we want to do
is to find the intersection of these
sets that would be those two threes
and the set difference that's all the
other elements
if we can then
put together the intersection and the
set difference
after each other then we have solved the
problem
and this isn't very hard let's start
with
the set difference but that we use the
without function you can hear the name
that it takes the data on the left
without the data on the right which is
the opposite of what we want
luckily we have the higher order
function or magnetic operator which can
flip the arguments of these two
functions
of these flip the arguments of this
function
so here are all the numbers from the
right except the numbers from left or
without the numbers on the left
there's only one number but you can
still be seen as a set
similarly we can take the intersection
that's those two threes
notice how this deals with kind of
multi-sets and then we're allowed to
have duplicates and that's exactly what
we want here
okay then we just need this intersection
followed by
the set difference
and that solves the problem as well
note how we are commuting
both of these are the functions and this
is actually a fork construct this means
that the outer functions these two are
applied to the arguments
and then the results are combined using
the concatenation function
we could also just flip the arguments of
the outer function and then the inner
functions wouldn't need to flip too much
another thing we could do but that
doesn't really make a difference is to
replace the concatenation with a union
being that the intersection and the set
difference cannot share any elements
then that's effectively a concatenation
it's just kind of cute that we are only
using set functions to solve this
problem
thank you for watchinghi
we're going to get a bunch of words and
we have to Center them on top of each
other within a certain
window
and we might need to lose some
characters to make them fit there
so
here are some words
and there are multiple ways we can
detect this problem I'm going to go
through only one that I like very much
and the way we're going to do this is by
first creating a matrix
and since a matrix is orthogonal it it
has the same number of columns in every
row then we're going to pad with spaces
which is great because that's what we
need to in the final result and we just
need to adjust where the spaces go
so we'll start off by making The Matrix
and then we're going to move the spaces
around to the correct positions
we're also going to get the width but
we'll take care of that in a moment so
the first thing we're going to do is to
use the mix function on the words and
what it does is it takes these inner
arrays and combine them into one array
with each element becoming a row in The
Matrix
so now we've got a matrix and there are
spaces here at the end you know we can't
really see them normally
now we have a width that we need to
either extend or truncate to
we want to do this for every row
um so we want to use the the take
function
let's say with the width 10 and we want
to apply that not on the entire array
that would take 10 rows we want to apply
it on each row and rows are vectors so
they have rank one so we use the rank
operator to specify we want to take from
a row from arguments of rank one
um really the left argument is a scalar
so that's rank 0 but it doesn't matter
because if we specify a rank that's too
high we just
leave it with
um the argument in whatever lowering it
has
so now we can see that competition got
truncated and so so did every line
now we can start working on this result
so let's create a little different
Lambda
and we need to move some spaces around
and the way we're going to do this is by
rotation so we can rotate each row
separately we want to take some of these
training spaces and move to the
beginning
let's first find out how many spaces
there are that is how much padding was
added after the truncation even though
we actually added all the spacing first
and then did a truncation we could have
done the opposite order but that would
have required taking the 10 elements
from each which is an explicit Loop and
we want to avoid that
so the argument is referred to as Omega
it's not the same as W
um so here we get the Boolean mask
indicating where we have spaces and we
can Sum along the rows of this to get
how many spaces there are in each row
right in order for something to be
centered we need to
uh
have half of the spaces on one side half
on the other side so we divide it by two
this little face changes the division
sign so that it takes uh what we're
dividing by on the left rather than on
the right now we don't need to put this
whole thing in parenthesis
so we need to move three and a half
spaces one and a half spaces of course
we can do that
um but the problem specification says
that
if there are an odd number of spaces
then we should leave the larger number
of spaces on the right which means the
number of spaces we move to need to move
over on the left is the lesser of the
two adjacent numbers so we round down
so now we need to move three spaces from
the right on the first row one space
from the right on the
um
on the second row and so on
moving from the right to the left that's
a rotation but normally rotation rotates
from the front to the rear in order for
us to rotate in the opposite direction
we need to negate that so now we get
negative numbers
finally
we do the rotation but the rotation
takes actually the amount of rotation on
the left so again we need this squiggle
to move the amount of rotation over to
the left
and we do that on the right argument
and that gives us the result so we can
see here we got two spaces on the right
here and one on the left that's because
we rounded down the amount of spaces to
rotate from the end to the beginning
this is this solves the problem but it's
not an actual function yet it's just a
one big expression that uses an
anonymous Lambda in the middle
to compute the result so in order for
this to become a function we can give it
a name it's not necessary but it makes
it easier
you can see here that we have a function
applied to the result of something else
so
um that is at the top it means we can
just State the multiple functions after
each other
and we want to get rid of the arguments
here we have this function is
the diadetic function
who needs to be applied between the left
argument and the 10 in our case and the
words that have been mixed
so this is the central function but we
need to pre-process the right argument
with the mix we do that with this
composition operator
we called beside so it's like we had
these two functions
in the explicit
phrasing we have them beside each other
they're right next to each other and so
this
composition
makes them be as if they were beside
each other so this will insert the left
argument here and the rest insert the
right argument over here and then
evaluate that and then on the result
we're going to apply this function over
here
so now we can try it 10 f
w
thank you for watchinghi we have two DNA strings and we are to
find out how many of the characters the
DNA bases are different between them and
the same length so this is
easy um here's a sample and if you want
to see which ones are the same then we
can get the mask like this and if you
want to know which ones are different
then we can can do an
unequal and then we all just need to
know how many ones are there here but
being because true and false and APL are
and represented by one and zero and
since they are just numbers they're not
separate type we can just sum them uh to
and summing them is using plus reduction
so we we reducing the result of this
because every function including this
derived summing function has long right
scope so we take take everything on the
right as argument um so the result of
this which is the mask get summed and
that gives us the number of
differences um this isn't a single
function we could uh wrap this up a
little bit as a function so we can uh
call the left argument Alpha because
it's the leftmost ele um character in
the Greek alphabet and the right
argument is called Omega um and then we
can put races around it to mark it as a
Lambda and then we can give it a name or
we could call it directly in line so now
we can go up here and um apply our
function to get the same result we can
actually be much shorter than this even
though this doesn't look like much um
and that is because we can switch to
test it
mode the way we do that is test it means
you don't mention the
arguments and if you just remove the
arguments and also the braces uh let's
give it a new name then we
can do it like that that works too um
however this definition We cannot put uh
in line as is if we wanted to do that
then we would have to parenthesize it um
like this there is however a tcid inline
definition that you could put inside and
that is um as an inner product so inner
product um let's let's try that first so
if we say 1 2 3 so we have two vectors
or they could be scalars it could also
be higher rank array but that's not what
we're dealing with here and for um up to
one dimension then the inner product is
the same thing as a reduce over the
result of a scalar operation also known
as a map reduce at least kind of because
it takes two arguments so uh let's take
10 100
1,000 and and the inner product uh
simply pairs up elements with the
corresponding element over here so this
is uh 1 * 10 + 2 * 100 + 3 * uh 1,000
and therefore um we can just replace the
multiplication with the unequal and the
plus stays the same and that would still
work so if we could do that here we
simply replace a slash with a DOT and
that gives us this and this because this
is is a diic operator it combines these
two functions to a new function and this
is constitutes a single function whereas
this before was two adjacent functions
uh the plus slash is one function
derived from this mtic operator higher
order function um that makes the
reduction and the unequal which is um
its own function uh so we have two
functions here we just have a single
derived function and so we don't
actually need the parenthesis and like
that so we can uh can call it that as
well
and then we can go up and apply it here
if you want to do that thank you for
watchingwelcome to the apl quest see apl wiki
for details
today's quest
is the sixth
from the 2014 round of the apl problems
of the competition
we are supposed to count the number of
ways that you can
throw any given result
with a given set of
dice
and so this isn't a statistics
of what the chances of getting a
particular result but just counting the
number of ways
a very simple approach to this is
exploiting the magnetic iota or the
index generator so let's say we have
two dyes
that have six sides so there's a normal
dice
um then the indices in an array of the
of that size six by six contain all the
different possibilities that the dice
can show
and so this means that if we sum each
one of these
lists of
face values
then we get all the
the sums
then
uh revenue that result gives it as a
single list and finally we can use key
to
and summarize
we are not interested in the actual
position here we're interesting in the
count so we take
the particular value
concatenate it to its count
and apply that
with key
and that gives us the result that we're
looking for
we can give this a name
this uses an index generation so we can
call it i
like this
however it does have a problem uh
besides for performance which will come
right back to and that is that since
it's generating an array
of the given dimensions where every
element is the index of that element in
in the array then it is subject to
dialogue apl's
limitations in the sizing of arrays
and as it is today and dalek appeal does
not allow arrays that have more than 16
dimensions rather more than 15
dimensions even um indeed if you need
more than 15 dimensions you might be
doing something um
wrong or at least a little bit odd
so if we try it uh let's say we here we
have um
two-sided dice
this actually means that like coins so
the coin flips
um that's all very good so we can either
have both of them showing uh showing a
one or both of them showing a two or one
of each
which means there are two possibilities
but let's say we have a bunch of coins
let's say we have 15 coins
um then
um
a lot of possibilities like this and
it's perfectly reasonable to throw than
16 coins as well problem is
that
we're not allowed to generate an array
that has this rank that has 16
dimensions
furthermore there's a problem of
performance here as well because we're
generating a nested array with one every
element is a pointer and because every
element is in itself an array
uh not just a simple scalar
um and
that is a bit wasteful in representation
and dealing with it
but we can achieve the same result in a
not too complicated way by observing
that the number of uh of elements in our
resulting array and it is clearly and so
in the two-dimensional case it's in
six by six whenever the both of them are
six and in general it is the product of
the dimensions and along every axis
so all the possibilities um is the
product
um off
of the number of sides and all the dice
and then
we have all these uh
values
um
although we should start with
with zero
you know because we're going to use um
we're going to use
mixed radix representation here
and so let's let's just take it for six
for now
um
and then so this this gives us this
gives us some a long list of 2 36 35.
now if we then represent this
in the radix of 6 6
then every row represents the the value
of
one die and so so the first row is the
first die and the second one is the
second die
and then we can get uh the sum the only
problem here is because we're counting
up from zero rather than from one we
just need to increment again
and then
we can
go and sum vertically
and that gives us the total sum
so here we managed to do it without
having nested arrays just direct
computation based on
the mixed radix
in this case that's the same radix but
it could be anything of course
and then we can proceed as we did before
uh by concatenating the value with how
many times it appears using that the key
and we can call that
e for encode because using encode over
here
to generate all the values
and then we can try it with 16 coins
and that works just fine
it will also be nice to see as i
mentioned there might be a problem with
the
performance of it because it's necessary
which here we're dealing entirely with
flat arrays so let's compare that as
well
we're copying in
cmpx from the defense workspace
and then we need some test data this is
a little bit interesting what kind of
test data there's no limit of course you
can throw as many dice as you want and
they can have as many sides as you want
so we can try to
make some
variation of of cases so let's just
start with small cases we can see it and
then we can scale it up so in fact we
can have a diet that has no sides at all
in which case it doesn't really
contribute but
we can still include it
um so
let's just start here with from uh
from zero to three all right so we can
have we can have a dice that have no
size but they don't contribute we can
also have no dice at all in which case
the result obviously is zero but we can
include that here so here's between zero
and three
dice
and then for each one of them
we use that number to replicate uh the
number of sides on a die um so here
three just to keep it small
and that means we could we could also
for example uh roll them like this so
this is these are
dice rolls with zero one two three
dice that have uh three sides
each
what we really want is we want all the
possibilities because maybe maybe we
have one diet that has
two sides and one has three sides one
has one side
and then we can we can do it like this
so this gives us a a grand table of with
zero one 2
and 3 and then
um all the different die sizes so we can
then combine all of these
into a single list so we can
do a concatenation reduction over this
list of
multi-dimensional
arrays we need to flatten each one
before we do that and then disclose
because we have reduced them
and that gives us
our
giant list of
die hands that we can then throw
and now let's scale this up a bit and
there's not really any
given
limit to this so i'll just say between
zero and four dice and the dice can have
up to
nine sites each and these are our test
cases that's count how many test cases
we've got we've got seven thousand
something in this case so that seems uh
well enough
okay so
cmpx and
and then we have i or the one that used
iota to generate
the indices
on each one of these test cases and then
we had e
which was the one that used encode on
each one of these test cases
oops
did i make a mistake here
oh yes of course
there's a mistake in
uh in our definition of e
uh and that is because i forgot to
i forgot to revel here the problem is
that
um we can be given the argument as a um
i guess a single number as well
um and then um we're going to missing
out in the rank so we need to make sure
that uh
the left argument to encode is also a
vector
um we can do it like this or we could
use the over operator to make sure both
the right argument is always going to be
vector anyway because we get it from
from iota
so let's try that again
and we can see that
avoiding the nested arrays can give us
some significant speed up there but
there's actually more we can do
um and that is
looking at key so for key
here we used a tested left operand
and there are some special cases and
this is exactly one of them
where we want the
the value concatenated with its count
and that has been highly optimized if
you state the operand as a defense so
left argument
concatenated with the tally of the right
argument instead of that and this seems
like a very small difference but this is
the defen inner
key
and then we can compare the performance
of
e and e d
and we should see a significant
performance improvement there too
there we go
so
playing around a little bit and trying
out the the operands for key can
actually make a big difference
and there are some
some combinations that have been special
cased and run much faster
thank you for watchinghi we constructing concentric rings of
numbers where we're given a number as
argument and that goes in the middle and
then we keep decreasing the numbers as
rings around it until we reach
one
and we can do this um by generating
first the sequence that we want want
going from the
um outside to the inside so let's say
the argument is
five and then we want a ring in the
middle well that's which is just a
single number which is five and then
ring around that for four and then three
around that two around that one around
that so it's going to be um large like
this okay let's um start working on this
as a uh tested function that takes us
argument uh the this sequence that we
generating because we want the sequence
itself and we also want it then in
Reverse to uh decrease once we pass the
center so we can reverse it and we can
get its um
identity and we can concatenate these
together
oops but now we get a duplicated middle
element which we don't want so we can
drop the first one of the Reversed
argument the Reversed sequence and that
gives us the middle row or middle column
in the final Matrix that we
want so all we now need to do is expand
this to become a matrix where we um sort
of say uh rotate around the
middle and one way we can do this is and
as if we were making a multiplication
table so for a moment let's try make a
multiplication table that's J J jut do
times uh selfie or commute so this is an
outer product and then we are using uh
the commute to take this argument over
here on both sides and this gives us a
multiplication
table so we can see that five can 25 in
the middle and then this is 4 * 5 is 20
over here all the way up to 1 * 2 and uh
2 * 1 and then one over here of course
we don't actually need a multiplication
table what we want is that uh the lowest
value from the rows or the columns
should Prevail so over here we want it
to be a one and over here we also want
the one and here we want the two and so
on then five in the middle so we want
the minimum function so the minimum
function is written like this it's like
uh a vertical bar with an indicator line
that shows the minimum uh
value
and then that gives us exactly the
result we want now this is an expression
but we can easily convert this to a
function f and then we can apply F and
that solves our problem thank you for
watchinghi we are to build a
staircase and the way it works is that
we're getting a number and we have to
create a matrix that is this wide and
high and the bottom right including the
diagonal um of this Matrix should be the
quad character this little boxy
character and the other one should be
spaces so if we get five we need to make
this little
staircase and there are a few different
ways we can do this let's get started um
we created a little Anonymous Lambda we
can always give it a name later and for
now sure let's use five as
example we need to create something that
is the bottom right
so one way we can think of this is It's
a range going from the top left to the
bottom right let's create a range that's
Iota for It's Greek letter like I for
indices is the indices up until the
argument the argument is Omega because
it's on the right and it's the rightmost
letter of the Greek
alphabet but this only goes in one
direction we need to go two directions
so this call for some kind of table and
something that goes diagonally uh
increasing towards the bottom right from
the top left um is an addition table so
if we create an addition table we write
a jot and a DOT and then the function we
want this an out of
like an outer product but it's an outer
addition and we want to use this Iota
Omega on both sides so instead of
writing it twice we write the selfie
operator or also known as commute its
official
name and here we can see how it
increases uh towards the bottom right
and once we reach above the number we
were given then that's the parts that we
interested in so if we compare if the
argument is less than and then APL will
will map automatically the single number
to all the numbers that are in this
table then we get this Boolean Matrix
and a represents booleans with zeros and
ones and that's really convenient
because since it's just a number we can
add to it in order to get
indices remember we're counting from one
like we can saw we generated indices
from one and we can then use that to
index
into the space character and the quad
character then we use square brackets
for indexing
here and we've got ourselves a solution
so let's call this one F and we can
apply
F
however if we think about this a little
bit we're doing too much work we're both
doing an addition and then a comparison
when we really could just do a
comparison from the outset so if we do
an outer comparison table
instead then we do get a triangle out
this triangle is not right because it's
the top right corner and we don't have
the diagonal but the zeros here they do
form kind of a triangle that we want
except it's on the wrong
side so what's the opposite of less
than well that's greater than or equal
to okay well we can definitely build on
this the only step that's missing now is
reversing so this we can see the axis
over which we are doing the flip it's
we're flipping horizontally over that
vertical
bar um kind of like spinning a globe and
this gives us what we
wanted so if
we call this
G and we do the same thing as
before we've got G and apply to five and
that
works but we can actually do better
because um let's think about performance
here we are creating a whole Boolean
table and if we were to use a big
argument this table would be rather
gigantic and then we are uh reversing
this entire table all that's happening
here is that we're doing a
comparison of the elements going down 1
2 3 4 5 with the columns 1 2 3 4 5 if we
reversed the columns so we would get 5 4
3 2 1 then the tall side of the triangle
over here would end up on the right and
then it would be created from the outset
in the right orientation so how can we
do
this let's uh try this so we've got this
Auto product we've got the Yota 5 and
we've got an aota 5 and all we want to
do is reverse the right
side like that
but we really don't want to compute aota
5 twice so what we can do is go back to
using this selfie
operation but right before we create the
table we want to pre-process the the
table functions right argument with a
reversal so jot in this context not the
same as this one it has a function on
the right and on the left
we essentially apply this function
that's on the left but be right before
we do that we pre-process Its Right
argument so
pre-process with a
reversal and that gives us this table
right away which of course allows us to
write um a new
function that on just the same pattern
as
before G25
I forgot the one
plus there we
go
okay should we compare the performance
of these two let's do that so we copy in
the compare
execution uh utility from the defense
workspace and it just takes Expressions
so write cmpx and then we running G on
say a th000
and G2 on a th000 and then we wait a few
seconds for it to run these a lot of
times so we get some averaged out
results and we can see that we pretty
much have the runtime simply by um
reversing arguments to the table
generating function instead of reversing
the resulting table can we do
better actually I think we can because
if you think about it so let's say with
a th000 we generated a table here with a
million elements and then we added one
so that's a million additions but
there's maybe something that's worse
than that today computation is really
fast what's slow is memory
throughput and APL is clever it stores
arrays in generally in the smallest data
type internal data type that it can so
this Boolean Matrix is stored as single
bits in memory smallest units of
computation in the
computer once we add one we have to
switch to an integer
type and the smallest integers we have
available are 8 bit integers which means
we're using eight times as much memory
for to store this Matrix compared to
just storing this and what can we do
about it remember that we were counting
1 2 3 4 5 we're counting from one if we
switch our system to count from zero
instead then we don't have to add this
one we can use the booleans directly to
index into this character vector and
over here what happens is that instead
of getting 1 2 3 4 5 we get 0 1 2 3 4
they still have the relative size the
same to each other adjacent elements
increasing um monotonically and um never
two elements are the same so it doesn't
really matter what our numbers are in
these indices as long as we're just
counting up so how will this
look and we have a statement
separator diamonds are unbreakable so
two we can't Traverse from one statement
to the next one and in here we're
setting a system variable called quad Io
Io doesn't stand for input output it
stands for index origin so we're setting
the system index origin to zero and it
will be local only for this function and
then we can remove this one
plus wonder how how big a difference
this will
make look at that we just have our
runtime again which means that G3 has
about takes about a quarter of the time
with argument 1,000 compared to the
original G but pretty much using the
same
method
okay let's look at a an alog together
different approach now we're going to
take the
quad character and we're going to
manipulate it until we get our desired
staircase the way we're going to do this
is we're going to replicate it so we can
write three and a slash that's replicate
this we get three of these if you write
two three then we can replicate each so
the two replicates this and the three
replicates it and we get this
list if if we do Iota 5 then we get all
the components we need for our staircase
but they are so to say
disassembled we can assemble them with
mix this increases the rank the rank of
a vector is one and we want the rank to
be two wanted to have two Dimensions be
a matrix by breaking this levels of um
of
structure so here's our staircase and
now we can reverse it
um but this is not a proper function we
can write it like
this however I think in this case the
tested solution one way we don't mention
the arguments explicitly is a little bit
nicer so this
works but if you use a fork
constructs then we need an we can have
an array on the left that's that
quad then we wanted the replicate each
but now we have swapped the arguments so
this array is on the left and the counts
on the right and for that we use this
same symbol as we did before the selfie
but this time it is used with an
argument on the left so we don't use the
right argument also for the left we use
the right argument on the left and the
left argument on the right so it
commutes it switches the argument
order and all we need on the right
is the counting up so the way this this
works is a tested function we don't need
the braces we can put parenthesis just
to separate it from the
argument is we apply this function then
we have our array and then we apply this
derived function between the results
this one and well it's result it's just
a
value so this is this works um then we
have a mix which is fine but we can't
just put in a reverse here this will
break the structure because we would
have the result of this and the result
of this being combined as with being the
arguments for this function which is not
what we want we want these two to be
joined into a single function we could
do that with the top operator which um
applies this to the result of that and
derives a new
function so this works now we don't need
the parenthesis since we're not applying
it let's call this
h
however um we can phrase this a little
bit nicer it's a bit nasty to create
this extra level of nesting and then
just destroy the level of
nesting we can instead do a mapping of
cells in the argument so over here we
have a vector and it Vector is one
dimensional it create it consists of
numbers that are Zero
Dimensional this is is itself a Zero
Dimensional um array it's just a single
character so we can say I want to
assemble a new
function I want to sorry I want to
assemble an a result based on this
function we're creating a new function
which is like this one but Maps together
arguments of rank Zero from the left and
rank Zero from the
right and then take these results so
each one will become a vector and those
vectors have to become the components in
our overall result array so vectors put
them together make up a matrix and for
that we don't need a um a mix anymore so
we don't do the mix here which means we
can just insert uh the reversal here
let's call that
H2 so now we can do H2 and five and this
also works it looks a little bit neater
than the uh than the original H one we
have
here the performance of these two is
probably going to be about the same
because the same thing is happening
inside we can you can try it out
though yeah that's within fuzz
tolerances it doesn't really
matter but there's a whole different way
we can do this instead both of these
Solutions the H Solutions are
essentially loopy Solutions we're
mapping over explicitly um and creating
the rows by themselves and then joining
them uh together here is a very
different way of kind of doing the same
thing and that is by exploiting the that
replicate which we saw before it has
some extra tricks up it up its
sleeve um we can
do um negative numbers and negative
numbers they create um a replication of
that
element that is the same as the positive
value but instead of using the actual
data the actual value we're using a
prototypical value and as we saw with
the the mixing the prototypical values
for this quad character for any
character is the space which is exactly
what you want so if you write -2 3 here
and we only have a single element we
could do an each but it doesn't matter
uh let's let's do the each just to see
how it looks then we can see that over
here we got two spaces and then three uh
quads if you don't do the each they get
joined
together so we get two spaces and three
quads like this o but this means we we
can explod this looking at
our staircase over here we got four
spaces and one quad three spaces and two
quads so if we start playing with this a
little bit we've got a Yota 5 and we
want each number to be paired up
with well with what exactly well first
we have a one and then we want four next
to it so that's 5 minus one gives the
four and same thing on the next line
we've got two we want
three minus 2 uh sorry 5 - 2 is three
but we actually want negative numbers so
we can flip the arguments of
those so let's try
this we do five minus this we get these
numbers if
we take this and put the five over here
on the minus we get the negative numbers
so now we need to join these pars
together with the original
numbers and there are a few different
ways we can do it I prefer to go
directly to a tested solution so we've
got numbers from 1 to five and over here
we um we have the number five itself
being passed
in and then we have another function in
the middle we want to um
subtract
so this gives us our negative number so
this are the indices up to five minus
the five itself this is an identity
function but we don't just want that we
also want the original numbers so we
could get those with the left identity
so this points the finger at this one
and now we just want to combine these
two so we want the minus and we want the
left identity and we want them
concatenated together but not one after
another we want them to be in two
columns in pairs so we want every scaler
from here paired up with every scaler
from here and we did this before with
the rank operator so we want to map over
subarrays of rank zero these are the
simple scalers and that gives us this
table right now we
can use this directly each row to
replicate our quad
we're using the rank again uh we need to
remember to swap the arguments because
we have the array that's being
replicated on the left and this time we
want to map over rank zero on the left
and the one on the right but the rank
operator actually allows us to remove
the zero because if we ask for something
that's higher ranked than it has here
rank one and it only has rank zero then
we just use the highest rank that we
have which is
zero that gives our staircase directly
okay let's remove the out of parenthesis
and call this H3 it's the same kind of
idea of using replicate but and this
time we are forming the pairs that form
every Vector in itself so
let's uh compare the execution time of
we know that H1 and H2 are about the
same so we can we can compare H2 uh
1,000 with H3
1000
and that was a pretty significant speed
up okay so now we know that uh when
we've got the F and we've got and the
G's we can actually look at our
definitions um
here and we know that uh G3 is uh the
fastest one of the G's and H3 is the
fastest one of the H's so in order to
conserve a bit on space and time uh
let's compare the performance of the F
and the fastest G that was
G3 and the fastest
H so uh um we have here that
G3 is the fastest
one we can see that an F is
significantly slower it would be
interesting to run the test again using
just G3 and H3 because when something is
very much slower than others it tends to
skew the
results okay we can
see the trend
here and that's
ithi we're going to find the end points of
one array in another
array
so here's the
thing APL has a primitive function a
built-in which finds the beginning
points this can be a little bit hard to
visualize so I'm going to
stack Mississippi here on top of the
boan result that we get spreading out
the
letters here we can see that we're
searching for iy and we're finding that
it begins here and it also begins here
stretching towards the right the result
that we want is with the ones being here
and here meaning where they end they're
basically uh two easy ways to do
this one of them is to note that we
already have these ones in the right
relative
locations but they're just offset from
where they're supposed to be we need to
move them towards the right by how many
steps
well it has something to do with the
with the length of of the match but if
we were to move four steps to the right
then we would end up one beyond the m so
we need one less than that okay let's
just try
this so we're going to take this
primitive and we're going to wrap it in
a Lambda so it makes it easier to change
its
result and we can rotate with the rotate
function and well that rotated One Step
left to to rotate right we want negative
numbers okay and then we said that it
has something to do with the length of
the left
argument what happened
here oh this is again to the left so now
we want to negate this so that we are
moving towards the
right okay so we can see that we got the
I here but the one is now one step too
far so really we would want to subtract
one from uh from this we can addtive -1
to the length and that gives us the
result we want but we can actually
simplify this a bit because subtracting
one from a number or adding negative one
as I've done here and then negating it
that's the same as subtracting that
number from One oops subtracting that
number from one right there here we go
so this formula will will
work um we can reduce the amount of code
a little bit um by observing that we've
got kind of a fork construct what do we
mean by a fork it means that we have a
middle function here that takes the
result of something in the terms of the
arguments and something else in the
terms of the arguments so we can change
this to a tested form changing the curly
braces to run
parenthesis and then we can remove the
explicit mention of
arguments um over here we do need to
refer to a to the left argument and we
could do that using just functions to
make it fully tested and but we can also
just make this inner expression into a
function so here we have a small Lambda
that's applied to both arguments
ignoring the right argument only using
the left argument and returning one
minus the length of the left argument
and that value is used to rotate the
result result of the find primitive
which shows us the beginning
points and this gives us uh the correct
result so we can take this whole
function here and give it a
name missing that brace
there and then we
can right uh left argument
and right argument and we get our result
so this is one way to do
it another way to do
it is to observe that the fine
function gave us the beginning
points but if we read from the right
instead of from the left then that's
actually the end point doesn't matter
that what we're looking for here is a
palindrome um it's still finding that
from the left and then if you read it
from the right we get the end
points so if we reverse both arguments
we could do that with a over operator
which pre-processes both arguments with
reversal and for ease of comparison
let's also indicate what's going on over
here so let's reverse that as
well so if now we can see that we
are looking for the beginning points but
if you're reading in Reverse that's
actually the end
point so the only thing that's missing
then is reversing the
result and now we've got the end
points can give this a
name and then we can apply it like
this that's another solution thank you
for watchinghello and welcome to this
epl quest cfl wiki for details
today's quest
is the 10th and last problem from the
2014 round of the apl problem solving
competition
we're given a vector of numbers
supposedly non-zero
and we are to say uh what the largest
percentage increase is from
one
number to
the next number
so let's start with a simple test case
from the problem statement
and
one way that we can do this is by seeing
what is the the what are the deltas what
are the differences from
uh
once a month
so we can what we want to do is a
pairwise
difference
over this vector
and here it's all constant but it
doesn't matter
and then we want to see
this increase
what percentage is it of the month that
we started with so
um that means the first 20 is an
increase over the 80. the second 20 is
an increase over the 100 and the third
third increase is over the 120 that is
there's no increase on the 140 and we
can therefore drop the last element
and now we just need to find out what
the fraction is of these so we can write
the first
part
so that's the the increase
divided by the month that the the month
that we started with its value
um and then we get well fractions but we
want percentages we also need to have
the largest percentage and so a good
idea is to start off by reducing the
number of numbers we're dealing with so
we want the maximum percentage
and then
we want to convert it into a
percentage there so we need to multiply
by a hundred and let's make this into a
function that takes an argument
right there
here's an interesting thing
to look at
this negative one drop
another way we can think of it is
that we for every
window of size 2 much like what we did
to get the deltas the differences
we want to select the left one
and we can actually write this
as a pairwise reduction as well but
instead of a normal arithmetic function
we just want the left value
and
if we use a negative number as the the
window size just like we did for the uh
for the subtraction then we will reverse
it
so now left so this reverses the range
so instead of getting 80 100 we get 180
and then we select the left one but now
if we want to get the right value which
is the
the first one then we need to do
the right side instead
and what's interesting here is that if
we take this definition of a
um
and
use
we can replace this negative one drop
omega you can um with this equivalent ex
sub expression here
then especially if maybe if we
parenthesize it we can see a pattern so
and let's start by by calling this one
renaming and the a here
but we could actually
combine these because we are doing a
subtraction
divided by the right side
that means we can we can fuse these
together
to a single
n-wise or in this case negative two-ways
uh reduction and
this parenthesis becomes um unnecessary
and that looks really neat
that doesn't mean it's a good idea to do
it
why is that because
um certain combinations that are
very frequently occurring for example
and a n-wise
or especially two-wise pairwise and
subtraction
and also the right and the left
and those are cases that are special
uh special case in the interpreter and
optimized and will run much faster if we
replace them with our fork like this a 3
train
then the special case doesn't run and
we're going to get significantly worse
performance and we can illustrate this
just even with a not very large argument
so here's a thousand
random numbers up to a thousand
and
let's copy in cmpx from the defense
workspace
and then we run the first version which
uses the two different and
two different anyways reductions and the
second version which uses the fused and
wise reduction but otherwise are
entirely identical
and
we can see that yeah that's that's
pretty hopeless in comparison so we
definitely want to stay with a there
but we're actually not done we can
actually do and
something more
um let's let's look at a again
and then let's uh actually we can we can
start off with with b even let's start
off with b and then and we can do some
uh
some well
mathematics uh deriving some some a
different expression for this um
let's start off by taking this train and
making it into maybe a slightly easier
to read and read even so
let's put in our test case here um so
make sure it's it still works
and then we are replacing this train
with the defense so and what we need to
do here is
we have the subtraction of the left
argument in the right argument
and then
divided by the right argument
okay that so far we've just replaced
the the train with a
led and now
since this is a fraction right we have a
numerator and a denominator here
that means that we can multiply or
divide above and below the
the division and
and the result will stay the same
so
let's divide by the right argument here
and divide by the right argument over
here as well
same result of course just it's a good
idea to check that and we can
immediately see omega divided by omega
that should give us one remember we said
there are no zeros here
at least presumably there aren't
um and then
this is
a
a difference
and they're divided so we can we can
split this up into two fractions instead
so we can say
alpha divided by omega minus omega
divided by omega
and then of course this becomes a one as
well and we have also divided by one
here so that we can eliminate that as
well
okay
and
getting there now
we're doing a bunch of divisions here
pairwise divisions and from every
division we are subtracting one from the
result
that means we could just break out you
can do the all the divisions first and
then subtract one from all the results
instead
so we if we take this
negative one and
move it over here
so we add negative one to that i'll get
rid of this parenthesis of course
and that then we have a little defend
that is nothing but a cover function for
a normal division
so we can just put in a normal division
there instead
and now we're subtracting one from all
the results and then we are taking
the maximum of that that means
they would already that the one that's
the maximum would already have been the
maximum
before we subtracted one so we can move
this
maximum before that that the difference
here is that instead of subtracting one
from a bunch of different numbers we're
just subtracting one from a single
number namely the maximum one
and here we have a whole
new formulation of it
and that is not only shorter than the
original um
but actually better performance as well
let's try it so we found that a was the
first one but we derived c from b where
we had diffused and diffused nys
reduction
so c
so why is it that we are making we're
having such a significant difference uh
between
these two well remember
we do we're doing the nyx reductions
those are the ones are actually doing a
lot of work and in the beginning we had
two n-wise reductions
we had the one to
compute the differences and the one to
compute the origin value
that we were to compare the difference
against
whereas in this one
we're
the the the work that's being done here
is only a single nys reduction so over
there we had an
n subtractions and then n selections and
then n minus 1 divisions and here we
have just
n minus
well it wasn't even n it was actually n
minus 1
subtractions it was n minus 1 selections
and then there was n minus 1
divisions
and here it's just an n minus 1 division
and then we're doing the maximum which
we have to do anyway
and then we're doing a single
negative one plus and a single one and
plus that doesn't really make a
difference there so that's why that we
are we're cutting significantly down on
the time it takes to compute this and
the resources takes to compute this
thank you for watchinghi
we're going to find out where a
chess Knight can move from a given
starting position
the different ways to attack this
problem
and they fall into two main categories
we could start with the starting
position and compute all the places
where the Knight can move or we can
consider every possible position on the
board and ask ourselves whether the
Knight can move there and this letter
method leads to simpler solution so
let's try that
as an example case we're given position
five four but let's not actually use
that for now we just generating
a chessboard
this is a Lambda and the index generator
which generates
an array of shape 88 that is eight rows
eight columns
and every element is
the position of that element or the
indices of that element
so every element is a vector of two
elements because there are two
dimensions
and it has then the index for that
position
now if we subtract
from every element the entire argument
we get the distance
vertically and horizontally from each
position to the starting position
and we can spot our starting position
here by being 0 0 of course there is no
difference between the starting position
and the position where well we are
starting and neither
vertically nor horizontally
and what we're after are the valid moves
for a night which you could see as
moving One Step In One Direction and
then two steps in the orthogonal
direction or the opposite it's the same
thing of course it's an L shape so we
could move one step right and two steps
up or we could look at it as two steps
up one step right
or we could go one step up two steps
right and so on two steps to the right
and one step down
what is common for all of these we can
spot is that
um not that one that one is that they
all have a difference from a starter
position that has the numbers two and
one although they may be negative or not
so we could generate the list of all the
differences so we would start with
negative 2 negative one and then
negative two one and then negative one
two and so on and so on there will be
very long list and we could then look up
to see if
for each difference whether it's a
member of that list of permitted
distances
um but since that list is very long we
can shorten it a bit by taking the
absolute value of first
now all the places you can move to are
either one two or two one so we can look
with membership
but we want the lookup array on the left
so we swap the arguments of the
membership function and then it has to
be either one two or two one so now for
every absolute value differences in this
table of differences we look up if it's
a member of that and that gives us a
Boolean array
indicating
the positions where our knights from the
middle here can move
of course we're not interested in this
Boolean array we want the indices where
it is true that it can move and for that
we have
the where function which gives us the
indices of the truths
and this is a solution which is pretty
elegant
but I think actually there is a needed
solution
so if we cut back again to where we have
our distance table
then we can use a little bit of
mathematics the Pythagorean theorem says
that in a right triangle
the
two shorter sides
if you take the length and square them
then if you add them together you get
the square of the diagonal
oh this might not look like we're
dealing with triangles but actually to
move from the starting position and up
here we can see this moving at a
triangle with a side that has length one
it's one step to the right here and the
side that has length two which two steps
up and so on the order of them doesn't
matter because it's just a sum
um so we can start by
squaring
the
distances here and then it doesn't
matter which sign they have either
because you square a negative number it
becomes positive two so one way to
square is to multiply by itself so
multiplication and then the same symbol
that we used for commuting the arguments
or swapping the arguments we can also
use for what I like to call a selfie
because it looks a little bit like a
selfie face
um so this is self multiplication
so now all the values have been squared
and we can see here that now we're
looking for all the places that have a
four and a one or one and a four
now we can sum so this is a plus
reduction each one of them
and here we can see that the places we
can move to are the ones that
have five as the total sum so we're not
actually interested in the length
of the diagonal
we're just interested to see if it's
Square length is 5.
so we compare all these values with five
and that gives us our Boolean mask and
then as just as before we ask where are
these ones
and that gives us our solution
thank you for watchinghi
so this time we are going to emulate
some behavior in an APL interpreter
which is to print out
um arrays
but instead of printing them out one by
one we're going to combine them into a
single array which will look the same
that's the point
so here's some sample data
and well if we print it out we get them
next to each other but if we print them
out one by one
instead then they end up on top of each
other like this and so the idea is we
need to generate an array which looks
like this when we print it out
and there are a few different approaches
to that I'll just show a few but when we
had the chat session then we had a lot
of different ways to do it including
some very silly ones
okay so
um maybe
the simplest way to do this
is to split the display of each one into
separate rows and then
combine all the rows into a single list
of rows and then combine them all into a
single Matrix and that's basically it
and there are a couple of things we need
to watch out for that so here is a a
different Lambda and we take this data
and there are some issues with
um with simple scalars that mess up our
algorithms we can take that in a moment
so we'll start off by
formatting each element of the right
argument so this doesn't actually change
how they look at first but this makes
them into character
um arrays they might be scalars vectors
or matrices because we don't have any
higher rank elements specification
so this will look much the same now when
we and we can split each one into its
constituent
Parts into its rows
which for vector and scalar is not going
to do anything significant just try to
enclose it
so we split each and this gives us all
these rows so now we can see that if we
were to combine
all these arrays here then we're going
to get the rows of our final result so
this is exactly what we're going to do
we're going to do a concatenation
reduction
and now they've been combined but
they're also enclosed because a
reduction reduces the rank and we had
here a list that's rank one so we have
to reduce it to rank 0 which we need to
unpack so that we do a disclose
and finally we mix to make this Vector
vectors into a matrix
and we get this result
and that is in fact a matrix we can see
if we select this and there are a bunch
of headed spaces at the end this is why
it's important for us to
um so format it otherwise we might get
padding with numbers instead
one little thing kind of style thing we
have two Loops here two eaches we can
merge them to a single Loop by doing an
a top instead so every time we format we
finish off post processing with the
split and then we go to the next element
however there are some issues here and
there is if we have
um
just simple character scalars
then we get the wrong result this is
supposed to be stacked on top of each
other remember
if we output each one separately then
they go like this
and the problem is that this gives us a
scalar and it doesn't change the format
doesn't have a character doesn't change
and so when we split that nothing
changes and then we just merge them all
together and basically there's no change
all the way through all no apps we can
fix this by making each one into a
vector
how do we make a scalar into a vector
without making uh any effect on any
other arrays and there is a trick
and that is to do a replicate so
replicate takes
a um an array on the right
and a some multiplication Factor on on
the left and then it it replicates the
elements here if we do a one
then we see no change but the important
thing is that it needs an axis so if we
ask what is the shape of this it is
three what is the shape of a scalar is
an empty Vector it has no X's
um but if we do a replicate on it then
this has to return a
um a vector because if the number was
higher we'd have to have a vector if
we're replicating along this axis the
single axis that it has so this became
but on any other array then a scalar
this has no effect whatsoever
so we can go up here and do a one
replicate on each and that gives us our
result and if we try to do it on our
test data then it looks just the same
because one replicate does not have an
effect on any other arrays
okay this was one way and to do it
another way to do it is to take
advantage of apl's default display
and the way we're going to do that is
again we start off by making sure that
our arrays are not scalar so we don't
end up any any problems with that and
then
instead of just formatting them right
away we're going to stack them on top of
each other so we have a vector
of vectors and matrices now
and if we use the magnetic comma bar and
that is a table function it makes sure
that that the argument becomes a table
so if it's a vector it becomes a column
Matrix instead
and if we then do a format on this
then API will transform this nested
array with various data types into a
uniform character array and there's
going to be a matrix in this case
because nothing has higher rank
and well look we almost got where we
wanted
there's just one issue there's one space
too much on the left and one space too
much on the right but that's easy to fix
and there are a couple different ways
maybe the most straightforward way if
but not most efficient
is to do a transpose so put the whole
array on its side that looks all very
silly drop the first row and drop the
last row so that's negative one drop
drops from the from the rear and then we
transpose back again
and now we've got the right result so
this is one way to do it another way to
do it would be with the rank operator
and so we could say here uh
rank drop rank run one that means drop
on each row and we also need this one
we can also combine them
into a single thing so if we make a
little tested function here and we can
write it like this so this is saying the
argument and one drop from that negative
one drop from that all of that is rank
one
and that also solves the problem
finally we can kind of sidestep this
whole issue of
um combining the arrays into a single
array and making them match in the width
and so on
and we can do that
simply by formatting them and then uh
concatenating and
Carriage returns or new lines to them
so how do we do that this time we're
going to go test it right from the
outset we'll start off by formatting
each one and this time we're not worried
about and about making them into
vectors
or higher rank because we're going to
concatenate a new line to them and then
the result is going to be exactly the
same becomes a vector at that point
anyway
so
here we have formatted each one of
course this looks much the same so these
are now character matrices we can see
the
um that if you try to add a number to
them but trust me from this
and then we want to have a concatenation
on each of each one
with a new line so how do we write a new
line in a tested function and we're
going to use the Unicode character set
on universal capture set system function
and with an argument of 10 for a line
feed you could also use 13 for character
turn
problem is this messes up our tested
function a bit really we want a fork we
want a left iron here which is the
formatted thing and we want the new line
on the right and this is a constant and
we could parenthesize this
and may use the constant operator so
this derives a constant function and
this adds then a new line to the right
on each one
and this will look very silly
spaced out this is because we added an
extra new line after each row but they
are also already matrices so we get this
double spacing
okay slightly more elegant and less
efficient but it looks cool
um is to
compose these two functions together
they concatenate each with the UCS
and then we have the the 10 as the
constant function so now the fork looks
like this we have the left line the
format each the right time is the
constant 10 and
and the middle time is the concatenate
each with the Unicode value of and then
we get that 10 in so this gives us
exactly the same effect and we don't
actually need spaces and space there
okay so now that all of this is in in
place we don't need the structure
anymore we don't use these matrices we
can just make everything flattened out
enlisted and we can do that with the
inlist function
and well there we are this one issue is
that training line break here because we
added one to each
so we just need to drop the last one so
negative one drop and then because this
is a magnetic function and we again need
this everything to be a fork so this is
one function which is a forking itself
and this is a left eye in here so we
need this to be a function we compose
them together so pre-process the drop
with the list
and there we have it a third solution to
the problem thank you for watchinghi this time we have to remove any
elements from a given list uh that are
not in an non decreasing sequence from
the beginning of the list so at the end
we have something that's sorted but
potentially shorter than the
input and um here's some test data that
that we're
given and there are a couple of
different ways uh we can do this
let's look at a very literal
interpretation of uh the problem
statement so here's an an anonymous
Lambda and we want to compare adjacent
elements to see if they fit so we can do
that with a two wise or pair wise less
than or equal to over the
argument what this means is that one is
less than three and three is less than
seven uh but seven is not less than
three so the first element we always
want to keep of course and then uh
because it it that's where the sequence
begins and then uh this one we want to
yeah so this one we want to keep this
one we want to keep this one we're going
to keep this one we want to remove
because um it's outo sequence five is
greater than three um but it's not being
eliminated by the first
pass so um let's put in a one here to
keep the first
element and then um we take the argument
and filter it by this
mask uh yeah here we
go so here the the five is there the
eight is is there and that means that we
really have to apply this again
so if we use the power operator to apply
this
twice
then we can see that we have eliminated
the five however since we have the two
fours over here at the end uh they still
survive so we need to do it
again okay this is good if we keep doing
it then nothing more happens and then
there's a trick that we can specify a
match instead of a number and that means
it will keep doing this until there are
no more differences so until two
consecutive iterations match each
other and go give this a name and we can
do ft and that solves the problem
however it's not a very efficient way of
doing it because we are doing a multi
pass uh on this so instead what we can
do is a single
pass and the way we can do it is by
scanning using maximum so this gives us
the largest value that we have seen so
far okay we can still see T up here you
can see we never go down again now we
just need to keep the elements that are
either
and um
already well we need to keep the
elements
that match the current maximum because
if they don't match the current maximum
then they must be smaller than the
numbers we've already seen and they need
to be
eliminated so equal to the maximum this
gives us the corresponding
elements and then we just do the
filtering like did with the first method
so here's a single
pass uh
solution for the elimination sort thank
you for watchingwelcome to this third apl quest see the
apl wiki for details
today's quest is the third problem from
the 2013
round of the apl problem solving
competition what is in a word
task is to write a defend which returns
the number of words in a given text
which can be given either as a single
character or as a vector of characters
what defines a word
for the this problem
is
a space delimited but there could be
multiple spaces between words that can
be leading and
training spaces in the input we have to
account for that
let's begin by creating some test data
so this is a normal text but i put in a
dash here
so that we make sure that we're
splitting on the right thing
this is a single letter
and we can also have an empty input
and then we have a text with more spaces
so we can have some leading spaces
and maybe some training spaces as well
okay let's get started
um
maybe the most obvious approach is to
split on sequences of spaces and we can
do that or let's say if we start by
comparing
an input string with a space
and this gives us a boolean vector
indicating where the spaces are
now the partition function um
groups
runs of ones or
elements corresponding to runs of one so
we want to
invert this
and then we can use this to split
so we use partition
on the string itself
and that gives us the individual words
and we can count them
if we try to do that on
on the string that has more spaces we
can see that it still works forwards
there and that's because any run of
zeros is a
an area that gets cut out
and
we split up at that point
now this runs into a problem if we try
to do it on a single letter
and that's because we cannot petition
when there are no access to petition
along so we must ravel first
and then it works it also works on the
empty one um that's not a problem
so we can put this uh together to a
fairly straightforward uh tested
function
um
it we want
we want the tally
um off
where the
spaces
are different from the argument
partition enclosed the revel of the
argument
so who we are binding the space to is
different from function to
achieve a magnetic function there
if you come from other programming
language background and especially
perl you
[Music]
might grab for regular expressions for
this so we can try that approach as well
and we have
our string and then
we have the quad s that's a string
search
regular expression search
and the pattern we want here are
with the inverted character class none
spaces
any number of
of those one or more
and then it doesn't really matter what
we're going to return
because we just want to count them we
don't actually want them so the best
option here is use code three which
means the pattern num in is in the
offset from the left and that since
there's only one pattern that's
just zero so we get a bunch of zeros
and then we can see we get one zero per
word
there and that works and also on the
scalar letter um and it works also on
on the empty
we just get nothing and then we just
need to count them
as you can see here so that
and that's our second solution
right there
okay here's a um
an interesting
solution that i came up with that's it's
kind of abusing a built-in functionality
a system function called vfi that's
verified and fixed input and really what
it does is it parses numbers so we can
see if we
give it some text
then um it
looks at this input as a space a space
separate the fields we can also have
multiple spaces and that's fine um it
removes all such extraneous spaces
and it returns a two element vector the
first element is
the success
and it says one e3 that successfully was
converted and the word 3 was not
successfully converted 2.5 was and 2.5
and was not successfully converted and
then the second vector are the values
that we converted to
and with zeros
for those tokens that could not be
converted correctly
now we're not interested in what the
actual values are we just want to count
how many such space superior the tokens
there were whether or not they could be
converted successfully or not so we get
the first vector which is this boolean
and then we can just count the number of
elements there and that gives us four
tokens so this
works for all our inputs even for the
empty one
and it works for the single letter as
well you just cheated as a text
here's one with more spaces and our
original string
so that's an additional solution in
order for this to be a proper function
that we can give a name
then we need to bind together
compose together two functions for
example the first two we could also
compress
the second two it doesn't really matter
right um
so far for these
uh approaches where we're actually
parsing and splitting up
into tokens but there are better ways to
do this in apl
but for that we have to work with
boolean masks
and the way we often do it in apl we
compare a scalar with a vector so here's
our string and then we have
bits for each one now we're not going to
use this to
split up rather we're going to analyze
it
we want to know how many words there are
and what defines a word
is that we have
a separator and there could be multiple
separators let's let's try it with
m and then
we have something that's not a separator
so we're looking for this pattern here
where we're going from spaces to none
spaces
and again here from spaces to none
spaces from spaces it could be many
spaces to none spaces and that's what
gives us a count of words that's that's
one way to do it
and
the way we can do this
is by comparing adjacent
elements
so we do the envi and wise reduction so
here it's a two wise reduction
on this as this means we're taking every
pair of two overlapping windows of two
and comparing them to each other with
less than y less than because in a
boolean vector we can use less than as a
boolean function to find out it only
becomes true when you have a zero on the
left and a one on the right right run
one is not less than one and zero is not
less than zero and one is not less than
zero so that's the only time when um
when it will match and we can see here
if we it gets one element shorter
because we're doing pairs if we line
them up we can see how this one
corresponds to this zero one here or
every time we have a one we begin a word
um so this is fine then we can we can
sum this
and that gives us a number of words for
however there's a problem
if we look at our string again where it
doesn't begin with any spaces
then let's go back and see what happens
here we compare this
space and
so far so good but now when we do
the pairwise less than
then we're missing one element at the
beginning
because sure enough
there is
um and and
um
there's none space at the beginning of
the string
but we never go from zero to one because
there's no zeros there so we're missing
a one at the front so how can we fix
this and we can insert a space
so by inserting one space doesn't matter
if we have multiple spaces because you
know from from space to space
is just zero zero and that doesn't
trigger but this will insert a 1 at the
beginning you can see if we go back to
the one that already has spaces
then it doesn't add any additional ones
so this
gives us the solution and we can sum it
like this it gives us the number of
number of words
and we can just wrap this in braces and
then we have
our solution
oops
and this is a pretty good solution if
you want to optimize for performance
even more than this
then we have to think about how the data
is represented in memory
now as we come into our function
then we have this name a variable name
omega referring to the whole argument
and it may occur later again in the
function and therefore
the interpreter has to keep this value
available at all times
when we concatenate a space at the
beginning we'll need to make a new copy
of this
um and so this
if it's a very large argument then we're
going to spend a lot of
time writing to memory it's just a copy
of everything with a space in front
there are things we can do about this
notice that here the data type is
whatever type of
character array it is so normally it's
one byte per character but if we have
some unicode things in there you can end
up with two bytes or four bytes per
character as internal representation it
can be rather expensive to write the
whole thing again
once we've done the comparison
then we are down to booleans so that's
only one bit
per character because it's in in the
comparison and since we're adding a
space in the beginning and space is not
different from space so we know that
we're going to begin with a zero
and that means we can put in a zero here
and avoid
copying the whole array and that's going
to give us somewhat better performance
but there is even more we can do because
if you think about what's happening
again
we have a boolean array here and we have
to rewrite that
when we insert a zero in the front
because in memory we have a header that
introduces the array and then we have
the data from the array
if you want to insert an element at the
beginning
then every element every bit has to move
over one step we have to rewrite that
whole array we can do that in place but
it's still a rewrite
so if we can get rid of that
inserting something at the beginning
that will give us a performance benefit
now
how can we do that well if we think
about it the only reason we want to
insert a bit the beginning is because we
need to make sure
and
to get the right result
when
um
when we don't have any leading spaces
in other words if we're missing a
leading space
that means we're beginning with a word
that's not being counted
and that means this mask this boolean
array the first element indicates
whether or not
we're beginning by word so we can just
add that value to our total count
so we take the first element
of the mask and add that to the
to the sum and then we just have to save
the mask value
right there give it a name
um here's an another problem and which
is
if we have a one element vector or
scalar here then we can't do the
pairwise thing correctly um
so
well actually we can do it if we have a
one element if you have a scalar we can
do it correctly because
um so we have to revel that as well
but there's actually a simpler way to do
it um and that is simply inserting value
on the right now
if we think about it we're doing pairs
and we're doing with less than and what
we want to do is detect the words we're
going from
spaces to none spaces
but instead we if we detect the end of
the words meaning going from none spaces
to spaces
then we only need to append rather than
prepend a single value
and appending something to an array that
is often very cheap because we don't
need to move all the elements of the
array rather we can just extend it by a
little bit the interpreter by default
will
allocate additional memory at the end of
the array and if you're talking a
boolean array like this that additional
bit might even be inside a single byte
that has already been allocated making
it even cheaper to do
so how can we formulate this well we
can't just put a zero um at the end if
we go back to this solution here because
what we want to trigger is another now
we're not worried about the a word
beginning at this rate at the beginning
of the string we weren't worried about
words ending at the end of the string
um and we need to have another and
another triggering of a word ending so
word endings are indicated by the
pairwise
less than
and we only get those if we have we only
get an indication if we have a 0 on the
left and a 1 on the right
and also now since we are
we're interested in uh where the spaces
are at the end of the words
then and we need to flip this around
to an inequality so let's actually try
this so we have our string here
um let's print it out again so we can
see
so now we are we are trying to find
these places where a word ends so we go
from a 0 to a 1
and the problem is at the end there's no
space there
so what we can do is we can go and
instead of doing a normal concatenation
we're doing a flipped or commuted
concatenation
and this shows us the word endings even
for when the string ends with a word
character
and now we can do
the comparison as before
and we can sum that
to get the the word count we can try
that with additional spaces as well it
works as well let's let's look at what's
happening here so m
is this one and there are additional
spaces at the
at the end
and then we compare two spaces
and we can see there's a an extra space
there at the end but it doesn't matter
when we then concatenate another one to
the end because the only thing that we
find is when zero goes to one
so
it all works as it's supposed to and
then we can we sum it and we get our
result
we could also have done the opposite we
could have kept the inequality and
appended a zero and flipped this the
direction of the comparison so it would
be greater than instead of less than it
would be exactly the same
and let's give this a name
we'll put the argument name name here
and let's look at
all our definitions
that we have
um and at this point we're going to have
a look at what the performance looks
like and i could predict this already
splitting up into sub strings is going
to be expensive we're going to have lots
of pointers one for each word
and spinning up a regex engine is going
to be expensive as well
and the same thing with quad vfi is
going to be expensive because we're
actually trying to parse
every single token whereas we only
really need to look at where those
tokens are to count how many there are
so it's absolutely certain that the last
four solutions are going to blow the
first three right out of the water
let's see how how
badly so let's create a text
here a testing for testing purposes
um and we can see
we're going to
um let's just try it first to see what
it looks like here we reshape 4
into 20 elements and then random
elements so we're going to create some
random text here we can see what that
looks like so that looks kind of like a
natural text we don't care about what
the characters are
okay let's make it big then
so here are a million of characters
let's
copy cmpx in
from the defense workspace
and then we can
start off here with f on t
g and t
h on t
and just just take i which is the least
efficient going to be off
of these and to see what that looks like
together
give it a moment to compute
and we can see indeed
that the boolean mask-based
solution it's not even measurable in
speed compared to the others
but interesting the
most expensive one was spinning up the
regex engine to do this quad vfi had to
do a lot of work as well in identifying
the tokens and splitting into substrings
was then the fastest among these
now let's compare
the the four boolean solutions to see
if
what we expecting is actually holds true
so this is i j
k
and l
and we'll see that
our expectations held up um
the solution where we prepend the space
and therefore had to copy an entire
array consisting of one byte per
character and was the slowest one
when we uh changed to
prepending a bit to a boolean array that
gave us a significant speed up about it
took about half this amount of time
but
avoiding the copying of the array either
by saving the mask and looking at the
first bit of it or by
appending a bit rather than preventing a
bit gave us the most significant
savings
thank you for watching and see you next
weekhello and welcome to this very first
episode of the apl
quest where we go through
one problem every week
from a past apl problem solving
competitions phase one have a look at
apl wiki for the details
today's problem is the first problem
from 2013
where we are asked to write a different
generate odd numbers
let's start by generating some numbers
let's say we want to generate the first
10 numbers
problem here is that these are all the
adjacent integers so we multiply by two
getting us every other
number and then we can offset it by one
for example we can take a one and
subtract it so we're swapping the
arguments on the minus so
there are other alternatives we could as
well
add negative one
to this
or we could parenthesize it
and for this we can build our defen
oops that's the argument name omega and
we can try it
and there we go
now as you can see
by default apl starts counting from one
a lot of people computer scientists
especially some mathematicians prefer
standing starting counting from
zero instead and apl allows you to
choose that so we can set the index
origin to zero and now
um
we
count from zero instead
this has upsides and downsides
upside of course is you can choose
whatever fits your problem and your
comfort
downside is that if you share code with
others you need to make sure you get the
right index origin you might need to set
it yourself and so it's a classic
problem to
try to write code that works with any
index origin and we can see that if we
now
try to apply a function it gives an
entirely wrong result
so that's no good the corresponding
function
for
index origin zero instead of subtracting
one would be to add one
there are other ways of generating
this um yes the problem asked for a
defense but we can also write tested
functions in apl
so here's another approach let's start
by
writing the framework for a tested
function so we put some parentheses here
and then we can do two times and not the
name of the argument but rather the
identity
of the argument so the density function
and we can
get 20 there
then we can use this
to reshape a bunch of
zeros and ones
so this is zero one reshape we swap the
arguments from the reshape so the shape
on the right and the content on the left
and now the only thing we miss is
asking for the indices where there we
have the true values or the ones so the
where function
and uh there we go this was index origin
zero now let's switch back to index
origin one
um and of course this won't work anymore
rather we just have to flip the ones and
the zeros
and there we go
okay and that's
all very nice but how about if we wanted
to write a function that could work with
either setting of quad io of the index
origin and there are various uh
approaches to that
um here are some cool ones that came up
in the live event
let's say we start by multiplying the
argument by 2
and then generating
those
integers
and now we take the parity of that so
that's the
two residue or modulus 2
of that
and now we ask for
where
we have the ones
okay that's good now what happens if we
change
uh to quarter yo zero
okay so
this part up here
gives it starts off differently
and then when we ask for the parity we
get the
opposite but that's exactly what we want
when we're using quality of zero
which means if we ask
where
are the ones we get the right result so
we can see that this function works with
either
either origin let's give it a name
argument goes here and really what's
happening is the the iota the index
generator and the iota underbar the
where function are cancelling each other
out
so
quadrio
gets one
and this works and quad io gets zero
and it still works so it's a really
clever solution um for writing
it in a way that doesn't matter which
index origin you're using
now the reason we're bumping into this
is because we're dealing with indices at
all we have the index generator we have
the where function which is the indices
of the true values
but we could also go about this in a
very different way in a mathematical
way so if we observe that we start with
a one
and then we
increase
with two every time
that gives us that's an interesting
property
so
let's say like this let's take we're
using overtake here so we're taking the
first 10 elements
of a one
now there aren't 10 elements in the one
so apl will pair with appropriate fill
elements which are zeros
we can subtract this from two
and notice here that we have the
beginning element the one and then the
offset to the next number over and over
which means if we ask for the cumulative
sum or the plus scan
of that we get all the odd numbers and
since we didn't use any index
related functionality
then
there is no influence from the index
origin so we can put this into a
function
as well
argument goes here
and we can try it
f10
and quarter one
f10 there we go
um
now let's say we wanted to go back to
our original formulation where we
started off with
two times
the
integers the indices
so in one case we wanted to
subtract one that's when what i o is
one in the other case we want to
add one that's in the case when quadrio
is zero
so how could we adjust this of course
both the subtraction and addition can be
seen as an addition you just need to
either add negative 1 or you need to add
1.
so that means if quad io
is 1
then we
want to subtract 1.
and if quad io
is 0
then we need to add one
and we can map this in a mathematical
way
so we have either a
a zero or a one
and if we take negative one and we raise
it to the power of those two
then for the zero we get one and for one
we get negative one which is exactly
what we want so now we can write our
function
as
negative one raised to the power of the
quad io and this will just take whatever
global quatero is currently in effect
and we add that to twice
the indices
so now we can try this was quad io1 and
quota was zero
and it still works
let me show you another very clever
solution it is as follows
iota
plus iota
minus the tally
this is a tacit function
we can apply it and we can see that
indeed it works um let's see what a
structure looks like it is a fork where
the right tie end of the fork is itself
a fork we start off by subtracting the
tally from the indices now what is the
tally that's how many major cells there
are in
the argument now a symbol number is
just one so
this is a clever way of subtracting one
from
the indices so let's try that we have
the indices
and we're subtracting one
and then we're using that as right
argument for plus
and the left argument is iota applied on
the argument so the indices again
now if we add these up
then well you cannot probably see this
already that we get exactly what we
wanted
and so the way we can write all this
together is
the indices
plus the indices
minus
the tally
and we can give this a name and apply it
like that
and that's all for today
thank you for following alongwelcome to the apl quest c appeal with
cupid details
today's quest is the eighth from the
2014 round of the iphil problems of
solving competition where we are to
compute the distance between two points
in and space this is really a very
simple problem
the distance is the square root that is
there
to raise to the power half of
the sum
of the squares
of the differences
along each
dimension
so we can test this
and we have another test case and this
is 2d space so let's try a 4d space as
well
we could say u1 a
v1
and
u2 a
v2
right
so this really solves the problem um and
there's not much variation one would
really want to make here on this
however there are some
interesting things we can do
since we like computing things on the
entire race and let's try to do this on
multiple arrays
on multiple vectors at a time points in
in the space at a time and so there are
some fun tricks that we can
take care of here
let's say we have a collection of
points but
this u1 and
u2
they don't have the same number of
dimensions so if we try to mix them into
a flat matrix
then we end up getting padded with zeros
on the right
that's actually not a problem because
when we do the same thing on the other
point
we get zero zero minus zero zero squared
sum it it doesn't actually contribute
anything and so it doesn't hurt our
computation that means we can kind of
upgrade all points to the dimensionality
of the point that has the highest number
of dimensions
so we can try this
and
that works
quite well
now and here's the thing
we might want to
define our function in terms of leading
axis notice here we have summation along
the trailing axis
and indeed um if we try to express this
in a test form
then we naturally end up there
because there's a common trick
to use
the problem of having multiple or even
one magnetic function inside a
test definition if you try to do this
then there's a problem here that we have
a magnetic function here and what we
could move it over as an atop on the
power but another trick is to use uh one
base as summation which might even be
faster on
non-integer
numbers
and now the summation goes vertically
which means if we try to use the same
thing
we get an entirely wrong result
that is of course because
we are subtracting the two matrices
correctly
and then squaring them correctly and
then
um we have now in our case a two by four
matrix and instead of summing along the
rows we are
uh summing along the columns and that
has those we're mixing up the two um
inputs that have nothing to do with each
other
in that case we would want to state our
arguments in transposed form which means
that each
row or physic each major cell represents
one dimension in
n space
so this can work as well
um to spice things up a little bit let's
do some uh some code golf as well so
we've got b here
and we can actually
we can create something that's a bit
shorter we can remove the zero from this
power here
it decreases readability but it does
save a character
and then here we are summing the squares
now summing square same thing as summing
the self multiplication
and and so we could write that as
uh summing on
the self multiplication
here but this you should recognize as
being an inner product
and so we we're still not it's still not
correct syntax because this is a
magnetic function applied on this static
function here
and so we could make it on top and then
it would have about the same performance
as before but because this is a selfie
meaning we are
we are taking the
the difference
and using it as both arguments on the
inner product then we could just
subtract twice which of course is a
waste of
computation resources but it can be done
so we could state it
like this
um so this is a fork and then that's
used as the right time in this for the
fork
so
this is
code golfed and away and it will still
work
but it won't work on
the higher rank arrays because it's
trying to do a matrix multiplication of
two arrays that are two matrices that
are not conforming with each other
so that doesn't work
finally um
note this that we're doing subtraction
then we're squaring summing and then the
square root which is the square root is
the inverse
of the square which means if we had the
under operator which allows you to do
some operation
so to say under the influence of some
other operation we could sum under the
influence of
squaring now we don't have that as a
primitive but we do have it in apple
cart
so we want the under operator that uses
the inverse
and we get this formula over here
so let's call it like this
and now we can use a i can write a
definition here which uses
under
so
it's very simple it's just summation
under
squaring or self multiplication if you
want on
the difference
and then we can try that
and we get the result and it should even
work with
our high rank things because it's the
same
summation along the rows as what we had
before
if we had uh if you compare now uh the
our code golf
thing here
with um
using the under operator
this is kind of nice and then there's
one it's one character longer
but if there was a primitive under
operator
then it would actually be a character
shorter in which case i would say the
nicest looking expression would also be
the shortest one thank you for watchingwelcome to the apl quest c apl wiki for
details today's quest is called
gothforth and multiply
it's really simple we just need to make
a multiplication table
it's the eighth problem from the 2013
round of the eppl problem solving
competition
for once we're going to go straight to
the obvious solution
well we can generate the indices from
one to
a certain target number
and then
we simply need to provide the outer
product
using that argument
both on the left and the right side so
both vertically and horizontally in our
table and this gives us our
solution
so just get rid of the argument and we
can give it a name
and now we can apply it
as you want and it works even on zero
okay now let's go to have some fun
because this problem is already sold
the first thing we're going to do
is try to solve this without using the
outer product which is otherwise the
obvious solution
and a couple of different ways that we
can do that
the first thing is to use the definition
of the outer product the other product
pairs up
every element
from
the list on the left with every element
from the list on its right
now we can actually use a property of
the multiplication
that it
maps or distributes over
multiple arguments so if we pair up
every element from and our list of
numbers with the entire list of numbers
then that will be the equivalent so
let's say we have
the numbers here and then we multiply
using
sorry we should not use our product we
should multiply using a rank and we want
every element so those are scalars rank
0 from the left
and pair them up with the entire vector
rank 1 on the right
using this iota 7 as both right and left
argument and that gives us
our solution
so this is just using outer product in a
hidden way because this is the
definition of outer product for scalar
operands
we can do one more fun thing
i think a lot of people are not aware
that if you give a vector argument to uh
iota
then it generates all the indices of an
array with that shape
this actually holds true even for a
scalar one element vector
as well
and now since
these are the indices
those are also the corresponding numbers
that need to be multiplied together in a
multiplication table
so we can simply say
that we multiply
and across these or we reduce each of
these
pairs of numbers
and with multiplication
and that gives us our solution as well
and there's even more fun we can have
let's start again with these numbers and
this time we reshape them into the shape
of our
multiplication table
so this just gives us repetition
and now what we can see is
that
multiplication is just a series of
additions so on the first row we we need
our original
numbers from one to seven on the second
row we want the numbers from one to
seven added with
the numbers from 1 to 7 again and in the
third row we want it added again so this
is simply the cumulative
addition going down
and we can easily write that
as
the plus slash bar
so this is uh class
backslash bar this is a cumulative
vertical addition
and that gives us our multiplication
table as well
and we can then write this as a function
wrap it in braces replace the sevens
here with the argument
and that gives us our
solution as well
we can even make this test it
we can observe that this is a function
application of iota on the argument and
this is duplication on the argument
duplication is could also be written as
self-concatenation
because we could
express this as omega comma omega
so now we can write this testedly as
self-concatenation with iota on the
right
and
then this is our tested equivalent
let's have even more fun let's eliminate
the iota how can we eliminate the iota
well if you take seven and use it to
reshape one we get seven ones
and now we can do the same thing the
cumulative addition on those
that gives us the equivalent of the iota
and then we can proceed as before so we
can write this testedly using the same
technique as before you want the
cumulative
vertical sum of the self
concatenation
reshaping
the cumulative sum
of
reshape with the right argument of one
so now we can apply this and we get our
multiplication table yeah i know it's
silly but it's a nice exercise and can
give some insights into the relationship
between
the functions
and we can even take this uh one more
step
we can
by saying that instead of one here we
can observe that a scalar has a total
count of elements which is
one
so we could
use this as well
let's do
this step by step
we take the self concatenation and
reshaping the one and then gives us all
ones
and then we just need to do the
summation
and row wise
and then we can do it column wise
like that and we can all we can put all
this together to a single tested
function as follows
we just
this one stays as at the top at the end
and
the horizontal summation becomes on a
top on the reshape
and there we go we've got
no iota and
uh you're not even implement yeah and
then
just defining everything in terms of
cumulative additions
okay so we can see that it's not a
problem to
implement this multiplication table
using
other functionality than out of product
let's take it one step further let's get
rid of all apl operators now we're only
allowed to use functions
okay
how can we do this
well what we can try to do is we can
start by generating our numbers
and now we can
recycle these
until we have enough numbers for them to
fill the entire multiplication table
so this just repeats them over and over
again
and then we need to multiply them with
the corresponding numbers which means
the first seven numbers here need to be
multiplied by one the next seven needs
to be multiplied by 2. so if again we
start off with the numbers from 1 to 7
and we now replicate them by 7 each
and now we can put these two things
together
and those are the numbers in our
multiplication table the only thing we
now need to do is to reshape them into
the right shape and we've got a
multiplication table
we can write this whole thing as a
function simply by replacing all the
sevens here with the name of the
argument
and there we have it
multiplication table
implemented only using functions no
operators if you don't like operators
there are other fun ways that we can do
this and we can take again
reshaping
the numbers over and over
and then we can try transposing that
and then we can see that all we need to
do is multi now we have the
corresponding vertical numbers as in
when we had the outer product and the
cars and and the horizontal numbers as
we had with our as the right argument in
the
uh for multiplication in the outer
product and then we only think we need
to do is multiply these two together
so in other words we can say that we
take this and multiply
with its transpose
and we've got a multiplication table
right there if we wanted to make this
into a function we could just wrap it
again
alternatively we could give it a name
but there are even simpler ways of doing
this
and that is by relying on apl's scalar
extension
you can always scale or extend
by using a scanner function together
with an enclose
so how is this going to work well we've
got our numbers from one to seven
and then we can enclose that it makes it
a scalar
now if we pair up these two
then then the scalar one two three four
five six seven gets paired up with one
and paired up with two and paired up
with three
so we can simply write iota seven
times the enclose of iota seven
and that gives us the rows of our matrix
the only thing that's missing
is mixing the rows into a proper matrix
and we can write this tacitly
simply removing the arguments so here's
we have a fork we have enclosed iota
applied in the argument and the yodes
are applied on the argument so we can
get rid of the mention of the argument
and make it
0.3
and we need to enclose off the iota
and there's our tacit equivalent
solution
now what you can observe here is that we
are computing the range the iota first
and we can actually break that so to say
out of the expression
by making it in the top
of
an iota so we want the enclose of iota
and
the identity of the iota
and then we mix that and that's applied
on the iota itself so this is a more
efficient silly solution
finally for the ultimate
challenge
is to implement the multiplication table
without any arithmetic at all so by
arithmetic we need to we mean things
like plus and times
and of course this might seem impossible
but we can actually implement
multiplication in the old-fashioned
counting stick
way and there are different ways we
could do it
here is an example let's make it a bit
smaller so we can see what we're doing
we know that iota can generate the
numbers that we need to get multiplied
together by using two of the same
but how do we
how do we actually multiply them
so what we can do is we
each of these pairs themselves can be an
argument for iota
and this gives us and
this gives us and for each one of these
pairs gives us
the indices of an array of those
of those dimensions
but of course
that implies actually some
multiplication say if we have three and
two that gives us an array that has
three rows and two columns and that has
six elements which is because it's the
number of rows times the number of
columns
that's where we're going with it so the
one the only thing we need to do to know
now is how many elements are there in
each one
well if we ravel them
and then we can count how many elements
are there in each one and we just
implemented multiplication table without
using any arithmetic whatsoever
so we can make this into a function
and that works or we could make it test
it
by observing that here we again have
the
um self-concatenation
and we are applying iota on that and
then we have these three loops the three
eaches that we can fuse together
and we've got ourselves a tested
solution
there are other ways
let's look at the numbers again
and now we use outer product and we're
going to write a custom function for the
outer product
the function that just returns a value
the value i'm using here is a hash or a
reference to the root namespace it
doesn't matter at all i'm just using it
as a placeholder value just to show that
i'm not using any numbers or any
characters any values whatsoever it
could have been any array whatsoever as
long as it's just a scalar
oops sorry i needed
the selfie here
so now this gives us a multiplication
table but missing the values we just
have a scalar in each position
however we do have the numbers as
arguments
so we can write
the arguments in here
and what we need we can then do is we
can replicate using this
so we just instead of having a single
reference to the root namespace we now
are going to have one reference two
references three references and so on
and then we can replicate again using
the left argument and effectively
this is a multiplication
it's the replication of a replication
and here is the multiplication table in
unary
we can convert from unary to normal
numbers simply by doing a
tally we've got a multiplication table
so this is another solution
here here's another fun one
we can take
the numbers
and do an outer replicate
on these
so here we have
one ones two ones three ones one two two
two two three two and so on
we can already begin to see where we are
going with this
now what we can do is
that we we need to know how many do they
add up to in total and this is where
where the function where comes in so if
you do a where on each
as what does where do it normally gives
us the indices where where there are
ones in a boolean array
however
so for the first column it will give us
in this index one
and then index one and index two index
one and two and j3 if the but actually
what it does is it gives us this many of
the corresponding index so in the second
column we're going to get
two ones and then the next row
two ones and two twos
etc
and now
we're done
because this is the multiplication table
in unary completely ignoring
those actual values so if we just fuse a
tally on that we have a multiplication
table
it isn't quite a valid tested function
but there are various ways around it
we could
fuse these two together and then it
would be would be valid or
we could
compute iota twice
give it this left argument and right
argument to the outer product that would
also be valid
and finally
maybe for the most basic of
counting on fingers type way of doing
this
let's
try with
with these numbers and we're making an
outer product
on that with a custom function
and we are starting off with the empty
vector
so this gives us
one empty vector for every result these
are placeholders
and now we are going to take a value i'm
using the reference to hash again as
just a
placeholder value
and we're going to concatenate that to
the empty vector so that gives us a
one limit vector for each one
but we're not going to concat it with
cardinal catenated just once
we're going to concatenate it as many
times as the right argument shows so for
and for the columns in the first column
we're going to concatenate it once in
the second column we're going to
candidate it twice and so on
as we can see here
but we're not going to just do that
either we're going to
use to do this whole thing also as many
times as
the left argument says so the first row
we're going to
to
concatenate
this reference to the empty
vector
and we are so the first one we're going
to concatenate it once
once
in the second row first column we're
going to concatenate it twice
once
in the first row second column we're
going to concatenate it
once
but doing so twice
etc
and this gives us our unary
multiplication table and as before we
can insert tally
to generate our multiplication table
of course these are all silly and what
you should be doing if you want the
multiplication table is just the regular
outer product with normal multiplication
thank you so much for watchinghi
we have to look at a given number and
check if the digits
alternately
grow and Shrink that is there aren't any
digits next to each other that are the
same and you don't have a digit that is
followed by another digit that is larger
and then another digit that's even
larger or the opposite going down
so
here's a sample number
and we need to look at the digits not
the number itself
the way we do this is by representing it
in base 10.
but I hear you say
it's already in base 10.
that's only for us humans to perceive it
but really it's just a number and it's
being presented to us in what looks to
us as a base 10.
if you want an actual real base 10
representation of it
then we would want to have it instead as
a list of digits where each digit
represents the the count of a of units
of that size for that position in the
numbering system
okay that's a lot of
um Babble about number systems let's
just try this so we have a represent
function in APL also known as encode
we're going to take this number and
encode it in a certain Radix a certain
base
and we can say that every
position in our number system uh you
need 10 of those units in order to get
the same in the next higher unit
now this might seem obvious that they
should all be 10 but some numbering
systems have mixed bass for example the
way we count time we have a thousand
milliseconds
makes up a second but 60 seconds makes
up
a minute and 60 Minutes makes up an hour
and 24 hours makes up a day and
seven days makes up a week for example
so we specify here that we want all
these bases 10 but the number got
truncated because we didn't have enough
tens
so we don't want to specify
how many digits they are we would like
to have this done automatically and
there is a trick to that
when I go the other way and I want to
convert these
digits to a single number then I use the
decode function which is just the same
symbol but upside down so this converts
to a number base and this evaluates in a
number baits that looks like the base of
our pillar and here I don't need to
specify the number of digits because if
I only specified once then that gets
mapped out to all the digits
okay how can we use this
well this is a neat trick and that is to
use the power operator the power
operator
takes a function on the left and the
number on the right
and applies the function that many times
so here I don't want to apply this
function
the trick is to apply it negative one
times what does that mean
that means asking the APL system
what would be an argument to this
function
with this left argument such that the
result would become this
ah so being that this evaluates
from base 10
and we need to get this result
then the argument given to the function
must be the list of digits that
represented in base 10.
that's exactly what happens that's the
result we get
and with that in hand we can start on
the actual core of the problem
let's wrap this thing in braces making
it a definite or a Lambda an anonymous
function
in here the argument on the right is
represented by the rightmost letter of
the Greek alphabet
okay
we've got the digits the next step is to
compare adjacent digits we need to make
sure that we're going down and up and
down and up or the opposite way
if we reduce with minus then we get
the first digit three minus one minus
four minus one minus five that's not
interesting but if we give this
derived reduction function and number on
the left say two
then we only reduce over Windows of size
2. so this is three minus one one minus
four
minus one and so on
three minus 1 is 2 1 minus four is
negative three four minus one is
positive three
now we need to check if we alternately
go down up so if the positive number is
positive we're going down if we put
numbers negative that means we're going
up
but in order to deal with this it would
be nice to normalize these to just be
ones and zeros so we use the Signum the
sine function
and that gives us one whenever it's
positive and negative one when it's
negative
so we might think that now we can do
adjacent different from
and this says these are all true
but what happens if we've got
a zero in there
right so now we have two ones in a row
and the difference between them is zero
but zero is different from one and zero
is different from negative one and so if
we do adjacent
different from it looks like everything
okay when it actually isn't
so that doesn't quite work
what we can do is adjacent differences
again
here we can see that from one to zero
there's only a difference of one and
from zero to negative one also a
difference of one
and we must have only negative ones and
positive ones there
so
sorry only negative twos and positive
twos there
so how can we find out if that is the
case
well if we take the absolute value now
they shoot all the way all of them be
two and if we have any zeros
will spot that there's only a difference
of one in between
you could even be a difference of zero
if we have the comparison being
identical
but for a good number a zigzag number
everything is fine it's all twos so now
we need to check are they in fact all
twos well how do we check that
is 2 equal to these yes it is equal to
all of those and is it all true this is
an and reduction
yes it is and if we mess up any part of
our number
then
it's not true anymore
so this is one solution to the problem
but there's actually a clever thing we
can do
we can start off the same way
as before
with the adjacent differences
and then we can remember something from
basic math lessons
which is when we do multiplication
equal signs give positive and unequal
signs give negative
so if we multiply these adjacent numbers
then this will be positive this will be
negative this will be negative and so on
And if every time we go from one digit
to the next we switch direction that
means that adjacent numbers will have
opposite signs and therefore all the
multiplications must give us negative
numbers
so if we do adjacent multiplication
we can see that there is a positive
number here and that's not what we want
if we fix the number
all of the signs are negative which is
what we want how do we check if all of
them are negative
well instead of like we did before
we did an end reduction on two equals
then here we need to check if zero is
greater than all of these values
and do the end reduction
same pattern
and this works nicely
there's an interesting pattern going on
in this function
and that is we have an argument
a function with two arguments
a diametic function we call that and
this left argument another function with
two arguments and its left argument
another diametic function and its left
argument and it keeps going like that
onto the last function which is applied
to the result
when we have this kind of pattern that
means the function is a nice fit for
tested programming
so
we can get rid of the braces
and C is to mention the argument by name
which is what tested means it's just
understood that the argument is there
without mentioning it instead since we
want the value here of the argument
we'll denote that with the
identity function it's a normal function
but applied to the argument
it just yields the argument so this is
again the argument's value and then we
we express that in base 10. and then we
do adjacent differences and adjacent
products and then we compare it with
zero and to an end reduction then
and this would work
however
we can be a little bit more clever
and what we can do here is we can modify
the function H instead of mentioning the
right argument implicitly by a identity
function we can bind
a fixed left argument two to the
function that we're going to then invert
and that gives us the base 10
representation and this whole thing
becomes one giant tested function and
that's our the rightmost part of our
function train our string of functions
and their arguments
and now we can try applying these again
and we can see that
this still works so this is a nice
tested way to do it
thank you for watchinghey
our job is to take a
number and split it into its integer
part and its fractional part
so here's a number
and we can get the integer part by
lowering it
so this symbol is kind of
is a a stylist wall and the floor next
to it so this floor and we could also
round up using the ceiling which would
be like a wall and a piece of the
ceiling above but now we're flooring
and that gives us one
and what we could do is we could
subtract
this so we can make a what's called a
train
um or it's a fork a special construct
where we
um refer to the function to the argument
in terms of function application
so this is you could call this a one
train
um and then we can use the identity
function
to just give the number itself and if we
subtract
the floor from the argument itself then
we get the fractional part
now all the remains then because we have
to return a two element result which is
the integer part and then the fractional
part is to concatenate in front
the forward part
so that's the integer part
this is one way we can do it
um there are other ways to do it
we have something called the division
remainder so when you divide
um if you are using integer math then
you might have something left over say
if we divide 10 by 3
we get three in the third
however if we did an integer division
then we would only get up to three times
three is nine it would have one left
over so if we we can write that in API
with a vertical bar which in this is a
notation technique from traditional
mathematics means divides
so 3 divides 10 then what happened you
get
one left over if we had three divides 11
then we would get
two left over
and so here comes the trick
if we have a number that's not a whole
number and we want to divide it by one
then
well of course it gives the same result
but if you're using integer math the
closest we could get is the one
and then we would have this left over
so if we say what's the division
remainder
when we divide by one
then we get the fractional part
and so we could go up here and
substitute it
and we all we need to do is to take this
one and bind it together with the
remainder function
to create a function that just takes a
single argument because we've already
filled one slot with the one
and we can write that as with with this
jut composition operator
and this says the one should be always
be the left argument to the remainder
function and then we concatenate the
float value on the left
so there's another way to do it
but there's actually
a very neat way that we can do this in
one go without constructing the results
from its two parts
and that is by using the encode or
represent function
now let's say that we have a movie which
lasts 96 Minutes
but we want to know how many hours and
how many minutes is this
so what we can say is
we use the encode
we could also see this as kind of like a
letter T and this stands for converting
to a base which could be a mixed base so
we have a number system for time where
there are 60 units minutes in an hour
and then it doesn't really matter how
many hours there are in a day it would
be 24 but it doesn't matter in this case
and if we use a zero then we don't roll
over to the next unit we just say this
is the highest unit and anything that's
bigger than that will just remain within
that position keep counting up
so you can see this is one hour and 36
minutes
now what if we were to represent
um in where the unit is a one
and then
um
that means that none of the whole part
of the number can be represented in
um in this digit
only anything less than that
before we go there let's just try it 96
and a half minutes in hours and minutes
we can see that the fractional part goes
over here
and so if we change this to a 1 then the
whole 96 will overflow to the next
higher unit which is the highest one and
the zero indicates that everything goes
there
and we just get the half remaining
and we can try that with our other case
we can see that it splits it up
so a whole solution to this as a full
function we'll do the same trick as we
did with the one and the remainder
binding them together using the chart so
two we can bind together
the zero one which is an array with the
encode function and this becomes a
standalone thing that we can give a name
and we can apply it and that's the
entire solution
thank you for watchinghi we're going to compute the windows
average of a list of
numbers now normally this is a very
simple thing to do in
APL so let's say we have the numbers uh
1 2 3 4 5 six and we want to do a window
average um the specification here says
how many enable
neighbors and on each side of an element
so let's say we want two Neighbors on
each side that would mean like for the
uh number three here we want these two
neighbors and these two neighbors to be
included so that means uh these five so
if we write this as a testet function or
Point free function and we have the a
left argument of two which is the window
size but number of specified as number
of neighbors then the full window window
size is going to be 2 * this because
it's on both sides plus one um because
of that middle element that's the one
we're Computing the the window average
on right
now so we want uh the left
argument and we want two times that and
then we want to add one so this gives us
five and this is going to be uh the left
argument to the plus reduction so this
doesn't just reduce the whole thing um
but rather reduces over Windows of that
size so the right argument to the
reduction the actual um data that we're
going to reduce is going to be the right
argument to this outer
function and the left argument is going
to be this uh
expression that is in terms of the left
argument so now we got uh the sum of 1 2
3 4 5 so we can see 1+ + 2 is 3 + 3 is 6
+ 4 is 10 + 5 is 15 and then and 20
because we got 2 + 3 is 5 + 4 is 9 + and
5 is 14 + 6 is
20 okay now we just need to find the
average this is the sum we need to
divide by the length but the length
conveniently that's already there as the
left argument to uh to this plus
reduction so if we wrap that in an inner
function and then say we divide by the
left argument here so there are three
functions here this is a density
function that Returns the right argument
that's this one over here there is a
function in terms of the left argument
that's this one and the middle function
takes the results of those two AO
functions and says that the the NY is
Windows reduction using Windows of this
size uh on this
data divided by the left argument so
that's the length of that
okay makes sense that the the average of
one to 3 4 5 is three and the average of
2 3 4 5 6 is
four now here's the catch um and that is
we don't want two results like this
notice that we only computed the window
averages uh for these two elements and
not for all the elements because there
aren elements on the left and on the
right to create a full window and so the
problem specification says that we are
to
extend uh the original data with copies
of the last and the first uh elements on
the right and the left sides
respectively so um let's do that we can
always put in the actual formula for the
window
reduction afterwards
so we want the first element over here
and we want to repeat it as many times
as stated over here so we want a reshape
which is cyclic reshape so this just
reshapes uh the whole thing this
reshapes the and drops the trading
elements but we want to pre-process the
right argument with a first to take just
the first element so we've got this
function composition oper operator which
is pre-process the right argument and
this is the first function
so this reshapes the first element to
the length
two and how would we get uh reshaping
the last element well there isn't
unfortunately a function to get the last
element but there is a function to
reverse so if we
pre-process the right argument to this
whole function with a reverse
and reverse this whole thing that gives
us 654 3 2 1 take the first that's six
and then reshape
it and now we can just concatenate
together all the pieces that we've got
um so we want the original right
argument concatenated with
this and that extends with the right
number of sixes on the right so that the
actual original six becomes the center
of a window of length five and then we
have the left argument resets the first
concatenated to
this and now we have the full data that
we're supposed to operate on so we can
go in and take our original formula over
here and copy it down
here that gives us our uh running window
average and with extended neighbors so
we can get rid of this and give it a
name and now we can
apply to f 1 2 3 4 5
6 and we can do it with a
one so this is the average over and
every element and its adjacent element
so there's average of one because we're
extending one and two that's one and
the3 and here we got average over 1 2 3
that's two and so on thank you for
watchinghi we're going to implement a simple
seizure Cipher for uppercase
characters and
spaces so uh the idea is that we have
the uppercase alphabet as a built-in we
just need to also have a space in
front and we can make a Lambda around
this where we take
the argument which is represented by and
Omega which is the rightmost characters
in the Greek
alphabet
and we take a message and we can look it
up with a index of here so we look up
every character in the alphabet so we
can see H which is normally the eighth
character but it's now the ninth because
we have a space in
front and then as left argument we take
um a rotation of the alphabet
so we
can um take the same alphabet over
here and then we can index into it and
APL allows us to index with multiple
values at once so we take all these
indexes here and we use them to index
into the alphabet of course if we index
into the alphabet itself we get the same
thing but if we take Alpha the leftmost
character of the Greek alphabet and we
rotate the elements of the
alphabet um we can we can also show how
that
looks so if we take this
oops so this is a rotated
alphabet
um then that's a solution to that let's
clean up the code a little bit and we
can see here that we have some
duplication of
code um we can do an inline assignment
over here to a for the alphabet and then
we can use the a over
here and we can
avoid this parenthesis by flipping the
arguments of the iota of the index of
function so let's do that as well reads
nicer with the inline assignment as
well um and there you have it let's uh
give this in
name and apply
it oh of course we need a left
aggreement there to apply it there we go
and then of course once we have that
function we can apply it in reverse and
if we apply the reverse on the
forward then and we get back our
original message so same function works
for both encoding and uh decoding and
the way that works is that we have a
negative value under the rotation it
just means a reverse rotation so that's
all thank you for watchinghi
today we're going to take a text and
chop it into
sequences of a given length
this is something that's called KMS when
it comes to DNA sequences but that
doesn't really matter
first let's generate some fake DNA
and we can do that by taking the bases
that can appear in DNA and then index
into them
with a bunch of numbers let's just do 15
for now so there are four different
bases
and we want some random numbers for
those indices
that gives us some random DNA
now the problem is almost built into the
other Solutions are probably almost
built into the uh to APL
by way of
invoice reduce
so anyways reduce those reductions over
Windows sliding Windows over a certain
size the data goes on the right and the
window size on the left
and here we're not actually we're going
to do any reduction but we can use
concatenation reduction which then
concatenates the adjacent characters
forming subsequences
here for example is
the four wires or setting Windows of
size 4 reduction that's the Slash and
concatenation is the comma
and that gives us this if we do five we
get like this and so this almost solves
the problem because the problem
specification is that the left argument
is the length of these cameras and the
right document is the DNA
there's just one problem
um let's say that we have and now just
for clarity let's just use a normal
alphabetic letters
let's say we only have six bases
then we have these two five mirrors and
if we have five then we only have this
one which is still correct this is a
list of character vectors A list of
strings if you want
but if you only have four
then well this looks strange
so this output form from APL which is
known as the maximum boxing level or the
display
moment
um notice how it changed this Arrow
which indicated an axis into this circle
bar and this indicates that there is an
axis but it's a 0x it's linked zero so
this is still a vector of vectors
but there aren't any
and it's not the same thing as just any
empty list and we really want to be
consistent here and always return a
vector of Five Element character vectors
only that there aren't any
so into in here we can see that there
are indeed five elements which is great
so this is still correct this is a
vector of no Five Element vectors
however if we further shorten
then we get a length error
and API will not allow you to do an
invoice reduction over an argument that
is a data argument that is more than one
element shorter than the requested
length so the actual problem here is not
really solving the main thing of K mares
but rather working around this
limitation and I'll show a couple of
ways to do so
so first
um it's very simple
we can see that we can have
up and we can down to
one less than the requested length so
let's define a Lambda like that and the
data goes on the right
and the length on the left
and then we are going to look at
the left argument which is Alpha left
most character the Greek alphabet
subtract one
and then we do a
um
the maximum with that
and
the tally or length of the right
argument that's the data over here
so this style uh with a bar at the top
and it kind of looks like a wall with a
piece of the ceiling above and so it
also means round up ceiling but if you
use it with two arguments it's the
maximum which you kind of see it as a
measuring stick showing at the maximum
of the two values
and so this Returns the maximum we can
see here that this gives six this is the
length but if we decrease it five then
they're the same and four then it it
gives one less and three it stays at
four
so
if we then take this and Pad the
argument to this length which we can do
with the take function although take
text the length on the left and the data
on the right we can use the commute
higher order function or operator to
swap that so that the data goes on the
left and the next goes on the right and
then we we do this we put the argument
on the right
from the right over on the left instead
and now we can see that we got padded
with a single space here and if we give
it even less argument and less elements
we had accordingly so now we add up end
up having at least a length four and
with that we're done we just do the
um
and wise reduction
and we can see that we get the correct
result here so this is one solution to
the problem
we can try
and it works like this
another way to do this is something
that's actually stated in the full
problem text if you look there and that
is that if
the requested length is greater than the
length of the input then we return an
empty Vector so we can code this as well
um so we say if the requested length the
left argument is greater than the length
available in the red argument
then and then return an empty Vector
we'll get back to the definition of that
otherwise we just do the operation as
before
now what exactly we want to do here we
could just return an empty string but
that's not the right type let's let's
try that if we say 5 G ABC
we can see that this isn't the type
that we wanted we actually want a vector
of character of x's of the right length
so we can change this and say well it
doesn't actually matter what the content
is because it all gets
thrown out
we normalize empty arrays so that they
conceptually just contain spaces or
zeros and so on
so we can take the left argument which
is the length required
and take that many elements from the
right argument and that again pads it
with spaces
um
and this will then be our prototypical
element
then we enclose that to treat it as a
single unit
and then we take zero of those
foreign
we get the right type of result and it
also works
on
the full argument as before so these are
two different ways of coding around the
problem one is by extending the data so
that we always have enough data and that
was F
and and the other one was by doing a
test first and if we need to stop short
of actually
calculating the cameras and then we
construct an appropriate result and that
was G
thank you for watchinghi
we're going to generate inclusive
integer ranges which might be ascending
or descending
there are many different ways to attack
this and I'm not going to go through all
of them
in the chat event
we did have a lot of different
approaches taken up and I encourage you
to follow the link in the video
description to go to the chat log and
see what they all were
for now I'm just going to go through the
shortest solution we came up with
and the faster solution we came up with
so the problem specification is such
that we have both the beginning number
and the end number in the right argument
the normal thing for an APL function
would probably be to take one on each
side or a function probably the
beginning on the left and the end on the
right
but because of another follow-up problem
that was in the same competition that
this problem comes from they elected to
have both ends on the same argument so
given as a two element vector
and that influences a bit how we're
going to form our function let's say we
have we want to go from 3 to 10.
so the method we're now going to use is
that we're going to use the three
and then we're going to have a bunch of
ones
and then we're going to have those ones
added sequentially to the three until we
reach 10. so this would need 7
ones
doing a cumulative sum over those ones
starting with the three gives us the
sequence from 3 to 10.
if we wanted to go from say 10 to 3
instead then we would do the cumulative
sum beginning with uh with the 10 and
then we would have negative one seven
times
and that would give us a sequence from
10 down to 3.
so we're not going to figure out how to
generate these ones and append them to
the beginning value
so that we get the sequence that we want
first let's find out what the difference
is between those two values that we are
working with so let's say we have
3 and 10.
we write this initially as a does it
function
so here is a minus reduction that is
we're reducing over this Vector of
length two to get a single number
that just is the same as inserting the
minus between the two elements so this
is three minus 10.
there's a problem here with the sign if
you're going from 3 to 10 we want
something positive so really we want to
subtract in the opposite order once we
subtract the left element from the right
element
we can have a modified version of minus
which is the commuted minus I'm reduced
using that to and then we get a positive
7.
next up is to reshape A1
we could do this by again commuting the
arguments of the reshape function and
user 1.
however in the case where
we want to get negative ones this is not
going to work and we can't use a
negative number to do a reshape either
instead we'll apply another function
the number of elements that we want is
the absolute value of this
and the numbers that we want in our
sequence
is the sine
of the difference
if we were to have 10 3 then
the sign would be negative one now we
can take the absolute value and use it
to reshape the sign
finally we want to
be pinned the first element 10 in this
case
we cannot just say the first function
with concatenation
because we're getting out of sync with
how our Fork works
for this to work we want to apply this
function to the entire argument and this
function to the entire argument and then
we want all of this as a sort of
secondary step
the base function here is concatenation
before we apply the concatenation we
want to pre-process the right argument
to the concatenation which is going to
be
something based on this subtraction
and we can do that with the beside
operator the chart
this is pre-processing the argument the
right argument to the function on the
left with the function on the right
here we have a descending sequence from
10 down to 3 and here we have an
ascending sequence from 3 to 10.
the only thing that's missing is the
cumulative reduction
and this solves the problem
in the zero case that is when the
beginning and ending points are the same
this subtraction gives zero the absolute
value is zero the sine is also zero that
doesn't actually matter because we're
reshaving the length zero that's an
empty Vector concatenating the first
element that would in this case be just
10 as a vector
and then we're doing a cumulative sum of
that which just remains with 10 and
that's the result that we want when the
beginning and ending points are the same
so this solves the problem very neatly
but maybe most not the most efficient
manner
and the reason for that is that
we are generating a sequence here that
is not the
full length that we want so we are
prepending
another element that means that in
memory we have to rewrite all of this
data just pushed one step to the right
okay
furthermore if we are generating a
sequence of all ones then it would
probably be represented internally as a
bit Vector that is packed bit booleans
and then we are prepending an integer
value we would have to convert all these
bits to integers again
and then of course we're doing the
summation but we can probably not really
get around
doing is one addition for every element
let's look at a more efficient way of
doing this and when dealing with offsets
like this it's a really good idea to use
zero based indexing API uses one based
indexing by default so let's create a
little Lambda a function where we assign
to the special syntax uh a system
variable which determines what all
ranges are indexed from one or zero so
we assign a zero to that then it's going
to be indexing from zero
here's the index generator
let's do the indices for an array of
length of the argument
you can see it begins with zero if I
switch this to a one it begins with a
one so let's switch that back again
right what kind of sequence is it we're
looking for we actually have a beginning
point and an end point if we do this
subtraction then we get a range
of course it could be negative so let's
throw in the absolute value
oops we're missing the right argument
here
we're short by one it's the fence post
problem we have an inclusive range in
both ends and so the actual range is one
larger than this
let's add one
now the only thing that's missing is we
need to adjust we again want to start
with the first value and then we want to
add these offsets
but in the case of this ending we want
the offsets to be negative so how can we
selectively
change this to negative numbers
we could of course use a conditional
but really want to avoid branches and
all the problems that come with Branch
prediction
instead let's take a mathematical
approach that's the traditional way to
do it in APL
okay
let's look at these numbers again
we can see whether or not one is greater
than the other by inserting a greater
than function between them so this is a
greater than reduction
if they're the same we get a zero and so
too if the first one is actually less
than the second one
so we now have these two numbers
one and zero one for when we need to
reverse the sign
how can we map a 1 and a 0 to
a
negative value negative one and a
positive value one
a trick that I think a lot of people
Miss is that you can use power or
exponentiation
if you use negative one that the base
and raise it to the power of one well
any number raised to the power of one
is itself so that gives us negative one
raising report to a power of zero for
any number
gives us a one
so now we can use this in our function
if we use negative one to the power of
the greater than reduction of the
argument
multiplied by the sequence we had before
then we get negative offsets when the
sequence is supposed to be descending
and positive offsets when the sequence
is 2.
and to be ascending and if they're the
same then we get a single zero no offset
from the starting point
all the remains is to add the first
value
to the sequence
and so this is our very efficient
solution
thank you for watchinghi this challenge is to take a variation
of a normal chest setup and just check
two things the King has to be between
the Rooks and the Bishops have to be one
white and one
black so here are some an example setups
the first one is valid that's a normal
uh chest setup with a queen and king in
the middle and uh Bishops next to them
and then Knights and Rooks and then some
variations of them uh these are invalid
because here the king is outside the
Rooks and here the king is again uh
here's the king is inside the Rooks but
the Bishops are both on uh the same
color
squares um and we can take this step by
step the two conditions and we create
this Lambda that refer to uh the
argument as Omega and then we just need
to check these two conditions the first
one is the order that uh we've got Rook
Knight sorry Rook King rook and that
means we're not interested in any of the
other elements only uh the letters K and
R so we can do the
intersection of the
argument with K and
R and now we can see that the first one
is valid because the king is in the
middle and then we can see that the uh
these two are this one is invalid and
this one is valid in this respect that
is invalid for a different reason so we
can just write that it has to be Rook
King Rook that matches the intersection
of the argument with Kings and
Rooks and the other condition so and and
and the other condition is that we have
opposite uh parity of the positions of
the um of the Bishops so let's not do
the end right now instead we're going to
do left um this ignores everything we
computed here and just returns one
what's on the left to make it a little
bit easier to see and then later we'll
restore this to an
end so if we create a mask where we've
got
Bishops and we transform the mask into a
list of
indices then we can get the parity which
is the remainder when you divide by
two and then we have to make sure that
they are not the same so one has to be
even the other one odd but doesn't
matter which one so they just have to be
different from each other so we insert
in inequality between them and we we get
this mask saying that uh that this is
valid valid and invalid
and now we can combine that with our
original mask that we got up
here to get our final mask just put an N
there and then it says that the first is
valid it takt to are
invalid thank you for watchinghi we're going to insert separators
between uh groups of three digits so
that's like the thousands in an integer
that's given to us as a character
Vector I'm going to go through a few
different approaches three approaches
here but there are many other ways to
solve this so have a look at the link to
the chat event in the video description
for more
okay let's first generate some test
data um so it doesn't really matter what
the digits are let's raise 10 to the
power of 0 through
9 and then we can make each one of these
numbers into a character Vector you
can't actually see the difference for
that
um but yeah they become boxed like
this and that's called that t
and then the separator doesn't matter
what it is just any one character here's
a
comma okay so um whichever way we do
this we have to start kind of from the
right finding groups of three
digits so um let's apply this Anonymous
Lambda to each one of the T with S as
left argument um and then we reverse the
argument
that that allows us to work from the
left
instead and what we actually want here
is a grouping so we can use the petition
enclos function to group and the way it
works here is that we're giving it a
mask so we're going to generate one 0
one0 0 and and as a mask and the ones
indicate beginning a new
section and how many elements do we want
well if we take the number of elements
in the right
argument um that gives us the length and
if we then replace uh if we then
reshape this and reshape a one 0 0 then
we will use those numbers cyclically so
this gives us one and then one 0 1 0 0 1
0 0 1 and so on and that's exactly what
we want uh for our partition in close
and we just have to remember to do it on
the Reversed
digits so this gives us our
groups now we can
add a separator to the front of every
group in list this and then we just need
to um remove
one from it because we we have one more
separated at the end that we don't want
and the last step is then reversal again
and that gives us uh the results we want
so let's call this one
F so this is one way to do it it's just
making these
groups another way to do it is to reach
for the regx
sublanguage so let's try
that again we want to work from the rear
we could use the regx engine to uh with
um lookaheads and look behinds in order
to work from the rare but it's much
easier to just reverse and then we want
to replace and we want to replace any
sequence of three characters which is
just going to be digits so there's no
reason to specify they have to be digits
except for the very
end so this is a negative look ahead to
say so we look look for any three
characters that is not followed by the
end of everything replace that with the
match followed by the
separator that gives us this reverse
thing and then we can just reverse and
be
done let's call this
G and finally um a more AP way of doing
this so let's uh let's look at what
happens here again we need to work from
the
reverse but now we're going to split up
into groups while keeping this flat so
it's going to be similar to the
um to the partition
inclose but we're going to and reshape
into a matrix so we're going to have
three
columns and then the number of rows how
many rows do we want well it might not
be divisible by three we can certainly
divide the length into three and then we
need to run up to make sure that we have
all the
digits
o uh was missing a reshape
here okay so now we can see that we have
been we have uh reshaped and reused the
digit so if there's only one digit it
gets filled out into to three here this
is a 10 this is 100 and here's 1,000 the
last three zeros followed by one over
here and then we're recycling the digits
over here but we're going to strip those
extra digits at uh when we're
done okay now that we have a matrix we
can take the separator and concatenate
on the
right so it gives us a column of
separators and then we just need to
flatten
everything and remove some trailing
characters we can see here we need to
remove three characters here two here
one here and then three and then
two and then one okay so we need to find
out how many characters do we need to
remove now let's just concatenate that
number as we Computing it well it has
something to do with the length as we
can see and it goes in periods of
three but this counts the wrong way here
this says remove one remove two remove
zero 1 two 0 we really want to go down
because we want to do 3 2
1 and uh we could do this with a
subtraction but we could also um just
negate the right argument to uh the
remainder so so now we it says we need
to remove
two that and one and zero so this is
just off by one so we just need to add
one more to
this however uh in order to remove from
the rare we need to use the drop
function and in then we need to have a
negative left argument so instead of
doing one plus this we can do -1 minus
this
and that
strips the excessive characters and then
we can
reverse it gives us our
result okay so which method is better
this one is a bit more involved and
depending what you need um if you just
need brevity or uh maybe some clarity
straightforward way or maybe you need
high performance uh then you can choose
between these let's look at how the
performance Compares
so um we're copying in the cmpx facility
from the defense
workspace and then we need to have a uh
a very long number so we can we actually
need to split up into a lot of digits um
let's
say a million dig um
digits so yeah let's just take the first
digit of that you can see this are the
the it's just Z one two 3 it doesn't
matter because it's just any
characters okay and then we need to
compare the execution uh of separator FN
and separator
GN and separator
hn just need to wait for it to actually
do
this and we you can see that using the
array based approach the flat array
based is definitely the fastest thing
you can do then uh if you have to use
nested arrays do that and resort to regx
if you really can't figure out a
different way to do it without regx
thank you for watchinghi
let's
compute areas of
Circle sectors
and when we're doing so we'll be using
APL as the mathematical notation
when reasoning about and simplifying the
mathematical formula
okay to get started
the area of a circle one way to think
about the area of a circle
is that you sort of say unroll the
circle
into its slices these pie slices or
sectors
infinitely thin ones put them next to
each other we get a rectangle the long
sides of the rectangle are then
contributed by the circumference and the
short size of the rectangle are the
radius
well the radius is equal to compute from
the diameter that's just half of it but
the long sides well we know that
diameter
times pi gives us the circumference
and we know that this this circumference
that has to contribute to Long sides
being that there are two that means half
of that would be one of the long sides
so we can compute the area of the
rectangle as the short side times the
long side
if it's pi times
half of the diameter that's pi times the
radius so it's pi times the radius
times the radius that gives us the area
of the circle
and we can express this in the APL quite
easily
we don't have a symbol for pi directly
but almost always when we're using pine
mathematics it's because we want to
multiply by pi
APL does have a function to multiply by
pi and appropriately is denoted by a
circle
so
Circle R means pi times R where R is the
radius and we want to multiply that by r
of course we haven't defined what R is
and we are going to take as right
argument
the diameter not the radius the right
argument that's omega as the rightmost
letter of the Greek alphabet and we can
divide that by two
and assign it into r
the result of an assignment is the value
that was being assigned so this sets are
to half of the argument diameter and
returns that same value which we then
multiply by pi times R and we can try it
with some values
APL automatically Maps arithmetic
operations so it doesn't matter that we
have three values here it will just work
these are the areas of circles where the
diameters 9 12 and 15.
we are multiplying Pi Pi with r and then
we keep multiplying and it doesn't
matter which order we do the
multiplication in so we can remove the
parenthesis over here and now it's very
clear that we have I term R times r
or R times itself
instead of using the dynick function
multiplication with one argument on each
side we can mention that the argument
only once and use the commute operator
or higher order function to change the
multiplication from a diadic function in
fix that takes its arguments on the side
to become a prefix function
and it uses then the same argument on
both sides of the multiplication
the symbol for this self thing as in
self multiplication is a bit like a
selfie face
but now of course we're only using R
here in the assignment and never reusing
it so we might as well just use the
Omega divided by 2 directly
this gives us the areas of these circles
but we don't want the full circle we
want
a fraction of a circle
a sector and specifically we want it
given in degrees so how big a part
of the full circle is it that we're
dealing with well let's say we have 60
degrees
so we want a fraction
of the full circle
how much out of the full
360 degrees
is it that we are having so it's the
left argument Alpha on the left most
letter of the Greek alphabet and divided
by 360. that's how big a part of the
circle it is and we multiply that by
the area of the full circle
and so we can see that
60 degrees out of a full 360 that's a
sixth of the full value we get the area
of a 60 degree slice or sector of a
circle
this is a solution to the problem
but let's try simplifying and condensing
this a bit
the first thing I'm going to do is undo
this selfie that we did before and
we do that since we have a fraction here
it's Omega divided by 2
then we can say Omega times Omega that's
the square of that divided by 2 and
divided by 2 again that is divided by
two times two
how does this work out because APL
functions have long right scope that is
this division symbol sees everything on
its right as its right argument so this
becomes
Omega divided by 4 and then times Omega
again so this is also Omega squared
divided by 2 squared
you can see we get the same values right
there okay it's all multiplication
division stuff and we know that
everything we multiply together on the
right that's what we divide by and
everything on the left and that's that
which is being divided so we are
dividing by 360 over here on the left
and we can move that over on the right
just by adding another 360.
to the terms on the right
and then of course we can compute two
times two times 360 is 1440.
okay this is already looking better
and this is about as dense as we can get
it while still mentioning the arguments
explicitly
however there is a different style of
APL functions and they're commonly
called
tacit functions and specifically we're
going to use a type of tested function
called a train
interested functions the reason they're
called tested we don't mention the
arguments we only mentioned functions
and that means the whole function the
overall function is defined in terms of
function applications to the argument or
in this case of arguments
since we have two arguments then all the
functions are being applied to arguments
are going to be applied to both of those
arguments and
this function the pi times function we
just want as a multiplication Factor we
don't actually need it to be applied to
any arguments at all
and therefore we're going to move it
over to the very end it will be a type
of post processing step
right then let's look at what we've got
in terms of the arguments well over here
I spot the left argument times the
regular argument again we're actually
doing a multiplication by everything on
the right but that doesn't matter
because it's all multiplications we are
talking about
so let's parenthesize this of course
that will still work
um and this is now a sub-expression
defined in terms of a function
application on both arguments
this one is a bit more problematic
because we don't need the left argument
at all we only want the right argument
so how can we express this in terms of a
function application to the two
arguments to both of them we need a
function that ignores the left argument
but does
take the right argument and returns it
as is that's it's an identity function
specifically a right identity function
now for that we have something called
Write tack symbol or the functions could
actually just be called right
and if we give it a left argument it
completely ignores that you can kind of
see it as a symbol that stops on the
left and points at the right so it will
return just the right argument like this
we can try it
it gives the same result and finally
another problem this isn't the function
at all
this is a constant but we need it to be
a function we need it to be something
that we apply to the arguments
but we don't want the left argument
don't want the right argument at all we
just want the constant this calls for a
constant function
obviously APL doesn't have a built-in
constant function that just takes
argument or arguments and returns 1440.
however we do have a higher order
function
which takes an operand just like we had
this selfie symbol which took a function
that took two arguments and made it into
a function that took a single argument
using the same argument twice we also
have a higher order function that
doesn't take a function but takes a
value in this case 1440 and turns it
into
a function that always returns that
value no matter which arguments you give
it
happens to be it's the same symbol
there is no contradiction or ambiguity
here because
this symbol this operator always takes a
single thing on its left
in order to derive a new function if the
thing on its left is a function then it
does that which we said before of moving
arguments around
and if it is a value then it derives a
constant function
so
we can give this function arguments
on one of both sides here we don't need
to parenthesize this last part because
remember APL functions have long right
scope and so the division sees
everything to its right as its right
argument
and this will then create a constant
function 1440 constant function apply it
to these arguments
and return 1440.
this is of course Very verbose and
unnecessary
but now we can switch from explicit
to test it and we do that simply by
eliminating all mention
of the arguments and we don't even need
our curly braces anymore we do need a
pair of outer parenthesis though
here's an argument let's get rid of that
that's another argument we're getting
ready
um over there then there are these two
arguments that we're getting rid of and
these arguments over here we want to get
rid of
and look we get the same result
the last step is then removing all the
Redundant parenthesis
and there we go
a tested function to compute
Circle sector areas
thank you for watchinghi here we are to take two
texts and we are to split the one on the
right such that um the first character
of the second segment is the first
character that is found in the left
argument let me illustrate
this so let's say We've Got U this is
the the splitter
characters and this is the actual
uh text that you want to split so D
doesn't exist on the left y exists on
the doesn't exist on the left a does
exist on the left so we want to split it
here we want to get Dy and we want to
get a
log and there are a few different ways
that we can uh we can do this let's get
started so what we can do is we can find
where we've got
and elements in the their
positions so if we look up
um so this is a lookup
function and but this will look up
elements of the right in the left and we
want the left in the right so we can
flip its
arguments so we can see that a is found
position three p it says seven because
it doesn't actually exist there so it
goes to the next index over here and L
in position
four we're not interested in all these
positions we just want the smallest
one so we can apply the
minimum uh reduction on on this that
gives us the
three however um three is not actually
the index we're interested in we want to
get one less than that because we want
to split it so we only get the first two
so we can add1 to
this then we take this
number and we use it to take this many
elements from the right argument and we
can also use it to drop this many
elements from the right argument we want
both to take and to drop and we want
them joined
together so the
take and the drop and we could
concatenate them together but that
doesn't do anything because then we're
just rebuilding the text from the right
no we need to encapsulate them so we
need to pre pre-process the arguments to
the concatenation function with an
enclosure and that gives us our result
there's one little issue here and that
is if the right
argument and which is the place where we
look up elements from the left argument
doesn't have any Dimensions that is if
it's a
scaler then we get an error and we can
fix this by pre-processing the right
argument with a comma uh which is Ravel
this makes it into one element Vector
instead and then it
works
so we can give this a
name this is
f a different way uh to approach
this um is begins off the same way
this's time uh let's stay
explicit so we've got
dialogue and
APL and we're going to do much the same
thing as before
let's look up the left argument in the
right
argument we saw this before let's take
the
minimum and
now we want to petition the right
argument and the way we petition is
using
um or actually partition inclose is the
more correct term is but using a Boolean
mask that is as long as this or shorter
could actually be one limit longer but
that's not really relevant
yet we want a one every time we begin a
new section and zeros for everything
else so this is a three that's where the
second position begins we also want to
begin at a partition a section position
one now we just need to create a buan
mask that has and these values now there
is a function in APL that goes the other
way if we write one Z 1 0 0 then and we
can use the where function to say where
are the ones but we want the opposite we
want to know we want to start with one
and three and do the inverse of
where luckily there is an operator in
APL which is is called the power
operator which can apply a function
multiple times including a negative
number of
times so this creates the shortest
possible Boolean
result
um that satisfies that when you apply
where to it you get one and
three so if we go in here and we use
where in inverse on this that gives us
the MK that we need and then we take the
right argument and do a partition in
close only the mask needs to go on the
left so we flip the arguments of this
and that gives us our
split there are still a couple of issues
as we have had before if we have a
scaler on the right of course then we
get a rangar and but we can we can fix
this by putting a
uh Revel over
there and another problem
is what happens
if the left argument contains the first
letter
interestingly this actually works but
how is that even possible for that we
let's take our part our solution
again we generated these two so we get a
one because we want to start a position
at the first position and then we
generate the lowest index where D
appears where the uh a letter from the
left
appears which is also
one so what happens when there are
duplicates for the where
inverse ah then it says that there are
two here maybe a little bit obscure
what's happening but let's say that
we've got 1 1 3 4 four four and five so
these are the positions of and our boans
that means that we want to have three
times
A1 at position four that is exactly what
the wear inverse
does so similarly we can go take this
one and put where in front of it so it's
saying where are the ones well there are
two ones at position two and there are
at position one and there are no ones at
position two there's one one at position
three there are three ones at position
four so this solution actually works
even though and we finding a match at
the very first uh position
we can also take the solution and turn
it test it like the other one so in this
then we would have the
reversed and index of we put left
argument on the left and the right
argument on the right we can join the
reduction to that so we're doing the
minimum of the re
flipped index
of then we apply this
and then we have to
apply this derived function to the
result of the concatenation which one
way we can do this is like this you can
test it this still we still explicit but
we've prepared all the pieces for ATT
tested
conversion you you see that this
works and now we can get rid of um all
mentions of arguments
and this wants identity function applied
to the right
argument and we can call this G oh we
still need uh the comma over here we
need to um we need to pre-process the
right argument using
Revel so now we can
write and and it also works for
scalers thank you for watchinghey
we're given a list of heights
of buildings
and imagine that we're standing at in
front of that list and looking
unto these buildings
then we cannot see a lower building
that's behind a taller building but we
can see a taller building behind a lower
building
so just needing to see a little piece of
a building in order to count it as being
seen
how many buildings can we see
let's have some test data
so here we have two buildings that have
the same height that means that the
second one is entirely obscured by the
first one
and here's one that's lower
which means you can't see that either
then there's a higher one that one we
can see
and again the lower one
and that's obscure is behind both this
number 10 and the fives over here so
suddenly we can't see that then there's
a 15 which is bigger than the 10.
and that's our third building we can see
in the 10 is obscured behind the 15.
but we can do this by hand we want to
write an API function that does this and
let's start by defining an a function so
this is an anonymous Lambda and we're
putting the test case on the right
referring to it with Omega which is the
right most letter in the Greek alphabet
and therefore is indicating the or is a
symbol for the right argument in defense
or lambdas if you want
okay now we can start computing
and what we want to do here is we want
to Traverse from the left to the right
and all the time looking at
how high a building have we seen so far
and what we can do is we can do is it's
called a scan using this backslash
and it's a cumulative reduction and in
this case we're using it the maximum
function so
maximum of five and five is five maximum
of five and two is five and then we can
see that so here we're getting a five
and then with the 10 we go up to 10 and
the 10 continues until ruling rolling
over the three because we're doing
maximum until we get the 15. so let's
try that
foreign
all we need to do is to see how many
different numbers are there because any
you will never get a lower number after
a higher number but we can get some of
the same
we're not interested in these are the
same we only want to count the first one
of each and a simple way to do that is
simply taking the unique
from that
so these are the heights of the
buildings but the problem statement is
to count how many there are so this
Telemark
counts how many there and there are
three
so let's call this F this is a very
short neat solution to the problem
and there are other ways that we can
solve it let's start again with
this cumulative maximum
and
this time we're going to look at the
mathematical relationship between these
numbers
so we are interested in whenever we go
from one Building height a plateau like
this to the next one we want to find the
places where
we're looking at consecutive adjacent
elements we have an increase
and we can do that by comparing
pairs five five five five five ten ten
ten and so on
so we want to reduce using less than
so reduction is the forward slash the
cumulative reduction is the back of
Slash backslash but we don't want to
reduce over the whole thing we only want
to reduce over sub
arrays of length two so that's what the
two on the left means
and we can see that these numbers then
correspond to the spaces in between so 5
is not less than five five is not less
than five but yes five is less than 10.
there is but one problem that since
we're looking at the change here then
we're missing
the
um we're missing one because there's
only one one for the change from this
size to this size and one one from this
size to this size
that's one less than what we have so we
could
um we could solve this in a couple
different ways but a very simple way is
to add a zero in
um in front
note that we cannot just add one because
if we
if we try to use an empty list of
buildings and we added one then if it
wasn't for giving issues with the with
the pairwise reduction we would be
adding one to because there would be no
buildings and then we'd add one we say
there is one building but there aren't
any but if we put a zero in front
then we will get an increase from 0 to
5. there the problem statement says that
these will be
positively and positive height buildings
make sense and so let's put this in
again
and then we can see that we get a one at
the beginning
and all we need to know now is how many
ones are there and we can do that by
summation so this is a plus reduction so
we're using a plus reduction a pair Y is
less than reduction and a cumulative
maximum reduction
and this gives us the three as well
let's let's call this G
now
if you think about what is the
performance going to be of these then F
has some pretty bad issues we're using
unique here even though we know a lot
already about
what this array looks like we know that
it's a non-decreasing
list of of numbers and unique will have
to it doesn't know this it doesn't know
this property so it will have to compare
all the different numbers that are in
the list which if it was a big city
could be a lot of numbers
um and it might do some hashing and
things but it's still not going to be
very efficient because it doesn't and it
doesn't know that all we need to do is
look at where the numbers increase
um and then it produces these numbers
which we actually don't need anyway so
even that will take up memory
um just for the a new array containing
all the unique numbers only for us to
encounters we're not actually interested
in the result of the unique we just need
it for the counting so that's really
inefficient whereas G is much more
efficient
um we
we keep we started off the same way so
of course that's that's the same thing
uh we'll get back to the zero comma for
a moment is concatenation then we switch
to a Boolean array
and as soon as you do that APL is clever
enough to compress this into using one
bit per element so that means we're now
down to an eighth of the memory used for
to represent all the data we need to
compute on if
we have one byte integers in the in the
Heights if we have even higher buildings
for multiple byte integers internally
then it's going to be even more extreme
difference it could be effective 16 or
32.
um and then the summation of this
Boolean is going to be really fast
because the inter because um the
processor has instructions on Counting
how many ones there are how many bits
that are set in the a byte and we can do
this in enormous chunks as well we don't
care about the individual bytes we just
want how many unbits are there in the
entire memory that we give it so that's
going to be really fast
however
um there is one issue
and that is the zero
quantization here this is our original
data that we get in and if we
concatenate the s0 on the left that
actually means
that we have to rewrite everything in
memory because the numbers are stored in
their order
and we have a packet so even even if
there wasn't the issue of preserving
this array which we would anyway we have
to rewrite an array of almost the same
size to one one element
more rather than doing the computation
directly on the data as given so this is
going to be a quite expensive operation
just in memory right time and in today's
computers
um the X very often the actual highest
cost is memory read and write
the processors are now so fast
um and so smart that they will just sit
idle waiting for us to give them work to
do all the time and many operations just
happen at memory throughput time and
this is
yeah this is uh the real bottleneck and
we want to avoid memory rewrites like
this so how can we code around this we
can
make a copy of of G where we want to
avoid this remember I said before that
there's an issue if we have a an empty
list where we can't just add one that
becomes wrong but let's ignore that case
for a moment
so here we know that we are off by one
we're not with missing a count of one
which is the initial going from zero to
the first building that you can see so
we add that back here and this gives us
the wrong result if the argument is
empty but we can do the check if the
argument is empty
um so
let's make two statements this is the
the Diamond this is a statement
separator and then we have what we call
a guard it's like an early out condition
and we're going to take this this is a
short formage of writing the empty
numeric list and if that matches the
argument then
we know that there are zero right there
cannot we cannot see any buildings if
there aren't any buildings to see
so this is a really quick check there's
we're not comparing any data we're just
immediately looking is are these the the
same we don't even
um
yeah we would I think even internally
it's represented as some constant that's
always there but even if it wasn't we're
talking about looking at the data type
of the array that they're both numeric
and looking at the shape of the array
and they're the same shape so we're done
that's there because there's no actual
content to compare
so this is a really quick check of
course that does have had some overhead
and it does add a branch point where a
branch particular could fail but it's
going to be dwarfed uh by
and the actual computation that happens
in the in the general case and of course
here we are saving ourselves even one
comparison
um everywhere and we get a single number
and then we're adding one which is
really cheap obviously as well okay so
let's see if we can
um actually see
the difference in performance
we have some a tool called cmpx or
compare execution uh we'll copy it in
from the defense workspace
and then let's generate a cityscape with
a whole bunch of numbers
um
let's do a thousand buildings and then
I'm going to randomize so the first one
is going to be a size one building and
the second one is going to be a size one
or two and then the third one is one or
two or three
and so the question mark role it takes a
number and generates a random number
between one and that number and the Iota
generates a sequence from one to a
thousand and this because we give it a
thousand and this and the right
and what this means is that in general
the buildings will become bigger and
bigger and if we made them all the same
then pretty quickly we would not see
anything more very little likely of the
senior so this ensures that we'll still
even at towards the end we'll still be
seeing more buildings
right a thousand random buildings
um and then we write our Expressions
that we want to test
so we want F applied to S and the g
applied to S and H applied to S and now
that we wait a moment for it to run
these Expressions a whole bunch of times
and comparing
them to each other
and we can see here that there's quite a
significant difference in the
performance between them but also
the
the definitions are Maybe
getting more and more complex and and
certainly longer
so sometimes you just have to wait
between how neat you want the code and
how performant you want it you can
always have both
thank you for watchingwelcome to the apl quest capl wiki for
details
today's quest is problem six from the
2015 round of the apl problem solving
competition
we're given two rectangles as two
coordinate pairs and we have to check if
they overlap
and that can be a little bit hard to
think of just in terms of words so let's
illustrate it here are two rectangles
and we can label their corners
in order to not continue to in order not
to get confused which rank that we're
talking about we're not just going to
use x and y like normally would we want
to use an alternately named coordinate
system for one of them um
where the horizontal axis is a and the
vertical axis is
b
so we got the xy rectangle and the a b
rectangle
and we can see here that each one of the
of the elements in the coordinates
are defining an edge so the left edge of
the xy
rectangle is defined by the x1
coordinate
and the bottom edge is defined by y1
similarly a1 defines the left edge of
the
other rectangle and b1 the bottom edge
now we don't know what order these are
given in and that's something we have to
keep in mind but for simplicity you just
keep it like this
and here we can see that
the vertical edge left edge of the x y
rectangle which is defined by the x
coordinate x1
and the vertical edge the right edge
defined by x2
fall in between so to say the range
between the vertical edge
a1 and the vertical edge of
a2
and similarly but oppositely
the edges defined by b1 and b2 fall in
between the edges defined by y1 and y2
and clearly these two rectangles overlap
now when a b is entirely contained we
have still the edges even though they
don't intersect the edges a1 and a2 are
in between x1 and x2 b1 b2 are in
between y1 and
y2 and even though there's only a
partial overlap like this
we still have at least one edge
vertically x2 between a1 and a2
and both of the horizontal edges b1 and
b2 are in between y1 and y2
now there's only one of each
so the edges x2 and
y2
are in between
the corresponding vertical and
horizontal edges on
the other rectangle but also a1 and b1
are in between
and here we have both x1 and x2 in
between and only
b1
in between
the other and then
2 in between b1 and b2
now there's no overlap anymore even
though x1 and x2 didn't move and they're
still in between a1 and a2
it isn't the case anymore that any of y1
and y2 are between 1 and b1 and b2
so we can see that in order for there to
be an overlap there must be at least one
horizontal edge that is of one rectangle
between the horizontal edges of the
other rectangle whichever one it is and
there has to be at least one
vertical edge from one direct angle
between the two vertical edges from the
others
of course if you move the rings entirely
away so that nothing has been in between
each other then there's no overlap
either
here there is an overlap
vertically in that b1 is between y1 and
y2 but there's no horizontal overlap
because both a1 and a2 on the same side
of x1 and x2
and so while close there is no overlap
here both conditions have to be held and
we're going to use this as our
case where it is false there's no
overlap
moving
x1
and moving the xy rectangle a little bit
to the left there will be an overlap
just in the corner and we can see that
we have the edges x1 x
and
y2
in between the corresponding edges under
the rectangle and also of course
follows with that that b1 and a2 are
in between the corresponding edges of
the xy rectangle
in the code we're going to
use labels for these it's the same
rectangle a b but we'll have x y one and
x y zero for the one that should give
true and the one that should give
false
and then in order to give some of them
some concrete values that we can work
with
let's just set an origin point which is
where the a1
sorry where the
b1 and the x1
edges would meet had they continued out
that gives us some nice small positive
numbers to work with but this of course
will be
very general
right
so
a b will have 0 2 and
5 9
x y 1
4 0
11 3
x y 0
zero and thirteen
three
and now we'll start building things up
so let's just make a placeholder
function for now the concatenation of
the encloses that just juxtapose
the two arguments and we're going to run
our test cases every time so w