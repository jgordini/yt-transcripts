hi
this may look like a very complicated
specification
but all is really asking for
is cutting it a
Vector into two parts
and we specify the length of one of the
two parts the other one is just the rest
of the elements
we want either the first
n elements
grouped and then the rest of them in the
second group or we want the second group
to be the last n elements and then the
leading elements up to that
form the first group
and the way we determine if we want the
first to last
is by the sign of this number
so a positive number we specify the
length of the first group and the
negative number specifies the length of
the last group
this kind of specification
is parallel to apl's take and drop
Primitives
so the take primitive can take the first
three or take the last three and
similarly we can do
drop the first three
and
drop the last three
this pretty much gives away how we can
solve this problem
so if you take the positive case first
and make a little Lambda
where the left argument is Alpha and the
right argument is omega
we can see here that we want the first
three elements
and then we want the second group to
have the first three elements removed
however if we flip the sign here
then our groups come in the wrong order
we can fix this by
reversing
but we don't want to always reverse we
want to conditionally reverse
one way we can do this is by using the
power operator
power braid it takes a number on the
right
and that number is the number of times
we want to apply this function on the
right on the left
how many times do you want to do it well
we want to do it zero times if the left
argument is positive and one time is the
left argument is negative
luckily
APL comparisons return 0 or 1 for false
and true
so if 0 is greater than the left
argument that gives
zero in this case we reverse zero times
and if it is
true then it gives a one a reverse once
which solves our problem but we can make
it a little bit more elegant
by observing that since we only have two
elements in our array reversing is the
same thing as a one step rotation so we
can try this
the dyadic form of the same symbol is
the rotation so here we've rotated one
step and if we
have a positive number the number on the
left we want to rotate zero steps
and that means we can use the same
expression
where the zero is greater than the left
argument in order to find out the
rotation amount
this function
can be converted to a tested or Point
screen form
we can observe here that we have a
pattern we have these two arguments that
are applied
with one function and with another
function and then there's an invisible
function that binds them together which
is the stranding into an array
but stranding into an array is actually
concatenation of the enclosures
so if we do a concatenation but
pre-process both arguments with an
enclosure we get get the same exact
thing
and now we can make a proper Fork
so what happened here is that we
removed the explicit mention of the
arguments
to outside this little function
and so these are three functions one two
three the arguments are used on the left
and the right function and their results
are combined using the middle function
which is the stranding together
functional pairing function
concatenation of the enclosures
here we have zero is greater than the
left argument
so now we can go through and convert
this whole thing to a tested function
zero is greater than the left argument
left argument here
right argument here and we finish off
that tested function
however
this inner function is being applied to
the result
of taking the left argument and the
right argument that doesn't add anything
so we can strip off that outer level
and here's our final function
thank you for watching