welcome to the apl quest
see apl wiki for details
this is the first problem of the 2014
set from the apl problem solving
competition
we're given this left argument
the two supposed shorter sides of a
triangle and this right argument the
longer side
we are to check
if these three numbers together
can work as length of a right-sided
triangle
a right angle to triangle
it's of course natural to use the
pythagorean theorem let's put in some
test cases here two shorter sides two
and four another case with shorter sides
three and four
we're going to try this with a longer
side that's four and a half and five the
first one is going to be false and the
second one is going to be
true the pythagorean theorem states
that
the sum of the squares of the left of
these two shortest sides
matches the
square
of
the longer side
we can write this in various ways
if we
observe that the square is of the same
thing as multiplication by itself
then we can see that we are summing over
in the application of a
scalar function
all right with a scalar reduction over a
replication of a
scalar
function application is
the same thing as an inner product
and here we have
the same argument being used twice on
the inner product which means we can use
the selfie or commute
operator we can do the same thing with
the commute for
the multiplication
there's the different way of stating the
same thing
we can also make a tacit
we want
this inner product applied on the left
argument
and we want
the self multiplication applied on the
right argument
same thing just in a test form
we can also break out the multiplication
because we really start with
squaring both arguments and then we're
summing one of them
so by using the over operator we can
preprocess both arguments with
self-multiplication or squaring
and now we only need to sum the left
argument so we could write this as
the sum of the left argument matches the
right argument
or
we could use normal equality but
pre-process
an argument we can't represent the left
form but we can't pre-process the right
one and we're going to pre-process it
with
summation the problem is of course it's
the left argument we want to deal with
but we can fix this by commuting
swapping around
the two arguments
we could also start off by commuting
then we preprocess with squaring and
then we have
the summation on the right
however
observe that
a reduction over a single element
doesn't actually change it so the fact
that we're preprocessing only the right
argument with the summation
could
we can use that
to fold this
reduction into our preprocessing of both
arguments because a summation of a
single argument doesn't matter
here we have equality where we
preprocess both arguments
with the summation of the square we
don't need to compute anymore because
we're treating both arguments exactly
the same
and of course we can combine
this plus reduction over the
multiplication
and into
an inner product if we prefer that style
a whole different way to approach this
is by using complex numbers
so in the complex plane
we can
we can look at the two shorter sides as
the two components the real
and the imaginary
and then
we have the diagonal being the magnitude
the whole length of that vector in the
2d space that the complex plane forms
so now we just need to
combine these two parts into a single
complex number and it doesn't matter
which one becomes the real part and
which book and becomes the imaginary
part because we're going to take the
absolute value of it anyway
so
um we can start off by saying the last
element of the
left argument
we multiply that
by the imaginary unit
and then we take the first element there
and add to that so this combines the two
now we can take the absolute value of
that
and compare it to the right argument
we can also make this test it
we
all this thing that we're doing
is really pre-processing the left
argument so as before we can swap our
arguments around and pre-process the
right argument instead
the last element we multiply it here and
then the
the first element take the absolute
value of that that's how we preprocess
another way that we can
write this
is using negative 11 circle that's
simply its definition
it just multiplied by the imaginary unit
then someone came out with a clever
thing using
four circle
if we apply four circle we get back to
what exactly that mean on the ratio
between the two elements in the left
argument
and then we multiply by the second
element
then that should match the right
argument
and that holds for our test cases let's
prove that that is in fact
the case
for that
let's try to make a test it again we are
preprocessing the right argument
so we can
we can write it
the ratio of these two the four circle
on that and then we just want
the last argument in the last element of
the uh
of the original left argument so we can
write that we can either combine these
two they take the um the first
um of the reverse but we can also just
use
um a right tech reduction it's a right
reduction
and we preprocess the right argument to
the equality with that
and we just need to commute things
around so this is the tested form um of
that alternatively we could use first
and we could and
commute the elements
of the sorry commute the arguments of
the division and that would also work
but how does it actually and how does
this actually work let's go go back to
our and our defense form
with uh let's see before circling right
here
this one
so the definition of a four-circle is
the square root
which we don't have in
this apl
but we're using this as a placeholder
we're going to eliminate it later so the
square root of and one plus
the square
this is going to be a little bit and
complicated using the elements of the
left argument so let's give them names
a and b
now we this is the last one is b
and the fraction
bond random is just a divided by b
here's the square of a fraction that's
the same thing as the fraction of the
two squares
we have a b outside the
square root we can get it into the
square root
by squaring it
now we have 1 plus this fraction
where the
denominator is b squared that means that
we can
we can add on top of the
of the fraction a b squared instead
and now we can observe that we have this
whole thing this sum is being divided by
b squared
and then it's multiplied by b squared
those eliminate each other
we have a square root here
and we can and we can just square on
both sides of the equality
and now we have the sum of squares here
so we don't really need these names
anymore it's just the sums of
um of a b squared
and a and b together they are the left
argument so we can get rid of our
temporary names and this is exactly the
pythagorean theorem so we've proven that
the solution using four circle
is exactly the same thing
okay
now for the last solution which is a bit
involved and it uses a rarely the rarely
used uh
domino
function
which is a matrix inversion although
we're using it here only on vectors and
scalars so
it's a bit of a misnomer to call it
matrix conversion maybe extra inversion
or just
inversion
and it's very clever it is
the
ratio between the inversions
of
of both arguments so this is using over
we check if it matches
the ratio
between these
the arguments
okay what's going on here how does this
work it does actually work for our test
cases but let's start to
to unpack this a bit
and so first we have a division here and
we're pre-processing both arguments
using
this domino
here's the right argument
and
here is the left argument
and then we are checking if it matches
the ratio between the arguments of all
now um
this inversion function and we'll apply
it to a scalar is exactly the same thing
as just a normal reciprocal so we can
replace that
and we can also see that we're dividing
by a reciprocal that's the same thing as
a multiplication
so far so good
what does it actually mean
to invert a vector
what it does is
it finds a vector for which the dot
product with the original vector gives
one
so it's in a sense it's inverse
just like
five and a fifth multiplying by each
other you get one
so the vector is going to have the same
direction
but this reciprocal magnitude
this is
the in
this means that the inverse vector
would need
to be multiplied twice by the magnitude
to get the original uh
vector
right what's
since uh
multiplication once by the magnitude
gets us um half it gets us
to the middle to one
so that's the same thing and that means
that multiplying twice by the
magnitude gets us all the way back
to the original
let's
test this out a bit so we invert
3 and
the 3 4
and then we can multiply that
twice
by that supposed magnitude
and we can see that we're right back
where we started
if we try to do this for and
for arguments
that are not
forming a right angle triangle
then we're going to see that it's not
going to work to
add up
close
but not quite
nope this isn't even right it's supposed
to be
two even closer still not right
have our example from um before
so if multiplying it twice gives gets us
all the way there multiplying it once
gets us halfway there kind of
meeting uh in the middle
where do we so if
multiplying the inverse
by the magnitude
twice gets us all the way to the
original argument if you only multiply
it half
halfway there or you multiply it once
then it would be the same thing as
starting from above starting from the
original and dividing it once by
uh by the magnitude
hence what we have here
so we multiply so this is the diagonal
the order magnitude and we're
multiplying it once by the magnitude is
the same thing
as dividing
the original by
the magnitude and that only holds
if
it's a right angled
triangle
so we we need to test if they meet in
the middle if the
if the inverted vector
times the supposed magnitude matches the
original divided by the supposed
magnitude then they met in the middle
and then what we've supposed is them is
the magnitude is actually the true
magnitude
okay so we said that the inversion
of this vector
is the same thing as scaling it down
twice by its magnitude so let's
let's test that let's write that out
so we're scaling it down we're dividing
it
by its
magnitude twice
and its magnitude
is of course
the square root
of the squares of this component
next out
next up we see that we have a square
root here
but it's squared
so they cancel each other out
oh sorry did i
let's go back a step
we had the square root
of
the sum of this of the squares of course
to get a get diagonal and that was
um that was being squared yeah so these
two cancel each other out
and we have the sum of uh the squares
that we are dividing um
the original by
now we can see that we have alpha
divided by something over here
and then multiply it by something
and over here we also have alpha divided
by so if we divide both sides of the
quality by alpha
we can eliminate that
now we have a reciprocal of this
times
the right argument
so a reciprocal multiplied by something
that's the same thing as that something
divided by the value
then we can take the we have a
reciprocal of the right argument over
here and let's take the reciprocal
of both sides of the equality that
eliminates this and we just need to swap
over the arguments over here
we divide by
the right argument over here and here we
just have the right argument so let's
multiply on both sides of the equality
by
the right argument
that eliminates this division
and this self-multiplication is of
course the right argument squared
and therefore
we have here the pythagorean theorem
again the square of the long side
equals
the sum
of
and the squares of the
the two shorter sides
so that's how
this very impressive five character
solution works and inspect the whole
the exact same thing but just in a very
disguised way and then with one caveat
since we're doing all these divisions if
we have any zeros
then it will fail so it doesn't actually
work if any if sides are zero but then
that it's very clever
thank you for watchinghi
we're going to count how many of each of
a given set of letters appear in a given
string
so let's start with some sample data
and we can see here that there are three
A's
two C's no G's and two T's so let's see
how we can compute this
because we're only returning the numbers
for each letter one number for each
letter and not say some kind of
dictionary that Maps the letter to its
count then it's very important that we
preserve the ordering
of the letters
so we want first the count of the A's
then the C's then the G's and then the
t's
and the way we can do this is with an
outer product an outer product Compares
and or combines
every element from the array on the left
with every element from array on the
right using
a given function
in this case it is equality that we want
to use
so we write this in a special syntax jut
Dot and then we put the function on the
right
and this gives us a table and we can see
how the a c g t formed our the
individual rows and then the letters of
a t t a c c a formed the columns and we
get true which is one in APL whenever
they are equal to each other so the
first one is an A and then we get a t
and another T and an a
in order to find out how many there are
of each all we need to know is how many
ones are there
in each row and we can do that by
summation
so
this is the reduction operator
also known as reduce and when it's
written like this then it reduces along
the rows which is exactly what we want
here
we can see that this gives us the right
numbers that we have three A's
twozies no G's and two T's
this is an expression for the solution
but we want to package this up as a
function and there are a couple of ways
we can do that the simplest way to do it
would be to
take the formula itself substitute an
Omega with the hard-coded value and that
represents the argument and then the
braces are the function definition
now we can apply F directly to the
argument
however
since we're only referring to the
argument here
so the at the very right
and only once it's very simple to
convert this to a so-called tested or
point-free function
that is one where we don't mention the
argument specifically
however
um there is a system to this if we
remove the braces and the Omega then we
end up with a new derived function which
is the outer
equality or out of product equality
with
a left argument but no right argument
and that's a bit of a problem
so we really want a placeholder for the
argument here and that we can do by
putting in
the
density function so in a tested function
we always refer to the arguments in
terms of function applications and in
this case we just want the value of the
argument itself so that is the density
function applied to the argument
so this works exactly the same
we could also combine things in other
ways in order to show kind of the
grouping between things
so the summation here is really
it really forms a pair to go with the
outer product
to form this sum of the equality table
and if you want to indicate that then we
can put it over here and group them
together with parenthesis and this will
work as well
whereas before this whole part formed a
single derived function
and then its result was being fed to
this derived function the summation now
it is
a combination of these two functions the
table and the summation and this whole
new derived function which is the sum of
the equality table gets as left argument
these four letters and as right argument
the identity the result of the identity
function applied to the argument
instead of doing that we could also bind
or Curry an argument
using the bind operator which uses the
same symbol as the outer product but
they're not always related
and this binds a left argument to this
General function which is just the sum
of the equality table
so we can
use this function as well it gives the
same result
we could also Define a general purpose
function say counts
which we'll just Define as that middle
part
and now we don't need any parenthesis
because it's just the two functions with
no arguments or anything else around
them
and this would be a general purpose
function in that we have to give it the
vocabulary as left argument
and then
the main data argument on the right
and we can then use that in turn
to create a derived function based on
the general accounts function
then we can then apply
thank you for watchinghi
we are given a bunch of scores and are
to convert them into grades represented
as letters
here are some scores they are arranged
in a table a two Row three column table
and the shape doesn't matter
we need to be able to handle any array
but as we'll see that won't be a problem
let's start off with a little Lambda or
a defen and then we refer to the
argument with the letter Omega the
rightmost letter of the Greek alphabet
now we use the the interval index
function
it gives us the indices
of the elements on the right
in a lookup array on left
but it's not just finding those elements
there it is the intervals so the array
on the left has to be sorted and we
figure out which interval with the right
side elements fall into
on the left let me illustrate this so we
write our cutoffs from the table
and now we go and look up
71 it's not in the list of cutoffs
instead it would fall in this interval
and the intervals are
inclusive on the left and exclusive on
the right the last
cutoff goes for Infinity after that
and and this is interval number one
which Falls between after the first
cut off
we can see that by 59 which falls in
that first interval so which ends before
65 begins at zero if there were any
elements that would go before zero that
is negative number then
we would get a
interval number zero but by default
that's not a proper index and we don't
want that so therefore we begin with
0 which is the cutoff for the first
element APL supports
multi-indexing that is when we index
into an array or a string in this case
then we can index using multiple indices
the result is all always has the same
shape as the indexer so here
we get an array of two rows and three
columns of indices and each one of those
indices will then be applied in turn to
the lookup array this effectively
translates the indices to this alphabet
and here we have it these are the letter
grades thank you for watchingwelcome to the apr quest capl wiki for
details
today's problem the eighth from the 2015
round of the apl problems of
compensation
asks us to replace
instances of the number 13
with the number 12.99
but only numbers not where it's written
in text
however um
while
the test case is given in automated
testing system on problems.trypill.org
only our fully numeric
and flat arrays
by extending the
the domain you can get quite some depth
to this problem
without further ado let's get started
so let's start with
a very simple test case the type of test
cases that we might see in the automated
testing system
and for this we can use a mathematical
approach
so
we can say
the argument
minus
0.01
times
a boolean mask
the argument
so here this will give us ones where
there are 13s and then we multiply with
this which is a difference to
that we need to make when we have a 13
and then we subtract that from the
argument itself and that works fine for
arrays
like this
however
if we
say
take it very literally what it says in
the problem specification that we only
need to concern ourselves with uh
with data that is uh there are numbers
and not uh 13s that occur in text that
would seem to indicate that there could
be text so let's throw in some
characters
so this is a flat array still but it's
mixed type
and of course
this is not going to work very well when
we try to apply the f
function
on it
and that is because
and
we
are trying while we can compare to 13
and it will give us 0 for the d and the
e
we cannot subtract zero from d and e so
we get a domain error in this case
and we had to go with an entirely
different approach
so
let's write a different function here
and
one way we can do this is to use
um selective assignment to change the
value or we could use
modify this and select the assignment to
do the subtraction
for that we need a variable which we are
allowed to change uh the omega in a d
fin is a constant we're not allowed to
uh to change that so we'll take that and
we'll
use the name r instead
we don't need
this value right away so we'll defer
that instead we want
12.99 and we want to put that into
uh
into r but only into a subset of r
selected by the mask where
13 is equal to
the argument or we could put an r as
well here it would give the same result
now the r has been updated we just need
to
ignore the result of this assignment
which would be 12.99 anyway
and then return r
and g can be used in this
variable and it just ignores the d's and
e's and even the 11 because we're only
interested in elements that are
13.
okay
what happens if
we
change things up a little bit let's do
let's take
these numbers and letters from b and
make them up and make them into a matrix
instead
so now we've got a matrix with numbers
in one column and characters in
the other column and if we try to use g
on
on this then we get a rank error
because we cannot use compress
with a matrix left argument it has to be
a vector a mask over the columns or
elements in this case but
we can of course
fix this
so if we um
if we take
this g
and make it into an h and then we ravel
the
argument values first
and then we ascending to the reveled
argument
and then but we didn't actually revel
the um the array r and then we're
returning that there so let's try that
hnc and that works as well
but we said text before and
that might be even
more than
this
before we go there and let's just see
another way of doing this which is
very similar in what it's doing
but
much more concise
that is to use that operator so really
what we're saying is that
not considering the shape of the
argument
we just want to replace with 12.99 at
the positions where 13 equals that
and that's exactly what the after
operator does
so you can write 2.99
at
where 13 equals
the argument
um and that's
all we need to do really
and that works as well okay back to the
text
and the text of course can be more than
a single character so let's
have a new array
which again let's stick to a matrix so
that we make sure that we don't have any
regression on that
and this time
we're going to use a character vector as
one of the elements
so it looks like this a nested array
this time because one of the elements in
the array is itself a vector
if we try to apply this function and i
on d or for that take if you were to try
to apply h which works exactly the same
way
then
it's not going to work
i would give us this
and h
so you get a domain error here and that
is because
um when we're doing this comparison
we're creating the boolean mask
and so we said 13 is equal to the
argument
on d and when and equal is a scalar
function which means it penetrates into
our structure
and so we get an array of the same exact
structure but with boolean values inside
however such a nested array is not a
valid argument and not for
replicate
and
not for
that operator either
so what can we do about this
well
one thing we could do
is
not to use equal because we don't want
to penetrate instead
and we don't want to penetrate into
the arrays
so if instead we look at
whether these
elements individually are members of
13 that would consider them as a whole
so we have a collection which is just a
single element 13
and then for each element in the
argument we look at whether or not they
are members of that collection we call
that single element and then we can see
we get
an array of the same shape as the
argument
and it doesn't penetrate into all that
structure
so if we modify our i function and
just changing that one little bit
then we're able to
use our function
successfully
okay
but let's
complicate matters even further
so we had
a
d here with a character vector which as
one of the elements but let's say we
have a more complex structure so we have
a still matrix
but
and still the same
elements
but this time
we we bunch together
these two
elements into a single element so
they're actually three elements and
we're going to
reuse the 11 because we need a fourth
element so we can see that here
and now the 13 is hidden deep inside
so while we can use
the function
j here
it didn't actually work because
inside it it had a look
are the elements members of 13
and it said that
the two element vector of dd and
13 well that's not a 13 it's a two
element vector
but that kind of defeats the purpose
because we would want this 13
to be replaced
so one solution to this
is to use recursion
we only want to consider the simple
scalars and replace those
now simple scalars they have a depth
of zero
if we don't have a depth of zero any
other depth
then we need to recurse we need to go
one step in so on each element
whether it's just an
a scalar enclosure or whether it is a
vector or any other rank array we go
through all the elements in turn
and consider them a new calling the same
function
otherwise which means we do have a
simple scalar there are only two cases
either we've got a 13.
in which case we replace it with 12.9 or
we don't
in which case we leave it unchanged
now we can apply the function to e and
we recurse through the whole structure
and replace the deeply hidden 13 with
12.99
we can actually use a method that we had
before
this
function h
we were reveling
the data
to find the elements so that
we could use compress
and we could do exactly the same instead
of rambling we kind of do a super
reveling which is in list still we're
not
changing the actual structure of this
temporary variable r
we are just assigning to its
corresponding
completely flattened version and the
same thing we are comparing 13 to the
completely flattened
data in r
and then we can
oops i should have
should have named this not k it should
have been
l
that's better
and then we can
we can use l on
uh on e and that still works
finally there's actually a pretty neat
trick
that we can
use in here and that is to combine
this ability to assign to
the enlist of a variable
with the neither notation of using an at
so
again we make a copy of our argument we
enlist that
and then change 12.99
where we have got
13
equal to well you can write the way
we've done before
well actually
i like writing 13 first um because it's
more i find it more idiomatic in apl to
write what we're comparing with
on the left as i see functions as having
a left argument which is kind of
parameter and the right argument is the
data so i'll write it like this
and now we've got we replaced all these
values of 13 with 12.99
um
but we have it all flat and we just need
to stick it back into the structure it
came from so we're assigning this
to the list of r
and then discarding that and returning r
and now we can finally run this
and
that also works
so that's all for today thank you for
watchinghi
this may look like a very complicated
specification
but all is really asking for
is cutting it a
Vector into two parts
and we specify the length of one of the
two parts the other one is just the rest
of the elements
we want either the first
n elements
grouped and then the rest of them in the
second group or we want the second group
to be the last n elements and then the
leading elements up to that
form the first group
and the way we determine if we want the
first to last
is by the sign of this number
so a positive number we specify the
length of the first group and the
negative number specifies the length of
the last group
this kind of specification
is parallel to apl's take and drop
Primitives
so the take primitive can take the first
three or take the last three and
similarly we can do
drop the first three
and
drop the last three
this pretty much gives away how we can
solve this problem
so if you take the positive case first
and make a little Lambda
where the left argument is Alpha and the
right argument is omega
we can see here that we want the first
three elements
and then we want the second group to
have the first three elements removed
however if we flip the sign here
then our groups come in the wrong order
we can fix this by
reversing
but we don't want to always reverse we
want to conditionally reverse
one way we can do this is by using the
power operator
power braid it takes a number on the
right
and that number is the number of times
we want to apply this function on the
right on the left
how many times do you want to do it well
we want to do it zero times if the left
argument is positive and one time is the
left argument is negative
luckily
APL comparisons return 0 or 1 for false
and true
so if 0 is greater than the left
argument that gives
zero in this case we reverse zero times
and if it is
true then it gives a one a reverse once
which solves our problem but we can make
it a little bit more elegant
by observing that since we only have two
elements in our array reversing is the
same thing as a one step rotation so we
can try this
the dyadic form of the same symbol is
the rotation so here we've rotated one
step and if we
have a positive number the number on the
left we want to rotate zero steps
and that means we can use the same
expression
where the zero is greater than the left
argument in order to find out the
rotation amount
this function
can be converted to a tested or Point
screen form
we can observe here that we have a
pattern we have these two arguments that
are applied
with one function and with another
function and then there's an invisible
function that binds them together which
is the stranding into an array
but stranding into an array is actually
concatenation of the enclosures
so if we do a concatenation but
pre-process both arguments with an
enclosure we get get the same exact
thing
and now we can make a proper Fork
so what happened here is that we
removed the explicit mention of the
arguments
to outside this little function
and so these are three functions one two
three the arguments are used on the left
and the right function and their results
are combined using the middle function
which is the stranding together
functional pairing function
concatenation of the enclosures
here we have zero is greater than the
left argument
so now we can go through and convert
this whole thing to a tested function
zero is greater than the left argument
left argument here
right argument here and we finish off
that tested function
however
this inner function is being applied to
the result
of taking the left argument and the
right argument that doesn't add anything
so we can strip off that outer level
and here's our final function
thank you for watchinghi and welcome to the apl quest
c apl wiki for details
today's quest is the sixth problem from
the 2013 round of the apl problem
solving competition
it's a very simple problem uh just
finding out the numeric range of an
array that is uh the highest value minus
the lowest value
um but we'll see that there is a special
edge case that we need to take action
for and we'll look into some
generalization as well
without further ado
and let's generate some data we can work
on
okay so here's a numeric vector and the
highest value is the maximum reduction
of that vector and this
lowest value is the minimum reduction
over the vector
and then we can take those two values
and subtract
the smaller
from the larger
and we get the full numeric range so
that's really all there is to the basic
problem
let's put this into a function and we
can write
the max reduction of omega minus the min
reduction of omega there's a redundant
parenthesis here but that's mostly just
for clarity and
to make the expression symmetric
so we can try this on v and that works
great now there are a couple of problems
with this
one is that it has to work on any array
so let's make a matrix which is two rows
and four columns containing the same
numbers as v it looks like this
now if we were to apply our function
here
on m instead then it doesn't work
because it gives us the numeric range
for every row we want the numeric range
for the entire array
and we can solve that
by
raveling the array first
so we revel it here remember it here
um and
this gives us the full range
as we can see here we are reveling twice
which is quite unnecessary and we can
actually in a neat way break this
reveling out of the parenthesis
so let's get rid of the ravel from here
and the rev from here
and we can actually switch to a tested
form quite easily so we just say the max
minus the min
off the ravel of
the array
here we go
and we can get this even further because
now we can observe that we actually have
a full tested function and a top simply
wrapped in a different wrapper so we can
completely get rid of that syntax and it
still works we can give this a name then
see how that works
of course still works on our vector
it also works on
a scalar where the range is zero because
we revel in the largest
minus the
smallest is and it's the same number so
it gives zero
so this is a good method
and one method that isn't so good but
it's kind of fun to look at if we take
our
our vector and do an outer product
but instead of multiplication we're
doing an outer
subtraction so that means it's a
subtraction table that gives all the
possible differences
between values and then the full range
is then the largest number in this table
so we can take the maximum of the level
of that and that gives us also the range
not a good way to do it but it works so
we could make a function out of this by
saying
um
the maximum over
and
ravel of
the outer
and
subtraction
selfie
and in fact this will work on our matrix
as well it just generates an even higher
rank array as an intermediary step
but there's a catch
according to the example cases in the
problem specification
the function also has to work on
empty arrays and that doesn't work why
doesn't it work well we can try our um
original function
um let's go up and define that again
we have it right here this was this one
if you try that on say the empty vector
we get a domain error
and uh we're supposed to get a zero
instead as it to say there is no range
the problem is
that the maximum
over
an empty vector
is the smallest representable number in
the current numeric system
so these are 64-bit floats and this is
the smallest representable 64-bit float
why is that
that is because the reduction over an
empty axis gives the identity element
for that operation so for plus identity
element is the value that you can plus
with
without changing anything that would be
zero for multiplication what you can
you can multiply with is a one
and for max the only number that you can
do a max with
and make sure that your original numbers
becomes the result so it's an identity
operation
nothing changes is the smallest
representable number or a negative
infinity if that's
available and similarly if we do a
minimum reduction we get the max
representable number and trying to
subtract
this very small number from this very
large number goes beyond the range of uh
the floating point system that we are
using and we get the domain error
so this system doesn't quite work
how can we solve it well one simple way
to do it is simply to say is our array
empty
now we can't just compare to the empty
vector because there might be multiple
x's say we could have a
a
zero row
two column matrix of numbers
which
isn't visible but it sure exists
what we can do is that we can take its
shape and there is a zero there and if
there is a
zero anywhere in the shape of an array
it's called an empty array and then the
range has to be zero so we can write
this function as if zero is a member of
the shape of the array then return zero
otherwise
we take the maximum
minus
the minimum
of the ravel of the array and now we can
apply this on each of our arrays the
vector the matrix the empty
vector and why not our zero by
two
matrix as well and now it works so this
is a valid solution and it's very clear
it's probably the clearest
solution that there is
but we can be a bit more
clever about this first for a fun
solution but not an efficient one
and that is if we sort the array first
so we let's say we start with our matrix
and then we revel the matrix and then we
sort it
then we know that
the
range is the last element minus the
first element
so the last element can be written as
the pick atop
reverse
minus the first element which is just a
first pick
and and that works and the reason i'm
using this method for getting the first
and last element is because if we try to
pick the first element of an empty
vector
then it coerces out a number so that
means that both of these terms would
become zero so we get zero minus zero
which is zero and that's the correct
result for the empty array even
of course if we have something like this
a matrix because we revel first it will
work the same way so this is a solution
but not a very good one in order to make
it a full function there are a couple of
different ways we could do it um
we could take this tested function here
and put it inside the parenthesis but as
you can see the color changes that is
because it ceases to use the sorting
idiom so things will run a bit slower
but it works if you want to preserve
the
speed of it then we can just string
things together
using in the top either way it could be
in the top here or you could be in the
top over here or we can use all three of
them all of that works
all three are topped together
there are uh
clever ways that we could do this
and for that we need to think a little
bit okay so we have a matrix
and we need to ravel it
and
um
then
we want to have a zero
if
the array is
empty okay how could we how can we do
that so we can we can tally the reveled
array
and then
we can
have a maximum
with one
so if the array is length zero then we
get one otherwise we just get the length
of the array
and then we can use this
to take from the reveled
um array again
okay so now here it doesn't make a
difference of course we can see that
that gives our data as we expected if we
do it on an empty vector
then we end up overtaking by one
and that pads with another
zero at the end and then the rest of the
procedure will be the same so we can say
the maximum minus the minimum
of
the revel
let's say we can write take this whole
expression here
we can
write it like this
and then we can go and simplify
things a bit um we can turn all of this
tested actually
so we could ravel first
and then we could apply a function to
that where we
use this value which is the length
except it becomes one and we can take
from
that same thing
so this is a possibility and now we
don't need the braces anymore
but we have three functions here so we
need to atop at least one place
so now we can this works and it works on
empty arrays as well
um and but there's actually
more we could we could do firstly for
the syntax here
and we instead of since we have three
functions that we want to avoid we
because of we have to do the explicit at
the top we can take
this which is a magnetic function
and put inside the parenthesis as a left
carriage on the strain so here is
the original function we're applying it
becomes a fork right here and then
another fork
and then finally in the top with this
function here so that works as well
and it gives us our results as we expect
what else can we do well
observe
that the ravel of an array
gives us all the elements in a single
vector
how many elements
well that's the product over the length
of all the x's in that array so for our
matrix
the shape is this
and that means that the product
is how many elements we have
very good
so if we
say that there are none
so if there's any zero inside
the shape then the product is going to
be zero
so we can take that the maximum of that
will one
and then we can simply use that to
reshape their array itself
so here when the array is empty we
reshape the empty array into a one
element
vector giving us just a one element
vector with a zero and if we used it on
say our matrix
then this would be equivalent to
reveling it
so we can put all this together and
again say
the maximum minus the minimum
of
the array itself
reshaped by the maximum of
one and the tally of uh the array when
that entire thing is reveled
and this works
so that's one way to do it
another thing we can do is since we're
raveling anyway then we can
selectively append a zero which will
then be picked up
by the maximum minimum or it could
actually be any other number that we
that we add
because it will be that same number
minus itself and then that the range is
zero
so how do we do this well we have the
condition zero is a
member of the shape of this array and
you can see that here
and then we can use this to
replicate
a zero or any other number
so here we get a zero but if the array
isn't
empty then we get nothing and we can
then
append that to
the ravel of the array
so now we can write
the revel over the array
concatenated with
this
as a tested function
so here we do not add any zeros
but in an empty array
we
do add it to the revel
so now we selectively add a zero when we
need it or any other number it would be
we can use any other number as well and
then we can say the maximum minus the
minimum of that and then that gives us
zero let's put this vector right here
there's no reason to find any other
number
so this is another solution
and can we be even clever yes because
think about it
we want to add a zero
if
there is a zero in the shape
and any other number in the shape
we're not interested in only zeros
we could even be multiple zeros it
wouldn't matter because the maximum and
minimum is not going to change just a
bunch of zeros or actually any other
number but the important thing is that
we add a number
or more numbers when there's a zero in
the shape
so how about just adding
all the zeros from the shape
okay let's say we have this array two
zero
zero two reshape zero this is this
invisible matrix and then we take the
intersection
of zero
with
the shape of this
that gives us the zero if our array
wasn't empty then there would be nothing
there if our array had multiple zeros in
its shape
then
we have the intersection of
and of a single zero
with
and
all these numbers here including the
zeros and so we get that single zero
so we can use this
and concatenate this intersection
so we can write the maximum minus the
minimum of
the ravel
concatenated with
zero intersection of the shape
and that works
this is probably the most concise and
way and a tested way of writing it
um
now for going a little bit beyond
the original question
uh quest which was just in a given a
numeric array um you we could choose to
understand it as giving any array that
consists eventually of atomic numbers
how would that look well and we could
split our matrix into a vector of
vectors
and
um and now our method is not going to
work anymore we're going to get
something completely unrelated to what
we're looking for and because our
function just travels it and that
doesn't un
open up the structure but we do have a
function called enlist which is just
like gravel but more powerful in that it
completely takes any array and flattens
it out to be a simple vector so if we
take our old solution of the maximum
minus the minimum
of
the
argument
and we overtake with
one maximum of the length
and all of this
applied not on the rebel but rather on
the list
now it will work
and we can do exactly the same thing
with our function up here that uses the
intersection the only important thing is
that instead of
just using the shape directly we
get rid of this ravel
and
move outside the whole expression this
in list
so this is in list
if the is any
zero in
the
intersection with the shape of that in
list then we concatenate that to the
argument which is the enlisted argument
and then we compute the range as normal
however at this point when we've already
made the enlist
we don't need to
to take the shape at all we because we
already know that this is a vector
so
and if it's a vector and it's empty
then it must be the empty numeric vector
so we can actually say that if the
argument
is
the empty vector so if the argument is
equivalent to an empty vector
um then
we
add another number so this is another
way to do it
and we can but of course it it works
just fine to say the intersection
with the shape or even with the tally
would be just fine as well
and that's it thank you so much and see
you next weekhi we are to take a multim
multi-dimensional array and
interchange the horizontally adjacent
elements here is an example
multi-dimensional array it is a
three-dimensional array with a two
layers and each layer has two rows and
then we've got five
columns and our task here then is to
Interchange adjacent element so Gela is
being interchanged with opton they
switch places Prospero with lysia and
then uh there isn't anybody to uh switch
position with toaza so that just stays
in place there and the same goes for
every row and
actually note that we can really operate
on individual rows we don't have to
worry about the overall shape of the
array though we'll get back to doing so
anyway so just to develop our algorithm
let's focus
on uh just the first
layers and first row and then all the
columns from
there we have those
here and so we'll start by the finding
or wrapping our Anonymous function
de and we
can take advantage of the partition
inclose function to pair up these
adjacent elements and flip the positions
and merge everything uh back
again and the with the petitioning close
function it takes a uh for our purposes
a mask have one when we are to start a
new section and then zero when we are to
continue a section so we want a mask of
one Z One Z onto the length of uh this
Vector um so we can get the length of
the vector uh with or the shape of it uh
with uh the shape function of
Omega and then we can use this to
reshape uh one Zer so we keep using from
this array one Zer uh cly until we have
the shape that we asked for and that
gives us this mask then we can use that
mask to partition uh the argument and
here we have the pairs that we're going
to flip and we now can uh reverse each
one of these and notice that the last
one that only has one element it's still
Vector of of character vectors here but
it its reversal doesn't have any
effect and now all we need to do is
merge these back together again so we
use a concatenation
reduction but uh the concatenation
reduction uh has to reduce it is a
reduction and reduces then the the rank
number of Dimensions from one this is a
a list Vector of vectors to zero so this
is a an enclosure of uh the actual
Vector result that we want we need to
then disclose that uh to get the result
we want this took care of
the simple uh case where it's just a
vector and we want this to apply to all
the vectors that can be found as
subarrays of our overall um array so we
had the entire n here and we can very
simply do this um that's we can we just
Define our function here e uh for uh
partition
inclose and specify that it should be
applied on rank one so it's not really a
specification It's actually an operator
that takes a function as left operand
and a rank specification as right
operand and saying this function must
never see any argument that has rank
greater than one so in effect the rank
operator will iterate over our given
argument and apply the function to every
subarray of rank no more than one which
is in fact always going to be present
because the problem specification says
that it will be a vector or higher rank
array so we can try this let's uh print
out the names again just so we can
compare them and then we apply uh the E
function to that and we can see that uh
we got exactly the result that we
wanted so this is one way to approach it
um but there are many others I'll go
through another couple um another way we
could do this is by indexing so we could
build up up the
indices uh of the elements reordered
such that we get the result that we want
and that takes um a little bit of an
algorithm so let's start again just by
the vector case and then we can apply
rank one to get the full uh thing so
here is our
vector and again let's define a uh
Lambda
a and and this time uh we again we have
the the shape of
that but now what we really want is to
find out which order should we put them
in in order to sort them but not just
sort them by say alphabetically but sort
them such that we interchange adjacent
elements and um we can start by
generating the nor noral indices right
so what we want here is the uh the
reordering but we need to adjust our
values because these are already sorted
so that two becomes uh less than one or
one is greater than two and three
becomes greater than four and so on and
we could do that by just adding two to
every other element so if we add two to
one we get three and that doesn't Clash
with the next three because this three
will also have two added to it and
becomes five and it won't clash with the
five because five becomes seven and then
and then the two and four stays and then
we just have to sort by uh that ordering
the ordering that would sort those
numbers enough talk and we can do this
in exactly the same way as before so we
uh we take the length and we use it to
reshape uh this time it's two and zero
and then we just need to add that to the
um to the indices that we computed over
here and for that um easiest thing is to
make a little train uh Fork so we do the
indices plus the reshaping of to
Z and we apply that whole thing to the
shape of uh the argument so we first
compute the shape and then we get the
indices of the shape and then we use the
shape to reshape to zero and then we add
those together they now have the same
length of course and that gives us uh
this so we can see the one was
incremented up to to three and the two
stays in place the three became five
four stays in place and five became
seven now we can H we can grade this to
find out what indices elements should we
take in order to make this
sorted and so here we can see that we
want F the the smallest element is uh
the second one that's the two then the
next one is the first one the next one
is the fourth one and the next one is
the third one and then the fifth one and
that effectively gives us um these flip
pairs for indices 2 one then 43 then
then five All That Remains now is to use
these indices to index into the argument
and we have gotten um our reordering as
we
wanted so here we're using indexing with
grading um we can call this I and then
specify that this goes on uh vectors and
that means that we can let's just's
print out our um example names here
again and then we apply our
function and we can see again that we
have the correct uh flipping of
Paris
and finally I want to show how to do
this uh using the stencil operator the
stencil operator is normally associated
with cellular automatons Game of Life
things like this um it processes Windows
of an array um it's it's almost an edge
case that it can have Windows of size
two and the movement the window moves
over by two steps and that effectively
isolates and adjacent pairs
this time uh let's do it tested and we
again we can start with uh the first
layer's first
row so we use run parenthesis instead
for a a train or a tested
function and um we can we start with a
stens operator and then the idea here is
that we use an Windows of size two with
a movement also of size two so we need
to make this into a matrix because every
row has serves a different purpose in
the right oper stens so the first row
specifies the window size the second row
specifies uh the window movement if
there were additional Dimensions we were
traveling along then we would have
additional columns in this
table and we can and we can isolate
these so we
can uh this the oper end function to
stencil is given uh two arguments and we
don't need the left argument so we use
the the right function and then we
enclose
that and uh we can see that we got the
pairs but stencil cuts the argument
short if it can't complete a window uh
with a specified
movement so we will have to address that
but for now
um we don't have to necessarily enclose
this we could also increase the rank uh
by not
enclosing so that gives us this table
and that can uh conveniently
be uh
reversed and then and we can Revel it
and
again right
there now and there is missing something
and and then is the last column so we
can read that column but of course this
only happens when uh the rows have an
odd length so here we use a a right
reduction to get uh the rightmost
element and that add this back again if
we had an even number of elements then
and
our and code here would add one more
column that didn't need to be added so
we can do this by cutting short and our
argument to just four not five uh names
and we can uh see
that and we have an extra Delicia and
over here because that was the last
element before it was moved one step uh
to the left this is of course wrong but
we can counteract this uh by taking the
uh the
shape so we take using the original
shape and that ensures that we chop off
the excessive uh element if it
exists and then if we use the odd
numbers here five then we also get uh
the right
result so this works um again on uh rank
one and we can call this s for stencil
and we can try to apply that on and our
whole multi-dimensional array and we get
the desired result
result um it would be interesting to do
a speed comparison of these three
approaches so let's copy in the compare
execution and facility from the defense
workspace and then uh I also have a
larger and here we only have 20 names we
have a larger many dimensional array uh
called a
uh we can see that
and a has
20,000 elements instead of um just 20
and it's distributed over five
Dimensions so it's a relatively large
array um and well we can also look at
the whole whole shape of this it has an
odd length and long last axis where
we're going to do all the the actual
computation so uh and we're going to
compare the execution and we've got e
with a as argument and we've got I with
a as argument and we got s with a as
argument and then we let it run for a
little bit to see how they stack up
against each
other and well those are some
significant differences we can see and
and if you reason about it we can also
see why that is
and the stencil operator and is
optimized for certain cases but not for
what we're doing here and so it goes in
and actually applies function and to
every window and and moves around and
that is expensive to
do the partition inclose function
generates an intermediary further nested
array that isn't otherwise necessary
and the indexing just directly goes in
and computes how we want the result
reordered and that then ends up being
significantly faster than other
approaches
but that
said we can do this much
better because if we look at our
definition say we we look at s here we
are treating every row separately and
potentially there are a lot of
rows and even though rank is optimized
again for certain Primitives and
constructs and when we have a complex
function like this there's nothing The
Interpreter can do and it just has to
Loop through um all the rows
individually if we could treat the whole
array and in one go then that would give
us a significant speed up and uh this is
what array programming languages like
APL are really good at
so let's try to reformulate this s into
a uh a function where we do not need to
specify that the rank uh of the argument
is restricted to
one and here well we still kind of want
to do that but we don't have to do it on
the entire
function because we do want these
windows and on rank
one but we can do that or all the way in
here
instead so this takes care of the
reordering of individual rows then we
might be missing a column we add the
rightmost column so to say that's the
last element of every Row in the entire
array to this potentially
multidimensional array that comes out
after running on rank one and instead of
doing this take operation on every row
individually we take the shape of the
original array the multi-dimensional
array and uh restrict along all X's
which won't have changed except for the
last one potentially um so that's just
one operation to cut short in our
array and now we can try to
compare uh our original s with our S2
and see if that made a
difference
so we can see that uh that became
somewhat faster um it still doesn't get
rid of this Loop for of the um the rank
one we could potentially get rid of this
one as well by specifying a window size
that is one and a movement of one in
every Dimension except for the last one
where we have a window size and movement
of two but it becomes a lot of
computation to get that uh window size
right and to then reform the argument
back again to the original so let's that
leave that there because as we can see
up here the stencil approach is anyway
much slower than the other one so this
will be more interesting and with and
our other approaches so then we had and
our function
e and let's try to define a new an
E2 that
and
does this on the whole array instead so
we want to get rid of the the rank one
here now this gives us the shape of the
entire array but we only want the
trailing uh element of the shape which
is
the um the number of columns so the
lengths of the rows and uh we can get
that for example like this to do with
get the less element uh the the
rightmost of uh the
shape then we reshape to the mask uh
that we want and actually this works out
very nicely because by default the
petition inclose Works along the
trailing axis so this is going to uh
split up our array into should we say
vertical slices of uh with two and so
everything else just works out we
reverse these two column and
multi-dimensional subarrays and then we
join them all together adjacent to each
other and since we use the reduction to
do that we disclose they should just and
work out so now let's try to compare e
and
E2 and we can see that just this little
bit of modification gave us some very
significant
savings okay let's see if we can do this
with the I function as well so we want
to have an a new I2
function and we don't want to apply rank
here now we end up in trouble
immediately because the square bracket
indexing requires us to know the rank of
what we're indexing so we have to
replace it with something else um and
for that there actually if we take these
two square brackets um and we we merge
them together uh then they become the
squad function which is then a proper
function
indexing but again we don't really want
to generate the indices along and every
dimension for all our elements so we can
use the slightly and unpleasant looking
square bracket access to say that all
the indexing that we are going to do we
are going to do and along the last
axis uh so that is the same thing as the
rank of uh the
argument and now and the what we're
indexing is on the left but it normally
takes it on the right so we swap that
and in order to just reorder and so to
have multiple indices along the same
axis then we need to enclose um the
argument over here and then of course
this is the entire shape so just as
before uh we want to get the length of
the last Dimension and the rest should
stay the same we get the mask we do the
grade and then we apply that there so
now we can compare and remember that I
was the fastest one before and now we're
doing I versus and I2 where we not going
over the individual rows with the rank
operator we are treating the entire
array at once and we get well similar
savings as we did with e
but wait there's
more let's think a bit about these
indices that we generated with the
grade let's do it for
five and for
six we were thinking about this
transformation as a positional one
flipping pairs but actually we can think
about it as a mathematical
one originally we had 1 2 3 4 5 six
and in order to get the one into a two
we just need to increment it and the two
becomes a one by decrementing the three
becomes four by incrementing and the
four becomes three by decrementing so
instead of adding two 0 two 0 if we add
one and negative one that pretty much
gives us the result that we're looking
for The Only Exception is when we have
an odd
length here the last element becomes too
big
but we know that the last element can be
no larger than the limit of the
series so we can clamp it using a
minimum and we don't even need to do a
minimum on on all the elements we can do
it just on that very last element
because we know that's the only one that
can be too
large and with that in mind let's go and
change this I2 into an I3 now we need to
give this a name let's call it alha last
and change
the um changes into one and negative 1
instead of two and zero we don't need to
grade anymore but we do need to clamp
the last
element and with that we can try running
I2 against
i3 although even though a has a lot of
elements the last axis that's the
important one is quite short so we don't
see a whole lot of speed up here if
however we make B be a flattened a such
that there are 20,000 elements along
that last axis that actually
matters then if we try comparing the
performance when we now need to grade
20,000 elements instead of of just 600
and something we get a substantial
performance benefit so sometimes
rethinking how we um construct our
indices and doing it in a less costly
way can make a big difference thank you
for watchinghi we are to find a reduced fraction for
a given
number so let's use an example of
1.2 I'll start with the actual full
solution because it's really short um
and then I'll explain how it does the
trick right so here is one .2 is
65 and the way this works is that we
have this is called a fork and where
this binds a left argument to the
Fort so the fork itself it
says and it looks like n symbol but n is
extended to be the lowest common
multiple so it's the low lowest common
multiple divided by the concatenation
what does it mean to take one function
divided by another one well we can
expand this to an explicit def instead
we have a left argument which has been
bound and that's called Alpha we have a
right argument which is called
Omega so here we
take the arguments and use them for both
these outer functions so this is the
lowest common multiple of the left
argument and the right
divided by the concatination of left
argument and the right
argument why does this compute the
reduced
fraction well what does it even mean to
have the lowest common
multiple this isn't the whole number
it's not usually how we think of lowest
common multiple but let's substitute in
this bound argument into the function as
a literal
now what does it mean here the lowest
common multiple of
1.2 that is also divisible by
one so we have to if it's divisible one
that means it has to be a whole number
if it's a whole number um then it can be
part of our fraction so let's try 1.2 *
1 1.2 * 2 2.4
3.6
4.8 and finally
Five Point well they become
six so if we multiply it with five then
we get six so the lowest common multiple
of one and 1.2 is
six so over here we get a number
six and here we concatenate the right
argument 1.2 with one so we have six
divided by one and by 1.2 now six
divided by one of course that's six that
gives us our left argument and and 6
ided by 1.2 why are we doing that
because we want to find out
um the
the other Factor we could say it's a
division we have six divided by
something is supposed to give one 1.2 so
that something we can find by dividing 6
by 1.2 because 1.2 times that other
thing will uh will give
six so this really becomes 6 divided
1 and 6 divided by the
argument and 6id one of course is six
and then we have 6 divided by uh the
argument and this is how uh the function
works
thank you for
watchinghello and welcome to the apl quest ca
bill wiki for details
today's quest is the second problem from
the 2014 round of the apl problem solver
competition we're given a text
and have to find the words in those
in the text and remove any vowels from
the words except if the vowel begins the
word or the vowel ends the word
let's get started with some test data
okay
we can identify where we have spaces
and non-spaces
in our text
then we can use this to partition
the text
because partition will take
elements that is letters here
that correspond to
runs of ones and group them together in
a single element
any
letter or character that corresponds to
a zero
will be discarded and at this point
we'll begin a new segment
so
we partition
using this mask
now it's a question of processing each
word separately
because we need to be a
case insensitive we have to
to handle all kinds of vowels upgrades
in lowercase we can start by uppercasing
our and
our words
and we can then find out which words
which letters are vowels
this gives us one mask per word
there's a problem however you can see
that in the third word the last letter
is a um is marked as a vowel and we
really
don't want to consider the vowel that
can be removed
also
and our masks are inverses of what we
actually want since we're going to use
compress to remove vowels then we should
have zeros for the characters we want to
remove and one for those we want to keep
that part is super easy to fix
we just negate it
and then we need to take care of the
issue of putting a one always at the
front at
the end well that we can do we can amend
this vector with one at position one and
also at the position of the length of
the word
now we're ready to do
the compression
looks good and we just need to join
things together with spaces
since we're already processing each word
we can just stick a space in front of
each word
enlist the whole thing
and remove the leading space
this solution is nice in the sense that
it expresses an appeal very much how we
think about the problem
let's call it
c for cut
there are other ways to to address the
problem however which avoids
splitting up the text
and processing in each word one at a
time rather
the ideal when doing array-based
programming is
to process the entire array in one go
let's see how we can do that
this time we're going to
start with uppercasing everything
and then
we need to
match up
the previous letter and
the next letter with the middle letter
in order to identify whether or not we
are at a word and word boundary
of course the first letter doesn't have
a left neighbor
but we could possibly supply that
now in order to
to match up the left neighbor the letter
itself and the right neighbor we can
drop
so
here's the left neighbor
left neighbor of the
h
in how is that space
we drop one
we get the h itself and if we drop two
then we get
the neighbor on the right
we want to drop all three possibilities
zero
one and two
and we want this dropping
to be done on the entire
vector
so we can say we want on
and
we want to drop using rank 0 every
single number scalar from the left and
we want 1 because we want to treat the
entire vector on the right
now we can compare
these
this whole matrix to spaces
for example and
like this
we can put it inside the parenthesis
and we know that
uh a letter is internal
if
all the
all these three the left neighbor
this letter and the next uh letter all
well if this the left character the
middle the current character and the
right character all are um
are none spaces
so and we can
combine
this
uh not equal with
a vertical and reduction
the only problem we have now is that
and since we added a character we have
one character too many and that we used
this
to
to push things
to the right and when we didn't drop
enough
then
one character from the end got pushed
too far we can see this above here
the last character we have is the u
and its left neighbor and his right
neighbor and here is another space
that's been added which we don't
actually want
we can fix this however just by dropping
the last element
another way we could do it um
is by
not adding the space on the left
um
because
that will just give us all the
information for all the characters
except the first one
we know that the first
character
is not one that we that we should
consider a an interior character because
it's right next to the beginning so we
can just add a zero on the left and that
will give us
the same result exactly
now the only thing that remains is
to check if
and
the these the letters are also vowels
so we can do this by simply saying
member of
aeiou the vowels
that gives us this mask and so these two
masks are the ones we're going to
combine if a letter is both interior and
it's a vowel
then
that's a letter that we can remove so
let's combine
the two parts
and this points out which letters we
have to remove but again we want to use
compress so we want to mark instead the
letters that we want to keep we could
negate it but we can also just combine
the negation with and into an end
now we are ready to do the compression
that works very nicely
let's call this one
drop
d for drop
because we're using drop in various
places
we talk about these neighbors and we can
we look at these triplets another way to
do this is by using nys reduce
so let's start over
with our text and uppercasing it
we can and we can look at triplets
initially we can try just concatenating
them together
so these are the triplets
but instead of applying and
this invoice reduce on the letters
themselves let's com
let's do it on the boolean mask of
whether there are none spaces
and now we just need to reduce each one
of these with an end reduction just like
we did before
we don't need to do this outside of the
nys reduction because analyze reduction
is indeed an introduction on each
sliding window of the size three in our
case
and that gives us
the mask for which letters are
interior
letters
which means
we can just combine all of this with
um our way of finding the um
the vowels in exactly the same way
oops
oh yeah of course
since we have sliding windows that don't
uh
that begin at the very left edge and we
have sliding window size three that
means that we don't have a corresponding
element for the very left most and very
rightmost letters but we know that those
are boundary letters and so we can just
supply those
that gives us our mask and we're ready
to do the compression just like we did
before
let's call this one r for reduction and
voice reduction
another way to look at neighborhoods is
using stencil
so let's try this again
uppercasing that
and this time we're going to use
stencil
and
stencil with a window size of three and
applies its operand
on each sliding window
at the edges
if necessary it pads and it is necessary
in our case we want window sizes of
three and every element gets a chance to
be the center of a neighborhood of size
three
stencil with pad with appropriate
padding which for text is spaces and
that's great that's exactly
what we want
what operand are we going to give to
to stencil we're not interesting in the
left argument to the operand which is
the padding information
we just want the right argument
and we again we want to know where it is
all true
that
the letters are different
from space
that gives us our mask including the
zeros so this is exactly what we had
before with the end wise reduction and
we can just copy the rest of our code in
this is our stencil s
function
now it will be interesting to compare
the uh performance of these wouldn't it
let's do that um but for our test case
is tiny we also need to generate some
larger test data so
now i'm going to copy in the cmpx
utility which measures performance and
also
for convenience i'll have the delete
extraneous blanks in order to generate
our test data copy those from the decent
workspace
okay for our test data and let's have
some uppercase characters and some
lowercase characters
and then we need to have some some
spaces as well and in a nice proportion
i'd say if we take about 60
and overtake then we get and a bunch of
spaces at the at the end
then then let's choose some random ones
from this
so random and we'll take
a thousand of those
from all of them the length of that
so this gives us a
a bunch of
letters if we just take the first
hundred of those to have a look at what
they could look like we can see here at
the end we have some
some double spaces so that's why we need
uh to apply delete
external blanks
and then that won't happen
no more double blinks
okay then we're ready to assign this
it's not even though i asked for a
thousand it's of course not exactly
going to be a thousand because we're
deleting some spaces here and there but
it's close enough
for purposes
and let's generate some apl expressions
that we're going to compare the
performance of
and we had c for the cut
method and d for the drop we had r for
reduce and s for stencil each one of
those is going to become
called on the entirety of
this
test data here so these are our three
api expressions
and now we're running the timings on
those
see what that looks like
all right
well
that's pretty significant differences
we've got there
and the cut method which is our baseline
is not very good compared to uh
to using drop and
reduce
that's because uh draven uses are
entirely flat
uh solutions
whereas uh when we cut into individual
words then we get a pointer array and
one pointer pro word and that's going to
be very expensive to traverse
so that one's basically out there's
nothing we can do to fix that stencil
that doesn't look good at all
and the reason is that we gave a rather
complex
operand to stencil and there are just a
few
common patterns
that when addressed when expressed as
defense
have been optimized
very heavily and they will give us way
better performance
so
let's see if we can
use one of those instead
so i know that
one thing we can do with stencil that's
super fast is just getting uh getting
the right argument
now since we have neighborhoods of three
and from a vector that means every
such neighborhood is a vector in itself
and stencil will collect them into an
array where the major cells are
these vectors so an array that consists
of vectors is a matrix we'll get one
neighborhood per row
and all we need to do now um
is the exact same thing here we're just
comparing two
spaces and then
we are reducing across
the rows
so all this
should just work in exactly the same way
and let's try it on our small test case
oops yeah i made a mistake here
i am
missing a space
nope not necessarily i made i haven't
parenthesis that could be missing or we
can just remove this parenthesis over
here that's why it was read before
okay let's try it again there we go now
it works
right
so and
let's do this comparison again with the
new updated stencil version
but this time we're going to skip the
one that that cuts using petition
because that's hopeless
stencil is still the slowest of the
string
but
uh it's not bad right they're all very
similar to each other and if something
is convenient to express using stencil
then by all means it can work very
nicely
and then you don't have to worry about
how much padding you need for various
sizes which you didn't need to worry
about for the anyways reduce
but there's another problem
and that is let's update our uh our
small test case
with some punctuation the problem here
is with the final letter
since we are detecting whether the
characters that are non-spaces then
question mark is a non-space and u will
be considered an internal
letter so for example using this s
we can see that
o and u
get removed which is of course wrong
so
how can we fix this
well here are our definitions
the problem is that we are using
the property of being a non-space
to identify which
characters are eligible to be uh
be removed and
which ones are have
non-space neighbors
i really want to turn it upside down we
want in order for a character to be
considered an interior letter
it's it's
the determining factor there is that its
neighbors
are also letters not just non-space
characters but letters so we just need
to turn things around a little bit
for the dropping method
the only thing that we need to do
is to check
if
and
characters are
in the set of uppercase letters and
membership goes the other way around so
we can swap that
and if
they are letters
all of them
then
and
we have an interior letter
and actually
the exact same thing applies
to all of these solutions
so here
with
an invoice reduce
instead of checking whether we have
taken whether we have none letters we
just look whether or not they are
members in
uppercase
alphabet
and so too
with stencil
instead of checking whether or not
and we have none letters we just check
whether or not they are members of
topics alphabet
and now we can generate new test data
so this time we're going to have
uppercase letters and lowercase letters
and also
some punctuation
let's say 65 overtaking that to get some
some spaces there and then we just use
the same formula as
before we want
random
about a thousand
of
the length of the argument
and this time we don't need to remove
extra blanks
right
the comparison we're going to do is
exactly the same as before
and the performance is very similar to
what we had before but this time
we are correctly handling all of these
so we can see it
for example
with the dropping
on t
and
reduce on t
and stencil
and t you can see that the u
remains right there
so these are good solutions aple
solutions there's another approach
though and sometimes it's more
convenient
and that is to use regular expressions
and
we found
two
interesting ways of doing this using
regular expressions
what we can do is we can we want to look
for
some characters and then we want to
remove them and we want to do so case
insensitively
the letters
that we want to remove are the vowels
but we don't want to remove all the
vowels
we want to make some assertions about
these vowels
what we want to assert is
that
this question whether on the left
we have
a word character
if there's not a word character on the
left
then
we're not interested in this vowel that
also means is the first character in
this
in the input then we're not interested
in it we also want to to make sure that
on the right we have a word character
if it's the last character in the whole
input then there are no characters to
the right
and we're also not interested
it's important to note that these look
arounds or look behind look
ahead
are not part of what's being matched
they're just something that's being
checked when we try to match them
so that works as intended
it can be hard to think about these uh
assertions
i personally find it easier to think
about
things in a different way and that's
with what you could call exception
patterns to detect things
and let them go through so again
we
we do want all the vowels
and we want them removed but we want to
preserve some
which ones are that we want to preserve
we want to preserve any any letter that
is preceded by a word boundary so that
means it's on the left edge of a word
or
at the right edge of a word
so those will replace with themselves
and any vowel that remains after that
that hasn't been consumed by the first
pattern we're going to replace with
nothing
so let's call
this one b for word boundaries
and the one we had before we'll call it
a
for
look around
and then we can compare the performance
of these so now we have a
drop we have reduce we have stencil and
then we have look arounds and
word boundaries
each one we're going to run on the
entire expression of
an entire argument of t3
and we'll we can oh we didn't get the
exact same result uh why is that
this is
look ahead
oh well that's interesting
this works
well let's do some debugging and see
what uh what's happening here
we can start with some of our
string so if you take a hundred
from t3
and then
we can oh so we can even do it like this
we can say is d
matching a for a hundred of t3 nope is
it so for 50 of t3
how about for 20
yes
25 no okay so now we can look at 25 take
t3 and see what is it that's uh
oh this is at the very first space
at the very first space so
d removes the internal vowels like
this o for example
and a
we removed one
more thing than d where they different
oh did i simply forget a
an i oh d didn't remove the i
that's interesting
this eye doesn't get removed
but we clearly have an eye here
removes it
uppercase i gets removed
so what's going on here why is d not
removing this
oh i see
it's because i've did i put in digits by
mistake in our test test data
that's what it is
so
oh yes i'd put in a one over here that
should have been an exclamation point
so much for that there was some
troubleshooting right there
let's try the performance again but it
shouldn't really make a big big
difference in the results that we get
there we go now we can see it finally uh
so
the performance using regular
expressions is not good compared to the
api solutions and with multiple patterns
it's even worse than with a single
pattern with with look around but hey
sometimes
regex is the way to go especially if the
smaller amount of data or it's something
that's very complex to express or it's
something you just need a one-off and
not running
times then it could be quite fine
but
we should definitely prefer an array
oriented solution if at all possible
thank you so much for watchinghi
we're going to do a very simple test of
validity of some XML it's not a full
test at all we're just checking whether
the angle brackets
are matched
here's some test data that we can work
on the first one is valid and the second
one is not valid and that's because when
it says 2 is less than 3 it uses an
angle bracket there which messes up the
balancing of the angle brackets
there are three rules really that we
need to keep here
one is that every opening angular
bracket has a closing angle bracket that
is every less than sign is has a
corresponding
um greater than sign
another rule is that they cannot be
nested
and and
well finally
the meaning we can't have less than less
than and then greater than greater than
and then well you could say it's not
really an extra rule we have to finish
up with everything closed it can't be
shifted around
okay let's get started
we're going to Define this entirely
tacitly from the beginning
so let's apply this function to each one
of the test cases
and what we're going to do is note that
the only thing that matters for our
problem are these angle brackets we
don't care about any of the other
characters
so we can start by filtering so we only
have these angle brackets and none of
the other characters
and one way we can do that is by doing
an intersection
so we're treating the arguments as sets
and we're going intersection between
that and the angle brackets
so now we can see we've isolated out
only the angle brackets that makes it
much easier to work
the strategy we're going for here then
is to identify where we have such pairs
because the entire argument now must be
made out of entire pairs of open close
open close open close when we get here
we get open open and that's wrong
foreign
so one way we can do this
is by searching for angle brackets so
we're now going to change the
intersection function into a compound
function a fork
where we're going to find so this finds
the locations of what of the right
argument so this function here has a
very interesting structure
it is
bound with a right argument which are
these angle brackets which means that
when we apply it to some text it become
that text becomes the left argument and
then it's called a fork because it kind
of branches out and applies the two
outer functions to the arguments and
then the middle function
to the results of those two outer
functions so this is the intersection of
the left argument which is going to be
the text and the angle brackets which
have been bound on the right
this is the right side identity function
it ignores the left argument and Returns
the right argument so we again get the
angle brackets and this returns a
Boolean mask
same length as our argument with a one
every time what we're looking for starts
including overlapping matches but that's
irrelevant in our case
so here we have the Boolean mask and we
can see that we have open close open
close open close and so on down here we
have open close open close and then we
have one character that doesn't belong
there and then we continue with open
close
what we can do now is check
that the entire mask that we got out
consists of uninterrupted one zero one
zero one zero and so on
until the end and it has to also end
with
one zero
if the final character
is not or Define the characters are not
open close then we wouldn't get a one
zero at the end
if the final character isn't open we
won't get a one at the end because we're
not finding the entire open close and
then the find function will not say we
get a partial match
so we don't need to check for any of
those
and extra rules we could say whether
they're they actually match the knot
whether we're closing at the end we have
all boiled it down to this subset of the
input consisting of
open closes which are then mapped to
ones zeros
so we can apply another
tested function to that where we take
the argument length
and use it to reshape
1 0 as a constant so this operator takes
the one zero and makes it into a
constant function it's again the same
structure with the fork as we had before
but this time only with one argument so
we apply this constant function to this
mass that we got out
that gives us one zero we apply the
tally function so it looks like a
Telemark which gives us the length of
the mask that we got out and then we use
reshape which is a Greek row R for
reshape to reshape the result of the
constant function which is one zero into
the full shape cyclically so one zero
one zero one zero until we get the full
length
and then the only thing we need to do is
to check whether this mask matches
this mask that is whether this mask
matches
this mask as well
and we are given the mask as argument
here we indeed we used it to get the
Telly the length and we have this right
density function that we can apply so
this also corresponds to the mask we
asking whether it matches exactly
element for element the master we've
generated here
we can see the first one is good and the
second one
is not
and that's actually our whole solution
we can assign it like this
and apply it to each one of the elements
of t
thank you for watchinghey
our Quest today is to compare two given
character vectors or scalars
that is the economic strings and see if
they're anagrams of each other with the
definition here of an anagram being that
they have the exact same letters we only
have to care about one letter case at a
time
and that we ignore spaces all together
we don't have to worry about case
differences we don't have to worry about
other types of punctuation
okay let's get started
I have prepared a couple of left
arguments
and a couple of red arguments that we
can use
we are going to start by pairing them up
correctly so we got the left arguments
on the left and the right arguments on
the right
now we have an anonymous Lambda or divin
and we're going to pair up each
element from the left argument with the
right argument
the name of the left argument inside
this divin is Alpha and the red argument
is Omega left and right most letters of
the Greek alphabet
and we get pairs
obviously they're not ready to be
compared yet we need a couple of
pre-processing steps
so
the over operator preprocesses both
arguments before the main function is
being applied
the first step to pre-process is to
remove spaces we do that with the
without or set difference function
now what we're removing is constant so
let's bind this function with a constant
space so this becomes a derived function
a new function which is the without
spaces function
next step is to make sure that the
ordering is the same and an easy way to
do that is sorting
we use a little helper function where we
take the argument
and find the elements in the positions
of the grade of the argument
now the grade is exactly this the
indices that would put this array into a
sort order if we use those indices to
index and that's exactly what we do
now we can compare the two
and find out which ones are anagrams
we can simplify this a little bit by
observing that we have a Lambda or a
different here with a single primitive
inside that just takes the arguments
that's entirely unnecessary to wrap it
like this and instead we can just apply
the Primitive as it is
this looks good
let's give it a name
and now we can compare
left arguments each
now in the right arguments
and that gives us our result
thank you for watchingwelcome to the EPL Quest see APL Wiki
for details
today's Quest the fourth from the 2016
round of the EPL problem solving
competition asks us to take two vectors
and mesh them together
now that's really simple if they have
the same length but if they don't then
there's a little bit more work
okay a test case would be for example
these two character vectors
since they don't have the same length
then the trailing part of the one on the
left log will have to just be as it is
at the very end
so what we want to have is D and then a
from over here and then Y and then the P
from over here
Locus a from the left
of L from the right and then L from the
left o from the left G from the left
let's do that with a little Lambda a
different in between them
and what we can do is we can start by
just simply concatenating them together
now we have all the elements that we
want but we need to reorder them into
the correct order
so we want from the left from the right
from the left from the right and so on
now here's the thing and
if we have such a
um such a list we can sort it
in API the normal way to sort things is
by using
grade
so
here we're grading the same thing and
this gives us to it gives it to us in
escapedical order of course this is not
what we want but what I want to
illustrate
is the use of grade what does grade
actually do
Let's uh
let's try it like this
rain gives us the indices that we will
need to use in order to reorder into
sort order
so here in order to reorder this
um sorry in order to reorder this into
short order we first want element number
two that's a one then element number
four the other one
then the three which is in position one
then
the third element number the four The
Fifth Element which is five
and so if we do this
we get it sorted
but we don't have to sort by the data
itself we could sort by something else
so this is saying whatever would be
necessary to sort this vector
is used to reorder the letters in hello
so we have that result over here so you
want the second element that's the E the
fourth element that's an L the first
element that's the H and that's what we
have down here
if we can construct something that will
sort
in in such a way that it puts the first
element from the left and the first
element from the right and the second
element from the second element from the
right then we can use that to reorder
the concatenation into the order that we
want
well
if we start with a one from the left
and then and on the right a one on the
right
and then a 2 on the left and a two on
the right and we concatenate these
together three on the left and three on
the right
then if we ask how would we sort them
then we say we need the first element
from and then the fourth element that's
the one over here
and then the second amendment that's
this one and The Fifth Element that's
the one from over here so if you think
about these corresponding to the left
argument and the right argument
then this would actually put them into
red order and this works even if we have
trailing elements because first we'll do
pairwise the one from the left one from
the right one two from the left two from
the right three from the left three from
the right and then just the sole for
five or six whichever side those would
come from
this is the result that we want
so how can we generate this
this vector or these two vectors
together well these are just all the
indices in the left argument and the
right argument concatenated together
so if we go back back up here
and we
find out how many elements are there in
the left and how many elements are there
on the right Alpha is the leftmost
letter of the Greek alphabet should
mentioned Omega the right most so they
refer to the left and right arguments
six and three
now we can use Iota Iota is like an i i
for index generator to generate the
indices from 1 through this length
oops
those are the exactly the ones we need
now we can concatenate them together
and that's
the vector that we need to grade
in order to
sort
the concatenation
and this solves the problem
but we can actually clean this up a bit
notice the duplication of code
we are concatenating together the
indices of the tally of the left
argument and the indices of the tally of
the right argument
which means we're actually concatenating
together the left and right argument
just like before but just before we
concatenate them we pre-process both
arguments by converting them into their
enumerations
and we can write that
as
um the left concatenated with the right
with a special combinator called over
which takes a function on the right in
this case this function is
um
a juxtaposition of index generation and
tally which just we also call that in
the top so we're applying the tele and
then after what you're applying the
index generation on that
and that works the same
next up
we can instead of using the the indexing
syntax with the square brackets we can
use a functional form you see a moment
why that's a good idea
so there's a function which very much
looks like these two brackets put
together
or we can leave this parenthesis for now
so it's this squad
and it takes the indices on the left
except we need to enclose it for some
technical reasons but this works exactly
the same as the above
of course because of apl's long write
scope every function takes everything as
far as it can see until we close off
with some bracket or the end of the
um of the statement we don't need
parenthesis on the right
and now we can switch to a uh to a fully
tested mode tested 0.3 is a type of
programming where we don't mention the
arguments
and it can work really elegantly in APL
when we have three functions
that
where
two of them are being applied to the
arguments and the other two and and the
and one of them
is applied between the results we call
that a fork
let's pause for a moment and see how
that works let's say we have 10 on one
side and three on the other side and
three functions in the middle
the middle function is concatenation the
left function is plus and the right
function is minus so then the outer
functions are applied to the arguments
and
the middle function is applied between
the results so this is the concatenation
of addition and subtraction
and we can use any functions for this in
our case what corresponds to the
concatenation is in fact an indexing and
what corresponds to the plus is the
enclosure of the grade of the
concatenation of the indices of the
of the tally
and on the right the minus is the
concatenation over here
so we can substitute things into this
pattern
um
we can take this
over here and make it into a little
function instead put braces around that
oops
and then we can change the comma into
the indexing function and change the
minus into a comma we just need to put
our arguments back
we can go one more step by using and
actually a couple more steps by using
some combinators because this is a
single function and we Sorry up to here
and we want to apply the grade
on top of that on the result of that and
we want to apply the enclosed to the
result of that
and we can actually specify that using
the circle a little a little circle
there is this or chapter assist this
just means this function over here
um
well followed by this function
technically speaking it's actually this
function applied to the result of this
function
where the arguments are pre-processed by
this function of a
and the same thing we want and
this year the enclosed applied atop the
result of the grade so this is enclosed
of the grade of the concatenation of the
indices of the tallies of the two
argument and now we don't have to
mention the arguments anymore because
this is a single derived function a new
function that's being made by combining
old functions
and there's a final step we can do and
that's mostly just for the fun of it
is break up this compound function
we are pre-processing both arguments
with the indices of the tally
that would really be the same thing as
previously in both arguments first with
Tally
and then pre-processing them again with
the index generation so we can spell
that out
using this over we call it so this is
the enclosed of the grade of the
concatenation of the indices of the
tallies
of the arguments
in the indexes the concatenation
thank you for watchingwelcome to the APL Quest see APL Wiki
for details
today's Quest is the 9th from the 2016
round of the APL problem solving
competition
we are taking a text in and we're going
to split it
but there's a catch
we're splitting and are not just one
delimiter but on any of a set of
delimiters
let's start
by having a sample text
right so what's going on here is we have
two different types of delimiters we
have both comma and semicolon and we
also have consecutive delimiters which
we must respect so we have to have an
empty segment coming out here
that means as left argument we're going
to have a comma and semicolon
and so these are our two arguments and
APL has these uh infix functions
user defined functions this is a Lambda
type function known as a definite and in
here the left argument is denoted Alpha
as the leftmost letter in the Greek
alphabet
and the rightmost letter is an Omega and
that denotes the right argument so we
can see this just puts them next to each
other
and what we want to want to do here is
first identify where we have delimiters
in our text
so we can use membership for that and
that vectorizes so we're looking at
every element of the right argument to
see if it's equal to any element of the
left argument
that gives us a Boolean mask
and this Boolean mask
indicates where we're going to start our
segments and we can see the two ones
here after five characters corresponds
to the two commas over here
however there's a problem
and we we could start splitting here
um so
if we use this partition function
then using this mask as left argument
and using the text as write argument
then we lose
the hello
because it begins a petition
every time there is a one
we need to
um
we need to start off with a position
right from the beginning so we need to
insert
a delimiter at the very beginning of our
text first
before we do that I just want to go my
uh Crusade against parenthesis I really
don't like using parenthesis for
ordering execution
and the problem here is that apl's
functions are all uh and they all have
long write scope so everything towards
the right of a function
um is the right argument and what's
immediately to the left is the left
argument and so because we have a
complex left argument that's the whole
expression to this partitioning function
then we need to parenthesize it if only
we had a function that was exactly like
partition but with swapped arguments
then we wouldn't have this problem
because the right argument is not a
complex expression and it's just a
single array value and we don't have
that kind of function but we do have a a
modifier or a magnetic operator we call
it in APL terms which goes in the media
rate of a function
and then modifies that function
to
have swapped arguments so now I can take
the Omega on the left
and the Omega member of alpha on the
right and we get the same effect as
before
okay so far so good but we still have
this problem that we need a delimiter at
the front so there really there should
be
an extra deliver to any one of them of
course would do and that will solve our
problem
so how can we do that well we can
substitute
um the Omega for a variable that we
create
so let's create it first and we use
Diamond to separate statements in APL
because diamonds are Unbreakable
so this should be the normal Omega but
we want to prepend
a
um a delimiter so we can use the first
function that's this one
um applied on Alpha that gives us just
one of them of course any one of them
would be good but there's always a first
one and if we concatenate then that's
going to put it at the end but if you
swap the arguments then we put it on the
front
so this gives us all the say oh we need
to go and remove this comma here that I
inserted this gives us all the segments
that we want but they all have the
delimiter included so we need to drop
one so from each so this is the again a
modifier which is like a map that
modifies the drop function which
otherwise would just drop one element
um so this drops one element from each
and that shows our problem
however we can write this a little more
in a little bit more compact way
we can combine these two statements and
if we had T at the very end of this
expression then we could just do a
random expression because this
has t
um as the final result and we can do
that because by swapping the membership
here this is T member of alpha so we can
say
the membership swapped with t on the
right so this will still give the same
result but now that we have an
expression over here that has t on the
far right and we have expression here
that has t on the far left then we can
just move it over
um to here we still need the assignment
because we're going to use T later
but this allows us to write this as a
single expression like this
we could also give it of course a name
and then we can write
like this
or we could choose to split on vowels
thank you for watchingwelcome to the EPL Quest
see APL Wiki for details
today's Quest is the 10th and last of
the 2016 round in the EPL problem
solving competition
we are given the bunch of prices and
we're also given how many of each item
that were bought and we are supposed to
calculate the total
amount
that's this purchase sums up to
so here we have the number of items that
were bought and over here we have the
prices for each one
and this is mathematically really really
simple and we can multiply and APL will
automatically vectorize so
5 gets multiplied by 299 0 gets
multiplied by 499 and 2 gets multiplied
by 199.
these are the total prices per item
type per type of item and then we can
sum
sum is a plus reduction so we write a
plus and then the slash means insert so
there's a the Plus in between the
elements and that gives us our total
amount
so the problem can be solved this easily
but
um we could also try to make a single
function out of this that solves the
problem so for that we're going to use
braces like this that makes an anonymous
Lambda we could give it a name but we
can also just use it inline like this
and in this the left argument is
represented with an alpha and the right
argument is represented with an Omega
the left and right most elements of the
Greek alphabet
in here we can then multiply together
and that gives us exactly the same thing
this is basically a cover function for
the multiplication and then we can add
the summation as well and that gives us
and the solution
but a neat thing you can do is called
tested programming or points free
programming where you don't mention the
arguments explicitly so here we have
left and right arguments mentioned by
name
and we actually able to combine these
without mentioning the arguments
changing these braces into parenthesis
this makes a single function tested
function which we call an a top or a
true train there are two functions here
the summation and multiplication and
when you stick them next to each other
like this in isolation there are tied
together by the parenthesis here
then
the right side function
is given the arguments of the overall
function
and its result is then fed on to the
left side function
so this also works
this is called the two train or
a top a train because it's a sequence of
functions after each other train the
functions like a train of thought
but we can also be explicit about this
at top
we have an operator which is a higher
order function and it's infix it takes
the sum on the left and takes the
multiplication on the right
and
it combines them error com in a way that
the right function is applied first with
the arguments to the overall derived
function
and then the result is fed on to as a
post processor the left function which
is applied just one argument so this
also works but because we don't have a
train anymore we don't need to show that
these two carriages belong together
instead it's the higher order function
the operator that is binding them
together then we don't need parenthesis
here and all and this would still work
however there is another higher order
function or operator in APL which is
called Dot
which does the dot product and this is
exactly equivalent to doing a DOT
product on two vectors
so this will also work
and then you might ask well what's the
benefit of using this why can we not use
some over the multiplication well there
are a couple of reasons for that one of
them is Technical and one of them is
practical
technical reason is that an interpreter
instantly recognizes this combination
the um
and it has optimized code to do this so
instead of doing two Loops the
multiplication first and then the
summation then it confuse the loops and
make it run faster
however there's also practical reason
something we couldn't do is let's say we
um
instead of these amounts here we have
two sets of purchases so the prices are
the same in the store but customer one
buys five of these and two of these and
customer two
buys 50 of the first and
20 of the last so that should give us 10
times the price now we reshaped this to
um
two rows and three columns this is a
Greek Row for reshape and this will give
us
a matrix so we can see here we have a
matrix of
um two rows and three columns and this
it's like a database with records per
purchase so in this purchase or this
customer
um
but these amounts and this purchase a
customer report these amounts
and now if we
um if you then combine this we need a
parenthesis here so that we don't
um
end up multiplying directly by this
Sixth Element Vector which would be a
length error and now we can multiply
like this and we can see that we got one
sum per record in the database and if we
had only tried to multiply them directly
that would not work we cannot multiply a
two by three Matrix with a three element
vector and then sum it up afterwards
so that's why you really want to use the
dot operator or also known as inner
product whenever possible
thank you for watchinghey
what is the percentage of characters in
a given
character Vector that are either the
uppercase letter C or a place uppercase
letter
G we're about to find out
so let's say we have a DNA string here
we apply a function to it and the first
thing we want to know is which letters
are C and G we do that with a membership
where one argument is pre-filled we bind
an argument to it to look which is our
lookup array C and G and that gives us a
Boolean one bit for each character
which means we could sum this
and then we could divide it by length
and multiply it by 100
but
notice here that we are
and we are both dividing and summing so
we can actually combine these to an
inner products we could write
plus dot divide so it's actually these
bits divided by the length and then sum
all of that up
and this gives us a fraction which we
can then multiply by a hundred giving 37
and a half percent uh C's and
G's this isn't especially uh efficient
because we're going to be dividing these
booleans we really should be summing
them first so there are other ways that
and we can do this well that's slightly
less elegant and we could have sum this
first and then divide it by the length
we can also of course
multiply the length by a hundred first
and then
we can multiply the sum by 100 first
here and then divide and again we can
now
do the
plus the times for an inner product
and because of this parentheses here and
with a single thing on the right if we
want we can move division over on the
left
um and
commute its arguments and just another
solution in many ways to phrase this
these are just a few
thank you for watchingwelcome to the apl quest c apl wiki for
details
today we're going to compute the
fibonacci sequence note that we're
computing the first first n
elements of the sequence and not the nth
element which is a more usual task
so the fibonacci sequence is usually
defined as being recursive
the way it's defined is that we start
off with some seed values and then we
compute the next value by summing the
last two values in the sequence
we can express this
as with a stopping condition so if we
start off the sequence with zero and one
for the fibonacci sequence and and that
in that case we
say that for the
zero for the first
um
zero elements we just we don't need
anything at all
and we could just return zero
um
and for the
element number one uh which we want a
one
and when we sum them together we get the
zero and the one and that gives us a 1
and then 1 and 1 gives 2 and so on
so
if
the argument is less than or equal to 1
that means it's 0 1 and then we can
return the element itself otherwise we
want the sum of the function itself
applied to
each one of the argument minus 1 and 2.
so we can try this on
on one
two
three
and so on
but we don't want the nth element we
want
all the elements up to end so we can
apply this on each
of in
of the numbers here
and while this works
it is exceedingly inefficient not only
do we
compute the same sequence over and over
again for n minus 1 and n minus 2.
for every element of the sequence we're
also doing this whole thing over and
over again and this
becomes ridiculously slow
very quickly
so that's not a good
way to do it but it very clearly
expresses what the sequence is about
instead we're going to
focus on computing the entire sequence
at once
and the way we're going to do that is by
using a fundament what i call a
fundamental
fibonacci transformation function let's
call that delta
the fundamental function is that we are
extending the
currency generated sequence with one
more element by summing the last two
elements of the current sequence so the
current sequence
concatenated to the sum of the last two
elements taken from
the current sequence
and so if we start by applying this to
we can do it to a 1 because taking the
last two elements will give you a zero
and a one
and then
we can
apply it over and over again
so
how can we actually use this and how can
we define things in terms of
this function well now we can
write a
recursive function
where
we are looking at the element
at the argument
if it's less than or equal to one then
we know exactly what the sequence is
going to be if it's zero it's going to
be the empty numeric vector if it's one
it's going to be a vector
one and so we can transform a one into a
vector one and zero into a zero element
vector simply by letting the argument
reshape itself
and then and
and we
want to extend the sequence otherwise
and what sequence are we going to extend
we're going to extend the sequence that
we got for
uh
one less than the current number we're
at
and then we just need to extend it
so let's call this a recursive version
and this works but it has one problem
and that
approaches the field of tell call
optimization telecoil optimization is a
method where
we do not need to keep track of
the caller when we are recursing
[Music]
by not having to build up a stack
because the final result value is not
going to be
post-processed in any way
and the problem that we have up here is
that after we're recursing we're taking
the result value and modifying it
essentially we're building up a um
a sequence on the stack which is just
waiting for a value that can be extended
more and more
and we really should try to avoid that
both for
efficiency and not to run out of stack
space either
um
so if if the interpreter and this one is
is still called optimized then it will
detect that we're not using the result
just returning it
um and then it will not build up a new
stack frame we'll just replace the old
stack frame with a new one
um and for that we're going to
we want to know when to stop rather than
just
returning a value which is then used and
the way we know how to stop is when
we've generated enough of the sequence
meaning when the generator sequence is
long enough
so we'll feed every iteration of this
function
the stop condition in the form of a
length
how long we need to
to make it
and that's going to be
a left argument and that left argument
then is is given in the initial call so
our argument is 10 means we want to keep
going until we've got 10. of course we
can't make a function that just takes a
left argument so we'll use as argument
the seed value and that we're going this
the beginning sequence we're going to
start with
so if the cutoff point
is
uh
less than or equal to the length of the
currently generated sequence then we
either done or beyond done
and so we would in principle just return
the sequence but the problem is it might
have been too long and it only really
happens if
the argument is zero and we begin with a
seed value of of a one
then we need to chop it down just like
we did before
so we can do
a take which just caps
the sequence to the correct length
and now
since we know we're not done yet then
it's safe to just extend the sequence
and then we need to check again that
means we need to recurse
and the limit
for
for the sequence length is still going
to be the same so we feed that along to
the next iteration and here we can see
that the last call
is go is the recursive call
with the left argument but the result
isn't being used
a for further computation therefore this
is still called optimized
then we just need to start off with the
seed which is a one it doesn't matter
it's a scalar because we're going to do
the take on it so it's going to become a
vector anyway and we're going to extend
it in all other cases
so this is a
telco optimized version
there we go
and another way we could
see this use of the fundamental function
is by applying multiple times
and we can express this
using the power operator
so if we
use the power operator
with a number
on
some seed then we're going to extend it
problem is we're just generating a
little bit too much
but we can
use take again to chop it down
we don't want to start with 0 1 either
because then we get a 0 at the beginning
so we can express this
just by using argument over here
so this is using
the power operator
and
with two beginning values so we're
appending to the first two
oops
there we go
it's a bit
it feels a bit
silly to
make the sequence longer than it needs
to be and we only do that because we're
starting off with the seed value of 1 1.
problem is
if you want to start with an empty
sequence and append to that
then
when we try to try to take the last two
elements will be of an empty vector
we'll be padding with zeros and that's
going to be
zero
zero zero sum together zero and we add a
zero and the sequence will stay zero
forever so how can we ensure that we
always get at least one
well we can do that by a clamping
to be above one or doing a max with a
one
so um if we start with empty sequence
and then we apply the basic
transformation function on that
n
times we
max will a one
we need to bind these together so
essentially here what's happening is the
power operator is applying max over and
over again always with the constant one
as left argument but right before it
applies it in the next the next time it
pre-processes the right argument with
the fundamental extension function which
just then adds one more element to the
sequence
and that does the job so this is
appending to the first zero elements
oops
same mistake there we go
so that's another way to do it another
way we can
iterate is using reduction
and
there's a bit of a trick here going on
if we look at
at our definition of delta it's a
different and it it doesn't have an
alpha in there so it doesn't use the
left argument doesn't mean we can't give
it a left argument that works perfectly
fine
therefore we can start off with
our
with the sequence
and then we can apply
with some random value here
it doesn't actually matter
and this
is a reduction we have a sequence 42 42
1 in this case but the all these values
except for the last one don't matter
because only the right and right side is
going to be used as our seat value
and then we're just inserting
this delta in between them so we just
need to generate a sequence that
um
ends with a1 it doesn't matter what it
is we might as well just use
um all ones for that
and then we can reduce using delta
and that gives us this notice that it's
in enclosed because reduction has to
reduce the rank from uh one vector to
zero scalar so it encloses that but we
can just
disclose that and come back
so
this is a very short way and of defining
it and using a reduction
there is one problem however and that is
if you try to run this on zero so zero
ratio one that's an empty vector and
then we're trying to reduce over m to
vector right that requires that the
operand
has a known identity element
and we don't have that because it's a
user defined function and in fact there
isn't
one anyway
um
so we can't do that we have to extend
the sequence by one and then remove one
element again and it will be a little
bit ugly to do that but it can be done
so instead of using omega to reshape the
one
let's use one plus
or a one max and omega
that just means that if you have zero it
becomes one all the other numbers stay
the same and then finally we'll have too
many elements just in that case of zero
but we can fix that as we've done uh
before
by just taking the first n element so in
most cases it's not it's going to be a
no up but just for zero it's going to
chop the one down to a
zero
and now that works
and it works still for larger numbers as
well
okay that's it for using this
fundamental and fibonacci extension
function but there are other ways to
compute it
and and one is
by using a pairwise sum
so a pairwise sum is is we can see how
it's related to what we're doing because
we want to add the last two elements in
order to build up the next and
next element
but we want to extend the sequence not
shorten it down and a pair wise some
that's an otherwise reduce with with n
being two
it always removes
reduces the length of the argument by
one because it's taking two adjacent
elements and combining them into one
so we need to extend we need to pad with
an additional
numbers
so that means we could uh if we have a
pairwise sum
um of
zero and one that gives us the next
element but we need to have and
more elements
added up
so if we
if we add more and then we can use this
again
um
so if we if we add more elements so we
need to to extend with one element every
time around the loop and we and pairwise
reduction removes one so we need to add
two
so if we do this
oh no no this isn't working
um oh yeah of course the the problem is
that we need to have more we need to
have more ones here
uh
we need to make sure that the minimum
value is a and is a one
so we can do the same trick as we did
before with
with the maxwell one so let's try that
here so now now we don't actually need
any any start values
anymore
and we can apply this
again
and we can see how the sequence is
building up
so we just need and we just need this
transformation here to be applied and
over and over again
so we take
the argue the sequence as far as we've
built it up so far
and
put two more zeros on the left
pairwise reduction make sure that we
start off generating and generating ones
and we do that n times
beginning with an empty sequence
so this is a pairwise sum
another way to compute
the fibonacci sequence is by using a
transformation matrix
and that matrix
is a
tiny little
matrix looks like this
and if we multiply that by itself
and keep doing that
then if we look at the generated
matrices along the way we can spot the
fibonacci sequence in there for example
in the top right corner we're going down
one one two three five eight so on
and so again we have here m all over the
place and we have a matrix
multiplications in and in between them
this means
that we can define a
a vector of
m's
and then we can reduce those
using
the
matrix multiplication to get the tenth
element
however we want all the intermediate
values instead of using reduction we can
use a scan
and then we just need to have
the top right element
of each one
and that gives us uh the fibonacci
sequence
if you try to use it on a 0 it works
fine because we have a
we have
an empty vector with a no with a
reduction
and
with a known so we can try this
plus dot
times reduction over an empty vector of
and of matrices doesn't really matter
what their values are
and
that doesn't work
but a scan
and
scan just gives us the intermediary and
values beginning with the first one
preserved but when there aren't any
there's nothing that needs to be done we
don't need to curse on any value out we
don't want need an identity element
which would have been the identity
matrix um anyway but it would have been
relative to the argument and that hasn't
been defined
but this is using matrix multiplication
um
and we can we can hard code our
vector in our matrix inside here so it's
standalone
okay another way to do it is by
the only information is remember the
only information that we we need to
compute the next value in the sequence
are the last two elements
and so what it means is that
when we're going from the last the
current letter elements to the next last
two elements
then the last elements become the last
element becomes the first element and
the sum of the two becomes the last
element
so
consider here two and three let's say
those are our last
less elements
and
if we do a scan on those
then and
we preserve the first element
and the second element becomes the sum
of the two that's very close to what we
wanted we want to preserve the last
element
and then have the sum
and we can do this simply by reversing
the two
so
and now the three became the first and
the sum of two and three became the last
which means we can
if we do this again we get the next
values
and then we can we can
if we extract every time around the loop
then and one of the elements
the first one for example then we can
build up the sequence we just need to
store them somewhere
so we can define a function where we
have a result
variable
we're not going to use it initially but
we're going to
apply this transformation here
the plus scan on the reverse of the
current pair
and then we want to
take the first element from that and
and
append that to the result variable
and then we want to
return the new
the new pair which is
which is this whole thing
so here's a trick instead of
taking the first element let's leave the
whole thing
the whole
and when we do the concatenation to the
result variable we pre-process the new
value that is being added to the result
with
first
but still this whole function is the
modifying function in this
modified assignment
and the assignment is here and there's a
principle that the assignment always
returns whatever is on the right
so even though we're only actually using
the first value
the result of this whole assignment is
going to be this whole pair and that's
the whole pair that we actually
interested in
so now we can do this and we want to do
it n times
and we just need a starting uh
pair which is zero and one
so the first time uh so if we do this
zero times we have r already set to an
empty vector if we do it one time then
that means we are adding them
up we're getting one one taking the
first value that's one adding to that
then the second time around the loop we
do one one and adding up is two so we
get one two and we get another one and
um
and so on
and once we've done that n times then r
has accumulated all the values that you
want and we we're not interested in the
last pair which would be the result from
um from this application with the power
operator we just want the resulting
value
so that gives us our sequence
using
accumulation
and that's it for and
all the methods we're going to look at
for building up the results slowly we
can actually
compute the entire result
in one go
and there are uh because it's possible
to compute the nth fibonacci number
directly without building it up to it
and there are various ways of doing so
and one way is by using approximations
of the golden ratio
so if we have a bunch of
ones
so
for this series
and then we can reduce
using
um
addition to the reciprocal
that gives
so this gives us an
approximation of the golden ratio if
this value is large enough then we get a
very good value for the golden ratio
but as we get there um all the
intermediary values which we can get
with the scan are
approximations and these approximations
are exactly ratios of two uh adjacent
elements in the fibonacci series
so if they're fractions of the two
adjacent elements that means if you can
get either the numerator or the
denominator then we can get
the sequence
and we can do that with the
least common
divisor with a one
although you can see here we are we're
missing one we want actually the other
number in the pair
and we can just flip the uh the ratio
upside down
taking the inverse or reciprocal of that
and that gives us
the series directly computed
however we're both using a scan using a
custom function here and we're using a
number theoretical function on the
floats it's so the performance is not
going to be great
it is neat looking though
we can also use the sum of the binomial
coefficients to compute the nth
fibonacci number
the way it works is that
we start with the numbers from 1 to
n minus 1.
so
and then
we can give those a name and reverse
them
and then we can pair them up
with themselves in the normal order so
this pairs up 0 and 9 1 and 8 and so on
and
doing the binomial on that
and then we've sum that
and that gives us the nth fibonacci
number and in this way
notice that we have a
scalar function reduction over a scalar
vector application we can combine that
to be an inner product
and we want the same argument on both
sides i goes on both sides
um we only want just want to preprocess
the right argument to this inner product
with reverse so it can be stated like
this as well
and that means we can make this into a
tested function
apply it on 10 to get the 10th fibonacci
number
and we can therefore get and all the
numbers up to 10
by applying on each on the energy just
like we did in the very beginning with
the recursive version
of course this is hugely inefficient
both because of the expensive functions
that we're using
and the binomial and also because we're
recomputing it and
over and over
for every number
but it's kind of fun and short so this
is based on the coefficients
and finally we can use be nice formula
it's rather long and involved but it's
not using any difficult math and it's
all scalar functions and that has the
benefit then that we can just compute
the nth fibonacci number directly on the
whole sequence just by feeding it
the
all the indices that we want
i'm going to type it up um there's
nothing really to explain other than
this is a formula you can look it up
online
it can be stated in in various ways
because of some equivalences but it's
not really important
and so we want that on the entire
sequence and
that computes the sequence directly okay
on to
the finishing stage here which is going
to be performance comparison
let's copy cmpx
from diesen's workspace
and then we need to build up um all the
expressions that we want to run we can
get all the functions that we have
defined
like this but there's actually a feature
that maybe not so well known and that
quadranele can take a list of
uh
of letters
that it will then uh filter its result
with um to only include functions that
begin with any of those
of those letters and notice here that
all our solutions begin with an
uppercase
letter cmpx begins with a locus letter
and delta isn't a normal letter at all
so if you give it uppercase english
alphabet that filters and out
and each one of them well we we want to
apply to some argument or arguments
and
in order to get some balance in it
should it be a large number a small
number so let's apply to all the numbers
up to some limit
so we're applying it to
each one up to say
um iota 20
and we are doing that on each
so these are all the uh expressions
we're going to run
and then
see impacts on that and
this might take a little while
so i might cut this out of the video
and there we go here's our result
and and we can see that using venice
formula to compute the values is the
clear winner here um and even though
there's cute the binomial coefficients
is not going to
be able to compete with anything
thank you for watchingwelcome to the apl quest capl
wiki for details
today's quest is the third from the 2015
round of the apl problem solving
competition
we are to generate the fairy sequence of
order n
fairy sequence
is
the sequence of
fully reduced fractions from
0 to 1
where
these fractions only consist of
enumerators and denominators that are
between 0 and
n
and they have to be given in ascending
order by their value
and so we can see here an example for n
equals five we start off with zero which
is zero holes and a fifth a quarter a
third
not
a half yet because two-fifths comes in
between
a third
and a half
and there are various ways to
generate the sequence we'll have a look
at a few of them
so
let's indeed start with this example of
five
and
one way we can generate
the sequence is by generating all the
possible fractions using the numbers
between
one and five the zero is a little bit
special and then
we can
get rid of the ones that are not what we
want
so one way we can generate all these
all these pairs of numbers that
represent fractions is to think of an
array of the shape five by five
and so all the valid indices in such an
array
are all the different pairings these are
all the combinations of numbers between
one and five and this contains all these
fractions that we are interested in
plus some that and we don't want because
they are invalid so for example um
2 2 and 3 3 represent the same value as
1 1
but they're not fully reduced and some
of them are larger than one like four
halves or
and
five thirds and so on
so
we start off with this we don't need it
to be a matrix so we can start by
reveling that
and then
and we need to
and figure out
what uh quotients they represent so if
we divide
we do division reduction to dividing the
first element by the second element in
each one of
these that gives us our quotients
and now
we
want to find out which elements are the
ones
that are valid and unique we don't need
duplicates so we can see for example
here that one divided by one gives one
and two divided by two
also gives one
and we only want the first occurring one
that's the one that's the most that's
fully reduced as it uses the smallest
numbers
so we can use a unique mask this gives
us exactly what we want we a a boolean
vector with a 1 for the first occurrence
of every value and 0 for all the
duplicates
which we can then use to get the indices
of
the elements that we want to keep
that's one criteria
the other criteria is
that the fraction is represents a number
that is less than or equal to
one
so we can say one is greater than or
equal to this values and that gives us
this boolean mass and then we can find
out
the indices of the elements that we want
and they
so we can see that many of them are okay
to begin with but here we've got
element number six is valid in the sense
that it's not a duplicate
but it's not valid in the sense that
it is less than equal to
one so here third fourth fifth sixth
that would be
two wholes that's two and indeed that is
invalid so what you want are just the
indices that are in both groups that is
the intersection
of the indices
for the mask indicating which ones that
are less than or equal to 1
and the unique mask
so this is the subset
the intersection of
these two
and now
we can use these
indices
to index into our question so let's give
our question the name
and then we use that to index into
the quotients that gives us just the
quotients that we're after and then we
can grade that
this gives us the order that we want to
put the fractions into the fractions we
generated over here
let's give that a name
and then
we want
just
the fractions that are
by by these indices that we generate
over here
and we want them put into
this order
and the only thing we're missing now
is
the zero
so
we can stick that in front and and
have that
and separately either way we do it we
can say
zero one concatenated the only problem
is that we have a nested array on the
right and a simple
two element vector on the left but if we
do this
over
the nest function this function make
sure that the result is nested if
possible
so this is going to enclose the left but
not
the right it's also known as enclose if
simple
and that gives us
this function that's able to run all of
this and we can even do it with zero
and that gives us just the zero as the
problem statement states so let's give
this a name
and this is we'll call this
i
for
we generated all the indices and then
another i because we were using
indices to select subset that we want
we can also create a very slight
variation in this by making an
observation
that the
intersection of indices
between these two masks
that is
the indices
where both of these masks are true so we
both want them to be
that one is greater than or equal to
and
the unique
and we can actually see
the relationship between this set
function
and
the boolean function and they both have
the same
kind of general shape
just like or and
union do
and so instead of finding the indices
first we can find the combined mask
where both of them are true and then we
find the indices that are true for both
of them
and such a slight variation in code can
actually make
quite a difference in performance as we
will see
copying in the cmpx utility for
comparing execution
time
we're going to call it an ii on a
thousand
and i j on a thousand
and then we can see that we got a
tremendous speed up from this very
slight variation where we just prefer to
work on boolean masks instead of working
on
indices and that is in general true for
apl
so we are still
and using indices after we use our
boolean masks we might think that we can
get even better performance
by eliminating the use of indices as
much as possible so over here where
we
get the indices in order to select a
subset of the quotients we could also
just use the mask directly to filter
the quotients
we need
an indexing in order to do the sorting
but now that we don't have i anymore for
in the indices we instead can use the
mask to filter also
the
fractions
and so let's call this i using
masks all together
and then we can compare the performance
of our best
indices type
solution and the one that's using only
masks
but we see that that doesn't really make
a significant difference so it's not
always that eliminating indices and
using masks
or better
um
but for some cases and it's good to do
these performance comparisons
okay
a different approach
let's instead think of about this in a
more number three right equal way
so we are beginning with the indices
from one to five
and then and we'll
do all these combinations the same way
that we generated all the combinations
using iota omega omega
we can do an outer product using the
same argument on left and right
and in here we state our criteria
for
being
chosen
and so what are our criteria well we
want our fractions to be fully
reduced and we want them to represent a
number that's less than or equal
to
one
so fully reduced what does that mean it
means that they are relatively co-prime
um
or relatively prime
that is there is no number
that we can use that we divide the
enumerator and the denominator by to
reduce the fraction further that is to
say that the
greatest common divisor
is just one
so that we don't get any further by
dividing it
so that has to be true
and also it has to be true
and that
one is
uh oh it also has to be true that the
number that is represented by this
fraction is less than or equal to one
and that's only true if uh the
enumerator
is less than or equal to
the denominator so with this outer
product we're having enumerators on the
left and denominators on the right and
so we just need to make sure that they
are the left side is less than or equal
to
the right side
and that gives us this
boolean matrix
and here we can go in and find directly
what the pairs are with where
so these are all the ones where and it
is true
now what's missing is that we need to
sort them so we can sort them in the
same way as before
so we can
do the division over each one of them
and
grade that
and this gives us
the order we want to put these fractions
into
all the fractions are given
here
and so we
sort the fractions by this
and that gives us the proper order
and the only thing that's missing
as before is the one for zero
and we add that in exactly the same way
as before
so um
let's call this one
um
g for we're finding the
greatest common
divisor
and then and there's a trick we can do
here we're having an
out of product
but it's a custom outer product it's not
just using a primitive like uh
times and just less than equal to
and by
unrolling this into
a s into simple
and other products then we can take
advantage of optimizations in the
interpreter so what's actually happening
here is we're combining two things
with an end
we have the outer product with less than
or equal to
and we have the outer product with the
or
and so this is unrolled g into
two outer products
and that can actually make quite a
difference so if we compare
g on a thousand
and g two under a thousand
we can see that
that little change of unrolling the
complex
outer product into simple outer products
gives us
tremendous performance
advantages
okay
here's an entirely different way of
doing it
so far we've been generating all these a
enumerate enumerators and denominators
only then to
reduce with division over them all to
get our
our quotients what if we started by
generating the quotients
so here is an outer product
of
the numbers themselves so this gives us
all the quotients
right away
and then we can rather that into a
simple vector
and now we just need to eliminate all
the invalid ones so what does that mean
that means
anything that is greater than one needs
to be eliminated
we can do that by clamping it to 1. so
we take the minimum of 1 and
all these values so we can see that the
2 now became 1
and 3 become 1 as well 1.5 also became
one so you get a bunch of ones there
then we want to get rid of the
duplicates and we can do that with
unique
so here are all the uh the quotients
that we want but they are not in the
correct order yet
now the only thing we need to do with
them is to sort them we don't need to
grade one thing and use that to reorder
something else so we can use the short
idiom which is going to have
an performance advantage as well
now they're
sorted
and we just need to transform them into
into their
corresponding
fractions
and we can do that quite
cleverly
because
we can
use the greatest common
divisor
on
non-integers
to
find the number
that
would
that we can divide with and still get it
to be the result to be an
uh integer and so if we just divide by
that number that gives us um our integer
and we want the greatest common divisor
with
with one
on each of these and what we want to
divide
is
both
these numbers
themselves
and one so that will give us the
enumerator and the denominator
so these are our
and our fractions
and then the only thing as
as always is where we need a zero as
well
um now we could stick in zero and like
we did before just concatenating that
but since we're anyway converting two
fractions we can also just put
another zero over here on the left and
that takes care of the zero case
as well
so this is the one that uses quotients
right away
now
even here is a bit of a trick so
everything up onto the sorting looks
very nice and flat
but then we have a very explicit loop
we're doing each we're applying this
derived function on each element
and we can avoid that by thinking of it
in higher rank arrays
so
we still want the one and on the right
but let's instead of doing for each one
of them we generate a pair like this
let's generate a two column
matrix
so
one is the right
right argument to this
train the fork
but we need to
make this vector into a
column so we
concatenate rank 0. we want every
scalar in our
list
over here concatenated with another
scalar to become a two-element vector
with a scalar one
and that give means that every cell
which
every major cell and also every cell
which was before a scalar becomes a
vector and the result becomes a matrix
now we get a
a two column matrix we can we can try
this
and then we need to
divide these
rows
by
the corresponding
greatest common divisor so we can still
do the greatest common divisor like like
before and we just need to divide the
rows
of
this matrix
so the rows have rank one
with
the scalars
of
the
let's go this is upside down the scalar
is of the greatest common divisor
and that gives us this matrix and these
are in fact our fractions with one
fraction on each row however the problem
statement is it should be a vector of
vectors so the last thing we do is to
split that
and that gives us our vectors of vectors
so we we try to stay flat
as long as possible
um only changing to a nested
representation at the very end so let's
call this using quotients as before but
the flat edition
and then
let's compare the performance
of the quotients on 1000
and the quotient flat edition on 1000
you know it's a little bit more involved
using
rank over doing the each but
well the result speaks for itself
okay
finally
in all these cases we generated
too much we generated
all the different combinations
in order to filter them down to the ones
we wanted
maybe we can
instead
generate
exactly
the
fractions that we want
and turns out
that
there is in fact
a formula
to go from
um
from
existing
sub part
and the leading part of the sequence
to the next element so much like
fibonacci numbers are constructed by the
sum of the last two elements
generated
so far
so too
the ferry sequence can be generated um
by looking at the last two elements
before so we only every ferry sequence
begins very simply we begin with a zero
and then we begin with 1 over n 1 nth
that so in our example with 5 we start
with zero zero whole and then one fifth
that's always going to be the smallest
possible fraction
and then if we look at
um
or we can name our fractions in sequence
so the the next to last one that we have
so far
will be a
b's or a over b
and then
last one we have so far is c over d
and then the next one coming up is
p over q
and these p's and q's can be
computed where they're not too difficult
formula
just in terms of
a b c and d
and the n which is the type of sequence
that we are generating right now and so
we can do that right from the start we
know that the first two elements are
have a a equals 0 and b equals 1
and
c equals 1 and d equals n
and that allows us to compute
the next
term the third one and then the fourth
one and so on until we're done and the
stop condition for the sequence would
then be
when
uh
they are the same when we've reached one
hole
so
let's try to state this
it's it's going to be a bit of a bose
but
it's not really very complicated in
itself
so first we want to generate the start
sequence
let's say for
for five so we know that the first one
is going to be
0
1 because it's always 0 1
and the second one is going to be 1
and n which is our argument here
now there's since this is what we're
starting with and then we're going to
add more elements there's
one issue
which is when we have when n is zero
then
um
we don't want to have the one and n
that will give us one zero
[Music]
so we want to eliminate
the second element only take the first
element of this
when an n is zero
so what we can do is
we can take
how many elements
from this well there are only two
um
and we so we want to uh
or we can drop the last one when n is 0
or we can add 1
to n
so for 0 this gives us 1
and for 1 and this gives us 2 and for
any number higher than 1
that gives us more than two and then we
can clamp that down to two by taking the
minimum
so for five
this will give us two and for every
number it gives us two except for zero
where it will give us one so this is one
way to to restrict it like that
and then we want to apply the
transformation
um over and over again until our stop
condition is met
so we're going to write the
transformation eventually let's just put
in the stop condition so we use the
power operator
for that
and
we want to continue applying this
transformation of adding one more
element to our sequence one more
fraction to our sequence of
fractions
until
the
what we have generated
the last element
it is
uh it is true
that
um
the fraction
is
is finished
so it is the last last one so
it should be
one and
one over
one or we could even say if it's more
than that if it becomes uh positive
that's then we are also long finished so
if the
numerator is greater than or equal to
the denominator
then
we're done
now
there's yet another problem
the power operator will always apply the
function at least once but what if
our n is zero in that case we don't want
it to apply at all
so this derived function which is and
apply until a
certain condition
is fulfilled
we can say we want to apply this either
once
or no times depending on whether we have
n equals 0 or not
so we want to apply it
once
if
n is greater than
oh it's not even just one even even
not even just zero for zero we don't
want to apply it at all for one we also
don't want to apply it because we
already have
the full sequence zero and 1.
so for any number that is greater than 1
this evaluates to 1 and then we apply
this whole derived functions
once and for 0 and 1
this value is 0 and we don't apply this
function
at all and that gives us our secrets we
want
this is an array
this is also an array so we just need to
separate the two of them
okay and now for translation of
of this whole
sequence
we also have to remember that in that
formula that we had
you can go back and
look at it for a moment
we are using the last two elements
of the sequence
and we're using n itself
so n itself that was the right argument
here we're feeding it in as a constant
left argument
to this transformation function
then we take the last two elements of
the sequence that we've generated so far
and then let's
pick that apart into these names a b c
and d so
a and b
is the second to last fraction and c and
d
is the last fraction
so we are unpacking that
and then
and we just need to translate
all the mathematics and that's pretty
much an um mechanical translation
so we take
n plus
and b goes the formula
and then we're dividing
that by d
we need to
run that up
off and multiply by multiply c and
d by that
and then we need to subtract
a and b
and that gives us our new
term in the sequence so we can take
the existing sequence and concatenate
this new element to that
so
we run it
and we got the sequence that we want so
we now we generated
just the fractions that we were after
without generating anything else
just in order by computing the next term
in terms of the terms that we already
have uh created
so let's call this p for power
we're using power to iterate over it
and then uh we'll make one little
enhancements to this for performance
sake because here
we were
again dealing with nested arrays we
started off with a two-element
vector of
vectors that's already nested and then
we kept
appending more
nested elements to that
and we should really avoid doing so as
much as possible so let's try again to
generate this two-column matrix that we
saw before
um and then only as a very less step
split that into vectors of vectors
and so uh we want these four numbers in
a matrix two by two
however um if
and so we can we can reshape that you
could reshape it into a two by two
however if our n
is
0
then we want it to be a 1 by 2. we only
want the very first
ones as a single row
matrix so we can use that same formula
as before and
we can clamp
two with one plus
omega um
and that gives us in all other cases
then zero it will give us um a
two and then for the zero case it gives
us a one
and now we have a two by two matrix and
we're going to add
more rows to this and so all the
conditions everything is the same
here
we were looking at the last element we
don't want to use the last element
anymore now we want to use the last
major cell other than that it stays the
same and the formula here is all the
same
instead of
concatenating an enclosure we we just do
a leading axis concatenation we add one
more row
and over here where omega is
a matrix with two columns
negative two take will give us
a a two by two matrix again
we can just revel that and assign
to
all these four names in a flat way so
this is the same power based
solution
but
the flat addition and then we have to
remember to split at the end so that we
get a result that is a vector of vectors
we can try this on five and see where
you get exactly the same result so
ever so slight variation to make it use
flat arrays as long as possible how does
the uh compare
how does the comparison
how does the performance compare um we
have p and i'm not going to run it on
1000 because i happen to know
already that this is not a fast approach
in apl
so let's just do it on
100
and and
we can see that staying flat as long as
possible
was a really good idea that saves us a
lot of performance um but on the other
hand um
we can see that if you compare to the
queue that we have above that they don't
uh
the way we were doing is for a thousand
instead of
uh 100 it doesn't look very promising
and let's take the best of every
category and put them against
each other
so
and we'll just do it with 100 this time
so the best we had was
from was using indices
and we wanted to use the mask whether we
use the mask all the way through or
whether we only use the mask initially
to select which elements was not very
important but we can
we can use the one that uses the mask
that was the one that had best
performance
then
we had the version that used the the
greatest common divisor
and we found that by
splitting our
outer product into two outer products we
got significant
performance improvement
then we had
the solution that did the quotients
right away and of course staying flat
was a good idea
and finally we have
the power approach where we keep
extending our sequence and again the
flat one was the fastest one
let's compare all of these
and so we can see that and computing the
quotients
was
indeed the fastest way by far
although and using the
two outer products with a
number theory the greatest
common divisor was not a bad approach
and either
thank you for watchinghi we are given
the the
scores from people who have played
golf and then uh we are to give them
it's kind of a a grade give them a a
place in the
sequence and in the golf you want to
score as low as possible now that's very
easy
however there um The Twist here is that
if people score the same then they need
to get the same
place and all the slots that would be
taken if they were different are still
taken so then instead there are certain
uh positions that don't
happen and instead everybody gets the
average of what they would have gotten
had they been
different so here's some sample scores
and notice here that there are two 68
and they they're given in uh ascending
or n descending order and there are
three that got
70 so clearly 67 gets first place then
this would be second and third place but
since they're the same they have to
become the average of that which is the
two and a half place so they both need
to get two and a half then this gets uh
number four this is five six and seven
uh which need to share place so the
average of 56 7 is six and then we get 8
n over
here and there are a lot of different
ways that we can um attack this
problem
so one simple way is that we start by
grading so grading means uh telling us
what what position element uh we should
take in order to
sort so here we say well first you want
the first one then the second one then
the third
one um and since they're all in in order
already and since we be doing a stable
sorting here then we it just becomes
really the sequence of um indices so we
could actually
um
just replace this with with indices as
well here's the length and then we've
comput the indices like this and that's
going to be much faster because we're
just generating the indices right away
whereas this actually needs to do
comparisons of
everything okay now we need to uh group
them and there are again a couple of
different ways we could do this but
since they already in ascending order
and they are nonone zero integers then
we could actually just use those values
as left argument to the partition
function uh partion spell
this and that gives us our groups that
because this is exactly how the petition
function
works so now we have these groups some
of which only contain an single element
we can take the average of each one and
we can do this with a tested function
there's a FEA spelling which is the sum
divided by the tally
that gives us the average for each
one um but we also want uh repetitions
here so we want to take the shape or the
length of each segment and use that to
reshape this average so we take the
Telly and use it to
reshape the
average now we're back to having groups
but they have been smooth out so every
value in every group is the same now we
just need to join them which we can do
with the in list
function and that gives us our result in
order for this to be a proper function
which you can give a name f then we wrap
it in braces and replace the argument
with Omega which is the rightmost letter
of the Greek alphabet so that indicates
the right
argument and we can apply that right
there um we were doing grouping and
group really calls for the key operator
so this is a alternative way of doing
things let's take the argument
here
and we are going
to use the key
operator and we're not interested in the
actual values we just want to operate on
the indices so that's the right argument
in the to the upper end to key ke's an
operator takes this function as
operant that applies it in a certain way
and on that we're going to apply another
function which is going to be pretty
much what we had
before the only difference um is that
key will mix together the results and
make it into a single table that is
every such application here becomes a
row and they might not have the same
length so we can have that so we enclose
it and that gives us the same result as
before and then we can enlist it and
we're done so we can give this a name
g
now um there is
a um a little bit of a complication here
and that is that if we try to apply F on
just a single
number that works fine if you try to
apply G on a single number number that
gives us a rank error because key cannot
group a scaler it has no Dimensions
along which to group them so we need to
amend g a little bit by
um applying this whole thing that we
did this grouping to the result of a
reveling so this first makes it into a
vector and then uh we have apply the
rest and now we can do G otherwise it
gives the same results only to handle
the scaler
case Okay so this works as
well now we can go into a completely
different way of of solving
this and that is in order for us to get
the average positions
here if we go back to um to just the
indices let's look at uh let's stack
this on top of s actually so we can um
put s here and we put the indices here
that gives us a two element vector and
then we can mix them to make it into
rows of a matrix and that gives us this
um so now if we look at um at these
values let's look at the 70 we don't
actually need to take all the values
five six and seven in order to get the
average we could just have the smallest
value and the largest value and then add
those together and divide them by two
that would give us the average because
it's a contigous uh range of adjacent
indices so um how can we do this well we
already looked at how we can get the
indices
themselves and we
also
and we can also get the opposite we did
this with grade before but we could we
also have so this is
grade we also have a grade that goes the
other way and that wants to sort from
the largest to the smallest so let's
stack these on top of each
other and we can actually let's put in
the the grade up as well so we have all
three of
them okay
so here you look at the
268 then and this says this is the
second largest and we can see that eight
is the second largest number before
nine so we are going down instead but of
course uh we don't want actually to have
these large numbers here we want to go
from from low to high so we can
reverse the
grade and now we can see how everything
lines up except where the numbers
are the same so here's two and three
which is exactly what we need to average
three and two over here by 70 again we
have five six and seven and we got 7 six
and five so if we are to take the
average of these two that gives us six
these of course give six as well and
this gets six as well so that means we
can solve this problem um by taking the
grade of s or say the indices of X so
these are the um the indices and we add
them to the reversal of the
grade that gives us double uh the score
now we just need to divide it by two so
and we could use parenthesis and do
division by two but we can also flip the
arguments so the division symbol so it
takes what you divide by on the
left and that gives us uh the result
that we want so we can call this
H and um we still have the problem that
if you try to apply it on a single
number then the grade will
fail so we can put back in this
parenthesis and just put a revel outside
so this function is applied to the
result of this
function and there's one more way that's
interesting to look
at and that is um self indices so if we
look for the first occurrence of every
number in s in s
itself so then we can see uh let's let's
do the same same thing again let's stack
them on top of each other we can see
what's going
on we can see that we find a 68 in
position two and this 68 we can also
find in position two because they're
equal to each other same thing all the
7s are found in position
five there's a different function in APL
which is the interval
index interval index tries to find the
slot wherein a number and can fit so
let's say we wanted to find
um where can we fit in say
um
69 and a
half it says slot four 1 2 3 4 we can do
this because our numberers already
sorted so we can find that slot there if
we do 69 itself It also says four if you
do 68 it says
three so it it wants to place you can
see here it wants to place 1 2 3 and a
value that's identical to an existing
value after the last of those values
kind of first come first
serve and that's very convenient because
now if we use the interval index on of s
on
itself then we can see that the 68s they
with the noral index of they want to go
to the first
position and interval index wants to go
to the last position same thing here
five and
seven which means the average of the
index of and the interval
index is going to give us the score that
the position that we want so let's do
that
this is pretty neat how can we make this
into a a proper standard loone function
we could replace all the SS with omegas
and wrap it in braces but there is a
need a way and we can make it all test
it by saying that this is a self
application of the in uh index of and
this is a self
application of the interval
index um which means we can then
um apply
this and now we just have some redundant
parentheses we can
remove this is in my opinion a beautiful
solution um again you order to handle a
scaler case we need to
Ravel but other than that
and this
works
now it would be interesting to know
which solution is the fastest
one let's import the compare
execution and facility from the defense
workspace and we probably want to
generate some sample numbers and as well
so let's say that we are generating
um
five uh
th000
numbers in the range of
10,000 and so these are the upper limit
and we apply the r to that to get a
whole bunch of um of
numbers we can take the first 10 and and
look at them oh look at that they're not
sorted so let's sort
those and we can do this by indexing
into t with the grade so this exactly
what what grade does it
sorts okay it would also be interesting
to know how many unique numbers are
actually there we can do this by taking
the uh unique mask so if we try this on
the first
turn it indicates with a one every time
we have a unique number for the first
time and then uh with a zero for any
duplicates of that which means that the
sum of this is going to be how many
unique numbers we have so this is the
plus
reduction and we get there 10 seven out
of these and what about the whole big
collection so we can see that there are
about 4,000 unique numbers out of the uh
5,000 so there are some duplicates uh
here and
there uh and they're all in the range 1
to
10,000 now we can write
cmpx F on t g on t a h on T and I on
T and we let it run for a little while
it will apply the functions many times
to get an average of the execution
speed even
out oh look at that that's a huge
difference here in fact so much that we
can't really tell which one is faster H
and I so let's try those
again
and uh well I guess for this size
argument uh then H which was using the
grades up and down was uh the fastest we
can look at at what we've got
here thank you for
watchingwelcome to the apl quest the apl with
keeper details
today's quest is the fifth from the 2015
round of the apl problem solver
composition
it's a straightforward problem of
computing the standard deviation
only little catch is that it has to work
on an array of
any rank not just
a simple vector
now i didn't have a pleasure to work
together with
ken iverson but i did have the pleasure
of working with his close student roger
huey and roger used to say what would
can do
i can say what would roger do
and
well i can't be sure of course um i have
seen roger huey write
fantastic code and i think this is how
he would do it
suddenly he defined the mean
to be
like this
as that we've seen many times do and
then he might define the deviation to be
the argument
minus the mean so that's how far away
from the uh from the mean every element
is
then you might define some helper
functions small utilities like
uh square
to be
power with a um preset right argument of
two and also square root
to be
same thing with a half
and now with these
tools in our toolbox we're able to write
the standard deviation quite nicely
the standard deviation would be the
square root
of the mean
of the square
of the deviation
there we go
now since we have to have this work on
an entire
luxury and then
then this is not quite going to work
um because we need to revel that array
first
we can easily define in our function as
a standard deviation of the rebel
and now if we
try to say take this and
we can concatenate it with its own
kong vector
so that looks like this and then we can
do an f and that we get the same
standard deviation because the same
number is just duplicated
that's uh that works and however this is
defining it on these small
portions and i think that's what rosie
would do
we can however change to a more compact
style where we try to integrate the
various parts so let's have a look at it
and this is tool com called bracket devs
and we do that for f and it takes
because we have um
early binding then the actual definition
of standard deviation here uses all the
pieces that we use to define it we don't
remember the names for them and so this
is just the corresponding formula
with all the pieces put together
and we can try to see how we can um
how we can make this
um
more
collected together if you start looking
here we have the square
of the deviation we can just combine
those here
and also continue it might be helpful to
make this into a dyadic function
application which we can do by using
power and commute
the argument so we can put the two on
the left
similarly over here we have the square
root
we can also put that into um the
parenthesis here with the
with a mean
and we can make this into a daddy
function just for symmetry um by putting
the two on the left or we could put we
could put a half on the left and then
commute
but if you want even more symmetry with
what's going on over here then we can
pre-process the right argument of power
with a reciprocal and put a 2 instead
and now we have again these form in the
top we have this function here and this
function over here um and since we're
already having parentheses here we can
take
this function and just make it an inner
function
over here
well coincidentally
if we
ask apple card for the standard
deviation
then we'll find something that is well
identical
and with the little thing extra that we
are raveling and the argument before we
apply it so it works on high rank arrays
as well
that's the first way that we might want
to write this and this is something i'm
sure
so here we would have been happy with it
as well and that's using the under or
dual operator so let's define that since
it's not supplied out of the box in
dialogue apl
um and we since we're only using here
for magnetic applications we can have a
fairly simple um
definition for it so it's the um
we start off by
pre-processing the argument with
the right operand
and then we do the main action
application and then we undo the
application of the
the preprocessor like that
and this allows us to write the standard
deviation
call this is a version that using under
and then we can write it's the mean
under the square
m of
the deviation
and then we could um
so this works as well
and then of course we could
define in terms of that um
with the rebel as well
and we can we can have a look at what
that looks like when we put it all
together
oops
of course there's no u it is h
and similarly um
we could
try to integrate things if we really
wanted to but
it doesn't make so much sense here
because the the beautiful thing is that
we're using the under um but we could
so
um
we have
this this part over here this whole
thing is just a post processor on on
this parenthesis over here so we can
take the whole thing
and put it inside
oops
let's try that again
put that inside here
and now and there's no point in turning
the arguments around on the on the
square but we could replace it with say
self multiplication which is another way
of writing a square
and then uh i think it actually got it
wrong here that
it's supposed to be parenthesized
otherwise this is not going to work
so we want the mean
um and that done while we have
uh the square over here
and then we un undo the squaring so that
becomes the square root and then the
whole thing on
um
on the rival
still works
so that's
it for this time
thank you for watchinghi
we're going to split a list of words
into those that have an even number of
letters and those that have an odd
number of letters
and the ordering is important we want
the other ones first then the even ones
I'm going to go through three different
ways to do this but there are many ways
that this could be attacked
here's some test data
so we have for some even words and some
odd linked words and then some mixture
after that
we can start by using Telly to count the
number of letters in each word
we're not actually interested in the
real number of letters we're just
interested in whether it's odd or even
and an easy way to do this is to look at
the remainder when dividing by two so
this is the two remainder of these
numbers the length of each one
this means if you're dividing by two and
the number is even there's nothing left
over so you get a zero and
if it's odd we get a one left over that
we can divide evenly in two whole
numbers
and this pattern we're going to use in
all our Solutions this is the basics
right
um at this point let's make a Lambda or
a decent that takes an argument outside
of these braces and refer to the
argument with Omega
so this is the same and then we want a
pair
who want basically two masks you want
one mask for the odd numbers and one
mask for the even numbers
so this mask that we have here that is
for the odd numbers and if you want to
get the even numbers then we can do a
Boolean negation a nut
that gives us this mask
so how can we get both masks well we
could use a variable and uh so for one
mask and then compute the other masks
based on that but we can also be a
little bit more clever
um
there is a an operator higher order
function called over which allows us to
take a function and apply it to two
arguments but pre-process both arguments
first
this will allow us to concatenate the
enclosures
of
two
masks so
let's say that we have this mask over
here and we use the commute
or selfie operator to also place the
mask on the left that means we are
concatenating the enclosure of this mask
with itself that gives us two identical
masks
of course we don't want that we want the
original mask as we have it here and
it's negation and Boolean negation so we
can use the beside operator to
pre-process the right argument to this
derived function with the nut
and this gives us the mask
and its negation
each one of these masks we then want to
apply to the argument which is the list
of words
so applying it we want actually to
replicate we want to or also known as
compress we want zero of the first word
zero of the second word one of the third
word and so on that's used to this slash
now we always want the data that's being
replicated to be the right argument so
we bind the right argument as a fixed
constant
right argument to this function which
would take two arguments but now only
takes one argument which is the mask
which then conceptually goes on the left
but if one argument functional magnetic
function it always takes this argument
on the right we apply that to each one
of these two masks
and that gives us
a solution there are many ways that this
that the components we have here could
be mixed and matched but this is a very
nice straightforward flow solution let's
call that f
okay
in the specification for this problem
there's actually a hint saying that we
could use the key operator so let's try
that
we start off the same way as before with
the two remainder of the tally of each
on the sample texts
and all we want to do here with the key
it keep groups things by a certain
characteristic so we want this
characteristic this being even on it to
be the keys and the values that we are
grouping is just the original data so we
could do it by putting parenthesis
around this which becomes a little Fork
here
um and then we use the key operator and
the data the values goes on the right
and we need to choose a function
and the function we want here is we
don't want to ignore the left argument
and just enclose
the the data so we want the enclosure of
the right argument to that
and this almost solves the problem but
notice that the ordering is wrong and
ordering depends on the appearance of
odd and even numbered
and
words in the argument and since the
first word we encountered had an even
number of letters then the first group
is the even number so how can we force
the ordering that we want
well there are a couple of different
ways and I think the simplest one
is to just inject
words that have the right length and
then we remove them afterwards because
they're not actually part of the
incoming data so here this identity
function refers to the right argument
this whole thing actually is one big
fork this means we apply this function
on the left and this function on the
right and then this function in between
them which is the grouping so instead of
having a density function applied we
want a function that prepends and even
an odd numbered word and an even
numbered word now the shortest odd
numbered word would be a A Single
Character it could be the right text
that sake but just the space is fine as
well and the shortest odd numbered word
is a zero length word
so we bind those to as left arguments
just like we were using bind uh before
as for right argument to the replicate
function we're now using bind to bind a
left argument to the cousinate function
so this will prepend two words so called
words
um to the argument and then similarly
over here we we already know
whether they are or even the first one
is
um is odd and the second one is even so
we can prepend that to a result there's
no reason to compute that
over here
and that gives us the correct ordering
and this gives us all the odd ones first
and then all the even ones but there's
one element too much
for each one of them
so we can drop one from each
now because we only have a single
function here which is an argument bound
to the concatenate and we have a whole
train here this is a fork of a fork
then we need the parenthesis on the left
side here we can also move things around
we can swap the arguments of this middle
time function and then just move
the outer functions around
and this will allow us to remove the
parenthesis on the right for those that
prefer to do it like this and we don't
really need these spaces either
so this is
another nice solution
that we can apply
so
there we go
and finally
um something one might not think of at
first and that is to use grading or we
could say sorting by extension to solve
this problem the idea is that we sort by
the even oddness that puts all the
putting all the other ones
first and all the even ones at the end
and then the only thing that remains is
to split the result into two at the
right point where we transition from odd
ones to even ones
and so the way we can do that let's
create another Lambda with the test
cases over here and we begin exactly the
same way as before the two remainder of
each
of the length of each and this time
let's give that a name so we can
we can call that
n
it's kind of like the number but that's
a auto even
and then
we can sort by that so let's uh let's
start by sorting and we since we want
the odd ones first
then and the odd ones have the N equals
one then we want to sort descending
so descending on
um
on n
so you can see that this puts all the
odd numbers words first and all the even
numbered words at the end
now we can call this s
we want to know
and how many are there that are
that are odd numbers
well since we get a 1 for every odd
numbered
word in the list of odd events for for
these words that means that the total
count of ones is just the sum of the
Mask
so we can and we can find the count of
odd numbered ones as the sum that's the
plus reduction of n
which is then going to well we can we
can try it out first we get there are
four of those so that's all oddly and
great
and then of course there's going to be
also four we don't need to compute that
because we can then use this let's let's
call that c
we can now say uh the number c take off
the sorted list
and we can do
and see drop of the sorted list to get
the rest of them
so now we can
make a two element Vector C take of s
and C drop of s
and that gives us our result
this is very much broken up into tiny
little steps and we can you can try to
compress this a bit combining things and
there are some cute ways that we can do
this
here we have C and S and we have them
um in the same position C on the left s
on the right and then we are joining
those two together
which means that it's kind of a fork
right we have other arguments here
and and then the results are joined
together although we're not using an
explicit function here but we'll get
back to that
okay so let's try to put things together
here
if we have S
so this is our expression for S we want
that on the right
and then we want the expression for C
on the left
then we all we need to do is
have a fork in the middle so we want the
take and we want the drop and then we
need to have the concentration of the
encloses so that's that
Nate
over the enclosure of the two
so
here's a partial putting everything
together but we can actually do better
than that
the thing is that we need to
um
we need this enclosure and we are
Computing this expression separately if
we put them both on the right instead
like this
then we can use now we we only want
magnetic function so we want this one
applied and this one applied and what we
want to apply is actually
we want an insertion here of a tick
function an insertion of a drop function
we can use the reduction
for that and it's so lucky that when we
reduce from a vector to a limit Vector
then we get must get a scalar because we
drop the rank down reduce the rank and
we do that by enclosure so that
automatically encloses on both sides
we can write this and it's Fork like
this
and now and we can
substitute in this expression for n
in the rightmost occurrence so this puts
everything together with an inline
assignment however we can also be a
little bit more clever
um and make this a fork so we can see
the argument as one argument and
the the group number if you want or the
even odd number as the other argument
so we can make that a fork all the way
out here
so we say the whole argument we feed in
as the original argument feeding as left
argument to the inner function
and then we can use this as a train a
fork just like we did in the key
solution as right argument so now
whenever we want to have the the mask
which we called n here we refer that to
that as the right argument and whenever
we want the original data refer to that
as the left argument and this space
isn't needed either
so we can write it like that and and so
on and so on we could move the bits and
pieces around but these are just some
possibilities of how this could be
written so we can write this whole thing
as a as a nice Fork that uses a
different Lambda inside as the middle
tine
thank you for watchinghey
we're given a list in order to chunk it
up into chunks of a given size
there are multiple ways to address this
problem but I think the simplest one is
to use petition in close
here's a test case
the way partition in close works is that
it takes
one element as left argument for every
element on the right
that element
is a count the number of new sections or
segments that begin with this element
if we restrict that to Boolean
then it is just a true false indication
of whether we start a new segment here
or continue the previous segment
so we have seven elements here let's
start a segment with the
continue with cat in the same segment in
goes there too then the with lowercase t
is its own segment because we
immediately start a new segment with
head
and will include a sep in that same
segment but Pat gets its own segment at
the end
partition in close on that list
so our real problem is just to construct
a Boolean vector
that
given our chunk size has a 1
every n elements
let's create a Lambda or Anonymous
function we call it addition the list
goes on the right according to the spec
and the chunk size on the left
inside here Alpha refers to the left
argument because it's the leftmost
character of the Greek alphabet
we can use this to take elements from
A1
the way take works is
to pad with an appropriate fill element
if there aren't enough elements
foreign
here we have
a 1
in a group of three
Boolean numbers
we just need to repeat this pattern
until we get the full length of our list
the list itself is Omega the rightmost
character of the Greek alphabet
and the length of it is this tally mark
now we can
take this length and use the reshape
it's a Greek row which is like a letter
r for reshape
and we use that to reshape that
one zero zero pattern that we created
before APL functions have long write
scope so we need to parenthesize the
left argument to the reship function but
not the right argument
finally we need to take this Boolean
vector and use it to do the partitioning
so we can again we have long left scope
sorry long right scope and
uh short left scope so we need to
parenthesize the left argument and then
we use this to do the partition in close
on the red argument
I like to reduce the number of
parentheses that I have and
therefore when I have a
um a very straightforward argument on
the right it's just a single token here
that wouldn't need parenthesization if
it was a left argument then I like to
swap the arguments of the function in
question so partition in close it takes
the mask on the left the data on the
right
but there's a higher order function or
something we called an operator called
commute
which looks a little bit like a confused
face because it gets confused about
what's right and what's left it modifies
the function to its immediate left so
that it takes its argument in the
opposite order
this means we can move the partition
over on the left remember to commute it
and then put the right argument
um reference as left argument to
partition in close
and now we can try this with various
lengths if we go down to two
we get Pairs and the last one stands
alone one we can see we get an extra
enclosure of each element
um if we go to six then almost all them
elements are in the same seven we also
get an additional enclosure just a
single element and if we try to go above
that then there's no difference because
the specification is we just shorten
and this is what the mask indeed does
thank you for watchinghey
we're going to take a list of elements
and fit it into a square
now the number of elements might not
exactly be a square number so it won't
fill the square array results exactly
and in that case we need to pad with
appropriate padding
so let's for example
start with the numbers one two three
four and five
so they can't fit into a three by three
they uh
sorry they can fit into a three by three
Matrix so that would give us one two
three on the first row four five in the
second and then the rest is petting f a
zero and then a whole row of zeros they
cannot fit into a square that's two by
two because the five would be left out
obviously we need to base ourselves on
the number of elements here's a function
at even a Lambda if you want
and the argument is denoted by Omega the
right most element of the Greek alphabet
for the right argument this is a
Telemark counting how many elements
there are there are five
and we need to find a square number that
can fit here so we can take this
count of elements and take the square
root of that which is the same thing as
raising it to the power of f so raising
it to the power of a half APL functions
have long write scope so this power
takes everything on this right as its
right argument and the Magnetic one
argument form of the division symbol is
this reciprocal you could also say that
division symbol has
one as its left argument default just
like minus has zero as its left argument
default
okay so this gives us the square root of
5. and obviously not a whole number so
we need to round up because we need to
need the square to be at least fitting
or bigger
that gives us three we can give this a
name
so that we can multiply it by itself
and that gives us nine nine will then be
the number of elements that we will have
in our final array
so we need to pad with additional
elements and we can do that using the
take function but the take function
takes the number of elements on the left
and the data on the right so we swap
around the argument and have the
argument over here
now we have the nine elements and the
only thing that's needed then is to take
the shape which of the final
array which is going to be S rows and S
columns
and reshape done
but we can refine this definition a
little bit
um
so one thing that we can do is we can
see this whole expression here
as being in terms of s which is the
result of the expression over on the
right
so we can express this instead using a
tested function
where we
um
multiply
s with itself
so this is the S the comes in this
argument so this is self multiplication
that's the square and we need that to
take from the outer argument which is
the Omega constant so we use the same
symbol here three different ways first
we used it to swap the arguments and
then we use it here to apply a function
with the same argument on both sides and
finally we're using it as to generate a
constant function from a constant
so this gives us the square number of
elements that is 9 in this case and we
take and pad on the original argument
from outside
and then we just need to reshape and we
need to reshape into the shape of the
concatenation with itself it's just like
we have the self multiplication we'd
have the self
concatenation
and
here we go
this is just a style thing really
whether you want to express it one way
or the other but note that we have a
self multiplication and also a self
concatenation here which means if we had
s on out here we could Supply S as a
left argument and then we don't need to
do this self thing it will pair up S
from the left with s from the right
for the concatenation and for the
multiplication over here
um so this is another way to do it and
finally we already know that we can
apply a function with the same argument
on both sides by using that frowny
symbol until the derus is so we can use
that instead of using the name s
and
this is a very neat way of writing it
thank you for watchinghi
now we're going to
compute how far it is to go around a
path that is given as a set of points
including looping around and back to the
first point from the last one so it's a
going around in a loop it doesn't
actually matter where we start
doesn't matter the direction either it's
just the total distance
let's start off by having some points to
find that we can we can work on we know
from the problem description that this
is supposed to give 12 as a result so we
have a little bit of a senate check here
okay
we can
start by making a Lambda that we're
going to apply to
the points and the right argument
argument on the right side is referred
to as Omega
and we're going to go through and
follow very closely how the problem is
described
so we want to
connect the
last element with the first element
so
we can get
the first element with the first
function extracted but we need it to be
enclosed to be fitting into our format
of enclosures here little vectors of
vectors
and then we want to append that to our
original input
okay so now we've got the same point
over here
as we have over here
this means we can just consider adjacent
elements so we've got these two
iteration elements we want to measure
the distance from between them and then
these two elements and we want to
measure
the distance between these two elements
and then we add it all together and
that's going to be our result
so adjacent differences
um that is a windowed reduction so this
is a a subtraction because there's a
difference and reduction and but not on
the whole thing just over Windows of
size two so this should give us
three results
okay
now we need to use a little bit of
trigonometry
you may know that
if we have a right angled triangle then
the diagonal so to say
is the square root of the sum of the
squares of the sides of the triangle so
if we look at this as a a triangle we
moved three steps in one dimension and
four steps in the other dimension
um and those dimensions are orthogonal
to each other that means the total
distance traveled is the sum of the and
the square root of the sum of the
squares so it's going to be 16 and 9
that's 25 square root of that is 5 and
so on
so for each one of these pairs we'll
make a new Lambda and we call it on each
one that's the each operator which is
like a map
we want to take the first element so
that's the same first function here and
we want to take the last element last
element is the first element on the
Reversed argument
so this is the first and last this is
not going to make any difference at all
um so far but now we can do the math on
them individually so we're going to
um to take
the square of this one so it's so this
is the exponentiation function but it
takes the exponent on the right so we
use the commute operator to put it on
the left we want to do that
over here as well
and then we can add them together like
this
so now we get
25 here and 16 that's 0 squared is 0 4
squared 16 square root and so on
and now that we have these then we can
take the
square root of that whole thing
so square root the same as raising to
the power of f
and finally we can sum up everything
with a plus reduction
this is all very well but I think we can
do a little bit better let's give this
one a name this function a name for
later so we can do some speed
comparisons
and now we go up and and edit this
so our first observation here is going
to be that we are picking apart an
argument
that has exactly two elements
we could also
insert this function
between the two elements so this is the
only two elements then this is the same
thing as a reduction so if we reduce on
a two element Vector that's the same
thing as inserting that function between
those two elements
this means that what we have on the
right the last element is
the right argument and the left element
is
the first one so Alpha refers to the
left argument
fine
but we can further observe that all
we're doing here are some scalar
operations we're doing
a square
of both and then we are adding them
together and then we are doing the
square root of it
so before we get to that square root we
could just take the entire argument the
entire pair
so go back to removing this reduction
the entire pair as a two element vector
and using apl's
um array capabilities to do the squaring
on this list of two elements
and then we can
combine everything afterwards so let's
illustrate this for a moment let's
remove this
here and remove the summation
okay so now we can see that we squared
each pair
okay
so that means we can now do the
summation of them
and then we can do the square root
and with ready to sum again
right
what else can we do
next what I would do here
is move this square root over on the
left avoiding the parenthesis and we can
do that by commuting with the
exponentiation operator function again
so we're using compute
operator for that
and the reason I like to do this is not
just to save the parenthesis but also to
show a certain symmetry
we've got the commuted power here and
we've got the commuted power here and
they have inverse left arguments we can
see it's a this transformation and then
undoing that transformation
and I'd actually like to take this even
further let's try to link this first by
I want to show the symmetry of this 2
over here
and we can do that by
remember that that this 0.5 actually
goes over on the right because of the
commute operator so we can pre-process
the right argument to the power function
with the reciprocal
so we have a pre-process combinator
operator
and then we have
a reciprocal function so this is the
division symbol but when you recall it
with one argument to pre-process things
then it's going to be 1 divided by or
the reciprocal which means we can State
this as a 2. and now we can see a very
nice symmetry here in our code
okay
next observation is that this is a
scalar operation scale operations also
penetrate into all structure but we have
an outer explicit Loop here
and we don't need to have this scale
operation done piecemeal on each pair we
can do that outside before we
before we even go into a looping mode
then we sum each and pre post process
again with a scalar operation which is
the square root that doesn't need to be
inside the loop either so let's take
that out and
have the looping just be the summation
and now the only thing we have
in our looping and Lambda is a wrapped
derived function the plus reduction the
summation so there's no reason to wrap
it in a Lambda in itself we can just
apply it directly
this side over here I want to have a
look at as well
because
what is a pairwise
difference it is just comparing in this
case subtracting
um every element with its neighbor
so if we take all the elements and we
shift them around
One Step rotate them cyclically then we
get the neighbor element and then the
first element becomes the last element
and gets paired up there as well
so instead of
explicitly
adding another element and then doing a
pairwise
difference we can just do a subtraction
which goes on the entire array with the
one step rotation of the right argument
so this is the rotation Function One
Step we take the first element and put
at the end so now the elements here
occur are the neighbor elements of the
ones over here
right
let's call this G
and we'll get to a speed comparison
between these two in a moment because I
want to go one step further
notice these points that we have
the reason we need to Loop over them is
because they are enclosed we have
vectors of vectors but APL excels at
operations on entire arrays we can make
this into a simple single array using
the mix function every Vector here
becomes a row in in a matrix
and now if we were to
um
find the neighbors it would be the next
row over so we can rotate this time
we're rotating vertically to get the
neighbors
and from here on everything would be the
same
so we can take
the mixed points
and subtract them from our points and
then we want very much the same formula
as up here
we're going to do the the squaring
and now we need to sum the rows so no
need to to any explicit looping here we
just sum and this goes along the rows
and so on the rest of it is the same
this gives it the same result the only
difference here is that we start off by
mixing so we get a single flat array and
then we do the rest of it of our
computation on that flat array
so we can give this a name
and this is an a top right two train two
function suggestions to each other
there's our main computation function
and then there is a pre-processing
function which just starts by mixing all
these points into a single Matrix of
points with one point in each row
okay now for performance comparisons
for that let's generate some test data
we can take 10 rows and two columns
reshape a zero
and throw in the random role function on
that that gives us a bunch of numbers
between
0 and 1 which is fine these are floating
Point numbers good for our our purposes
here
it doesn't actually matter what the
values are because whenever you're
subtracting and squaring sun it's just
the same operation
now the specification is that we're
getting a vector of vectors so we split
so before we're using mix to join
together vectors of x's into a matrix
now we're going to use the opposite down
arrow to split the Matrix into a vector
of vectors
and let's give this the name Q for our
quality assurance
but we should also not use just 10
points let's use a thousand points
right now we copying in the compare
execution tool copy that from the
defense
workspace Library
and then we give it expressions
to compare so we have F on the on the
points and G on the points
and H on the points
and let that run for a little bit to see
how we stack up against each other
and well that's pretty impressive isn't
it so just doing some cleanup work
not really changing anything in the in
how we're computing
that got rid of a good 20 of uh almost
80 leaving only 20 percent
left of the computation time and
therefore resources
but switching to doing things in an
entire array
manner by starting off with some flat
data not nested data that pretty much
eliminated all the work that we needed
to do
so bear that in mind you want to go fast
stay flat
thank you for watchinghi
this time we're going to compute the
zodiac sign approximately
we're given two numbers one for the
month and one for the day
it's given as a table on the problem
description website
but I've imported it here
I'm not going to go into how we get it
in there are various ways to do that but
know that what we have here is a matrix
representation of character vectors
which is exactly like the table is there
including some strange spaces that we
really don't want and we're going to
clean all that up
so our first problem is that while the
table is laid out for human consumption
it is not really very good for machine
consumption we can see that we've got
four columns but it's actually a
database table of two columns the sign
and the date range the date range as
well is formatted nicely for humans but
not really very nicely for computers
so we've got two columns that are
actually the same column
um twice
let's start by cleaning that up so the
First Column and the third column Belong
Together
and the second column and the fourth
column belong together so we're going to
permute The Columns of the table
now we want to get
the the cells in the table that belong
together
to be together in sequence because the
the reading order here if we just
flattened our data is Aries Libra and
then March 21st and then September 23rd
and then Taurus and that's awkward
but if we transpose our table
then the reading order has all the signs
first and then all the date ranges
now the only problem is that we have two
rows for each one of these I only want
one with of course 12 columns so
two rows and 12 columns reshapes this
transpose table
and now we've got two rows one with the
signs and one with the date ranges
another problem is that strangely this
table begins from March 21st and since
we're going to look for dates in the
Gregorian calendar that begins with
January then we'd want to rotate this
around so this is a
negative 2 steps
horizontal
rotation of the table
so the normal rotation takes elements
from the left and sticks them over on
the right now we're doing the reverse so
that's what the negative number is for
and now we begin with January
instead
it's a table and it's much easier to
work with this data having it separately
one list of signs and one list of dates
so let's split the table into two
vectors and we can actually see the
dates but they are out there to the
right and then we assign them to S and D
for the signs and the date ranges
like that here are the signs and here
are the date ranges
and now we can see that the signs have
some training spaces which we should
probably get rid of immediately so the
signs and then we're going to use
um
especially syntax let's first try to
remove the signs so we want to this is
the a set difference so without we can
read it as without from each one of them
a space
and that works this removes them but
this didn't update the variable and we
could assign it just to to S but
more fun is to use something called
modified assignment which is something
you see in other languages as augmented
assignment you might see things like
plus equals so you have some some
variable name V and then you increment
it like this or decrement it or have it
in APL we allowed absolutely any
function
on the left that function is given the
original value on the left and this
parameter a new updating value on the
right
and then whatever it computes is then
assigned to the variable
so in this case our function is a
derived function which is the without
each
function
and then we just stick the assignment
Arrow over here
and then this parameter is given as
write argument and the variable's
current value is given as left argument
and the result is put into that same
variable
now this has been cleaned up
next step is to parse the dates
we could go and pass the uh the month
names but we actually know that there's
one month for each so that's just the
range
um Iota 12 that's the integers from 1 to
12.
the only thing we should extract then is
the the day of that month and we only
want the first number in each cell
because it's actually redundant
information the last day of one sign is
the day before the first day of the next
sign and we're going to go with
beginning dates rather than end dates
so a really nice way to do this is to
use quad vfi
and this means verify and fix input
and it's called verify and fix where
verifying make sure that a token is a
proper number and fixed actually
converts that text to a number
and so we can try this with the first
one
so the first one of d
it's if we just run this by itself then
by default it splits on Spaces it uses
them as token separators so we can see
it saw three tokens here this generally
there's 20 and dash February and then
there's 18. and the very far part is on
the left and the fixed part is on the
right the very first part is a Boolean
mask saying that this token was invalid
this token was invalid and this token
was valid as a number and these are the
values with zeros substituted for
invalid values so we can see we only got
the 18.
however we can also tell
GFI to use one or more field separators
so we want both space
and N Dash as
field separators
and now if you try running this we can
see that it's split it up and we got
both the values 20 and 18 out recognized
as numbers and then there was the
February and the January that were
considered invalid tokens they're not
actually proper numbers
and since we know exactly what kind of
data we have here this is good enough
for us to parse it fully
we can then
well we can we can take it one step
further
um we know what this mask is going to
look like so we can ignore that and we
know what this one is going to look like
so we can just go in and take the second
element of
the second element
and we can do that with the pick
function
2 2 means go into the second element of
the overall structure and then inside
that go into the second element again
and that gives us the 20. now the only
thing we need to do is wrap this in a
little Lambda where Omega represents the
argument and apply that to each of the
that gives us our cutoff days of the
month
we can make this into a matrix
so now we have a column vector or column
Matrix single column and then we can
take those indices from 1 to 12 and
concatenate horizontally to that Matrix
and that gives us a lookup table for
where the cutoff dates are
let's call this
C for cutoff
so here is our cutoff table
okay
now if we have to come up with a
strategy for actually finding the signs
and if you look at our table again
then we'll see that
if we go and look for December here
the
we're going to end up with the end of
the year
here
being Capricorn
and that's that's fine that's the 12th
one but there's also a part of the
beginning of the year
which is a bit of an issue so any dates
before the first cutoff should really
end up with Capricorn as well
one way to do this would be to add
another element to our lookup table
another one is by doing a cyclic lookup
so we could use modulus and compute the
indices but even easier is to rotate
cyclically
like we did before and we we rotate
technically the whole
um the whole table of signs
and then
we can have indices or positions between
zero and 12.
so we'll we'll call it zero when we are
before the first
cut off date that is from January 1st to
January 19.
and then we'll call it one when we have
from January 20 and onwards and two when
we kept that and so on and then we have
the 12th one
when we have December 22 and onwards to
the end of the year
so this means that we want the Capricorn
to be in front because that's going to
be the zeroth step
and currently we have the signs arranged
with
Aquarius first
but we can do the same kind of syntaxes
before we do a rotation but rotate takes
the amount on the left and the data on
the right so we need to commute or swerp
the arguments negative one step
now we have Capricorn first
so if we have zero rotation of
of the signs
then we get Capricorn first and if we
pick the first one then it becomes
Capricorn
if we rotate it one step that is after
the first cutoff date
we get Aquarius at 12 or 11 let's do
that first
we get Sagittarius and 12
we're back to Capricorn
so this works really nicely
we then just need to do some lookups
into our table so here's the table of
cutoffs and we have something called
interval index
interval index it looks where do things
fit with every major cell or Row in this
case
being the beginning of a section so it
will look this something belong with 120
and further or 219 or further and then
this is the first interval here between
these two is called interval one before
the first one is called interval zero
and then the last one defines the
interval 12 which is exactly what we
want
so we can try it 223
interval 2. so this is this works with
lexicographical ordering meaning we
first we look at the first element and
then we look at the second amount which
is exactly what we want so 223 a three
it falls in here that's interval number
two
and we can try it with 10
31. the example K is given
that's over here now we can try it with
January 1st
you see we get a zero
so that's before the first one
so for a date like this
we can take this and rotate
the signs
and then we pick the first one
the remaining step is to make this into
a proper Standalone function
we will
we could put in an argument here
and then
wrap everything in the Lambda
foreign we could even save our
parenthesis by commuting the arguments
of the rotation
so this is one way to State it
or we could make a tested definition
where that's one where we don't mention
the arguments by name
instead we say that
we bind
as in fixed left argument two interval
index to the lookup we bind this lookup
table
and then we use that to rotate the signs
and pick the first one
that's another way to write it however
the reading order here with the swap
the arguments is not actually we don't
need to do this swapping because we
could instead write the rotation
and then use
the the sine Vector here but make it
into a constant function so this Returns
the signs
it gets rotated by the interval index
into the cutoffs so this is another way
that we can write it and now we can try
on each one of
223 and 1031 with this example cases
and we can try that with G as well it's
entirely equivalent
thank you for watchinghi
we're going to take a sequence of bytes
and cut it into pieces so each piece
represents
a single
code point or character
if we take this sequence of bytes to be
a utf-8 stream
okay so what exactly is it we mean by
this let's
have a sample text
so this is a normal d
and
this is a Yen symbol
here's an alpha and a down style circle
and a normal nine
if we look at the Unicode character set
code points for these
we can see that some of them have
relatively low values
some have
medium high values and some have very
very large values
and youtube8 is a variable with encoding
that means that when you have a sequence
of bytes that represents text each
character doesn't correspond to a fixed
amount of bytes
we can
ask
APL
to give us those bytes
and so we can see here that the number
of bytes is not something that directly
translates to what we have over here we
can see that the 68 is the 68 and the 57
stays 57
but that's where the obviousness really
ends the 165 became more than that and
then we have a bunch of numbers
representing these large values in the
middle namely in this case three for
each
okay let's call those the bytes
and then we can convert back again so we
can say utf-8
quad UCS on the bytes
that converted them back again
if we wanted
each character to become its own little
sequence of and of bytes then we can do
utf-8
we we bind this argument to the quad GCS
function and apply it to each so this
entire thing gets paired up in every
invocation of what GCS with each
character that we get from this
and this is the result that we want to
get to
given these bytes
the rule is
that when we have numbers here
that are larger than or equal to 128
and less than or equal to 191
then it is a continuation of the
previous byte so
68 is outside that range
194 is also outside that range so each
of these begin a new character the 165
is between 128 and the 191 so that
extends
the previous bytes to create a single
character then we have 226 that's
outside the range so now we begin a new
one but 141 and 186 they're inside the
range
and so they continue the previous one
and so on
it could be up to four bytes together
but we don't have an example of it here
it's mostly used
for emoji and and traditional Chinese
so how can we do this
well we can start by checking for this
range let's do everything here in tested
form that is without mentioning our
arguments explicitly we've got the bytes
and we want to do a comparison so the
upper bound is
191
we can bind together a fixed right
argument to
the less than equal function so it
becomes a new lesson or equal to 191
function then we can then apply that on
the bytes
really we
could keep going like this but it's
slightly difficult to see which bit here
a true false value corresponds to which
byte in the input
so
it would be nice if we could stack them
on top of each other to align things
and we can do that
by
making a vector of these two
and then we do what's called mix let me
change this Vector of vectors into a
matrix with two rows
as a notational nicety I'm going to
write in an operator a higher order
function that does this for us because
we're going to use it all the time
so if you look at the pattern here we're
going to call this operator with an
underscore because it will look nice
like this but it doesn't really matter
and we want the mix of the argument
and
a function
applied to the argument
that's all there is related to it
now we can go and say we have this less
than or equal to 191 function with this
higher order function we're applying it
on the bytes
now we have the stack here so we can see
that these are the byte values and these
are the corresponding bits so we can see
here that 68
is less than or equal to 191 194 is not
and so on
okay that's one half of the
of the by the the range the other part
is that it has to be greater than or
equal to 128.
and I like to put it on the other side
for this
because now we can combine this very
nicely as a fork so we have this
function so that has a magnetic function
derived from a diadetic function and
we've got this function which also we
say test it
and derived function from with diadic
function to a magnetic function
and we can make a so-called fork or
three train where we have a middle tine
which is the end function
this means that these two other
functions are applied to the argument
and then the middle function here is
applied to their results to get our
final result
and then our higher order function here
the the underscore operator Stacks the
original argument on top so we can see
what's happening
foreign
we can see that the ones here indicate a
continuation byte and the zeros indicate
a new character begins here but
but in order for us to use the partition
enclosed function
we need to flip things around because it
takes A1 wherever we want to begin a new
segment and a zero when we want to
continue a segment
but we can simply negate that with the
not function
now notice we have a not and we have an
end we can combine those into a nand
and this shows us where we begin a new
character
and the rest are continuation bytes
then we can take this
and use it as a mask for
cutting using the partition enclosed
function but the position in close
function takes its mask on the left and
the data to be cut on the right here we
have the mask on the right and the data
with the identity function on the left
so we use the partition in close
with the higher order functional
operator commute
that modifies this function to take its
arguments in the opposite order so the
grouping here goes like this we
start by binding these two
together to create magnetic functions
rather than applied to the arguments the
results are
combined with a nand function that
becomes the well left argument to
partition in close and the identity
function's result becomes the right
argument to partition in close
so this doesn't make sense to do the
stacking anymore so let's stop doing
that
and now we have the solution to the
problem and we could give this a name if
we wanted to
and then we can apply that to the bytes
however
this looks a little bit messy
we can use the Morgan's laws which is
these laws of formal logic that allow us
to manipulate and
the an expression
by knowing that and an or
duels under not to each other what that
means is that if you negate both
arguments and negate the result then you
get the other one
so if we instead of using end we then we
want to negate the result so that gives
us end and then we switch to an or now
we just need to negate the arguments so
what is not less than or equal to well
that's greater than and what is what not
less than equal to that's greater than
so we can write it like this as well
so these are this is one approach to the
problem
another one is you notice we're looking
into ranges
we have
a function called
interval index
it gives us the index of the interval
where a value Falls given some cutoffs
so
the cutoffs are left inclusive that
means that if we have 128 and
191 then 191 will belong to the next
interval we want it to be in this
interval so 192 Begins the next one that
means everything from 128 to just before
192 is in this interval here
and there's one interval on the left and
there's one interval on the on the right
so we bind this to the interval index
function
and this gives us the interval numbers
but let's use our underscore utility
here
to stack things and see how it looks so
now we can see that 68 Falls in interval
number zero that's on the left
94
for 194 falls on 2 that's to the right
165 Falls in between the two that's
interval number one
remember that we want ones where we have
0 and 2 because those will start new
characters and zero where we have a one
that means
all we want here is to know whether or
not these indices are different from A1
so one is different from then it is zero
or two
and this gives us our argument for
partition in close that we can then use
on the argument and remember to get rid
of this utility
and that gives us the same result
we can give this function the names as
well and apply it on the bytes
so this is a different way to do it
thank you for watchinghi this Quest is based on the game Risk
if you're not familiar with the game
Risk then I suggest you pause the video
right here and read through
this now we are going to generalize the
rules of dice throws in risk and so we
have two integer
vectors and and uh the left one is the
attacker and the right one is the
defender and we have to find out how
many armies the two players
lost so we're going to have a large
example where the attacker attacks with
five armies as if that was allowed and
throws five
dice
and the
defender uh defends with three
Dice and so uh we want to find out how
many uh each player loses so we can see
here that uh the attacker matches over
here so the attacker
loses and
then the attacker has more than the
defender so the attacker uh wins that
means the Defender loses and then the
third one the attacker has less than the
defender so that clearly uh the attacker
loses an army here so all in all we only
considering the first three the attacker
loses two and the defender loses um this
one now let's compute that um the rule
is that the attacker wins if uh the dice
show if the attacking die shows more
than the defending
die uh we giving given our um throws
here already sorted so that makes things
easier but we need to take care of this
discrepancy in length potential
discrepancy in length between them um
and it's an inefficient but elegant way
of doing this is to Simply compare all
values so this isn't out of product it's
not really a product it's really a
comparison we are comparing all the
values here with all the values over
here even though we actually only want
the corresponding values
compared and that gives us a comparison
table and
where uh we have the rows here
correspond to the six uh and six and
four 2 1 and then the columns here
compared to the uh six five and five and
so we can and this is one for true and
zero for false so we can see here that
uh this is the right comparison with the
six and the six and it's not greater
than this is the six and the five it is
greater than and this is the four and
the five that uh is not greater than so
we want the
diagonal um and we can get the diagonal
in APL by using a transpose a
generalized transpose so a normal
transpose
um that just flips the
axis but the generalized transpose we
take a mapping as the left argument to
the to the transpose function and we can
say where we want the particular AIS to
go so uh if I want the first axis to
become the first axis and the second
axis to become the second axis that has
no effect if I want the second axis to
become the first uh the first actually
to become the second one and the second
one to become the first one um then we
get that normal
transposing however if I M both of them
to the same axis that means as we
Traverse this
array and instead of traversing first uh
along a a major uh the major a leading
ax the rows and then along uh The
Columns every time we take one step down
we also take one step right so
essentially we're collapsing the two A's
into one and taking the diagonal between
them and that gives us this diagonal
that we were looking for now this is uh
who wins but we're actually interested
in who loses so we want the opposite of
uh the greater than Which is less than
or equal
to okay now we want to know how many
there are so really what we want to know
is um how many ones are there and how
many zeros are there because the on
indicates that the attacker lost and the
zero indicates that the uh Defender
lost
and we can do this in in various ways
and you can see the uh description for
this video to go to the chat the event
that happened and it has other ways to
do this but I'm just going to show you
uh one way to do that here I'm going to
make this uh list this Vector into a
column and then I'm also going to negate
it and I'm going to concatenate them
together so this is a function
of the result of uh this function where
we're taking the uh colonized form and
concatenating the negated
form so this column represents the
attacker's losses and this column
represents the defender losses and now
we can see all we need to do is sum The
Columns and that's exactly what we're
going to do with the leading first X's
uh plus reduction
and that gives us 21 which is exactly
the result we were looking for so we can
take this whole
construct give it a
name and then we can go in and
substitute it in here then the whole
thing reads a little bit
nicer thank you for watchinghi
we're going to simulate
casting dice
and then figuring out how many different
ways of each total result there are and
then
drawing a diagram
that shows the frequency for each one
so first let's start by throwing the
dice and this is actually interesting
because we can think of the dice throws
as
um indices
so each die represents one independent
dimension in the full
set of possible outcomes
and so if we have three dice then each
one of them can contribute with a
magnitude along that its own dimension
which means that throwing dice is
actually the same thing as creating
indexation vectors and if we want to
make all the different possibilities
that's the same thing as creating an an
index a temple of contents of an array
that has the dimensions of the number of
sides in the dice
so for a normal
six sides then the Iota function which
generates indices does exactly what we
want
so there are six possibilities the
numbers from one to six and if we have
two days with six signs each then we can
get this collection which is a
six by six
array of Two element vectors into the
space
each Vector representing an outcome
and then we can sum each one so this is
a plus reduction on each
and that gives us all the outcomes as a
two dimensional array because there are
two dice and if we do this with more
dice then we get a whole lot of numbers
like this in the Scrolls by
Let's uh try instead of normal six-sided
dice to have a two-sided die that is a
coin flip a three-sided die that's a bit
difficult to build but it can be done as
a kind of weird Twisted piece of
something that can land in in three
different ways
um and then
a uh
we can even do a six-sided normal die
yeah
so here we see the uh the full space
it's a two by three by six array and
then we have summed all the
um
the numbers and these are all the
outcomes which means we can Revel this
that is remove the shape we just get a
flat list back and that gives us this
very long list of possible results and
since that we start off with the lowest
possible value and then we increment by
one going along the
um at the
in the Revel order that means we already
have our possible outcomes in sorted
order we'll never get a smaller value
after we've gotten a larger value
therefore and we can take this and throw
it at the key operator it's a higher
order function that takes an operand
that is a function in this case we'll
write it as a Lambda and it calls this
function
as many times as they are our unique
elements so we will call it on three
four five six seven eight and then
eventually a 9 and so on
up to the top value
which is 11.
and for each call it will give a left
argument represented by Alpha and a
right argument represented by Omega left
and right most
elements or letters in the Greek
alphabet
and the left is going to be the actual
value and the right is going to be the
indices where that occurs so we can see
that we here have all the outcomes and
we and here the indices where this
occurs are 300 occurs in the beginning
four appears in position two and
position seven so we can see the second
four over here and also position 19
is the one over here
but we're not actually interested in the
indices themselves we just want one
asterisk for each index and we can write
that by
taking an asterisk and making it into a
constant function and applying that to
each
index
and that gives us
um
our
possible outcomes for these three types
of dice and we can try and try this for
two six sided dice then we get this
and for a single die we yeah that's just
one outcome for each possibility
however this has an issue and that is
that we in the process
of
Computing like this we
have
created an array of the number of
dimensions of the count of the dice
um
and this is problematic because there is
a limit in dialect APL to the number of
Dimensions you're allowed to have in an
array which is at 15. so if we have say
16
coin flips
so this is a reshape so we're reshaping
two into length 16. then
we can see that the result array would
have too many dimensions and that's not
allowed
so we need to solve this problem in a
different way
so how can we do this
we can still think about it as indices
into an array
but this kind of
um indexing
is also a mixed based system actually or
in this case if they're all the same
that's the same base system what does
that mean it means if we look again at
this array then we can see that it's
like a number system where we're
counting up we start one one one one one
one two so this is the the ones place
and this is the sixth place we can see
once we reach
um
to the end here after the six so this
corresponds to
a digit zero a digit one digit two and
so once we reach the digit five then
there are no more digits in this in the
ones place because it's the final base
six and then we continue
by incrementing the next number over so
this would correspond to the number one
zero in base the mixed base two three
six so this looks a little bit funny
because we start with index origin one
but if we subtract one
notice API uses a high minus for
negative numbers
then we can kind of see the numbers as
they progress so zero one two three four
five and then one zero
one one one two and so on
um
and over here we can then by the time we
get to 2 5 then since the middle one
only has is is base three the digit is
only base three we need to progress to
the top digit which is not the hundredth
place but rather the three times sixth
place that is the 18th Place
and then we progress to that and this is
the last number before we need to add
one more digit
Okay so
how many are there here remember how we
did the the sum reduction
um to get the the addition reduction to
get the sum so two we can do a
multiplication reduction to get the
product
so there are 36 possibilities
um when we have
a specific ordering of the dice here and
we have to because they're all set
different here
and we can generate all these numbers
again we need to subtract one
and now we just need to express them in
this mixed base
so we can say two three six
encodes so a base looks like this or
this evaluation in a base and this kind
of looks like a t so it's
it's converting to that base so we're
taking these normal decimal numbers and
we're converting to the mixed base 2 3
6.
and that gives us this one number per
column notice that so this is number
zero number one number two and so on
then we get number one zero in base two
three six and so on
and here we never exceeded rank two we
are just dealing with low uh rank arrays
and it's also beneficial because we
don't have this array of arrays a
multi-dimensional arrays of little
vectors we're keeping everything flat
and that's going to be a much more
performant
now that we have this we need to add one
back again because dice they start with
one two three and instead of zero one
two
and then we just need to sum vertically
so we're using the plus but this time
we're using reduction with a bar on it
which means we're reducing vertically
actually along the leading first axis
it gives us all our outcomes so this is
the same thing that we had from before
with the reduction on each of
the indices of an array that has the
shape 236
where we then Ravel them so we can see
that
this is the same but this time without
any issue that if we try to use 16
coin Flips For example that just works
no problems there
okay
then we can go in and put in our
function from before where we use key
left argument and an asterisk constant
for each of the indices
and then we can see we get some huge
thing for for this very big conflict but
it works
um and if we try to do this on our 236
case
we got the nice curve from before if you
try to do it on two dice
then
um
oh this uh what is the problem here this
doesn't quite look right
um that's because we're using we should
go back again try this one this
constantly appear we need 16 reshape two
over here
there we go that's better of course if
you have 16 coins and they they both
contribute
um one and two then the Lower Side you
can get there's one for each one so
that's 16 and then going out from there
and then and we can try our six six case
have a six six over here
um
there is but one little problem
and and that is if you only have a
single number here then
expressing it as in the base here is
going to just give us a flat Vector but
we want to explicitly make this a
vector rather than a scalar which gives
us a matrix and it doesn't actually look
different but it will make a difference
when we use the key part so this is
correct whereas if we didn't do the the
Revel into
a vector from a scalar then we get a
rank error
so that's important and there are
different ways we can we can do this but
now let's make this whole thing into a
proper function
we put bases around it substitute an
Omega for the argument
and now we have a function that we can
use and that doesn't hit any issues with
the maximum rank
and it works as well on
a scanner
thank you for watchingwe have to find the longest run of ones
in a Boolean vector or scalar let's keep
that in
mind so let's first have some sample
data and here we can see that we have a
run of length three of length two and a
run of length four so that will be the
answer
four um let's make a Anonymous Lambda we
can always name it later and take the
argument s in here we refer to the
argument as
Omega and we can go directly and cut
this into pieces well there is a
petition function which takes a mask
like this on the left and some data on
the right corresponding
length and it keeps uh runs of that
correspond to ones and it discards any
elements that are that correspond to
zero and then begins a new Partition at
that point it doesn't really matter what
our data
is so we can use uh the same bu and
Vector for the data and as the
mask and then we just need to uh count
the length of each one so this is the T
mark appli to each mapping over
those we could also State this argument
only once by using the selfie operator
or commute so this derives the new
function that's the same as this one but
takes one argument and uses it as both
arguments of the original okay next step
uh then is to take the maximum and that
is
four there's one tiny issue that is if
there aren't any runs of uh of
ones then then this gives us an empty
list of lengths and a reduction a
maximum reduction over an empty list
should give us the identity element
that's the argument to the maximum
function that will not affect the
outcome for any other
argument so that has to be the minimum
representable value and what we're
seeing here is indeed the smallest
possible
64-bit uh binary
float
so how can we fix this well we can make
sure there's at least one value at all
times so we just inject a zero in front
of
that and then it
works however injecting a zero this
seems like a simple thing it actually
can have an impact on performance so
let's
first um give this a
name and then we are going to import the
compare execution facility from the
defense
workspace let's generate some Boolean
test data so we want it to be in the
range of two we want there to be 10
million elements of those and we want
them to be random and then we get random
ones and twos but we actually want
booleans so we compare them to a one
that gives us so the ones give one and
the twos gives give a
zero
and then let's think about how we can
solve this problem a different
way the problem is that
um this is a potentially very long list
of lengths and when we inject a one uh
one element at the front a zero then
even if we were able to do the
transformation in place in memory we
would have to move over every element
one step to the right that's a total
rewrite of all the data and a
potentially expensive operation compared
to everything else that we're doing so
if we didn't do that then we could end
up with this very large negative
value however any other uh argument to
the maximum reduction would have
positive values in it that is if we have
runs of ones so what we can do is we
take the maximum of the result of this
maximum reduction and zero if it's a
very large negative value we get zero if
it's a positive value then the zero is
not going to affect
it how big of a difference does this
make well let's try it we apply F on
this Boolean and G on the
Boolean and we wait a moment to
see which effect this has that's about
twice as fast for 10 million elements it
will vary according to how many elements
there are so this is definitely Ely a
good
technique that said we went as we can
see here in the top left corner by a
nested array that was strictly
unnecessary we
could compute the lengths of runs of
ones directly rather than actually
generating pieces that have these
lengths and then measuring the lengths
so how can we do this let's start over
with our sample
data and have a
think if we can find the location of
beginnings of a
run and we also find the locations of
the ends of the
run then if we subtract the index the
location of every beginning from its
corresponding end that will give us the
length so
how do we do this let's go to our to an
anonymous Lambda
again and we want to compare adjacent
elements if the left element is less
than the right element and the whole
domain is just zero and one then we know
that we have a zero and a one and that's
the beginning of a
run so we can do a two wise less than
reduction of the
argument
and that gives us the indication where
we
have this run and this run why are we
not finding the first one that's because
we never went from zero to one there's
no zero on the left but we can inject
that okay and similarly if we had
been let's go let's go look at the uh
the
ends and this tells us that we we have a
um the end of a run at uh coming up to
this zero at the end but of course let's
say there was no zero at the
end then we would fail to find the
end so let's put in a additional zero
over
here okay so with this we have our
um
ends and we also had our
beginnings now we just need to convert
these Boolean masks to be
indices and we do
this with the indices function or
where so this gives us the
beginnings and uh this let's change that
to the S again gives us the ends and if
we just
subtract the corresponding elements then
we'll get the
ls oh yeah it has to be the opposite
order of
course want to
subtract the beginnings from the ends
there we go of course this has a lot of
duplicated effort we are uh generating
this zero followed by the argument
followed by zero
twice there are a couple of different
ways we could uh we could solve this but
actually a neat way is to start with
somewhere else we are doing a
subtraction and we're not subtracting
these masks we are subtracting the
indices of the ones in the masks so
that's the same thing as subtraction
where we pre-process both arguments
using the indices and we have a higher
order function function an operator for
doing exactly
that so this isn't any shorter overall
but it will help us later um so this is
a subtraction of the indices that means
we don't need to explicitly compute the
indices over
here and now we can see that this is
lends itself nicely to a fork because we
have a shared left
argument and we have a shared right
argument and the only difference here is
we have two functions being applied the
lesser than reduction and the greater
than reduction So This lends itself very
nicely to the fork construct so let's
remove everything
here and
this now we have a right argument a left
argument two functions that are being
applied and the result of those become
the arguments to the minus that
pre-processes its arguments with finding
the
indices
and from here on it should be simple we
do the maximum but we also want to catch
the zero
case so we do the zero maximum like
before otherwise we would have the same
problem and um performance issue if we
inject a zero in the data
itself let's compare these two
approaches
then so we had uh
oh did I just overwrite this one let's
go up and rescue that one it's this one
and this one should be called
H and now we can compare our
fastest of the original algorithm which
was G on B and this one h on
b wait a moment to see so these are the
two approaches of uh creating runs and
measuring the length
and Computing it directly from the
indices and we can see that makes a huge
difference so that was a nice
Improvementhello and welcome to this fourth apl
quest check apl wiki for details
today's quest
is called keeping things in balance
here we take a character vector
and
it has parenthesis in it
we need to check whether the parentheses
are balanced so it looks like a normal
mathematical expression or
whether things are wrong say we begin
with closing parentheses that aren't
there or we end with some open
parenthesis
let's get started
let's start by
having a test
data just to see how this works
so we create a character vector
and let's put in some expression there
for example
something like this
okay this is a balanced one
and the approach we're going to start
off with today is that we're going to
find out where the depth of the
parenthesis nesting changes
and there are a few different ways we
can do that then later we'll move on to
actually
finding out whether or not the
parentheses are
balanced or not
a very simple approach and a classic one
in apl
is to convert
the input
into a normalized form
so
we can look up
every character in this test case
the indices of its characters in the
open plan and closed paren
and apl does this that if an element
isn't found in a lookup array then we
get the next index so one and two are
the open and close and three is any
character which wasn't found
now we need to map these
to indicate when the parenthesis level
changes
so
and we
use this to index into
a vector
and we say when we have open parenthesis
then we increase the parenthesis level
when we have a closing
pan then we decrease the parenthesis
level and any other character we map to
zero as it doesn't affect the level
let's stack this together with original
input so we're going to
mix
the concatenation of
the enclosures
with the original
and we can see how when we have open
parenthesis the parenthesis level
increases closing parenthesis decreases
and any other character leaves the
parenthesis level unaffected
so we can make this into a function
let's call this the
parenthesis
depth changes
using indexing
and so it's going to take this formula
but there are other ways that we could
do that you do this
we can in a similar manner
but instead of lookup we can do a
comparison so if we take the character
vector consisting of these parentheses
and do an outer product
with the characters here we get a table
and we can do the same trick as before
to stack up
on top
oops
oh it's a
yeah
that's not what i should have done i
increased the rank which is just
sticking up it's already a matrix there
we go
and we can see here that
the
first row of this boolean matrix
indicates whenever the parenthesis level
increases and the second row indicates
when it decreases
and then the other row is of course zero
and then we can do this clever thing
that we can subtract the top row
from the uh subtract the bottom row from
the top row so the top row minus the
bottom row that's a vertical minus
reduction
and that gives us the same thing now we
need to stack them on top of each other
there you go
all right now we get the same thing as
before so this is a different way of
doing it
and we can call this the parentheses
depth
changes
uh using the outer product over out of
product
um so we can we can even do this as a as
a tested function because it's so simple
and the argument is just the identity
right there
okay but there are more ways we can do
this we can also do the two comparisons
each by themselves
so let's say we take
the comparison to the left
parenthesis
and the comparison
with the right parenthesis
and put them next to each other that
gives us these two vectors we could of
course stack them on top of each other
and then we get just like the other
product but since we're going to
subtract them from each other we can
just put the minus in between and that
gives us
the parenthesis depth changes right away
we can
give this a name and we can again make
it into a tested function because it's
really simple
so we can and it looks very nice as well
symmetric like this so we can bind
this to
equal making equal
equals and left parenthesis
in a magnetic function and subtract
the same thing we can we can put the
because equal is computed so we can put
the argument on either side i'd like to
put it like this because it looks really
cool
so this is the depth uh using a fork um
with the two outer tines equality to the
two parenthesis and then subtracting
the
the two from each each other
um now this is on a tiny little test
case let's get some real data that we
can try this on and then let's do some
performance comparison before we move on
to the second part of the problem
because we haven't solved the whole
thing
yet we need to find out are they
balanced or not
so for that
i'm going to copy in some functions from
the defense workspace and we're not
going to use these functions other than
just their source as example data so
there's a turtle function there's a joy
programming language interpreter
and then we need the comparison and
performance comparison
as well we copy those from defense
right and
they are large functions these turtle
enjoy but not really large enough so
let's create some data we have some data
i know that uh turtle has parentheses
that are well balanced and joy has
parenthesis that are not well balanced i
looked that up before um so this gives
us these two test cases let's call it
yes and no and whether or not they are
balanced
um i'm going to
take the source code of each one
so the vector representation
of each
of turtle
turtle and joy
and then i'm going to make them a little
bit
bigger so we're going to take that
source code and reshape it using 100
times its current shape
and this gives us
some
large test data we can see here that
y
is a bit a bit of a million and
um
n is a couple of million
so now we can compare them but instead
of typing out the expressions with these
three different functions let's use an
apl expression to generate the
expressions that we're going to time
a little bit of meter programming here
so every function begins with a d
and we concatenate that to each of these
suffixes i o and f
and then we concatenate each of those to
the entire
argument y so this gives us
these three expressions
and we can run cmpx on those
and we can see that the df
the one that just that is the fork just
compares it to one parenthesis and the
other parenthesis and subtracting them
is by far the fastest one for these
cases and what if we do it on something
that isn't balanced
and again um interestingly enough here
the i and the o are approximately the
same speed but df still wins out
so this is the first part of the problem
determining when the parenthesis level
changes goes up and down
next we're going to use this
to compute whether or not they're
actually balanced or not
so we can use df that was the fastest
one on our test case that gives us
these ones and zeros
and now
we have to think about what does it mean
that it's
balanced
so
there really two things to it one is
that when the whole input is finished
when we reach the end we have to reach
down to parenthesis level zero
and when we
go along we're never allowed to dip
below zero because that would mean that
we have closed more parenthesis than
we have opened
so we want the
running total the the
of the parenthesis depth that's very
simple we can do that with a
with a scan
and this is then the parenthesis
parentheses depth
and and we also want to know what is the
um
what is the left element whether or not
it is zero that would be the sum
of them and that's zero so now we can
just put together these two
conditions
the first condition being
that it is always true it's true for all
that they are greater than or equal to
zero in the running sum
and also
it has to be true that 0 equals
the full sum
let's give this a name and we'll call it
ba
because we're using this and condition
both this condition has to be true and
this condition has to be true
but we can also do it a different way a
little bit more succinct
at least the first part
if we're saying it has to be all true
that's the end reduction that all of the
elements
have to be
greater than or equal to zero
now the parenthesis level can only
change by one step at a time there's no
double open parenthesis there's only
single open parenthesis and they can
only
go down one level so the first condition
which is to check that we never reach a
negative level
it would have to pass negative one in
order to become negative it might
continue further on but it's a
sufficient check
to see whether or not we have any
negative ones
so we can say
negative one is a member of
the running sum
means it's invalid
and the second and then so now we're
doing it in reverse we're using a
negative conditions and similarly we
have to say that
0 is different from
the sum
so these are things that are not allowed
to be
to be present
and therefore if neither of them are
present
then our expression is well balanced so
instead of having an and we have to use
a nor
so we can call this
balanced using nor
let's compare the performance of these
two and similarly we can create the
expressions that we want so
we start off with uh
ba and bn we could
we can just spell it out since the only
two of them
bn
um and each one of them concatenated to
the entire
yd here uh so we have we haven't
assigned this yet
we should go up and
assign this
so this is the depth
for
y
and we should do the depth fun
for n as well
and then we can get these two
expressions
and cmpx
on that
and yeah it's about the same
you can do the same thing for the nose
and that's a bit faster
and we can probably reason our way for
that
because
in ba
we
did the comparison of everything
in the running sum and then we check
whether they're all true
whereas
in bn we're not doing any comparisons
and
for we're not doing comparisons for all
of the elements we just start looking
for negative one and as soon as we hit
any negative one we're done so the
membership function will just terminate
right there it doesn't have to look
through the entire array so in some
cases that can be faster
and so here bn
in some cases can be faster than
ba and that means we can potentially put
together a whole
solution here
based on these so we take
df from before
and
we
supply its results to bn and that should
give us
the answer and so we can do
f on each of y and n should give it one
and zero and that worked we can we can
also spell it out
um
so
but
we'll come back to that
because there's one more step we can do
let's go back for a moment and think
about what we're doing
the running sum
and the full sum
you can then observe since we're adding
the elements from left to right that
means that the last
element of the running sum
is equal to the the full sum
and so we're actually doing a little bit
of unnecessary work we're summing twice
one once we're summing a cumulative sum
and the other one we're summing
everything again so the last step of the
cumulative sum is the same thing as
doing the entire sum it might drown in
the mass of the cumulative sum but still
it could be a little bit of performance
gain
so being that we found that bn was the
fastest let's rewrite that and so to say
break out
the
scan and just pick out the right element
from this scan the cumulative sum
instead of using a new reduction
so let's break out the scan here
um and we do that
put the scan outside
and that means that the
um
this scan is already just
the identity
but since we now have just a single
argument with a dyadic function we can
just glue those together with a bind
operator
and then we have zero is different from
and this
is the last element so the last element
of the
of the scan we can also just write that
as a right reduction
so this is bns
and now we can try to compare them
so we can say we're looking at
bn
and
bns
each one concatenated to
the yd
and we got a bit of a speed up there
and we can try it again with nd as well
and we got a bit of a speed up there
again
so while it's not all about performance
this was fairly easy to to
go from one solution to another and you
got better and better performance
so
we can put all of this together
and a final solution
we define f
and then we take the definition from b
and s here
and then we also want
the
parenthesis
comparison
like this
this was the df
now there's one problem we want to apply
this function which is
a fork and then we want to apply this
function which is at a top and this
gives us sort of say three parts it
becomes would be a fork and we would
call this the adequately
the scan that's not what you want but we
can fix this by taking the scan
and moving it
to
be in the top on top of the
um
of the subtraction
and now we have a fork as the right part
where we have uh the two comparisons and
then the scan of the subtraction as the
middle time so the scan post processes
the
result of the subtraction
and then we feed that over to where we
extract the
nest element so we can check that it's
in non-zero and then we can
and also we look whether or not there
are any negative ones in that and then
we do the nor at the end and that is our
solution so this is a really good apl
solution
to the problem
and that's what i would use
now that that's done let's look at some
alternative solutions that are not going
to have good performance but they're
interesting to look at nonetheless
something that would be nearer to many
people especially if they come from
other programming languages and
especially if they come from pearl is to
use regular expressions
and we can do that as well so let's go
back to our test case here and observe
it
we're only interested in the parenthesis
so we can do the set intersection
with parenthesis
just to get the structure that's the
only thing we're interested in
and now we can go in and remove pairs of
parentheses
so here's a set of parentheses with
nothing in them here's a set of
parentheses or nothing in them here's
another one
and then repeat the process until we are
done and if there's nothing left
that means that they've been balanced if
anything is left any parenthesis is left
hanging whether it's opening
at the at the end or closing at the
beginning then it's
unbalanced and that means if the result
of this repeated transformation is the
empty character vector that means it's
balanced
okay how can we define this
so we start off by applying the function
of
intersection
with the parenthesis
and then we can write a regular
expression
now we have to escape the parenthesis
and replace
with nothing
so we can apply this on our test case
and then we can see it removed the first
parenthesis and the last parenthesis and
the inner of the middle parenthesis
and then we just need to do it again
and check whether or not
it is
the empty character vector
we don't know how many times we're going
to do it
therefore we have to say that
we are doing it until nothing more
changes
also known as power match
so applying it until there are no more
changes
and that allows us to do we can try this
and
but it's probably a bit much to do it on
the large case well we can try it
oh that worked okay and we can do it on
the uh on the last case of the no as
well and you can see that that worked so
let's call this
regular expressions
and we can just put it up here
that's our regular expression solution
this is not going to be performant for a
apl but well
oh i missed
missing the right argument
that is because oh yeah of course this
is because this is a magnetic function
we want to apply to our argument and
this is a magnetic function we want to
apply to our argument we need to glue
them together to become a top
right there
but regular expressions are very
expensive we have to spin up an entire
regular expression engine and possibly
transform our input to a format you can
understand and get the result back
collect the information extract
information from there we can actually
use quad r it's a fairly new feature
that was added to use quad r it's for
replacements of plane
text from this character vector to this
character vector as well
and we do that
by applying the variant operator where
we switch regex
off
and now we don't need to escape the
parentheses anymore because now it's
just plain text replace from these two
parentheses to nothing
so let's call this well it's not really
regular expressions anymore it's replace
but well
no regex i guess
however
keeping this method in mind we can also
try implementing it in apl and that
might give even better performance
so
now we have to think a bit
we have to find
places where we have an open paren and
close brand and then remove those
well let's look at our test case
we can easily use the find function to
find a oh find we need to remove the
all the characters that are not
paranthesis first
so let's take this and
compare
with this
you can see how it matches every place
where we find open brand close brand we
get a one bit indicating so
however our problem is that we want to
find
to to remove those parts
so we need to indicate
also
where
the closing parenthesis corresponding
closing parenthesis is
let's space this out a little bit for
readability
and what we can do here is we can do a
rotate
so we can do
both this mask that we just computed
and
or when it's rotated one step
and this indicates both the opening
paren and the closing paren
but we don't actually want to preserve
those we want to get rid of those the
way we do that is just by flipping the
the or to a nor
and this gives us a mask indicating just
the characters that we want to keep
so
now we
can say we want
this
just the the text that has the
characters
from an open print close paren
and then we
glue this together so we have a function
here and then negative one and that puts
it all together and we then we can
filter it using that
so that gives us this now it's not
useful to look at
the original anymore
and then we just need to repeat this
process over and over but we don't need
to repeat removing the parentheses
everything that's not parenthesis we
just need to repeat this squeezing of
away open paren close paren so we can do
the same thing with
power match again and then
we can compare
to
the empty character vector like that so
we can put all this together here we've
got
we can actually put it
atop and glue this together again
and this is using find
so we can try
uh find on each of y and n and it gives
us one and zero so now we basically
implemented the same transformation that
we used regular expressions and then the
quad r just for text replacement and
we've now implemented that same
transformation in raw apl
we can do
a comparison
of the performance of these so we have
re
and re0
and fi
and we're comparing them to
y
so
and we can see that
the regular expression engine it takes
is very heavy weight it's much faster to
do it either with replace without regex
or implementing it ourselves
and we can do it on end as well
and a similar thing so
it's probably easiest to implement it
just with the
text replacement that's built in
but if you implement it yourself you can
get a little bit
more performance right there
and finally uh some kind of joke
uh solutions that we can kind of
circumvent the problem because this kind
of parenthesis matching is already
happening in well in mathematics in most
programming languages as well when apl
evaluates an expression it has to do
this kind of thing as well
um
such an expression as this can of course
be evaluated as apl
if our parentheses don't match
then
april will tell us that there is
unpaired parenthesis
that means
the apl interpret itself somehow has
this
same functionality built in and we can
leverage that
and the same thing happens we if we use
braces that are not
in in defense that are not paired up
correctly then
ap let's tell that they're unpaired
braces
let's see how we can abuse this
we can start off
using the braces
and doing the same mapping as we did way
in the beginning mapping to 1 negative 1
and 0 and here we'll map the input to
braces instead
so we look up the in open and close
parenthesis
and then we use that to index into open
and close phrase and a blank
so this gives us an expression
which doesn't do anything useful it
won't be able to actually run
but apl's parser will protest if it
doesn't look right
how in order to force apl to actually
use this function we have to
execute it and that returns a function
with a strange display form that's not
very interesting
the only thing we want to see is whether
or not this errors are not
now if it does error then we can catch
that error if it doesn't error we need
to apply this function in a way that
won't error
and how can we apply a function that's
completely meaningless and doesn't do
anything it will just result in the
value error
well
we can take this function
and reuse it to reduce over a scalar or
one element vector reducing over a
scalar doesn't change that scalar at all
so apl will never actually use the
function it just registers that it's
there and will error if the function
doesn't work
so
this should work fine and if we try to
do it with an expression that doesn't
work like what we did before
then we should get an error
so the only thing that's left here is to
transform this into a function
we wrap it in a in a defend put in an
error guard
if we get any error
then
it's not balanced and otherwise uh we
it's going to reduce over the one and
reducing one doesn't change the one so
that's the one that we want for result
so this uses
nesting
depth of defense
we can try
try this but i think we'll run into a
problem that the test case is just too
big for the parser to to deal with
yeah this isn't working
why isn't this working
given giving the wrong result
oh yeah of course um i know why it's not
working because the test is cases are in
fact too big so let's just try it on
the
vector representation of turtle
and joy
okay now it's working um the the reason
is giving it a zero is because the error
guard is catching the air condition that
the expression is too complex for apl to
parse
so this is working
um
and here's another approach using
stranding
of parentheses so let's say we take
we start off the same way
by extracting just our parentheses
and then we
concatenate a one in front
of each character
and we also concatenate a one
in front of everything just in case
the expression is empty
and now we should be able to to run this
we can we can execute this in apl it
gives some nested array
but this will force apl to check whether
the parenthesis level is uh working so
we just need to we can format it to
flatten it
um and then we can we can try executing
it and then we just need to see whether
or not that will work so if we hit any
error return a zero
otherwise
we
ask for the first element of this which
is of course going to be one because uh
we should maybe flatten it as well
just in case it's nested
because it's all once everywhere and
this is using nesting depth of
parenthesis to parse this and we can try
it
and what we had before
so this is for joy
and it's okay and for turtle
oh this is not right
this is not working
so
see here oh of course we put a t here
instead of putting an omega was silly me
okay
turtle and uh joy yeah so those you give
the correct result and of course the
performance of this is going to
absolutely hurt i'm not going to bother
you with this these are just some fun
solutions of abusing the system
thank you very much for watchinghey this Quest
is
to take arguments that would be
arguments to the dyadic transpose
function
and see if the left argument is valid
given the red argument
I have prepared some test list arguments
and some tests write arguments
we can use the example function that is
outlawed
to try these out
What's Happening Here is that we have a
Lambda a function
and we set up an error guard that says
if any error happens then we return 0
meaning it's an invalid left argument
otherwise we're going to return one we
do that by actually trying to do the
transpose
discarding the result and then returning
one so if this works out without giving
an error then we return one
and so we can see that
um in this two by five table of test
cases
the entire top row are the ones that are
valid and the ones at the bottom row are
invalid now the actual content
of
the right argument and even the size of
the
or shape of the right argument isn't
irrelevant the only thing that is
relevant is how many dimensions it has
and that has to match up with the left
argument so let's try putting these next
to each other
we put the left arguments next to the
right arguments but we are going to take
the
shape of
the right argument
oh sorry it should be the shape of each
one of the red ligament here we go
okay
so
we can see here that in order to be
valid
then the left argument must have the
same number of elements as the shape of
the right argument
so that's one Criterion the other
Criterion is that the left argument
must enumerate X's that we want to map
the existing X's to and the X's had to
be consecutive counting up from one but
in any order and we allowed duplicates
so we can see some example of valid ones
this is of course just a permutation
Vector so here we're just changing the
order of the X's
this one we are mapping two x's the
first and the left axes to X is two here
we asked we are mapping both X's to a
single axis
down here
this is almost okay but we're not
mapping anything to the first axis and
there has to be a first axis in the
result so that's invalid and here the
problem the left argument isn't is valid
but only for a Rank 2 array a two
dimensional array but the actual right
argument has three dimensions
over here we're not using integers so
that's invalid you can't
enumerate the X's with fractional
indices
here we have too many and here we have
two
uh to few
because the red argument is empty it has
length zero but it's empty along that
one axis that it's empty along but we
don't have any
X's
on the left
we could also combine this with the the
tally of the X's
and this just gives us the count the
number of dimensions in the right
arguments we can see here that this is
this has is a Zero Dimensional array but
we're trying to pair it up with a list
of x's that has one element so we're
trying to map an axis that doesn't exist
just as an example
okay now let's get started so there are
two parts to this there is the part
about being a kind of permutation Vector
but possibly with duplicates
and then there's the the part where the
number of elements in the left has to
match the number of dimensions on the
right
foreign
the first part whether or not the
argument is a preventation vector
possibly with duplicates so these are
all our left arguments and we're trying
to compute something on each one of them
so we have the Lambda and the each
now
again two parts to this sub problem
there's the permutation part and then
there are the duplicates part
the easiest thing is to get rid of is
duplicates
that we can just do with
the unique function on the right
argument so this gives us rid of all the
duplicates and then we have to check
whether or not it is a permutation
for that we have to go ahead go explore
the grade primitive a bit
so this is grade up let's try some
argument for that what grade does is it
Returns the indices that you would need
to use in order to sort
so what this is saying is in order to
for this to become sorted we need the
third element first then the first
element then the second element and
finally the fourth element
we're not going to saw it
but what is interesting here is that if
you grade again
this is already a permutation vector and
asking for the indices that would sort
implementation Vector is the same thing
as asking instead of
um which element should I take in order
in order to get things sorted then where
we're getting instead where should I
send this element in order to get things
sorted
so if we try this it says send this
element to the second position send this
element to the third position this one
goes to the first position and this one
stays in the fourth position
why is this relevant well even actually
we already have a permutation vector
so
this is a presentation of extra because
it contains all the numbers from 1 to
its length for
and we grade that
so
this gives us again
which element should we take in order to
get this to be sorted so we want element
number two element number four element
number one and element number three
now if you do the grade again which is
the inversion of the permutation
notice that we get back to where we were
before
well it makes sense if this is invert a
permutation and we invert the
permutation twice we should get back to
where we were
that means we can write a function that
checks whether or not a given Vector is
a permutation vector by comparing the
original Vector to the grade of the
grade
so we can write this as the argument
matches the grade of the grade of the
argument and we can try this
this is a permutation vector
this is not a permutation vector
the only thing we're now missing is that
we want to look at the unique elements
not just all the elements if we try this
first on x
um oh right uh some of the
um some of the elements of X are
scalar
but we can fix this by reveling the
argument
right so here we have some that are
valid according to this Criterion and
some of the invalid ones are also value
to put this criteria it's going to fill
the other one but some of the valid ones
are invalid
marked as in value because not being
permutations let's look at X again
and we can see that that's because they
have duplicates
now let's try to compare
with the uniques instead and we don't
need to Revel anymore because unique
itself would Revel if the argument is
scalar
this works
we can beautify this a little bit and
make a little bit more efficient we only
need to compute the unique elements once
let's assign those to U and then we can
just use U
right this takes care of the one
argument
is the one criteria which is that
the left argument must be a permutation
Vector although it is allowed to have
duplicates the other criteria is that it
had to match its length to the length of
the shape of the right government
argument that is the rank of the right
argument
now let's include the right argument
we want the length of the left argument
to be equal to
the length of
the shape
of the right argument
this worked right away but we can
beautify this as well
notice how the quality is between two
lengths
this calls for the over operator which
pre-processes both arguments to a
function
with some other function before the main
operation is done
foreign
now we see that we have two arguments
being given to this main function
but one of them is being pre-processed
by the shape
that we can use the beside operator
which pre-processes only the right
argument to the main function with a
preprocessing function
and finally we just have a single
derived function
which is wrapped in a different Lambda
now that means we can just take away the
wrapping
this is the other part this checks
whether the left argument
is has equal length to the shape of the
right argument now all we need to do is
combine the two
criteria we want this one to be true
and we want
the unique elements
matching the grade of the grade of the
unique Elements which are
the unique of the left argument
this is our solution we can give it a
name
and now we can write
using this name
thank you for watchingwelcome to the apl quest cap wiki for
details
today's task
is the fourth from the 2015 round of the
apl problem-solving competition
we are to implement what's traditionally
called progressive dyadic iota or
progressive index off
it's just like normal index of
but
instead of finding the first occurrence
of
every element on the right in the array
on the left
it consumes
the elements on the left so it's like
without replacement index of without
replacement
and this is a classic problem in apl and
it has been
discussed and documented for decades
the most commonly used traditional
formulation for this
is very well explained in the apl
cultivations
and there's also a link there
to a video where i explain this
so i'm not going to spend too much time
and energy on this just to show that it
works and
how we can update the traditional
formulation to the modern times
let's have some sample data
we got landon and finnegan
and our task is then to find the indices
without replacement
so f isn't found and there are six
elements in london
which means that it should get a
b index seven because that's how iota
works same thing goes for i
n finds this match in
position is three but that means this n
is consumed and the second end has to go
all the way to element 6.
e and g are not found so they're going
to be 7 as well
a goes to the a in london and the final
n while there are ends in london both of
them have now been consumed by the
previous ends and it will be as if there
are no more ends and we also get seven
so the traditional formulation in
question um
goes like this
and if we try it
um on the arguments
oops
made a mistake here
oh um yes
it has they're missing and
no another and um
reshape here here okay um
then we get these results as we uh as we
said seven seven for the f and i
three and six those are the two first
two ends consuming the two ends in
london seven seven the e and g two is
the a and seven is the final end which
cannot find its match because the two
ends have already been consumed
and this all works very nicely
however if we change our arguments into
matrices
by applying table to both of them
and then we get an error
and this is because this traditional
formulation is using trailing axes
and other inappropriate functions
for such a thing but we can quite easily
update it to handle such cases the
problem here is we're consistently in
the wrong way we want to add more major
cells so we need to concastenate first
and then we are taking indices here from
this
vector of indices and but this uses the
shape of
the right argument and we only want the
number of major cells from the
arguments
and that solves our problem for higher
rank arrays now we can notice some
symmetry here it looks almost identical
what we have on the right and of the
left of the middle
iota
and so we could express this in terms of
a single function with that with slight
multiplication becomes the same
for
or the equivalent for these two sides
the only difference here is that we have
swapped arguments on the concatenation
and then we switch which
argument
is being used for the telly
so let's express it like this we have
the right argument
and the left argument and the right
argument we want to do this
preprocessing on both arguments
but that doesn't work because it's not
exactly the same function
so instead we're going to make it into
a train
and the train is going to
we're going to create a function on the
right
which we are then going to
use in commuted form on the left that
commution
takes because that's commuting takes
care of flipping the arguments of
the
congratulation here
but this one is always already backwards
it's right argument on left left
argument all right so we commute it here
and it's going to be commuted right back
again when we apply r over here
then
we have two grades that are magnetic so
we apply those with our tops
and then we want
the tally off the right argument and
then of course when we flip the
arguments it's going to be a tally of
the left argument which is exactly what
you want here on the left side of the
omega
so
this is our solution
a
somewhat shorter
modern solution
so this is the uh the modernized fin ipl
solution let's call that f
and there's also an alternative
formulation listed in the field in the
api's
idiom list
which is much the same and if you go
through the explanations for for this
one
then you will probably be able to go to
have a look at this one and reason about
why it's
the equivalent so i'm not going to
explain that one in detail here either
it goes like this
and then we have something very similar
to what we have here on the left which
we're going to put on the right
but we have some the right argument
indices being generated over here and
swapped arguments of the congratulation
over here this alpha stays constant it's
always the left argument i mean let's
try this
the basic principle here is that we are
using
left argument as a constant um
lookup so that
the indices that we are generating for
the cells are corresponding to each
other and then we are pairing them up so
we have unique identities for the
indices in each array
being paired up
gives us the same result
and just as before it doesn't work on
high rank arrays and just as before we
can fix this by replacing
shape with tally
and
last axis of concatenation with first
axis concatenation
and just as before
we can
get rid of this
repetition of very similar code
by using the reversed
function from the right
the function on the right
is
we have to make it
fit into the the syntax of a train here
so here we have
the tally of the right argument and then
that's going to be the left argument
when we're on the left as as we want up
here
and then we want the indices of that so
we use another top
and here we have the backwards
concatenation do the swap there
look up into the constant that's an agh
train and then we have
a top will grade
over here
some people and i myself included prefer
not to have too many parentheses and too
many nested levels of parenthesis and by
observing that we have a single though
derived function on the right here of
the iota and
a
function that is
a 4 train on the left so there's an agh3
train with another train that's a
fortran on the left
and then
we can see that if we swap it over swap
the arguments of this middle iota we get
a single function derived on the left
and that doesn't need parenthesization
and we can avoid the parentheses
parenthesis
of here as well
so let's swap that over
and remember to commute the arguments of
iota and put this fortrain in problem is
of course that this is a magnetic
function so
we can pre-process the
right argument of
the middle ioto commute with that
another way we could do it would be to
do a post-processing um
of the result of iota but i like the
other style a little bit more because
this iota is going to use this argument
and
the grade atop is just in the way it
just separates the the function here
from its its arguments so you find it
easier to read
like this and that works as well and we
can well if the other one is f let's
call this one g
and we can even do a performance
comparison between these two let's
generate some test data
um so
alphabet uh let's take
a hundred letters from here
or yeah let's do a thousand for now um
to see a proper effect
and we do that make a right argument
which is another random thousand
letters there
and then
we can copy in cmpx from the defense
workspace
and run the two against each other
well
in this case and
f was significantly faster than g and
i've tried all kinds of cases turns out
that
in general f is either somewhat or
significantly faster so that's the one i
would recommend
using
okay with that practical thing aside
let's look at some and
other approaches to this that i'll then
explain fully
one way to go about this is to start
with um
a comparison table
between these two names
so here we have uh one row for every
letter of um
landon and one column for every letter
of
finnegan let's turn this on its side one
way we can
we can do that is by just putting in a
different flipping arguments alpha and
omega so alpha is on the right and omega
is on left
and what's the significance of this
table well it maybe becomes a little bit
easier to see if we stick and
landon on top
and we stick finnegan on uh left we just
have to
make sure that we add another element
which is going to go up here in this
corner
and where they meet so just put a blank
there
so what's happening here is that
finnegan is and has the letters that
need to be given positions in landon
and these vectors here
they represent kind of an identity for
our the letters in finnegan in relation
to the letters in london so this is
saying f in finnegan does not find any
match anywhere in london
and so to i and that's right because
both f and i are going to eventually get
a 7 not found
the ends
identify with
these two ends here these are the ends
that they want to consume and they both
want that so they're going to get
eventually um
distributed these two ends here need to
be distributed to these two ends
then e and g are just like f and i
a
will take
one of the a's which is only one and
then we have another and here down down
here which is a contender for the a's
for the ends in london but it's not
going to get any because they're going
to be consumed by the first
two ends
okay
so
we want to put all the all the ends
together and we want to put all the
letters together that are um that are
not matched so that we can
we can start matching up the available
letters with the ones that are looking
for them
and for this kind of grouping that's
where key comes into the picture
so let's just do a simple application of
key just to see what are the arguments
to the operand um for key
no we're missing an uh an a on the left
here we go so these are the uh these are
the unique rows so this this row is the
not found row this is the n row this is
the
um
this is the a row
and there are four letters
the letters in positions
1
2
5
and 6
that are of the not found type and then
there are three letters in position
three four and eight
that are of the
type where this mask indicates the
letters that they can consume in
london
um
for now we're not so interested in the
in the mask but we want to know where
are those letters and how many of them
are there so let's replace
the alpha with the where of alpha
this gives us the indices that
will need to be distributed
so these are the letters in finnegan
that are asking for these letters in
london
these are the letters in finnegan that
are asking for well there aren't any
these letters in london etc
let's move things around a little bit
and
look at the count because we need to see
how many there are
and if there are enough
so you can still put an
omega here and
this this table here
says that there are four that's the
count of these and there are four
letters that need
to
consume these letters over here there
are three letters that need to consume
these there is one letter that needs to
consume these
and so we can use
take here
to take as many elements as we need
those are the ones that are
corresponding now when we do that
then we and we don't have enough we're
padding with zeros
so this indicates that
three
the the third letter in finnegan is
going to get the index three
the fourth letter in in
um finnegan is going to get index 6
that's the last n in
london
and the 8th letter in finnegan which is
another n
won't be matched
so we can already kind of see our
solution and the result here is already
in here all the information for it let's
make it a little bit easier um to access
so what we're going to do is we're going
to take and pair up so this one
corresponds to this 0 and this 2
corresponds to this
0 over here
if we make what we have on the right
here
into a
into a matrix and one column matrix and
concatenate it to what's on the left
then we get a two column matrix
um
if we just do it like this then
key is going to pad with a lot of
elements because they're not the same
shape so let's enclose it just so we can
see what this is we're doing
see we can see that
um element one gets not found element
two gets not found
element three gets a three element four
gets a four limit five gets not found so
we need to combine these tables and then
we need to
just put them in the correct order
combining them
we can do by concatenating them along
the first axis
that's going to also enclose them so we
disclose them
and now we have all the information that
we need we just need to put it in the
right order we need to sort it by the
first column
so let's do that
we could do the first column sort we can
also just sort by the whole table
because it doesn't matter when the first
column are all unique elements we're
never going to look at the second column
at all
now they're in the right order and
here's our result actually just we need
to adjust these zeros to sevenths
eventually and we don't actually need
the left column either we just needed it
for the sorting so this means we're
getting all the columns and we just want
column two
and then we need to transform our zeros
into
into sevenths so seven meaning one
beyond the last element
position
in
the left argument so one beyond
the length of
the left argument
replaces the values
at
those values where they are
where zero equals them
and that gives us our solution
now
there is an additional problem that is
again high rank
comes to haunt us a bit
um
right what's happening here things are
going very wrong and this would also
happen if our rays were nested and that
is because we're using a scalar function
equality here this tries to compare all
the elements rather than compare the
individual major cells
not only that if they were nested it
would also dig in and create a nested
structure of booleans assuming
the length would be matching everywhere
and we this could even error
so we need to
to write this out a product but in terms
of
match and we can do that um so what we
want is
we want
every major cell from an omega here
com and needs to
be compared to all the major cells
from an alpha
and
so
we can pair up first the major cells
from
from omega
so that's rank negative one with the
entire alpha so we give it 99 as a big
value that's bigger than the rank of
of alpha
so now
what match would see is um in our case a
row on the left and entire matrix on the
right and now it needs to again traverse
that and compare um
the major cells
so on the right
need to be paired up with the entire one
cell which is a corresponding cell
on the left
and then we get our proper result
so let's call this
k for key because it's the keybased
approach the key is doing the heavy
lifting here
okay um a final
approach to this
um it's not going to be an aple approach
but
it's a different way of expressing the
way we might think about this problem
and for this let's use london as a left
argument but i'm also going to use a
different argument which is just going
to be nine for now and it will
expand on that later so nin
the first n consumes here that becomes a
three then we should get a
two and then we should get a
six at the end we can confirm that we
can try that with uh with k that we've
just defined
so three two six
right
what we're going to do is we're going to
literally
go through and consume letters the way
we've been talking about it now we are
not allowed to change anything in the
left argument of a defense so let's make
instead a copy of it that we are allowed
to change in whichever way we'll call
that a
because it's like
alpha um
and now that that's initialized we're
going to
traverse
all the elements in the right side
and for each of them
and we're going to
consume an element of a what does that
mean consume well let's change it into
something that won't match so
the first n in landon which if you
change that into something that's not a
n
then when we get around to the second
end in then
it won't match that end anymore you'll
have to go to the second one so then it
has been consumed
and
how do we find which element to consume
or we can just look up
the element the first match
because once we have consumed it it
won't be a match anymore and we change
that into some kind of symbol that
indicates that it's been consumed
this is an assignment so everything here
is going to be be very quiet
but
we can
discard these assignments every
assignment here is going to result in
the symbol so that's not very
interesting
instead we discard that and instead we
return
this modified array
a
and we can see that the
a and the n and the n have been consumed
we can even
look at what exactly is going on every
time around the loop by printing this
current state of a before
it gets updated
and here we can see the evolution first
we've got the pristine landon and then
we're consuming an n consuming an a and
consuming the final n
however we're not actually interested in
what london looks like when it's being
consumed we're interested in
the indices instead
and it is a well they're they're the
ones right here so we can
print that instead
and uh
we can see that we're getting our three
two and six and then these are the ones
that are being consumed now we don't
want to print them we want to return
them so let's give them a name
and then
every time around the loop here we have
a new value for i so we let the
the function return that instead and
those are the values that we want so we
don't need
our a being printed at the end anymore
and that gives us
our result
but there are some issues that we're
going to fix what happens if i add an
element here that's not found
we get an index error the reason is
because already this
lookup
we
we're going to get
and not found which is one element
beyond which is one index beyond the
last index and one index beyond the lens
index is not a valid index for a
what can we do about that
well we can create a new position in a
which is like a sacrificial position we
just we're going to override it whenever
we need to overwrite something that's
not in a
so let's just add one more element we
can use the same symbol for that doesn't
matter it's probably going to be
overwritten anyway
and then when we look up here we have to
watch out because now a has one more
element and we can we'll get an index
that's too large so we'll
um drop that before we do the lookup
you can see that s got a seven as it
should
further complications well what happens
if this element that we have chosen
as our um sacrificial element or or a
marker for something have been consumed
what happens if that itself
appears
in the array
that does not look right what's
happening
we remember how we when we are consuming
things we overwrite that element
with the special symbol
and so by the time we have consumed n
and a and n our landon looks like this
now we come and look for that same
element we're going to find that in this
position too
so we need a value that's not going to
match
itself at all
and here's a special trick
a kind of nasty one
and namespace we can create a new
namespace
and though a namespace is equal to
itself
even two namespaces that are created
under the same circumstances and are
otherwise identical regards to their
content
they are
passed around in apl by reference and
they have an identity so they don't
match each other
this means that we can use namespaces
that are being
generated
we will make a new namespace um
we could make a new namespace every time
and then we ensure that this namespace
that we are generating here
will never appear in any array because
every namespace has its own identity and
this one has never existed before
we could actually
also just use a single namespace as the
as the
namespace that we're blurring out with
but this itself would work
if you wanted to use a single one that
then we could define it outside and say
put it here
we can use that here as well it doesn't
matter
because that we have it in the lookup
array because we never have any um
any array coming in where we want to
look for this nice space because
namespace doesn't exist yet we're only
creating it once here so this would work
as well
and then
as the error lasting trouble and
it would be a problem if we had high
rank arrays
there are multiple problems here
and
with the first problem we're hitting um
apparently but there's actually
something going on before that is uh the
lookup
um and the problem is that we're
consuming elements one by one rather
than going and
major cell by major cell so we should
change this into a rank negative one
over here
and another issue is that we're
concatenating the wrong way we should
add another major cell which would then
be filled with uh with this element
and finally we're doing uh indexing over
here with square brackets which isn't uh
general we can't index into a general
array using a single call with square
brackets because we would potentially
need training semicolons over here
and that doesn't work so we'll change it
into using the index function instead
right
here
like that
and now we're getting the result we want
um
using high rank arrays as well
so let's call this
n
for using the namespace
and
if we look at
these solutions we found that f was
the
the fastest ones of f f and g and we had
the
the one that was based on key and then
we have the one
the user's namespaces
this over here was an outer product and
that's going to be problematic for very
large
very large data let's say that both
arguments have a thousand elements that
gives us a million elements a million
comparisons
there so that's going to be very
inefficient so we should
change our test cases to something
smaller
let's just do a hundred then
and a new y as well
and then we can
we can
compare them all
so we have x f
y and x
k y
and x
and y
and well it's very clear that
the right way is the old way
so
when you want to do this kind of
allocation which can be used for example
to
con to
[Music]
fulfill orders or warehouse with a limit
a limited amount on a first-come
first-served basis or allocate seats in
the airplane with various classes of
seats then
use the modernized expression from
the
finae pill idiom list and for the full
explanation of that have a look at
the links in the description for the
video
thank you for watchinghi
we have to move elements of a numeric
Vector that have a certain value to the
front of that vector
a traditional way to do this in APL
is to use sorting
but not sorting the vector itself that
wouldn't work rather sorting by a
certain criteria
let's have a little Lambda here
and compare the left argument to the
right argument
now we have indication of where the
threes are
and if it were to sort so all the zeros
came first well all the numbers that
correspond to zeros then
we would have all the threes at the rear
let's
flip the ones and zeros by using unequal
instead
now if we were to sort such that the
numbers corresponding to zeros came
first
then the threes would come first
how can we do that
the grade function
gives us the indices that we would need
to select elements from such that the
argument would be sorted
this says in order for it to sort this
numeric Vector we need to get element
number three first that's the zero then
element number six that's the other zero
and then one two four five and so on all
the ones of course we don't want to sort
the Boolean Vector we want to sort the
corresponding numbers in the actual data
Vector but this will still work because
the third element is the 3 and the Sixth
Element is three and then comes element
number one two four and so on
so instead of reordering the Boolean
Vector we are reordering the right
argument
this indexing square bracket can take
multiple indices and then we just get
all the elements selected by those
integers
and this solves the problem using
grading and reordering based on that
grade
this might seem like a very neat
solution but there's actually something
even shorter and I like this one better
and that's using set functions
let's think of these two arguments here
as sets
what we want to do
is to find the intersection of these
sets that would be those two threes
and the set difference that's all the
other elements
if we can then
put together the intersection and the
set difference
after each other then we have solved the
problem
and this isn't very hard let's start
with
the set difference but that we use the
without function you can hear the name
that it takes the data on the left
without the data on the right which is
the opposite of what we want
luckily we have the higher order
function or magnetic operator which can
flip the arguments of these two
functions
of these flip the arguments of this
function
so here are all the numbers from the
right except the numbers from left or
without the numbers on the left
there's only one number but you can
still be seen as a set
similarly we can take the intersection
that's those two threes
notice how this deals with kind of
multi-sets and then we're allowed to
have duplicates and that's exactly what
we want here
okay then we just need this intersection
followed by
the set difference
and that solves the problem as well
note how we are commuting
both of these are the functions and this
is actually a fork construct this means
that the outer functions these two are
applied to the arguments
and then the results are combined using
the concatenation function
we could also just flip the arguments of
the outer function and then the inner
functions wouldn't need to flip too much
another thing we could do but that
doesn't really make a difference is to
replace the concatenation with a union
being that the intersection and the set
difference cannot share any elements
then that's effectively a concatenation
it's just kind of cute that we are only
using set functions to solve this
problem
thank you for watchinghi
we're going to get a bunch of words and
we have to Center them on top of each
other within a certain
window
and we might need to lose some
characters to make them fit there
so
here are some words
and there are multiple ways we can
detect this problem I'm going to go
through only one that I like very much
and the way we're going to do this is by
first creating a matrix
and since a matrix is orthogonal it it
has the same number of columns in every
row then we're going to pad with spaces
which is great because that's what we
need to in the final result and we just
need to adjust where the spaces go
so we'll start off by making The Matrix
and then we're going to move the spaces
around to the correct positions
we're also going to get the width but
we'll take care of that in a moment so
the first thing we're going to do is to
use the mix function on the words and
what it does is it takes these inner
arrays and combine them into one array
with each element becoming a row in The
Matrix
so now we've got a matrix and there are
spaces here at the end you know we can't
really see them normally
now we have a width that we need to
either extend or truncate to
we want to do this for every row
um so we want to use the the take
function
let's say with the width 10 and we want
to apply that not on the entire array
that would take 10 rows we want to apply
it on each row and rows are vectors so
they have rank one so we use the rank
operator to specify we want to take from
a row from arguments of rank one
um really the left argument is a scalar
so that's rank 0 but it doesn't matter
because if we specify a rank that's too
high we just
leave it with
um the argument in whatever lowering it
has
so now we can see that competition got
truncated and so so did every line
now we can start working on this result
so let's create a little different
Lambda
and we need to move some spaces around
and the way we're going to do this is by
rotation so we can rotate each row
separately we want to take some of these
training spaces and move to the
beginning
let's first find out how many spaces
there are that is how much padding was
added after the truncation even though
we actually added all the spacing first
and then did a truncation we could have
done the opposite order but that would
have required taking the 10 elements
from each which is an explicit Loop and
we want to avoid that
so the argument is referred to as Omega
it's not the same as W
um so here we get the Boolean mask
indicating where we have spaces and we
can Sum along the rows of this to get
how many spaces there are in each row
right in order for something to be
centered we need to
uh
have half of the spaces on one side half
on the other side so we divide it by two
this little face changes the division
sign so that it takes uh what we're
dividing by on the left rather than on
the right now we don't need to put this
whole thing in parenthesis
so we need to move three and a half
spaces one and a half spaces of course
we can do that
um but the problem specification says
that
if there are an odd number of spaces
then we should leave the larger number
of spaces on the right which means the
number of spaces we move to need to move
over on the left is the lesser of the
two adjacent numbers so we round down
so now we need to move three spaces from
the right on the first row one space
from the right on the
um
on the second row and so on
moving from the right to the left that's
a rotation but normally rotation rotates
from the front to the rear in order for
us to rotate in the opposite direction
we need to negate that so now we get
negative numbers
finally
we do the rotation but the rotation
takes actually the amount of rotation on
the left so again we need this squiggle
to move the amount of rotation over to
the left
and we do that on the right argument
and that gives us the result so we can
see here we got two spaces on the right
here and one on the left that's because
we rounded down the amount of spaces to
rotate from the end to the beginning
this is this solves the problem but it's
not an actual function yet it's just a
one big expression that uses an
anonymous Lambda in the middle
to compute the result so in order for
this to become a function we can give it
a name it's not necessary but it makes
it easier
you can see here that we have a function
applied to the result of something else
so
um that is at the top it means we can
just State the multiple functions after
each other
and we want to get rid of the arguments
here we have this function is
the diadetic function
who needs to be applied between the left
argument and the 10 in our case and the
words that have been mixed
so this is the central function but we
need to pre-process the right argument
with the mix we do that with this
composition operator
we called beside so it's like we had
these two functions
in the explicit
phrasing we have them beside each other
they're right next to each other and so
this
composition
makes them be as if they were beside
each other so this will insert the left
argument here and the rest insert the
right argument over here and then
evaluate that and then on the result
we're going to apply this function over
here
so now we can try it 10 f
w
thank you for watchinghi we have two DNA strings and we are to
find out how many of the characters the
DNA bases are different between them and
the same length so this is
easy um here's a sample and if you want
to see which ones are the same then we
can get the mask like this and if you
want to know which ones are different
then we can can do an
unequal and then we all just need to
know how many ones are there here but
being because true and false and APL are
and represented by one and zero and
since they are just numbers they're not
separate type we can just sum them uh to
and summing them is using plus reduction
so we we reducing the result of this
because every function including this
derived summing function has long right
scope so we take take everything on the
right as argument um so the result of
this which is the mask get summed and
that gives us the number of
differences um this isn't a single
function we could uh wrap this up a
little bit as a function so we can uh
call the left argument Alpha because
it's the leftmost ele um character in
the Greek alphabet and the right
argument is called Omega um and then we
can put races around it to mark it as a
Lambda and then we can give it a name or
we could call it directly in line so now
we can go up here and um apply our
function to get the same result we can
actually be much shorter than this even
though this doesn't look like much um
and that is because we can switch to
test it
mode the way we do that is test it means
you don't mention the
arguments and if you just remove the
arguments and also the braces uh let's
give it a new name then we
can do it like that that works too um
however this definition We cannot put uh
in line as is if we wanted to do that
then we would have to parenthesize it um
like this there is however a tcid inline
definition that you could put inside and
that is um as an inner product so inner
product um let's let's try that first so
if we say 1 2 3 so we have two vectors
or they could be scalars it could also
be higher rank array but that's not what
we're dealing with here and for um up to
one dimension then the inner product is
the same thing as a reduce over the
result of a scalar operation also known
as a map reduce at least kind of because
it takes two arguments so uh let's take
10 100
1,000 and and the inner product uh
simply pairs up elements with the
corresponding element over here so this
is uh 1 * 10 + 2 * 100 + 3 * uh 1,000
and therefore um we can just replace the
multiplication with the unequal and the
plus stays the same and that would still
work so if we could do that here we
simply replace a slash with a DOT and
that gives us this and this because this
is is a diic operator it combines these
two functions to a new function and this
is constitutes a single function whereas
this before was two adjacent functions
uh the plus slash is one function
derived from this mtic operator higher
order function um that makes the
reduction and the unequal which is um
its own function uh so we have two
functions here we just have a single
derived function and so we don't
actually need the parenthesis and like
that so we can uh can call it that as
well
and then we can go up and apply it here
if you want to do that thank you for
watchingwelcome to the apl quest see apl wiki
for details
today's quest
is the sixth
from the 2014 round of the apl problems
of the competition
we are supposed to count the number of
ways that you can
throw any given result
with a given set of
dice
and so this isn't a statistics
of what the chances of getting a
particular result but just counting the
number of ways
a very simple approach to this is
exploiting the magnetic iota or the
index generator so let's say we have
two dyes
that have six sides so there's a normal
dice
um then the indices in an array of the
of that size six by six contain all the
different possibilities that the dice
can show
and so this means that if we sum each
one of these
lists of
face values
then we get all the
the sums
then
uh revenue that result gives it as a
single list and finally we can use key
to
and summarize
we are not interested in the actual
position here we're interesting in the
count so we take
the particular value
concatenate it to its count
and apply that
with key
and that gives us the result that we're
looking for
we can give this a name
this uses an index generation so we can
call it i
like this
however it does have a problem uh
besides for performance which will come
right back to and that is that since
it's generating an array
of the given dimensions where every
element is the index of that element in
in the array then it is subject to
dialogue apl's
limitations in the sizing of arrays
and as it is today and dalek appeal does
not allow arrays that have more than 16
dimensions rather more than 15
dimensions even um indeed if you need
more than 15 dimensions you might be
doing something um
wrong or at least a little bit odd
so if we try it uh let's say we here we
have um
two-sided dice
this actually means that like coins so
the coin flips
um that's all very good so we can either
have both of them showing uh showing a
one or both of them showing a two or one
of each
which means there are two possibilities
but let's say we have a bunch of coins
let's say we have 15 coins
um then
um
a lot of possibilities like this and
it's perfectly reasonable to throw than
16 coins as well problem is
that
we're not allowed to generate an array
that has this rank that has 16
dimensions
furthermore there's a problem of
performance here as well because we're
generating a nested array with one every
element is a pointer and because every
element is in itself an array
uh not just a simple scalar
um and
that is a bit wasteful in representation
and dealing with it
but we can achieve the same result in a
not too complicated way by observing
that the number of uh of elements in our
resulting array and it is clearly and so
in the two-dimensional case it's in
six by six whenever the both of them are
six and in general it is the product of
the dimensions and along every axis
so all the possibilities um is the
product
um off
of the number of sides and all the dice
and then
we have all these uh
values
um
although we should start with
with zero
you know because we're going to use um
we're going to use
mixed radix representation here
and so let's let's just take it for six
for now
um
and then so this this gives us this
gives us some a long list of 2 36 35.
now if we then represent this
in the radix of 6 6
then every row represents the the value
of
one die and so so the first row is the
first die and the second one is the
second die
and then we can get uh the sum the only
problem here is because we're counting
up from zero rather than from one we
just need to increment again
and then
we can
go and sum vertically
and that gives us the total sum
so here we managed to do it without
having nested arrays just direct
computation based on
the mixed radix
in this case that's the same radix but
it could be anything of course
and then we can proceed as we did before
uh by concatenating the value with how
many times it appears using that the key
and we can call that
e for encode because using encode over
here
to generate all the values
and then we can try it with 16 coins
and that works just fine
it will also be nice to see as i
mentioned there might be a problem with
the
performance of it because it's necessary
which here we're dealing entirely with
flat arrays so let's compare that as
well
we're copying in
cmpx from the defense workspace
and then we need some test data this is
a little bit interesting what kind of
test data there's no limit of course you
can throw as many dice as you want and
they can have as many sides as you want
so we can try to
make some
variation of of cases so let's just
start with small cases we can see it and
then we can scale it up so in fact we
can have a diet that has no sides at all
in which case it doesn't really
contribute but
we can still include it
um so
let's just start here with from uh
from zero to three all right so we can
have we can have a dice that have no
size but they don't contribute we can
also have no dice at all in which case
the result obviously is zero but we can
include that here so here's between zero
and three
dice
and then for each one of them
we use that number to replicate uh the
number of sides on a die um so here
three just to keep it small
and that means we could we could also
for example uh roll them like this so
this is these are
dice rolls with zero one two three
dice that have uh three sides
each
what we really want is we want all the
possibilities because maybe maybe we
have one diet that has
two sides and one has three sides one
has one side
and then we can we can do it like this
so this gives us a a grand table of with
zero one 2
and 3 and then
um all the different die sizes so we can
then combine all of these
into a single list so we can
do a concatenation reduction over this
list of
multi-dimensional
arrays we need to flatten each one
before we do that and then disclose
because we have reduced them
and that gives us
our
giant list of
die hands that we can then throw
and now let's scale this up a bit and
there's not really any
given
limit to this so i'll just say between
zero and four dice and the dice can have
up to
nine sites each and these are our test
cases that's count how many test cases
we've got we've got seven thousand
something in this case so that seems uh
well enough
okay so
cmpx and
and then we have i or the one that used
iota to generate
the indices
on each one of these test cases and then
we had e
which was the one that used encode on
each one of these test cases
oops
did i make a mistake here
oh yes of course
there's a mistake in
uh in our definition of e
uh and that is because i forgot to
i forgot to revel here the problem is
that
um we can be given the argument as a um
i guess a single number as well
um and then um we're going to missing
out in the rank so we need to make sure
that uh
the left argument to encode is also a
vector
um we can do it like this or we could
use the over operator to make sure both
the right argument is always going to be
vector anyway because we get it from
from iota
so let's try that again
and we can see that
avoiding the nested arrays can give us
some significant speed up there but
there's actually more we can do
um and that is
looking at key so for key
here we used a tested left operand
and there are some special cases and
this is exactly one of them
where we want the
the value concatenated with its count
and that has been highly optimized if
you state the operand as a defense so
left argument
concatenated with the tally of the right
argument instead of that and this seems
like a very small difference but this is
the defen inner
key
and then we can compare the performance
of
e and e d
and we should see a significant
performance improvement there too
there we go
so
playing around a little bit and trying
out the the operands for key can
actually make a big difference
and there are some
some combinations that have been special
cased and run much faster
thank you for watchinghi we constructing concentric rings of
numbers where we're given a number as
argument and that goes in the middle and
then we keep decreasing the numbers as
rings around it until we reach
one
and we can do this um by generating
first the sequence that we want want
going from the
um outside to the inside so let's say
the argument is
five and then we want a ring in the
middle well that's which is just a
single number which is five and then
ring around that for four and then three
around that two around that one around
that so it's going to be um large like
this okay let's um start working on this
as a uh tested function that takes us
argument uh the this sequence that we
generating because we want the sequence
itself and we also want it then in
Reverse to uh decrease once we pass the
center so we can reverse it and we can
get its um
identity and we can concatenate these
together
oops but now we get a duplicated middle
element which we don't want so we can
drop the first one of the Reversed
argument the Reversed sequence and that
gives us the middle row or middle column
in the final Matrix that we
want so all we now need to do is expand
this to become a matrix where we um sort
of say uh rotate around the
middle and one way we can do this is and
as if we were making a multiplication
table so for a moment let's try make a
multiplication table that's J J jut do
times uh selfie or commute so this is an
outer product and then we are using uh
the commute to take this argument over
here on both sides and this gives us a
multiplication
table so we can see that five can 25 in
the middle and then this is 4 * 5 is 20
over here all the way up to 1 * 2 and uh
2 * 1 and then one over here of course
we don't actually need a multiplication
table what we want is that uh the lowest
value from the rows or the columns
should Prevail so over here we want it
to be a one and over here we also want
the one and here we want the two and so
on then five in the middle so we want
the minimum function so the minimum
function is written like this it's like
uh a vertical bar with an indicator line
that shows the minimum uh
value
and then that gives us exactly the
result we want now this is an expression
but we can easily convert this to a
function f and then we can apply F and
that solves our problem thank you for
watchinghi we are to build a
staircase and the way it works is that
we're getting a number and we have to
create a matrix that is this wide and
high and the bottom right including the
diagonal um of this Matrix should be the
quad character this little boxy
character and the other one should be
spaces so if we get five we need to make
this little
staircase and there are a few different
ways we can do this let's get started um
we created a little Anonymous Lambda we
can always give it a name later and for
now sure let's use five as
example we need to create something that
is the bottom right
so one way we can think of this is It's
a range going from the top left to the
bottom right let's create a range that's
Iota for It's Greek letter like I for
indices is the indices up until the
argument the argument is Omega because
it's on the right and it's the rightmost
letter of the Greek
alphabet but this only goes in one
direction we need to go two directions
so this call for some kind of table and
something that goes diagonally uh
increasing towards the bottom right from
the top left um is an addition table so
if we create an addition table we write
a jot and a DOT and then the function we
want this an out of
like an outer product but it's an outer
addition and we want to use this Iota
Omega on both sides so instead of
writing it twice we write the selfie
operator or also known as commute its
official
name and here we can see how it
increases uh towards the bottom right
and once we reach above the number we
were given then that's the parts that we
interested in so if we compare if the
argument is less than and then APL will
will map automatically the single number
to all the numbers that are in this
table then we get this Boolean Matrix
and a represents booleans with zeros and
ones and that's really convenient
because since it's just a number we can
add to it in order to get
indices remember we're counting from one
like we can saw we generated indices
from one and we can then use that to
index
into the space character and the quad
character then we use square brackets
for indexing
here and we've got ourselves a solution
so let's call this one F and we can
apply
F
however if we think about this a little
bit we're doing too much work we're both
doing an addition and then a comparison
when we really could just do a
comparison from the outset so if we do
an outer comparison table
instead then we do get a triangle out
this triangle is not right because it's
the top right corner and we don't have
the diagonal but the zeros here they do
form kind of a triangle that we want
except it's on the wrong
side so what's the opposite of less
than well that's greater than or equal
to okay well we can definitely build on
this the only step that's missing now is
reversing so this we can see the axis
over which we are doing the flip it's
we're flipping horizontally over that
vertical
bar um kind of like spinning a globe and
this gives us what we
wanted so if
we call this
G and we do the same thing as
before we've got G and apply to five and
that
works but we can actually do better
because um let's think about performance
here we are creating a whole Boolean
table and if we were to use a big
argument this table would be rather
gigantic and then we are uh reversing
this entire table all that's happening
here is that we're doing a
comparison of the elements going down 1
2 3 4 5 with the columns 1 2 3 4 5 if we
reversed the columns so we would get 5 4
3 2 1 then the tall side of the triangle
over here would end up on the right and
then it would be created from the outset
in the right orientation so how can we
do
this let's uh try this so we've got this
Auto product we've got the Yota 5 and
we've got an aota 5 and all we want to
do is reverse the right
side like that
but we really don't want to compute aota
5 twice so what we can do is go back to
using this selfie
operation but right before we create the
table we want to pre-process the the
table functions right argument with a
reversal so jot in this context not the
same as this one it has a function on
the right and on the left
we essentially apply this function
that's on the left but be right before
we do that we pre-process Its Right
argument so
pre-process with a
reversal and that gives us this table
right away which of course allows us to
write um a new
function that on just the same pattern
as
before G25
I forgot the one
plus there we
go
okay should we compare the performance
of these two let's do that so we copy in
the compare
execution uh utility from the defense
workspace and it just takes Expressions
so write cmpx and then we running G on
say a th000
and G2 on a th000 and then we wait a few
seconds for it to run these a lot of
times so we get some averaged out
results and we can see that we pretty
much have the runtime simply by um
reversing arguments to the table
generating function instead of reversing
the resulting table can we do
better actually I think we can because
if you think about it so let's say with
a th000 we generated a table here with a
million elements and then we added one
so that's a million additions but
there's maybe something that's worse
than that today computation is really
fast what's slow is memory
throughput and APL is clever it stores
arrays in generally in the smallest data
type internal data type that it can so
this Boolean Matrix is stored as single
bits in memory smallest units of
computation in the
computer once we add one we have to
switch to an integer
type and the smallest integers we have
available are 8 bit integers which means
we're using eight times as much memory
for to store this Matrix compared to
just storing this and what can we do
about it remember that we were counting
1 2 3 4 5 we're counting from one if we
switch our system to count from zero
instead then we don't have to add this
one we can use the booleans directly to
index into this character vector and
over here what happens is that instead
of getting 1 2 3 4 5 we get 0 1 2 3 4
they still have the relative size the
same to each other adjacent elements
increasing um monotonically and um never
two elements are the same so it doesn't
really matter what our numbers are in
these indices as long as we're just
counting up so how will this
look and we have a statement
separator diamonds are unbreakable so
two we can't Traverse from one statement
to the next one and in here we're
setting a system variable called quad Io
Io doesn't stand for input output it
stands for index origin so we're setting
the system index origin to zero and it
will be local only for this function and
then we can remove this one
plus wonder how how big a difference
this will
make look at that we just have our
runtime again which means that G3 has
about takes about a quarter of the time
with argument 1,000 compared to the
original G but pretty much using the
same
method
okay let's look at a an alog together
different approach now we're going to
take the
quad character and we're going to
manipulate it until we get our desired
staircase the way we're going to do this
is we're going to replicate it so we can
write three and a slash that's replicate
this we get three of these if you write
two three then we can replicate each so
the two replicates this and the three
replicates it and we get this
list if if we do Iota 5 then we get all
the components we need for our staircase
but they are so to say
disassembled we can assemble them with
mix this increases the rank the rank of
a vector is one and we want the rank to
be two wanted to have two Dimensions be
a matrix by breaking this levels of um
of
structure so here's our staircase and
now we can reverse it
um but this is not a proper function we
can write it like
this however I think in this case the
tested solution one way we don't mention
the arguments explicitly is a little bit
nicer so this
works but if you use a fork
constructs then we need an we can have
an array on the left that's that
quad then we wanted the replicate each
but now we have swapped the arguments so
this array is on the left and the counts
on the right and for that we use this
same symbol as we did before the selfie
but this time it is used with an
argument on the left so we don't use the
right argument also for the left we use
the right argument on the left and the
left argument on the right so it
commutes it switches the argument
order and all we need on the right
is the counting up so the way this this
works is a tested function we don't need
the braces we can put parenthesis just
to separate it from the
argument is we apply this function then
we have our array and then we apply this
derived function between the results
this one and well it's result it's just
a
value so this is this works um then we
have a mix which is fine but we can't
just put in a reverse here this will
break the structure because we would
have the result of this and the result
of this being combined as with being the
arguments for this function which is not
what we want we want these two to be
joined into a single function we could
do that with the top operator which um
applies this to the result of that and
derives a new
function so this works now we don't need
the parenthesis since we're not applying
it let's call this
h
however um we can phrase this a little
bit nicer it's a bit nasty to create
this extra level of nesting and then
just destroy the level of
nesting we can instead do a mapping of
cells in the argument so over here we
have a vector and it Vector is one
dimensional it create it consists of
numbers that are Zero
Dimensional this is is itself a Zero
Dimensional um array it's just a single
character so we can say I want to
assemble a new
function I want to sorry I want to
assemble an a result based on this
function we're creating a new function
which is like this one but Maps together
arguments of rank Zero from the left and
rank Zero from the
right and then take these results so
each one will become a vector and those
vectors have to become the components in
our overall result array so vectors put
them together make up a matrix and for
that we don't need a um a mix anymore so
we don't do the mix here which means we
can just insert uh the reversal here
let's call that
H2 so now we can do H2 and five and this
also works it looks a little bit neater
than the uh than the original H one we
have
here the performance of these two is
probably going to be about the same
because the same thing is happening
inside we can you can try it out
though yeah that's within fuzz
tolerances it doesn't really
matter but there's a whole different way
we can do this instead both of these
Solutions the H Solutions are
essentially loopy Solutions we're
mapping over explicitly um and creating
the rows by themselves and then joining
them uh together here is a very
different way of kind of doing the same
thing and that is by exploiting the that
replicate which we saw before it has
some extra tricks up it up its
sleeve um we can
do um negative numbers and negative
numbers they create um a replication of
that
element that is the same as the positive
value but instead of using the actual
data the actual value we're using a
prototypical value and as we saw with
the the mixing the prototypical values
for this quad character for any
character is the space which is exactly
what you want so if you write -2 3 here
and we only have a single element we
could do an each but it doesn't matter
uh let's let's do the each just to see
how it looks then we can see that over
here we got two spaces and then three uh
quads if you don't do the each they get
joined
together so we get two spaces and three
quads like this o but this means we we
can explod this looking at
our staircase over here we got four
spaces and one quad three spaces and two
quads so if we start playing with this a
little bit we've got a Yota 5 and we
want each number to be paired up
with well with what exactly well first
we have a one and then we want four next
to it so that's 5 minus one gives the
four and same thing on the next line
we've got two we want
three minus 2 uh sorry 5 - 2 is three
but we actually want negative numbers so
we can flip the arguments of
those so let's try
this we do five minus this we get these
numbers if
we take this and put the five over here
on the minus we get the negative numbers
so now we need to join these pars
together with the original
numbers and there are a few different
ways we can do it I prefer to go
directly to a tested solution so we've
got numbers from 1 to five and over here
we um we have the number five itself
being passed
in and then we have another function in
the middle we want to um
subtract
so this gives us our negative number so
this are the indices up to five minus
the five itself this is an identity
function but we don't just want that we
also want the original numbers so we
could get those with the left identity
so this points the finger at this one
and now we just want to combine these
two so we want the minus and we want the
left identity and we want them
concatenated together but not one after
another we want them to be in two
columns in pairs so we want every scaler
from here paired up with every scaler
from here and we did this before with
the rank operator so we want to map over
subarrays of rank zero these are the
simple scalers and that gives us this
table right now we
can use this directly each row to
replicate our quad
we're using the rank again uh we need to
remember to swap the arguments because
we have the array that's being
replicated on the left and this time we
want to map over rank zero on the left
and the one on the right but the rank
operator actually allows us to remove
the zero because if we ask for something
that's higher ranked than it has here
rank one and it only has rank zero then
we just use the highest rank that we
have which is
zero that gives our staircase directly
okay let's remove the out of parenthesis
and call this H3 it's the same kind of
idea of using replicate but and this
time we are forming the pairs that form
every Vector in itself so
let's uh compare the execution time of
we know that H1 and H2 are about the
same so we can we can compare H2 uh
1,000 with H3
1000
and that was a pretty significant speed
up okay so now we know that uh when
we've got the F and we've got and the
G's we can actually look at our
definitions um
here and we know that uh G3 is uh the
fastest one of the G's and H3 is the
fastest one of the H's so in order to
conserve a bit on space and time uh
let's compare the performance of the F
and the fastest G that was
G3 and the fastest
H so uh um we have here that
G3 is the fastest
one we can see that an F is
significantly slower it would be
interesting to run the test again using
just G3 and H3 because when something is
very much slower than others it tends to
skew the
results okay we can
see the trend
here and that's
ithi we're going to find the end points of
one array in another
array
so here's the
thing APL has a primitive function a
built-in which finds the beginning
points this can be a little bit hard to
visualize so I'm going to
stack Mississippi here on top of the
boan result that we get spreading out
the
letters here we can see that we're
searching for iy and we're finding that
it begins here and it also begins here
stretching towards the right the result
that we want is with the ones being here
and here meaning where they end they're
basically uh two easy ways to do
this one of them is to note that we
already have these ones in the right
relative
locations but they're just offset from
where they're supposed to be we need to
move them towards the right by how many
steps
well it has something to do with the
with the length of of the match but if
we were to move four steps to the right
then we would end up one beyond the m so
we need one less than that okay let's
just try
this so we're going to take this
primitive and we're going to wrap it in
a Lambda so it makes it easier to change
its
result and we can rotate with the rotate
function and well that rotated One Step
left to to rotate right we want negative
numbers okay and then we said that it
has something to do with the length of
the left
argument what happened
here oh this is again to the left so now
we want to negate this so that we are
moving towards the
right okay so we can see that we got the
I here but the one is now one step too
far so really we would want to subtract
one from uh from this we can addtive -1
to the length and that gives us the
result we want but we can actually
simplify this a bit because subtracting
one from a number or adding negative one
as I've done here and then negating it
that's the same as subtracting that
number from One oops subtracting that
number from one right there here we go
so this formula will will
work um we can reduce the amount of code
a little bit um by observing that we've
got kind of a fork construct what do we
mean by a fork it means that we have a
middle function here that takes the
result of something in the terms of the
arguments and something else in the
terms of the arguments so we can change
this to a tested form changing the curly
braces to run
parenthesis and then we can remove the
explicit mention of
arguments um over here we do need to
refer to a to the left argument and we
could do that using just functions to
make it fully tested and but we can also
just make this inner expression into a
function so here we have a small Lambda
that's applied to both arguments
ignoring the right argument only using
the left argument and returning one
minus the length of the left argument
and that value is used to rotate the
result result of the find primitive
which shows us the beginning
points and this gives us uh the correct
result so we can take this whole
function here and give it a
name missing that brace
there and then we
can right uh left argument
and right argument and we get our result
so this is one way to do
it another way to do
it is to observe that the fine
function gave us the beginning
points but if we read from the right
instead of from the left then that's
actually the end point doesn't matter
that what we're looking for here is a
palindrome um it's still finding that
from the left and then if you read it
from the right we get the end
points so if we reverse both arguments
we could do that with a over operator
which pre-processes both arguments with
reversal and for ease of comparison
let's also indicate what's going on over
here so let's reverse that as
well so if now we can see that we
are looking for the beginning points but
if you're reading in Reverse that's
actually the end
point so the only thing that's missing
then is reversing the
result and now we've got the end
points can give this a
name and then we can apply it like
this that's another solution thank you
for watchinghello and welcome to this
epl quest cfl wiki for details
today's quest
is the 10th and last problem from the
2014 round of the apl problem solving
competition
we're given a vector of numbers
supposedly non-zero
and we are to say uh what the largest
percentage increase is from
one
number to
the next number
so let's start with a simple test case
from the problem statement
and
one way that we can do this is by seeing
what is the the what are the deltas what
are the differences from
uh
once a month
so we can what we want to do is a
pairwise
difference
over this vector
and here it's all constant but it
doesn't matter
and then we want to see
this increase
what percentage is it of the month that
we started with so
um that means the first 20 is an
increase over the 80. the second 20 is
an increase over the 100 and the third
third increase is over the 120 that is
there's no increase on the 140 and we
can therefore drop the last element
and now we just need to find out what
the fraction is of these so we can write
the first
part
so that's the the increase
divided by the month that the the month
that we started with its value
um and then we get well fractions but we
want percentages we also need to have
the largest percentage and so a good
idea is to start off by reducing the
number of numbers we're dealing with so
we want the maximum percentage
and then
we want to convert it into a
percentage there so we need to multiply
by a hundred and let's make this into a
function that takes an argument
right there
here's an interesting thing
to look at
this negative one drop
another way we can think of it is
that we for every
window of size 2 much like what we did
to get the deltas the differences
we want to select the left one
and we can actually write this
as a pairwise reduction as well but
instead of a normal arithmetic function
we just want the left value
and
if we use a negative number as the the
window size just like we did for the uh
for the subtraction then we will reverse
it
so now left so this reverses the range
so instead of getting 80 100 we get 180
and then we select the left one but now
if we want to get the right value which
is the
the first one then we need to do
the right side instead
and what's interesting here is that if
we take this definition of a
um
and
use
we can replace this negative one drop
omega you can um with this equivalent ex
sub expression here
then especially if maybe if we
parenthesize it we can see a pattern so
and let's start by by calling this one
renaming and the a here
but we could actually
combine these because we are doing a
subtraction
divided by the right side
that means we can we can fuse these
together
to a single
n-wise or in this case negative two-ways
uh reduction and
this parenthesis becomes um unnecessary
and that looks really neat
that doesn't mean it's a good idea to do
it
why is that because
um certain combinations that are
very frequently occurring for example
and a n-wise
or especially two-wise pairwise and
subtraction
and also the right and the left
and those are cases that are special
uh special case in the interpreter and
optimized and will run much faster if we
replace them with our fork like this a 3
train
then the special case doesn't run and
we're going to get significantly worse
performance and we can illustrate this
just even with a not very large argument
so here's a thousand
random numbers up to a thousand
and
let's copy in cmpx from the defense
workspace
and then we run the first version which
uses the two different and
two different anyways reductions and the
second version which uses the fused and
wise reduction but otherwise are
entirely identical
and
we can see that yeah that's that's
pretty hopeless in comparison so we
definitely want to stay with a there
but we're actually not done we can
actually do and
something more
um let's let's look at a again
and then let's uh actually we can we can
start off with with b even let's start
off with b and then and we can do some
uh
some well
mathematics uh deriving some some a
different expression for this um
let's start off by taking this train and
making it into maybe a slightly easier
to read and read even so
let's put in our test case here um so
make sure it's it still works
and then we are replacing this train
with the defense so and what we need to
do here is
we have the subtraction of the left
argument in the right argument
and then
divided by the right argument
okay that so far we've just replaced
the the train with a
led and now
since this is a fraction right we have a
numerator and a denominator here
that means that we can multiply or
divide above and below the
the division and
and the result will stay the same
so
let's divide by the right argument here
and divide by the right argument over
here as well
same result of course just it's a good
idea to check that and we can
immediately see omega divided by omega
that should give us one remember we said
there are no zeros here
at least presumably there aren't
um and then
this is
a
a difference
and they're divided so we can we can
split this up into two fractions instead
so we can say
alpha divided by omega minus omega
divided by omega
and then of course this becomes a one as
well and we have also divided by one
here so that we can eliminate that as
well
okay
and
getting there now
we're doing a bunch of divisions here
pairwise divisions and from every
division we are subtracting one from the
result
that means we could just break out you
can do the all the divisions first and
then subtract one from all the results
instead
so we if we take this
negative one and
move it over here
so we add negative one to that i'll get
rid of this parenthesis of course
and that then we have a little defend
that is nothing but a cover function for
a normal division
so we can just put in a normal division
there instead
and now we're subtracting one from all
the results and then we are taking
the maximum of that that means
they would already that the one that's
the maximum would already have been the
maximum
before we subtracted one so we can move
this
maximum before that that the difference
here is that instead of subtracting one
from a bunch of different numbers we're
just subtracting one from a single
number namely the maximum one
and here we have a whole
new formulation of it
and that is not only shorter than the
original um
but actually better performance as well
let's try it so we found that a was the
first one but we derived c from b where
we had diffused and diffused nys
reduction
so c
so why is it that we are making we're
having such a significant difference uh
between
these two well remember
we do we're doing the nyx reductions
those are the ones are actually doing a
lot of work and in the beginning we had
two n-wise reductions
we had the one to
compute the differences and the one to
compute the origin value
that we were to compare the difference
against
whereas in this one
we're
the the the work that's being done here
is only a single nys reduction so over
there we had an
n subtractions and then n selections and
then n minus 1 divisions and here we
have just
n minus
well it wasn't even n it was actually n
minus 1
subtractions it was n minus 1 selections
and then there was n minus 1
divisions
and here it's just an n minus 1 division
and then we're doing the maximum which
we have to do anyway
and then we're doing a single
negative one plus and a single one and
plus that doesn't really make a
difference there so that's why that we
are we're cutting significantly down on
the time it takes to compute this and
the resources takes to compute this
thank you for watchinghi
we're going to find out where a
chess Knight can move from a given
starting position
the different ways to attack this
problem
and they fall into two main categories
we could start with the starting
position and compute all the places
where the Knight can move or we can
consider every possible position on the
board and ask ourselves whether the
Knight can move there and this letter
method leads to simpler solution so
let's try that
as an example case we're given position
five four but let's not actually use
that for now we just generating
a chessboard
this is a Lambda and the index generator
which generates
an array of shape 88 that is eight rows
eight columns
and every element is
the position of that element or the
indices of that element
so every element is a vector of two
elements because there are two
dimensions
and it has then the index for that
position
now if we subtract
from every element the entire argument
we get the distance
vertically and horizontally from each
position to the starting position
and we can spot our starting position
here by being 0 0 of course there is no
difference between the starting position
and the position where well we are
starting and neither
vertically nor horizontally
and what we're after are the valid moves
for a night which you could see as
moving One Step In One Direction and
then two steps in the orthogonal
direction or the opposite it's the same
thing of course it's an L shape so we
could move one step right and two steps
up or we could look at it as two steps
up one step right
or we could go one step up two steps
right and so on two steps to the right
and one step down
what is common for all of these we can
spot is that
um not that one that one is that they
all have a difference from a starter
position that has the numbers two and
one although they may be negative or not
so we could generate the list of all the
differences so we would start with
negative 2 negative one and then
negative two one and then negative one
two and so on and so on there will be
very long list and we could then look up
to see if
for each difference whether it's a
member of that list of permitted
distances
um but since that list is very long we
can shorten it a bit by taking the
absolute value of first
now all the places you can move to are
either one two or two one so we can look
with membership
but we want the lookup array on the left
so we swap the arguments of the
membership function and then it has to
be either one two or two one so now for
every absolute value differences in this
table of differences we look up if it's
a member of that and that gives us a
Boolean array
indicating
the positions where our knights from the
middle here can move
of course we're not interested in this
Boolean array we want the indices where
it is true that it can move and for that
we have
the where function which gives us the
indices of the truths
and this is a solution which is pretty
elegant
but I think actually there is a needed
solution
so if we cut back again to where we have
our distance table
then we can use a little bit of
mathematics the Pythagorean theorem says
that in a right triangle
the
two shorter sides
if you take the length and square them
then if you add them together you get
the square of the diagonal
oh this might not look like we're
dealing with triangles but actually to
move from the starting position and up
here we can see this moving at a
triangle with a side that has length one
it's one step to the right here and the
side that has length two which two steps
up and so on the order of them doesn't
matter because it's just a sum
um so we can start by
squaring
the
distances here and then it doesn't
matter which sign they have either
because you square a negative number it
becomes positive two so one way to
square is to multiply by itself so
multiplication and then the same symbol
that we used for commuting the arguments
or swapping the arguments we can also
use for what I like to call a selfie
because it looks a little bit like a
selfie face
um so this is self multiplication
so now all the values have been squared
and we can see here that now we're
looking for all the places that have a
four and a one or one and a four
now we can sum so this is a plus
reduction each one of them
and here we can see that the places we
can move to are the ones that
have five as the total sum so we're not
actually interested in the length
of the diagonal
we're just interested to see if it's
Square length is 5.
so we compare all these values with five
and that gives us our Boolean mask and
then as just as before we ask where are
these ones
and that gives us our solution
thank you for watchinghi
so this time we are going to emulate
some behavior in an APL interpreter
which is to print out
um arrays
but instead of printing them out one by
one we're going to combine them into a
single array which will look the same
that's the point
so here's some sample data
and well if we print it out we get them
next to each other but if we print them
out one by one
instead then they end up on top of each
other like this and so the idea is we
need to generate an array which looks
like this when we print it out
and there are a few different approaches
to that I'll just show a few but when we
had the chat session then we had a lot
of different ways to do it including
some very silly ones
okay so
um maybe
the simplest way to do this
is to split the display of each one into
separate rows and then
combine all the rows into a single list
of rows and then combine them all into a
single Matrix and that's basically it
and there are a couple of things we need
to watch out for that so here is a a
different Lambda and we take this data
and there are some issues with
um with simple scalars that mess up our
algorithms we can take that in a moment
so we'll start off by
formatting each element of the right
argument so this doesn't actually change
how they look at first but this makes
them into character
um arrays they might be scalars vectors
or matrices because we don't have any
higher rank elements specification
so this will look much the same now when
we and we can split each one into its
constituent
Parts into its rows
which for vector and scalar is not going
to do anything significant just try to
enclose it
so we split each and this gives us all
these rows so now we can see that if we
were to combine
all these arrays here then we're going
to get the rows of our final result so
this is exactly what we're going to do
we're going to do a concatenation
reduction
and now they've been combined but
they're also enclosed because a
reduction reduces the rank and we had
here a list that's rank one so we have
to reduce it to rank 0 which we need to
unpack so that we do a disclose
and finally we mix to make this Vector
vectors into a matrix
and we get this result
and that is in fact a matrix we can see
if we select this and there are a bunch
of headed spaces at the end this is why
it's important for us to
um so format it otherwise we might get
padding with numbers instead
one little thing kind of style thing we
have two Loops here two eaches we can
merge them to a single Loop by doing an
a top instead so every time we format we
finish off post processing with the
split and then we go to the next element
however there are some issues here and
there is if we have
um
just simple character scalars
then we get the wrong result this is
supposed to be stacked on top of each
other remember
if we output each one separately then
they go like this
and the problem is that this gives us a
scalar and it doesn't change the format
doesn't have a character doesn't change
and so when we split that nothing
changes and then we just merge them all
together and basically there's no change
all the way through all no apps we can
fix this by making each one into a
vector
how do we make a scalar into a vector
without making uh any effect on any
other arrays and there is a trick
and that is to do a replicate so
replicate takes
a um an array on the right
and a some multiplication Factor on on
the left and then it it replicates the
elements here if we do a one
then we see no change but the important
thing is that it needs an axis so if we
ask what is the shape of this it is
three what is the shape of a scalar is
an empty Vector it has no X's
um but if we do a replicate on it then
this has to return a
um a vector because if the number was
higher we'd have to have a vector if
we're replicating along this axis the
single axis that it has so this became
but on any other array then a scalar
this has no effect whatsoever
so we can go up here and do a one
replicate on each and that gives us our
result and if we try to do it on our
test data then it looks just the same
because one replicate does not have an
effect on any other arrays
okay this was one way and to do it
another way to do it is to take
advantage of apl's default display
and the way we're going to do that is
again we start off by making sure that
our arrays are not scalar so we don't
end up any any problems with that and
then
instead of just formatting them right
away we're going to stack them on top of
each other so we have a vector
of vectors and matrices now
and if we use the magnetic comma bar and
that is a table function it makes sure
that that the argument becomes a table
so if it's a vector it becomes a column
Matrix instead
and if we then do a format on this
then API will transform this nested
array with various data types into a
uniform character array and there's
going to be a matrix in this case
because nothing has higher rank
and well look we almost got where we
wanted
there's just one issue there's one space
too much on the left and one space too
much on the right but that's easy to fix
and there are a couple different ways
maybe the most straightforward way if
but not most efficient
is to do a transpose so put the whole
array on its side that looks all very
silly drop the first row and drop the
last row so that's negative one drop
drops from the from the rear and then we
transpose back again
and now we've got the right result so
this is one way to do it another way to
do it would be with the rank operator
and so we could say here uh
rank drop rank run one that means drop
on each row and we also need this one
we can also combine them
into a single thing so if we make a
little tested function here and we can
write it like this so this is saying the
argument and one drop from that negative
one drop from that all of that is rank
one
and that also solves the problem
finally we can kind of sidestep this
whole issue of
um combining the arrays into a single
array and making them match in the width
and so on
and we can do that
simply by formatting them and then uh
concatenating and
Carriage returns or new lines to them
so how do we do that this time we're
going to go test it right from the
outset we'll start off by formatting
each one and this time we're not worried
about and about making them into
vectors
or higher rank because we're going to
concatenate a new line to them and then
the result is going to be exactly the
same becomes a vector at that point
anyway
so
here we have formatted each one of
course this looks much the same so these
are now character matrices we can see
the
um that if you try to add a number to
them but trust me from this
and then we want to have a concatenation
on each of each one
with a new line so how do we write a new
line in a tested function and we're
going to use the Unicode character set
on universal capture set system function
and with an argument of 10 for a line
feed you could also use 13 for character
turn
problem is this messes up our tested
function a bit really we want a fork we
want a left iron here which is the
formatted thing and we want the new line
on the right and this is a constant and
we could parenthesize this
and may use the constant operator so
this derives a constant function and
this adds then a new line to the right
on each one
and this will look very silly
spaced out this is because we added an
extra new line after each row but they
are also already matrices so we get this
double spacing
okay slightly more elegant and less
efficient but it looks cool
um is to
compose these two functions together
they concatenate each with the UCS
and then we have the the 10 as the
constant function so now the fork looks
like this we have the left line the
format each the right time is the
constant 10 and
and the middle time is the concatenate
each with the Unicode value of and then
we get that 10 in so this gives us
exactly the same effect and we don't
actually need spaces and space there
okay so now that all of this is in in
place we don't need the structure
anymore we don't use these matrices we
can just make everything flattened out
enlisted and we can do that with the
inlist function
and well there we are this one issue is
that training line break here because we
added one to each
so we just need to drop the last one so
negative one drop and then because this
is a magnetic function and we again need
this everything to be a fork so this is
one function which is a forking itself
and this is a left eye in here so we
need this to be a function we compose
them together so pre-process the drop
with the list
and there we have it a third solution to
the problem thank you for watchinghi this time we have to remove any
elements from a given list uh that are
not in an non decreasing sequence from
the beginning of the list so at the end
we have something that's sorted but
potentially shorter than the
input and um here's some test data that
that we're
given and there are a couple of
different ways uh we can do this
let's look at a very literal
interpretation of uh the problem
statement so here's an an anonymous
Lambda and we want to compare adjacent
elements to see if they fit so we can do
that with a two wise or pair wise less
than or equal to over the
argument what this means is that one is
less than three and three is less than
seven uh but seven is not less than
three so the first element we always
want to keep of course and then uh
because it it that's where the sequence
begins and then uh this one we want to
yeah so this one we want to keep this
one we want to keep this one we're going
to keep this one we want to remove
because um it's outo sequence five is
greater than three um but it's not being
eliminated by the first
pass so um let's put in a one here to
keep the first
element and then um we take the argument
and filter it by this
mask uh yeah here we
go so here the the five is there the
eight is is there and that means that we
really have to apply this again
so if we use the power operator to apply
this
twice
then we can see that we have eliminated
the five however since we have the two
fours over here at the end uh they still
survive so we need to do it
again okay this is good if we keep doing
it then nothing more happens and then
there's a trick that we can specify a
match instead of a number and that means
it will keep doing this until there are
no more differences so until two
consecutive iterations match each
other and go give this a name and we can
do ft and that solves the problem
however it's not a very efficient way of
doing it because we are doing a multi
pass uh on this so instead what we can
do is a single
pass and the way we can do it is by
scanning using maximum so this gives us
the largest value that we have seen so
far okay we can still see T up here you
can see we never go down again now we
just need to keep the elements that are
either
and um
already well we need to keep the
elements
that match the current maximum because
if they don't match the current maximum
then they must be smaller than the
numbers we've already seen and they need
to be
eliminated so equal to the maximum this
gives us the corresponding
elements and then we just do the
filtering like did with the first method
so here's a single
pass uh
solution for the elimination sort thank
you for watchingwelcome to this third apl quest see the
apl wiki for details
today's quest is the third problem from
the 2013
round of the apl problem solving
competition what is in a word
task is to write a defend which returns
the number of words in a given text
which can be given either as a single
character or as a vector of characters
what defines a word
for the this problem
is
a space delimited but there could be
multiple spaces between words that can
be leading and
training spaces in the input we have to
account for that
let's begin by creating some test data
so this is a normal text but i put in a
dash here
so that we make sure that we're
splitting on the right thing
this is a single letter
and we can also have an empty input
and then we have a text with more spaces
so we can have some leading spaces
and maybe some training spaces as well
okay let's get started
um
maybe the most obvious approach is to
split on sequences of spaces and we can
do that or let's say if we start by
comparing
an input string with a space
and this gives us a boolean vector
indicating where the spaces are
now the partition function um
groups
runs of ones or
elements corresponding to runs of one so
we want to
invert this
and then we can use this to split
so we use partition
on the string itself
and that gives us the individual words
and we can count them
if we try to do that on
on the string that has more spaces we
can see that it still works forwards
there and that's because any run of
zeros is a
an area that gets cut out
and
we split up at that point
now this runs into a problem if we try
to do it on a single letter
and that's because we cannot petition
when there are no access to petition
along so we must ravel first
and then it works it also works on the
empty one um that's not a problem
so we can put this uh together to a
fairly straightforward uh tested
function
um
it we want
we want the tally
um off
where the
spaces
are different from the argument
partition enclosed the revel of the
argument
so who we are binding the space to is
different from function to
achieve a magnetic function there
if you come from other programming
language background and especially
perl you
[Music]
might grab for regular expressions for
this so we can try that approach as well
and we have
our string and then
we have the quad s that's a string
search
regular expression search
and the pattern we want here are
with the inverted character class none
spaces
any number of
of those one or more
and then it doesn't really matter what
we're going to return
because we just want to count them we
don't actually want them so the best
option here is use code three which
means the pattern num in is in the
offset from the left and that since
there's only one pattern that's
just zero so we get a bunch of zeros
and then we can see we get one zero per
word
there and that works and also on the
scalar letter um and it works also on
on the empty
we just get nothing and then we just
need to count them
as you can see here so that
and that's our second solution
right there
okay here's a um
an interesting
solution that i came up with that's it's
kind of abusing a built-in functionality
a system function called vfi that's
verified and fixed input and really what
it does is it parses numbers so we can
see if we
give it some text
then um it
looks at this input as a space a space
separate the fields we can also have
multiple spaces and that's fine um it
removes all such extraneous spaces
and it returns a two element vector the
first element is
the success
and it says one e3 that successfully was
converted and the word 3 was not
successfully converted 2.5 was and 2.5
and was not successfully converted and
then the second vector are the values
that we converted to
and with zeros
for those tokens that could not be
converted correctly
now we're not interested in what the
actual values are we just want to count
how many such space superior the tokens
there were whether or not they could be
converted successfully or not so we get
the first vector which is this boolean
and then we can just count the number of
elements there and that gives us four
tokens so this
works for all our inputs even for the
empty one
and it works for the single letter as
well you just cheated as a text
here's one with more spaces and our
original string
so that's an additional solution in
order for this to be a proper function
that we can give a name
then we need to bind together
compose together two functions for
example the first two we could also
compress
the second two it doesn't really matter
right um
so far for these
uh approaches where we're actually
parsing and splitting up
into tokens but there are better ways to
do this in apl
but for that we have to work with
boolean masks
and the way we often do it in apl we
compare a scalar with a vector so here's
our string and then we have
bits for each one now we're not going to
use this to
split up rather we're going to analyze
it
we want to know how many words there are
and what defines a word
is that we have
a separator and there could be multiple
separators let's let's try it with
m and then
we have something that's not a separator
so we're looking for this pattern here
where we're going from spaces to none
spaces
and again here from spaces to none
spaces from spaces it could be many
spaces to none spaces and that's what
gives us a count of words that's that's
one way to do it
and
the way we can do this
is by comparing adjacent
elements
so we do the envi and wise reduction so
here it's a two wise reduction
on this as this means we're taking every
pair of two overlapping windows of two
and comparing them to each other with
less than y less than because in a
boolean vector we can use less than as a
boolean function to find out it only
becomes true when you have a zero on the
left and a one on the right right run
one is not less than one and zero is not
less than zero and one is not less than
zero so that's the only time when um
when it will match and we can see here
if we it gets one element shorter
because we're doing pairs if we line
them up we can see how this one
corresponds to this zero one here or
every time we have a one we begin a word
um so this is fine then we can we can
sum this
and that gives us a number of words for
however there's a problem
if we look at our string again where it
doesn't begin with any spaces
then let's go back and see what happens
here we compare this
space and
so far so good but now when we do
the pairwise less than
then we're missing one element at the
beginning
because sure enough
there is
um and and
um
there's none space at the beginning of
the string
but we never go from zero to one because
there's no zeros there so we're missing
a one at the front so how can we fix
this and we can insert a space
so by inserting one space doesn't matter
if we have multiple spaces because you
know from from space to space
is just zero zero and that doesn't
trigger but this will insert a 1 at the
beginning you can see if we go back to
the one that already has spaces
then it doesn't add any additional ones
so this
gives us the solution and we can sum it
like this it gives us the number of
number of words
and we can just wrap this in braces and
then we have
our solution
oops
and this is a pretty good solution if
you want to optimize for performance
even more than this
then we have to think about how the data
is represented in memory
now as we come into our function
then we have this name a variable name
omega referring to the whole argument
and it may occur later again in the
function and therefore
the interpreter has to keep this value
available at all times
when we concatenate a space at the
beginning we'll need to make a new copy
of this
um and so this
if it's a very large argument then we're
going to spend a lot of
time writing to memory it's just a copy
of everything with a space in front
there are things we can do about this
notice that here the data type is
whatever type of
character array it is so normally it's
one byte per character but if we have
some unicode things in there you can end
up with two bytes or four bytes per
character as internal representation it
can be rather expensive to write the
whole thing again
once we've done the comparison
then we are down to booleans so that's
only one bit
per character because it's in in the
comparison and since we're adding a
space in the beginning and space is not
different from space so we know that
we're going to begin with a zero
and that means we can put in a zero here
and avoid
copying the whole array and that's going
to give us somewhat better performance
but there is even more we can do because
if you think about what's happening
again
we have a boolean array here and we have
to rewrite that
when we insert a zero in the front
because in memory we have a header that
introduces the array and then we have
the data from the array
if you want to insert an element at the
beginning
then every element every bit has to move
over one step we have to rewrite that
whole array we can do that in place but
it's still a rewrite
so if we can get rid of that
inserting something at the beginning
that will give us a performance benefit
now
how can we do that well if we think
about it the only reason we want to
insert a bit the beginning is because we
need to make sure
and
to get the right result
when
um
when we don't have any leading spaces
in other words if we're missing a
leading space
that means we're beginning with a word
that's not being counted
and that means this mask this boolean
array the first element indicates
whether or not
we're beginning by word so we can just
add that value to our total count
so we take the first element
of the mask and add that to the
to the sum and then we just have to save
the mask value
right there give it a name
um here's an another problem and which
is
if we have a one element vector or
scalar here then we can't do the
pairwise thing correctly um
so
well actually we can do it if we have a
one element if you have a scalar we can
do it correctly because
um so we have to revel that as well
but there's actually a simpler way to do
it um and that is simply inserting value
on the right now
if we think about it we're doing pairs
and we're doing with less than and what
we want to do is detect the words we're
going from
spaces to none spaces
but instead we if we detect the end of
the words meaning going from none spaces
to spaces
then we only need to append rather than
prepend a single value
and appending something to an array that
is often very cheap because we don't
need to move all the elements of the
array rather we can just extend it by a
little bit the interpreter by default
will
allocate additional memory at the end of
the array and if you're talking a
boolean array like this that additional
bit might even be inside a single byte
that has already been allocated making
it even cheaper to do
so how can we formulate this well we
can't just put a zero um at the end if
we go back to this solution here because
what we want to trigger is another now
we're not worried about the a word
beginning at this rate at the beginning
of the string we weren't worried about
words ending at the end of the string
um and we need to have another and
another triggering of a word ending so
word endings are indicated by the
pairwise
less than
and we only get those if we have we only
get an indication if we have a 0 on the
left and a 1 on the right
and also now since we are
we're interested in uh where the spaces
are at the end of the words
then and we need to flip this around
to an inequality so let's actually try
this so we have our string here
um let's print it out again so we can
see
so now we are we are trying to find
these places where a word ends so we go
from a 0 to a 1
and the problem is at the end there's no
space there
so what we can do is we can go and
instead of doing a normal concatenation
we're doing a flipped or commuted
concatenation
and this shows us the word endings even
for when the string ends with a word
character
and now we can do
the comparison as before
and we can sum that
to get the the word count we can try
that with additional spaces as well it
works as well let's let's look at what's
happening here so m
is this one and there are additional
spaces at the
at the end
and then we compare two spaces
and we can see there's a an extra space
there at the end but it doesn't matter
when we then concatenate another one to
the end because the only thing that we
find is when zero goes to one
so
it all works as it's supposed to and
then we can we sum it and we get our
result
we could also have done the opposite we
could have kept the inequality and
appended a zero and flipped this the
direction of the comparison so it would
be greater than instead of less than it
would be exactly the same
and let's give this a name
we'll put the argument name name here
and let's look at
all our definitions
that we have
um and at this point we're going to have
a look at what the performance looks
like and i could predict this already
splitting up into sub strings is going
to be expensive we're going to have lots
of pointers one for each word
and spinning up a regex engine is going
to be expensive as well
and the same thing with quad vfi is
going to be expensive because we're
actually trying to parse
every single token whereas we only
really need to look at where those
tokens are to count how many there are
so it's absolutely certain that the last
four solutions are going to blow the
first three right out of the water
let's see how how
badly so let's create a text
here a testing for testing purposes
um and we can see
we're going to
um let's just try it first to see what
it looks like here we reshape 4
into 20 elements and then random
elements so we're going to create some
random text here we can see what that
looks like so that looks kind of like a
natural text we don't care about what
the characters are
okay let's make it big then
so here are a million of characters
let's
copy cmpx in
from the defense workspace
and then we can
start off here with f on t
g and t
h on t
and just just take i which is the least
efficient going to be off
of these and to see what that looks like
together
give it a moment to compute
and we can see indeed
that the boolean mask-based
solution it's not even measurable in
speed compared to the others
but interesting the
most expensive one was spinning up the
regex engine to do this quad vfi had to
do a lot of work as well in identifying
the tokens and splitting into substrings
was then the fastest among these
now let's compare
the the four boolean solutions to see
if
what we expecting is actually holds true
so this is i j
k
and l
and we'll see that
our expectations held up um
the solution where we prepend the space
and therefore had to copy an entire
array consisting of one byte per
character and was the slowest one
when we uh changed to
prepending a bit to a boolean array that
gave us a significant speed up about it
took about half this amount of time
but
avoiding the copying of the array either
by saving the mask and looking at the
first bit of it or by
appending a bit rather than preventing a
bit gave us the most significant
savings
thank you for watching and see you next
weekhello and welcome to this very first
episode of the apl
quest where we go through
one problem every week
from a past apl problem solving
competitions phase one have a look at
apl wiki for the details
today's problem is the first problem
from 2013
where we are asked to write a different
generate odd numbers
let's start by generating some numbers
let's say we want to generate the first
10 numbers
problem here is that these are all the
adjacent integers so we multiply by two
getting us every other
number and then we can offset it by one
for example we can take a one and
subtract it so we're swapping the
arguments on the minus so
there are other alternatives we could as
well
add negative one
to this
or we could parenthesize it
and for this we can build our defen
oops that's the argument name omega and
we can try it
and there we go
now as you can see
by default apl starts counting from one
a lot of people computer scientists
especially some mathematicians prefer
standing starting counting from
zero instead and apl allows you to
choose that so we can set the index
origin to zero and now
um
we
count from zero instead
this has upsides and downsides
upside of course is you can choose
whatever fits your problem and your
comfort
downside is that if you share code with
others you need to make sure you get the
right index origin you might need to set
it yourself and so it's a classic
problem to
try to write code that works with any
index origin and we can see that if we
now
try to apply a function it gives an
entirely wrong result
so that's no good the corresponding
function
for
index origin zero instead of subtracting
one would be to add one
there are other ways of generating
this um yes the problem asked for a
defense but we can also write tested
functions in apl
so here's another approach let's start
by
writing the framework for a tested
function so we put some parentheses here
and then we can do two times and not the
name of the argument but rather the
identity
of the argument so the density function
and we can
get 20 there
then we can use this
to reshape a bunch of
zeros and ones
so this is zero one reshape we swap the
arguments from the reshape so the shape
on the right and the content on the left
and now the only thing we miss is
asking for the indices where there we
have the true values or the ones so the
where function
and uh there we go this was index origin
zero now let's switch back to index
origin one
um and of course this won't work anymore
rather we just have to flip the ones and
the zeros
and there we go
okay and that's
all very nice but how about if we wanted
to write a function that could work with
either setting of quad io of the index
origin and there are various uh
approaches to that
um here are some cool ones that came up
in the live event
let's say we start by multiplying the
argument by 2
and then generating
those
integers
and now we take the parity of that so
that's the
two residue or modulus 2
of that
and now we ask for
where
we have the ones
okay that's good now what happens if we
change
uh to quarter yo zero
okay so
this part up here
gives it starts off differently
and then when we ask for the parity we
get the
opposite but that's exactly what we want
when we're using quality of zero
which means if we ask
where
are the ones we get the right result so
we can see that this function works with
either
either origin let's give it a name
argument goes here and really what's
happening is the the iota the index
generator and the iota underbar the
where function are cancelling each other
out
so
quadrio
gets one
and this works and quad io gets zero
and it still works so it's a really
clever solution um for writing
it in a way that doesn't matter which
index origin you're using
now the reason we're bumping into this
is because we're dealing with indices at
all we have the index generator we have
the where function which is the indices
of the true values
but we could also go about this in a
very different way in a mathematical
way so if we observe that we start with
a one
and then we
increase
with two every time
that gives us that's an interesting
property
so
let's say like this let's take we're
using overtake here so we're taking the
first 10 elements
of a one
now there aren't 10 elements in the one
so apl will pair with appropriate fill
elements which are zeros
we can subtract this from two
and notice here that we have the
beginning element the one and then the
offset to the next number over and over
which means if we ask for the cumulative
sum or the plus scan
of that we get all the odd numbers and
since we didn't use any index
related functionality
then
there is no influence from the index
origin so we can put this into a
function
as well
argument goes here
and we can try it
f10
and quarter one
f10 there we go
um
now let's say we wanted to go back to
our original formulation where we
started off with
two times
the
integers the indices
so in one case we wanted to
subtract one that's when what i o is
one in the other case we want to
add one that's in the case when quadrio
is zero
so how could we adjust this of course
both the subtraction and addition can be
seen as an addition you just need to
either add negative 1 or you need to add
1.
so that means if quad io
is 1
then we
want to subtract 1.
and if quad io
is 0
then we need to add one
and we can map this in a mathematical
way
so we have either a
a zero or a one
and if we take negative one and we raise
it to the power of those two
then for the zero we get one and for one
we get negative one which is exactly
what we want so now we can write our
function
as
negative one raised to the power of the
quad io and this will just take whatever
global quatero is currently in effect
and we add that to twice
the indices
so now we can try this was quad io1 and
quota was zero
and it still works
let me show you another very clever
solution it is as follows
iota
plus iota
minus the tally
this is a tacit function
we can apply it and we can see that
indeed it works um let's see what a
structure looks like it is a fork where
the right tie end of the fork is itself
a fork we start off by subtracting the
tally from the indices now what is the
tally that's how many major cells there
are in
the argument now a symbol number is
just one so
this is a clever way of subtracting one
from
the indices so let's try that we have
the indices
and we're subtracting one
and then we're using that as right
argument for plus
and the left argument is iota applied on
the argument so the indices again
now if we add these up
then well you cannot probably see this
already that we get exactly what we
wanted
and so the way we can write all this
together is
the indices
plus the indices
minus
the tally
and we can give this a name and apply it
like that
and that's all for today
thank you for following alongwelcome to the apl quest c appeal with
cupid details
today's quest is the eighth from the
2014 round of the iphil problems of
solving competition where we are to
compute the distance between two points
in and space this is really a very
simple problem
the distance is the square root that is
there
to raise to the power half of
the sum
of the squares
of the differences
along each
dimension
so we can test this
and we have another test case and this
is 2d space so let's try a 4d space as
well
we could say u1 a
v1
and
u2 a
v2
right
so this really solves the problem um and
there's not much variation one would
really want to make here on this
however there are some
interesting things we can do
since we like computing things on the
entire race and let's try to do this on
multiple arrays
on multiple vectors at a time points in
in the space at a time and so there are
some fun tricks that we can
take care of here
let's say we have a collection of
points but
this u1 and
u2
they don't have the same number of
dimensions so if we try to mix them into
a flat matrix
then we end up getting padded with zeros
on the right
that's actually not a problem because
when we do the same thing on the other
point
we get zero zero minus zero zero squared
sum it it doesn't actually contribute
anything and so it doesn't hurt our
computation that means we can kind of
upgrade all points to the dimensionality
of the point that has the highest number
of dimensions
so we can try this
and
that works
quite well
now and here's the thing
we might want to
define our function in terms of leading
axis notice here we have summation along
the trailing axis
and indeed um if we try to express this
in a test form
then we naturally end up there
because there's a common trick
to use
the problem of having multiple or even
one magnetic function inside a
test definition if you try to do this
then there's a problem here that we have
a magnetic function here and what we
could move it over as an atop on the
power but another trick is to use uh one
base as summation which might even be
faster on
non-integer
numbers
and now the summation goes vertically
which means if we try to use the same
thing
we get an entirely wrong result
that is of course because
we are subtracting the two matrices
correctly
and then squaring them correctly and
then
um we have now in our case a two by four
matrix and instead of summing along the
rows we are
uh summing along the columns and that
has those we're mixing up the two um
inputs that have nothing to do with each
other
in that case we would want to state our
arguments in transposed form which means
that each
row or physic each major cell represents
one dimension in
n space
so this can work as well
um to spice things up a little bit let's
do some uh some code golf as well so
we've got b here
and we can actually
we can create something that's a bit
shorter we can remove the zero from this
power here
it decreases readability but it does
save a character
and then here we are summing the squares
now summing square same thing as summing
the self multiplication
and and so we could write that as
uh summing on
the self multiplication
here but this you should recognize as
being an inner product
and so we we're still not it's still not
correct syntax because this is a
magnetic function applied on this static
function here
and so we could make it on top and then
it would have about the same performance
as before but because this is a selfie
meaning we are
we are taking the
the difference
and using it as both arguments on the
inner product then we could just
subtract twice which of course is a
waste of
computation resources but it can be done
so we could state it
like this
um so this is a fork and then that's
used as the right time in this for the
fork
so
this is
code golfed and away and it will still
work
but it won't work on
the higher rank arrays because it's
trying to do a matrix multiplication of
two arrays that are two matrices that
are not conforming with each other
so that doesn't work
finally um
note this that we're doing subtraction
then we're squaring summing and then the
square root which is the square root is
the inverse
of the square which means if we had the
under operator which allows you to do
some operation
so to say under the influence of some
other operation we could sum under the
influence of
squaring now we don't have that as a
primitive but we do have it in apple
cart
so we want the under operator that uses
the inverse
and we get this formula over here
so let's call it like this
and now we can use a i can write a
definition here which uses
under
so
it's very simple it's just summation
under
squaring or self multiplication if you
want on
the difference
and then we can try that
and we get the result and it should even
work with
our high rank things because it's the
same
summation along the rows as what we had
before
if we had uh if you compare now uh the
our code golf
thing here
with um
using the under operator
this is kind of nice and then there's
one it's one character longer
but if there was a primitive under
operator
then it would actually be a character
shorter in which case i would say the
nicest looking expression would also be
the shortest one thank you for watchingwelcome to the apl quest c apl wiki for
details today's quest is called
gothforth and multiply
it's really simple we just need to make
a multiplication table
it's the eighth problem from the 2013
round of the eppl problem solving
competition
for once we're going to go straight to
the obvious solution
well we can generate the indices from
one to
a certain target number
and then
we simply need to provide the outer
product
using that argument
both on the left and the right side so
both vertically and horizontally in our
table and this gives us our
solution
so just get rid of the argument and we
can give it a name
and now we can apply it
as you want and it works even on zero
okay now let's go to have some fun
because this problem is already sold
the first thing we're going to do
is try to solve this without using the
outer product which is otherwise the
obvious solution
and a couple of different ways that we
can do that
the first thing is to use the definition
of the outer product the other product
pairs up
every element
from
the list on the left with every element
from the list on its right
now we can actually use a property of
the multiplication
that it
maps or distributes over
multiple arguments so if we pair up
every element from and our list of
numbers with the entire list of numbers
then that will be the equivalent so
let's say we have
the numbers here and then we multiply
using
sorry we should not use our product we
should multiply using a rank and we want
every element so those are scalars rank
0 from the left
and pair them up with the entire vector
rank 1 on the right
using this iota 7 as both right and left
argument and that gives us
our solution
so this is just using outer product in a
hidden way because this is the
definition of outer product for scalar
operands
we can do one more fun thing
i think a lot of people are not aware
that if you give a vector argument to uh
iota
then it generates all the indices of an
array with that shape
this actually holds true even for a
scalar one element vector
as well
and now since
these are the indices
those are also the corresponding numbers
that need to be multiplied together in a
multiplication table
so we can simply say
that we multiply
and across these or we reduce each of
these
pairs of numbers
and with multiplication
and that gives us our solution as well
and there's even more fun we can have
let's start again with these numbers and
this time we reshape them into the shape
of our
multiplication table
so this just gives us repetition
and now what we can see is
that
multiplication is just a series of
additions so on the first row we we need
our original
numbers from one to seven on the second
row we want the numbers from one to
seven added with
the numbers from 1 to 7 again and in the
third row we want it added again so this
is simply the cumulative
addition going down
and we can easily write that
as
the plus slash bar
so this is uh class
backslash bar this is a cumulative
vertical addition
and that gives us our multiplication
table as well
and we can then write this as a function
wrap it in braces replace the sevens
here with the argument
and that gives us our
solution as well
we can even make this test it
we can observe that this is a function
application of iota on the argument and
this is duplication on the argument
duplication is could also be written as
self-concatenation
because we could
express this as omega comma omega
so now we can write this testedly as
self-concatenation with iota on the
right
and
then this is our tested equivalent
let's have even more fun let's eliminate
the iota how can we eliminate the iota
well if you take seven and use it to
reshape one we get seven ones
and now we can do the same thing the
cumulative addition on those
that gives us the equivalent of the iota
and then we can proceed as before so we
can write this testedly using the same
technique as before you want the
cumulative
vertical sum of the self
concatenation
reshaping
the cumulative sum
of
reshape with the right argument of one
so now we can apply this and we get our
multiplication table yeah i know it's
silly but it's a nice exercise and can
give some insights into the relationship
between
the functions
and we can even take this uh one more
step
we can
by saying that instead of one here we
can observe that a scalar has a total
count of elements which is
one
so we could
use this as well
let's do
this step by step
we take the self concatenation and
reshaping the one and then gives us all
ones
and then we just need to do the
summation
and row wise
and then we can do it column wise
like that and we can all we can put all
this together to a single tested
function as follows
we just
this one stays as at the top at the end
and
the horizontal summation becomes on a
top on the reshape
and there we go we've got
no iota and
uh you're not even implement yeah and
then
just defining everything in terms of
cumulative additions
okay so we can see that it's not a
problem to
implement this multiplication table
using
other functionality than out of product
let's take it one step further let's get
rid of all apl operators now we're only
allowed to use functions
okay
how can we do this
well what we can try to do is we can
start by generating our numbers
and now we can
recycle these
until we have enough numbers for them to
fill the entire multiplication table
so this just repeats them over and over
again
and then we need to multiply them with
the corresponding numbers which means
the first seven numbers here need to be
multiplied by one the next seven needs
to be multiplied by 2. so if again we
start off with the numbers from 1 to 7
and we now replicate them by 7 each
and now we can put these two things
together
and those are the numbers in our
multiplication table the only thing we
now need to do is to reshape them into
the right shape and we've got a
multiplication table
we can write this whole thing as a
function simply by replacing all the
sevens here with the name of the
argument
and there we have it
multiplication table
implemented only using functions no
operators if you don't like operators
there are other fun ways that we can do
this and we can take again
reshaping
the numbers over and over
and then we can try transposing that
and then we can see that all we need to
do is multi now we have the
corresponding vertical numbers as in
when we had the outer product and the
cars and and the horizontal numbers as
we had with our as the right argument in
the
uh for multiplication in the outer
product and then we only think we need
to do is multiply these two together
so in other words we can say that we
take this and multiply
with its transpose
and we've got a multiplication table
right there if we wanted to make this
into a function we could just wrap it
again
alternatively we could give it a name
but there are even simpler ways of doing
this
and that is by relying on apl's scalar
extension
you can always scale or extend
by using a scanner function together
with an enclose
so how is this going to work well we've
got our numbers from one to seven
and then we can enclose that it makes it
a scalar
now if we pair up these two
then then the scalar one two three four
five six seven gets paired up with one
and paired up with two and paired up
with three
so we can simply write iota seven
times the enclose of iota seven
and that gives us the rows of our matrix
the only thing that's missing
is mixing the rows into a proper matrix
and we can write this tacitly
simply removing the arguments so here's
we have a fork we have enclosed iota
applied in the argument and the yodes
are applied on the argument so we can
get rid of the mention of the argument
and make it
0.3
and we need to enclose off the iota
and there's our tacit equivalent
solution
now what you can observe here is that we
are computing the range the iota first
and we can actually break that so to say
out of the expression
by making it in the top
of
an iota so we want the enclose of iota
and
the identity of the iota
and then we mix that and that's applied
on the iota itself so this is a more
efficient silly solution
finally for the ultimate
challenge
is to implement the multiplication table
without any arithmetic at all so by
arithmetic we need to we mean things
like plus and times
and of course this might seem impossible
but we can actually implement
multiplication in the old-fashioned
counting stick
way and there are different ways we
could do it
here is an example let's make it a bit
smaller so we can see what we're doing
we know that iota can generate the
numbers that we need to get multiplied
together by using two of the same
but how do we
how do we actually multiply them
so what we can do is we
each of these pairs themselves can be an
argument for iota
and this gives us and
this gives us and for each one of these
pairs gives us
the indices of an array of those
of those dimensions
but of course
that implies actually some
multiplication say if we have three and
two that gives us an array that has
three rows and two columns and that has
six elements which is because it's the
number of rows times the number of
columns
that's where we're going with it so the
one the only thing we need to do to know
now is how many elements are there in
each one
well if we ravel them
and then we can count how many elements
are there in each one and we just
implemented multiplication table without
using any arithmetic whatsoever
so we can make this into a function
and that works or we could make it test
it
by observing that here we again have
the
um self-concatenation
and we are applying iota on that and
then we have these three loops the three
eaches that we can fuse together
and we've got ourselves a tested
solution
there are other ways
let's look at the numbers again
and now we use outer product and we're
going to write a custom function for the
outer product
the function that just returns a value
the value i'm using here is a hash or a
reference to the root namespace it
doesn't matter at all i'm just using it
as a placeholder value just to show that
i'm not using any numbers or any
characters any values whatsoever it
could have been any array whatsoever as
long as it's just a scalar
oops sorry i needed
the selfie here
so now this gives us a multiplication
table but missing the values we just
have a scalar in each position
however we do have the numbers as
arguments
so we can write
the arguments in here
and what we need we can then do is we
can replicate using this
so we just instead of having a single
reference to the root namespace we now
are going to have one reference two
references three references and so on
and then we can replicate again using
the left argument and effectively
this is a multiplication
it's the replication of a replication
and here is the multiplication table in
unary
we can convert from unary to normal
numbers simply by doing a
tally we've got a multiplication table
so this is another solution
here here's another fun one
we can take
the numbers
and do an outer replicate
on these
so here we have
one ones two ones three ones one two two
two two three two and so on
we can already begin to see where we are
going with this
now what we can do is
that we we need to know how many do they
add up to in total and this is where
where the function where comes in so if
you do a where on each
as what does where do it normally gives
us the indices where where there are
ones in a boolean array
however
so for the first column it will give us
in this index one
and then index one and index two index
one and two and j3 if the but actually
what it does is it gives us this many of
the corresponding index so in the second
column we're going to get
two ones and then the next row
two ones and two twos
etc
and now
we're done
because this is the multiplication table
in unary completely ignoring
those actual values so if we just fuse a
tally on that we have a multiplication
table
it isn't quite a valid tested function
but there are various ways around it
we could
fuse these two together and then it
would be would be valid or
we could
compute iota twice
give it this left argument and right
argument to the outer product that would
also be valid
and finally
maybe for the most basic of
counting on fingers type way of doing
this
let's
try with
with these numbers and we're making an
outer product
on that with a custom function
and we are starting off with the empty
vector
so this gives us
one empty vector for every result these
are placeholders
and now we are going to take a value i'm
using the reference to hash again as
just a
placeholder value
and we're going to concatenate that to
the empty vector so that gives us a
one limit vector for each one
but we're not going to concat it with
cardinal catenated just once
we're going to concatenate it as many
times as the right argument shows so for
and for the columns in the first column
we're going to concatenate it once in
the second column we're going to
candidate it twice and so on
as we can see here
but we're not going to just do that
either we're going to
use to do this whole thing also as many
times as
the left argument says so the first row
we're going to
to
concatenate
this reference to the empty
vector
and we are so the first one we're going
to concatenate it once
once
in the second row first column we're
going to concatenate it twice
once
in the first row second column we're
going to concatenate it
once
but doing so twice
etc
and this gives us our unary
multiplication table and as before we
can insert tally
to generate our multiplication table
of course these are all silly and what
you should be doing if you want the
multiplication table is just the regular
outer product with normal multiplication
thank you so much for watchinghi
we have to look at a given number and
check if the digits
alternately
grow and Shrink that is there aren't any
digits next to each other that are the
same and you don't have a digit that is
followed by another digit that is larger
and then another digit that's even
larger or the opposite going down
so
here's a sample number
and we need to look at the digits not
the number itself
the way we do this is by representing it
in base 10.
but I hear you say
it's already in base 10.
that's only for us humans to perceive it
but really it's just a number and it's
being presented to us in what looks to
us as a base 10.
if you want an actual real base 10
representation of it
then we would want to have it instead as
a list of digits where each digit
represents the the count of a of units
of that size for that position in the
numbering system
okay that's a lot of
um Babble about number systems let's
just try this so we have a represent
function in APL also known as encode
we're going to take this number and
encode it in a certain Radix a certain
base
and we can say that every
position in our number system uh you
need 10 of those units in order to get
the same in the next higher unit
now this might seem obvious that they
should all be 10 but some numbering
systems have mixed bass for example the
way we count time we have a thousand
milliseconds
makes up a second but 60 seconds makes
up
a minute and 60 Minutes makes up an hour
and 24 hours makes up a day and
seven days makes up a week for example
so we specify here that we want all
these bases 10 but the number got
truncated because we didn't have enough
tens
so we don't want to specify
how many digits they are we would like
to have this done automatically and
there is a trick to that
when I go the other way and I want to
convert these
digits to a single number then I use the
decode function which is just the same
symbol but upside down so this converts
to a number base and this evaluates in a
number baits that looks like the base of
our pillar and here I don't need to
specify the number of digits because if
I only specified once then that gets
mapped out to all the digits
okay how can we use this
well this is a neat trick and that is to
use the power operator the power
operator
takes a function on the left and the
number on the right
and applies the function that many times
so here I don't want to apply this
function
the trick is to apply it negative one
times what does that mean
that means asking the APL system
what would be an argument to this
function
with this left argument such that the
result would become this
ah so being that this evaluates
from base 10
and we need to get this result
then the argument given to the function
must be the list of digits that
represented in base 10.
that's exactly what happens that's the
result we get
and with that in hand we can start on
the actual core of the problem
let's wrap this thing in braces making
it a definite or a Lambda an anonymous
function
in here the argument on the right is
represented by the rightmost letter of
the Greek alphabet
okay
we've got the digits the next step is to
compare adjacent digits we need to make
sure that we're going down and up and
down and up or the opposite way
if we reduce with minus then we get
the first digit three minus one minus
four minus one minus five that's not
interesting but if we give this
derived reduction function and number on
the left say two
then we only reduce over Windows of size
2. so this is three minus one one minus
four
minus one and so on
three minus 1 is 2 1 minus four is
negative three four minus one is
positive three
now we need to check if we alternately
go down up so if the positive number is
positive we're going down if we put
numbers negative that means we're going
up
but in order to deal with this it would
be nice to normalize these to just be
ones and zeros so we use the Signum the
sine function
and that gives us one whenever it's
positive and negative one when it's
negative
so we might think that now we can do
adjacent different from
and this says these are all true
but what happens if we've got
a zero in there
right so now we have two ones in a row
and the difference between them is zero
but zero is different from one and zero
is different from negative one and so if
we do adjacent
different from it looks like everything
okay when it actually isn't
so that doesn't quite work
what we can do is adjacent differences
again
here we can see that from one to zero
there's only a difference of one and
from zero to negative one also a
difference of one
and we must have only negative ones and
positive ones there
so
sorry only negative twos and positive
twos there
so how can we find out if that is the
case
well if we take the absolute value now
they shoot all the way all of them be
two and if we have any zeros
will spot that there's only a difference
of one in between
you could even be a difference of zero
if we have the comparison being
identical
but for a good number a zigzag number
everything is fine it's all twos so now
we need to check are they in fact all
twos well how do we check that
is 2 equal to these yes it is equal to
all of those and is it all true this is
an and reduction
yes it is and if we mess up any part of
our number
then
it's not true anymore
so this is one solution to the problem
but there's actually a clever thing we
can do
we can start off the same way
as before
with the adjacent differences
and then we can remember something from
basic math lessons
which is when we do multiplication
equal signs give positive and unequal
signs give negative
so if we multiply these adjacent numbers
then this will be positive this will be
negative this will be negative and so on
And if every time we go from one digit
to the next we switch direction that
means that adjacent numbers will have
opposite signs and therefore all the
multiplications must give us negative
numbers
so if we do adjacent multiplication
we can see that there is a positive
number here and that's not what we want
if we fix the number
all of the signs are negative which is
what we want how do we check if all of
them are negative
well instead of like we did before
we did an end reduction on two equals
then here we need to check if zero is
greater than all of these values
and do the end reduction
same pattern
and this works nicely
there's an interesting pattern going on
in this function
and that is we have an argument
a function with two arguments
a diametic function we call that and
this left argument another function with
two arguments and its left argument
another diametic function and its left
argument and it keeps going like that
onto the last function which is applied
to the result
when we have this kind of pattern that
means the function is a nice fit for
tested programming
so
we can get rid of the braces
and C is to mention the argument by name
which is what tested means it's just
understood that the argument is there
without mentioning it instead since we
want the value here of the argument
we'll denote that with the
identity function it's a normal function
but applied to the argument
it just yields the argument so this is
again the argument's value and then we
we express that in base 10. and then we
do adjacent differences and adjacent
products and then we compare it with
zero and to an end reduction then
and this would work
however
we can be a little bit more clever
and what we can do here is we can modify
the function H instead of mentioning the
right argument implicitly by a identity
function we can bind
a fixed left argument two to the
function that we're going to then invert
and that gives us the base 10
representation and this whole thing
becomes one giant tested function and
that's our the rightmost part of our
function train our string of functions
and their arguments
and now we can try applying these again
and we can see that
this still works so this is a nice
tested way to do it
thank you for watchinghey
our job is to take a
number and split it into its integer
part and its fractional part
so here's a number
and we can get the integer part by
lowering it
so this symbol is kind of
is a a stylist wall and the floor next
to it so this floor and we could also
round up using the ceiling which would
be like a wall and a piece of the
ceiling above but now we're flooring
and that gives us one
and what we could do is we could
subtract
this so we can make a what's called a
train
um or it's a fork a special construct
where we
um refer to the function to the argument
in terms of function application
so this is you could call this a one
train
um and then we can use the identity
function
to just give the number itself and if we
subtract
the floor from the argument itself then
we get the fractional part
now all the remains then because we have
to return a two element result which is
the integer part and then the fractional
part is to concatenate in front
the forward part
so that's the integer part
this is one way we can do it
um there are other ways to do it
we have something called the division
remainder so when you divide
um if you are using integer math then
you might have something left over say
if we divide 10 by 3
we get three in the third
however if we did an integer division
then we would only get up to three times
three is nine it would have one left
over so if we we can write that in API
with a vertical bar which in this is a
notation technique from traditional
mathematics means divides
so 3 divides 10 then what happened you
get
one left over if we had three divides 11
then we would get
two left over
and so here comes the trick
if we have a number that's not a whole
number and we want to divide it by one
then
well of course it gives the same result
but if you're using integer math the
closest we could get is the one
and then we would have this left over
so if we say what's the division
remainder
when we divide by one
then we get the fractional part
and so we could go up here and
substitute it
and we all we need to do is to take this
one and bind it together with the
remainder function
to create a function that just takes a
single argument because we've already
filled one slot with the one
and we can write that as with with this
jut composition operator
and this says the one should be always
be the left argument to the remainder
function and then we concatenate the
float value on the left
so there's another way to do it
but there's actually
a very neat way that we can do this in
one go without constructing the results
from its two parts
and that is by using the encode or
represent function
now let's say that we have a movie which
lasts 96 Minutes
but we want to know how many hours and
how many minutes is this
so what we can say is
we use the encode
we could also see this as kind of like a
letter T and this stands for converting
to a base which could be a mixed base so
we have a number system for time where
there are 60 units minutes in an hour
and then it doesn't really matter how
many hours there are in a day it would
be 24 but it doesn't matter in this case
and if we use a zero then we don't roll
over to the next unit we just say this
is the highest unit and anything that's
bigger than that will just remain within
that position keep counting up
so you can see this is one hour and 36
minutes
now what if we were to represent
um in where the unit is a one
and then
um
that means that none of the whole part
of the number can be represented in
um in this digit
only anything less than that
before we go there let's just try it 96
and a half minutes in hours and minutes
we can see that the fractional part goes
over here
and so if we change this to a 1 then the
whole 96 will overflow to the next
higher unit which is the highest one and
the zero indicates that everything goes
there
and we just get the half remaining
and we can try that with our other case
we can see that it splits it up
so a whole solution to this as a full
function we'll do the same trick as we
did with the one and the remainder
binding them together using the chart so
two we can bind together
the zero one which is an array with the
encode function and this becomes a
standalone thing that we can give a name
and we can apply it and that's the
entire solution
thank you for watchinghi we're going to compute the windows
average of a list of
numbers now normally this is a very
simple thing to do in
APL so let's say we have the numbers uh
1 2 3 4 5 six and we want to do a window
average um the specification here says
how many enable
neighbors and on each side of an element
so let's say we want two Neighbors on
each side that would mean like for the
uh number three here we want these two
neighbors and these two neighbors to be
included so that means uh these five so
if we write this as a testet function or
Point free function and we have the a
left argument of two which is the window
size but number of specified as number
of neighbors then the full window window
size is going to be 2 * this because
it's on both sides plus one um because
of that middle element that's the one
we're Computing the the window average
on right
now so we want uh the left
argument and we want two times that and
then we want to add one so this gives us
five and this is going to be uh the left
argument to the plus reduction so this
doesn't just reduce the whole thing um
but rather reduces over Windows of that
size so the right argument to the
reduction the actual um data that we're
going to reduce is going to be the right
argument to this outer
function and the left argument is going
to be this uh
expression that is in terms of the left
argument so now we got uh the sum of 1 2
3 4 5 so we can see 1+ + 2 is 3 + 3 is 6
+ 4 is 10 + 5 is 15 and then and 20
because we got 2 + 3 is 5 + 4 is 9 + and
5 is 14 + 6 is
20 okay now we just need to find the
average this is the sum we need to
divide by the length but the length
conveniently that's already there as the
left argument to uh to this plus
reduction so if we wrap that in an inner
function and then say we divide by the
left argument here so there are three
functions here this is a density
function that Returns the right argument
that's this one over here there is a
function in terms of the left argument
that's this one and the middle function
takes the results of those two AO
functions and says that the the NY is
Windows reduction using Windows of this
size uh on this
data divided by the left argument so
that's the length of that
okay makes sense that the the average of
one to 3 4 5 is three and the average of
2 3 4 5 6 is
four now here's the catch um and that is
we don't want two results like this
notice that we only computed the window
averages uh for these two elements and
not for all the elements because there
aren elements on the left and on the
right to create a full window and so the
problem specification says that we are
to
extend uh the original data with copies
of the last and the first uh elements on
the right and the left sides
respectively so um let's do that we can
always put in the actual formula for the
window
reduction afterwards
so we want the first element over here
and we want to repeat it as many times
as stated over here so we want a reshape
which is cyclic reshape so this just
reshapes uh the whole thing this
reshapes the and drops the trading
elements but we want to pre-process the
right argument with a first to take just
the first element so we've got this
function composition oper operator which
is pre-process the right argument and
this is the first function
so this reshapes the first element to
the length
two and how would we get uh reshaping
the last element well there isn't
unfortunately a function to get the last
element but there is a function to
reverse so if we
pre-process the right argument to this
whole function with a reverse
and reverse this whole thing that gives
us 654 3 2 1 take the first that's six
and then reshape
it and now we can just concatenate
together all the pieces that we've got
um so we want the original right
argument concatenated with
this and that extends with the right
number of sixes on the right so that the
actual original six becomes the center
of a window of length five and then we
have the left argument resets the first
concatenated to
this and now we have the full data that
we're supposed to operate on so we can
go in and take our original formula over
here and copy it down
here that gives us our uh running window
average and with extended neighbors so
we can get rid of this and give it a
name and now we can
apply to f 1 2 3 4 5
6 and we can do it with a
one so this is the average over and
every element and its adjacent element
so there's average of one because we're
extending one and two that's one and
the3 and here we got average over 1 2 3
that's two and so on thank you for
watchinghi we're going to implement a simple
seizure Cipher for uppercase
characters and
spaces so uh the idea is that we have
the uppercase alphabet as a built-in we
just need to also have a space in
front and we can make a Lambda around
this where we take
the argument which is represented by and
Omega which is the rightmost characters
in the Greek
alphabet
and we take a message and we can look it
up with a index of here so we look up
every character in the alphabet so we
can see H which is normally the eighth
character but it's now the ninth because
we have a space in
front and then as left argument we take
um a rotation of the alphabet
so we
can um take the same alphabet over
here and then we can index into it and
APL allows us to index with multiple
values at once so we take all these
indexes here and we use them to index
into the alphabet of course if we index
into the alphabet itself we get the same
thing but if we take Alpha the leftmost
character of the Greek alphabet and we
rotate the elements of the
alphabet um we can we can also show how
that
looks so if we take this
oops so this is a rotated
alphabet
um then that's a solution to that let's
clean up the code a little bit and we
can see here that we have some
duplication of
code um we can do an inline assignment
over here to a for the alphabet and then
we can use the a over
here and we can
avoid this parenthesis by flipping the
arguments of the iota of the index of
function so let's do that as well reads
nicer with the inline assignment as
well um and there you have it let's uh
give this in
name and apply
it oh of course we need a left
aggreement there to apply it there we go
and then of course once we have that
function we can apply it in reverse and
if we apply the reverse on the
forward then and we get back our
original message so same function works
for both encoding and uh decoding and
the way that works is that we have a
negative value under the rotation it
just means a reverse rotation so that's
all thank you for watchinghi
today we're going to take a text and
chop it into
sequences of a given length
this is something that's called KMS when
it comes to DNA sequences but that
doesn't really matter
first let's generate some fake DNA
and we can do that by taking the bases
that can appear in DNA and then index
into them
with a bunch of numbers let's just do 15
for now so there are four different
bases
and we want some random numbers for
those indices
that gives us some random DNA
now the problem is almost built into the
other Solutions are probably almost
built into the uh to APL
by way of
invoice reduce
so anyways reduce those reductions over
Windows sliding Windows over a certain
size the data goes on the right and the
window size on the left
and here we're not actually we're going
to do any reduction but we can use
concatenation reduction which then
concatenates the adjacent characters
forming subsequences
here for example is
the four wires or setting Windows of
size 4 reduction that's the Slash and
concatenation is the comma
and that gives us this if we do five we
get like this and so this almost solves
the problem because the problem
specification is that the left argument
is the length of these cameras and the
right document is the DNA
there's just one problem
um let's say that we have and now just
for clarity let's just use a normal
alphabetic letters
let's say we only have six bases
then we have these two five mirrors and
if we have five then we only have this
one which is still correct this is a
list of character vectors A list of
strings if you want
but if you only have four
then well this looks strange
so this output form from APL which is
known as the maximum boxing level or the
display
moment
um notice how it changed this Arrow
which indicated an axis into this circle
bar and this indicates that there is an
axis but it's a 0x it's linked zero so
this is still a vector of vectors
but there aren't any
and it's not the same thing as just any
empty list and we really want to be
consistent here and always return a
vector of Five Element character vectors
only that there aren't any
so into in here we can see that there
are indeed five elements which is great
so this is still correct this is a
vector of no Five Element vectors
however if we further shorten
then we get a length error
and API will not allow you to do an
invoice reduction over an argument that
is a data argument that is more than one
element shorter than the requested
length so the actual problem here is not
really solving the main thing of K mares
but rather working around this
limitation and I'll show a couple of
ways to do so
so first
um it's very simple
we can see that we can have
up and we can down to
one less than the requested length so
let's define a Lambda like that and the
data goes on the right
and the length on the left
and then we are going to look at
the left argument which is Alpha left
most character the Greek alphabet
subtract one
and then we do a
um
the maximum with that
and
the tally or length of the right
argument that's the data over here
so this style uh with a bar at the top
and it kind of looks like a wall with a
piece of the ceiling above and so it
also means round up ceiling but if you
use it with two arguments it's the
maximum which you kind of see it as a
measuring stick showing at the maximum
of the two values
and so this Returns the maximum we can
see here that this gives six this is the
length but if we decrease it five then
they're the same and four then it it
gives one less and three it stays at
four
so
if we then take this and Pad the
argument to this length which we can do
with the take function although take
text the length on the left and the data
on the right we can use the commute
higher order function or operator to
swap that so that the data goes on the
left and the next goes on the right and
then we we do this we put the argument
on the right
from the right over on the left instead
and now we can see that we got padded
with a single space here and if we give
it even less argument and less elements
we had accordingly so now we add up end
up having at least a length four and
with that we're done we just do the
um
and wise reduction
and we can see that we get the correct
result here so this is one solution to
the problem
we can try
and it works like this
another way to do this is something
that's actually stated in the full
problem text if you look there and that
is that if
the requested length is greater than the
length of the input then we return an
empty Vector so we can code this as well
um so we say if the requested length the
left argument is greater than the length
available in the red argument
then and then return an empty Vector
we'll get back to the definition of that
otherwise we just do the operation as
before
now what exactly we want to do here we
could just return an empty string but
that's not the right type let's let's
try that if we say 5 G ABC
we can see that this isn't the type
that we wanted we actually want a vector
of character of x's of the right length
so we can change this and say well it
doesn't actually matter what the content
is because it all gets
thrown out
we normalize empty arrays so that they
conceptually just contain spaces or
zeros and so on
so we can take the left argument which
is the length required
and take that many elements from the
right argument and that again pads it
with spaces
um
and this will then be our prototypical
element
then we enclose that to treat it as a
single unit
and then we take zero of those
foreign
we get the right type of result and it
also works
on
the full argument as before so these are
two different ways of coding around the
problem one is by extending the data so
that we always have enough data and that
was F
and and the other one was by doing a
test first and if we need to stop short
of actually
calculating the cameras and then we
construct an appropriate result and that
was G
thank you for watchinghi
we're going to generate inclusive
integer ranges which might be ascending
or descending
there are many different ways to attack
this and I'm not going to go through all
of them
in the chat event
we did have a lot of different
approaches taken up and I encourage you
to follow the link in the video
description to go to the chat log and
see what they all were
for now I'm just going to go through the
shortest solution we came up with
and the faster solution we came up with
so the problem specification is such
that we have both the beginning number
and the end number in the right argument
the normal thing for an APL function
would probably be to take one on each
side or a function probably the
beginning on the left and the end on the
right
but because of another follow-up problem
that was in the same competition that
this problem comes from they elected to
have both ends on the same argument so
given as a two element vector
and that influences a bit how we're
going to form our function let's say we
have we want to go from 3 to 10.
so the method we're now going to use is
that we're going to use the three
and then we're going to have a bunch of
ones
and then we're going to have those ones
added sequentially to the three until we
reach 10. so this would need 7
ones
doing a cumulative sum over those ones
starting with the three gives us the
sequence from 3 to 10.
if we wanted to go from say 10 to 3
instead then we would do the cumulative
sum beginning with uh with the 10 and
then we would have negative one seven
times
and that would give us a sequence from
10 down to 3.
so we're not going to figure out how to
generate these ones and append them to
the beginning value
so that we get the sequence that we want
first let's find out what the difference
is between those two values that we are
working with so let's say we have
3 and 10.
we write this initially as a does it
function
so here is a minus reduction that is
we're reducing over this Vector of
length two to get a single number
that just is the same as inserting the
minus between the two elements so this
is three minus 10.
there's a problem here with the sign if
you're going from 3 to 10 we want
something positive so really we want to
subtract in the opposite order once we
subtract the left element from the right
element
we can have a modified version of minus
which is the commuted minus I'm reduced
using that to and then we get a positive
7.
next up is to reshape A1
we could do this by again commuting the
arguments of the reshape function and
user 1.
however in the case where
we want to get negative ones this is not
going to work and we can't use a
negative number to do a reshape either
instead we'll apply another function
the number of elements that we want is
the absolute value of this
and the numbers that we want in our
sequence
is the sine
of the difference
if we were to have 10 3 then
the sign would be negative one now we
can take the absolute value and use it
to reshape the sign
finally we want to
be pinned the first element 10 in this
case
we cannot just say the first function
with concatenation
because we're getting out of sync with
how our Fork works
for this to work we want to apply this
function to the entire argument and this
function to the entire argument and then
we want all of this as a sort of
secondary step
the base function here is concatenation
before we apply the concatenation we
want to pre-process the right argument
to the concatenation which is going to
be
something based on this subtraction
and we can do that with the beside
operator the chart
this is pre-processing the argument the
right argument to the function on the
left with the function on the right
here we have a descending sequence from
10 down to 3 and here we have an
ascending sequence from 3 to 10.
the only thing that's missing is the
cumulative reduction
and this solves the problem
in the zero case that is when the
beginning and ending points are the same
this subtraction gives zero the absolute
value is zero the sine is also zero that
doesn't actually matter because we're
reshaving the length zero that's an
empty Vector concatenating the first
element that would in this case be just
10 as a vector
and then we're doing a cumulative sum of
that which just remains with 10 and
that's the result that we want when the
beginning and ending points are the same
so this solves the problem very neatly
but maybe most not the most efficient
manner
and the reason for that is that
we are generating a sequence here that
is not the
full length that we want so we are
prepending
another element that means that in
memory we have to rewrite all of this
data just pushed one step to the right
okay
furthermore if we are generating a
sequence of all ones then it would
probably be represented internally as a
bit Vector that is packed bit booleans
and then we are prepending an integer
value we would have to convert all these
bits to integers again
and then of course we're doing the
summation but we can probably not really
get around
doing is one addition for every element
let's look at a more efficient way of
doing this and when dealing with offsets
like this it's a really good idea to use
zero based indexing API uses one based
indexing by default so let's create a
little Lambda a function where we assign
to the special syntax uh a system
variable which determines what all
ranges are indexed from one or zero so
we assign a zero to that then it's going
to be indexing from zero
here's the index generator
let's do the indices for an array of
length of the argument
you can see it begins with zero if I
switch this to a one it begins with a
one so let's switch that back again
right what kind of sequence is it we're
looking for we actually have a beginning
point and an end point if we do this
subtraction then we get a range
of course it could be negative so let's
throw in the absolute value
oops we're missing the right argument
here
we're short by one it's the fence post
problem we have an inclusive range in
both ends and so the actual range is one
larger than this
let's add one
now the only thing that's missing is we
need to adjust we again want to start
with the first value and then we want to
add these offsets
but in the case of this ending we want
the offsets to be negative so how can we
selectively
change this to negative numbers
we could of course use a conditional
but really want to avoid branches and
all the problems that come with Branch
prediction
instead let's take a mathematical
approach that's the traditional way to
do it in APL
okay
let's look at these numbers again
we can see whether or not one is greater
than the other by inserting a greater
than function between them so this is a
greater than reduction
if they're the same we get a zero and so
too if the first one is actually less
than the second one
so we now have these two numbers
one and zero one for when we need to
reverse the sign
how can we map a 1 and a 0 to
a
negative value negative one and a
positive value one
a trick that I think a lot of people
Miss is that you can use power or
exponentiation
if you use negative one that the base
and raise it to the power of one well
any number raised to the power of one
is itself so that gives us negative one
raising report to a power of zero for
any number
gives us a one
so now we can use this in our function
if we use negative one to the power of
the greater than reduction of the
argument
multiplied by the sequence we had before
then we get negative offsets when the
sequence is supposed to be descending
and positive offsets when the sequence
is 2.
and to be ascending and if they're the
same then we get a single zero no offset
from the starting point
all the remains is to add the first
value
to the sequence
and so this is our very efficient
solution
thank you for watchinghi this challenge is to take a variation
of a normal chest setup and just check
two things the King has to be between
the Rooks and the Bishops have to be one
white and one
black so here are some an example setups
the first one is valid that's a normal
uh chest setup with a queen and king in
the middle and uh Bishops next to them
and then Knights and Rooks and then some
variations of them uh these are invalid
because here the king is outside the
Rooks and here the king is again uh
here's the king is inside the Rooks but
the Bishops are both on uh the same
color
squares um and we can take this step by
step the two conditions and we create
this Lambda that refer to uh the
argument as Omega and then we just need
to check these two conditions the first
one is the order that uh we've got Rook
Knight sorry Rook King rook and that
means we're not interested in any of the
other elements only uh the letters K and
R so we can do the
intersection of the
argument with K and
R and now we can see that the first one
is valid because the king is in the
middle and then we can see that the uh
these two are this one is invalid and
this one is valid in this respect that
is invalid for a different reason so we
can just write that it has to be Rook
King Rook that matches the intersection
of the argument with Kings and
Rooks and the other condition so and and
and the other condition is that we have
opposite uh parity of the positions of
the um of the Bishops so let's not do
the end right now instead we're going to
do left um this ignores everything we
computed here and just returns one
what's on the left to make it a little
bit easier to see and then later we'll
restore this to an
end so if we create a mask where we've
got
Bishops and we transform the mask into a
list of
indices then we can get the parity which
is the remainder when you divide by
two and then we have to make sure that
they are not the same so one has to be
even the other one odd but doesn't
matter which one so they just have to be
different from each other so we insert
in inequality between them and we we get
this mask saying that uh that this is
valid valid and invalid
and now we can combine that with our
original mask that we got up
here to get our final mask just put an N
there and then it says that the first is
valid it takt to are
invalid thank you for watchinghi we're going to insert separators
between uh groups of three digits so
that's like the thousands in an integer
that's given to us as a character
Vector I'm going to go through a few
different approaches three approaches
here but there are many other ways to
solve this so have a look at the link to
the chat event in the video description
for more
okay let's first generate some test
data um so it doesn't really matter what
the digits are let's raise 10 to the
power of 0 through
9 and then we can make each one of these
numbers into a character Vector you
can't actually see the difference for
that
um but yeah they become boxed like
this and that's called that t
and then the separator doesn't matter
what it is just any one character here's
a
comma okay so um whichever way we do
this we have to start kind of from the
right finding groups of three
digits so um let's apply this Anonymous
Lambda to each one of the T with S as
left argument um and then we reverse the
argument
that that allows us to work from the
left
instead and what we actually want here
is a grouping so we can use the petition
enclos function to group and the way it
works here is that we're giving it a
mask so we're going to generate one 0
one0 0 and and as a mask and the ones
indicate beginning a new
section and how many elements do we want
well if we take the number of elements
in the right
argument um that gives us the length and
if we then replace uh if we then
reshape this and reshape a one 0 0 then
we will use those numbers cyclically so
this gives us one and then one 0 1 0 0 1
0 0 1 and so on and that's exactly what
we want uh for our partition in close
and we just have to remember to do it on
the Reversed
digits so this gives us our
groups now we can
add a separator to the front of every
group in list this and then we just need
to um remove
one from it because we we have one more
separated at the end that we don't want
and the last step is then reversal again
and that gives us uh the results we want
so let's call this one
F so this is one way to do it it's just
making these
groups another way to do it is to reach
for the regx
sublanguage so let's try
that again we want to work from the rear
we could use the regx engine to uh with
um lookaheads and look behinds in order
to work from the rare but it's much
easier to just reverse and then we want
to replace and we want to replace any
sequence of three characters which is
just going to be digits so there's no
reason to specify they have to be digits
except for the very
end so this is a negative look ahead to
say so we look look for any three
characters that is not followed by the
end of everything replace that with the
match followed by the
separator that gives us this reverse
thing and then we can just reverse and
be
done let's call this
G and finally um a more AP way of doing
this so let's uh let's look at what
happens here again we need to work from
the
reverse but now we're going to split up
into groups while keeping this flat so
it's going to be similar to the
um to the partition
inclose but we're going to and reshape
into a matrix so we're going to have
three
columns and then the number of rows how
many rows do we want well it might not
be divisible by three we can certainly
divide the length into three and then we
need to run up to make sure that we have
all the
digits
o uh was missing a reshape
here okay so now we can see that we have
been we have uh reshaped and reused the
digit so if there's only one digit it
gets filled out into to three here this
is a 10 this is 100 and here's 1,000 the
last three zeros followed by one over
here and then we're recycling the digits
over here but we're going to strip those
extra digits at uh when we're
done okay now that we have a matrix we
can take the separator and concatenate
on the
right so it gives us a column of
separators and then we just need to
flatten
everything and remove some trailing
characters we can see here we need to
remove three characters here two here
one here and then three and then
two and then one okay so we need to find
out how many characters do we need to
remove now let's just concatenate that
number as we Computing it well it has
something to do with the length as we
can see and it goes in periods of
three but this counts the wrong way here
this says remove one remove two remove
zero 1 two 0 we really want to go down
because we want to do 3 2
1 and uh we could do this with a
subtraction but we could also um just
negate the right argument to uh the
remainder so so now we it says we need
to remove
two that and one and zero so this is
just off by one so we just need to add
one more to
this however uh in order to remove from
the rare we need to use the drop
function and in then we need to have a
negative left argument so instead of
doing one plus this we can do -1 minus
this
and that
strips the excessive characters and then
we can
reverse it gives us our
result okay so which method is better
this one is a bit more involved and
depending what you need um if you just
need brevity or uh maybe some clarity
straightforward way or maybe you need
high performance uh then you can choose
between these let's look at how the
performance Compares
so um we're copying in the cmpx facility
from the defense
workspace and then we need to have a uh
a very long number so we can we actually
need to split up into a lot of digits um
let's
say a million dig um
digits so yeah let's just take the first
digit of that you can see this are the
the it's just Z one two 3 it doesn't
matter because it's just any
characters okay and then we need to
compare the execution uh of separator FN
and separator
GN and separator
hn just need to wait for it to actually
do
this and we you can see that using the
array based approach the flat array
based is definitely the fastest thing
you can do then uh if you have to use
nested arrays do that and resort to regx
if you really can't figure out a
different way to do it without regx
thank you for watchinghi
let's
compute areas of
Circle sectors
and when we're doing so we'll be using
APL as the mathematical notation
when reasoning about and simplifying the
mathematical formula
okay to get started
the area of a circle one way to think
about the area of a circle
is that you sort of say unroll the
circle
into its slices these pie slices or
sectors
infinitely thin ones put them next to
each other we get a rectangle the long
sides of the rectangle are then
contributed by the circumference and the
short size of the rectangle are the
radius
well the radius is equal to compute from
the diameter that's just half of it but
the long sides well we know that
diameter
times pi gives us the circumference
and we know that this this circumference
that has to contribute to Long sides
being that there are two that means half
of that would be one of the long sides
so we can compute the area of the
rectangle as the short side times the
long side
if it's pi times
half of the diameter that's pi times the
radius so it's pi times the radius
times the radius that gives us the area
of the circle
and we can express this in the APL quite
easily
we don't have a symbol for pi directly
but almost always when we're using pine
mathematics it's because we want to
multiply by pi
APL does have a function to multiply by
pi and appropriately is denoted by a
circle
so
Circle R means pi times R where R is the
radius and we want to multiply that by r
of course we haven't defined what R is
and we are going to take as right
argument
the diameter not the radius the right
argument that's omega as the rightmost
letter of the Greek alphabet and we can
divide that by two
and assign it into r
the result of an assignment is the value
that was being assigned so this sets are
to half of the argument diameter and
returns that same value which we then
multiply by pi times R and we can try it
with some values
APL automatically Maps arithmetic
operations so it doesn't matter that we
have three values here it will just work
these are the areas of circles where the
diameters 9 12 and 15.
we are multiplying Pi Pi with r and then
we keep multiplying and it doesn't
matter which order we do the
multiplication in so we can remove the
parenthesis over here and now it's very
clear that we have I term R times r
or R times itself
instead of using the dynick function
multiplication with one argument on each
side we can mention that the argument
only once and use the commute operator
or higher order function to change the
multiplication from a diadic function in
fix that takes its arguments on the side
to become a prefix function
and it uses then the same argument on
both sides of the multiplication
the symbol for this self thing as in
self multiplication is a bit like a
selfie face
but now of course we're only using R
here in the assignment and never reusing
it so we might as well just use the
Omega divided by 2 directly
this gives us the areas of these circles
but we don't want the full circle we
want
a fraction of a circle
a sector and specifically we want it
given in degrees so how big a part
of the full circle is it that we're
dealing with well let's say we have 60
degrees
so we want a fraction
of the full circle
how much out of the full
360 degrees
is it that we are having so it's the
left argument Alpha on the left most
letter of the Greek alphabet and divided
by 360. that's how big a part of the
circle it is and we multiply that by
the area of the full circle
and so we can see that
60 degrees out of a full 360 that's a
sixth of the full value we get the area
of a 60 degree slice or sector of a
circle
this is a solution to the problem
but let's try simplifying and condensing
this a bit
the first thing I'm going to do is undo
this selfie that we did before and
we do that since we have a fraction here
it's Omega divided by 2
then we can say Omega times Omega that's
the square of that divided by 2 and
divided by 2 again that is divided by
two times two
how does this work out because APL
functions have long right scope that is
this division symbol sees everything on
its right as its right argument so this
becomes
Omega divided by 4 and then times Omega
again so this is also Omega squared
divided by 2 squared
you can see we get the same values right
there okay it's all multiplication
division stuff and we know that
everything we multiply together on the
right that's what we divide by and
everything on the left and that's that
which is being divided so we are
dividing by 360 over here on the left
and we can move that over on the right
just by adding another 360.
to the terms on the right
and then of course we can compute two
times two times 360 is 1440.
okay this is already looking better
and this is about as dense as we can get
it while still mentioning the arguments
explicitly
however there is a different style of
APL functions and they're commonly
called
tacit functions and specifically we're
going to use a type of tested function
called a train
interested functions the reason they're
called tested we don't mention the
arguments we only mentioned functions
and that means the whole function the
overall function is defined in terms of
function applications to the argument or
in this case of arguments
since we have two arguments then all the
functions are being applied to arguments
are going to be applied to both of those
arguments and
this function the pi times function we
just want as a multiplication Factor we
don't actually need it to be applied to
any arguments at all
and therefore we're going to move it
over to the very end it will be a type
of post processing step
right then let's look at what we've got
in terms of the arguments well over here
I spot the left argument times the
regular argument again we're actually
doing a multiplication by everything on
the right but that doesn't matter
because it's all multiplications we are
talking about
so let's parenthesize this of course
that will still work
um and this is now a sub-expression
defined in terms of a function
application on both arguments
this one is a bit more problematic
because we don't need the left argument
at all we only want the right argument
so how can we express this in terms of a
function application to the two
arguments to both of them we need a
function that ignores the left argument
but does
take the right argument and returns it
as is that's it's an identity function
specifically a right identity function
now for that we have something called
Write tack symbol or the functions could
actually just be called right
and if we give it a left argument it
completely ignores that you can kind of
see it as a symbol that stops on the
left and points at the right so it will
return just the right argument like this
we can try it
it gives the same result and finally
another problem this isn't the function
at all
this is a constant but we need it to be
a function we need it to be something
that we apply to the arguments
but we don't want the left argument
don't want the right argument at all we
just want the constant this calls for a
constant function
obviously APL doesn't have a built-in
constant function that just takes
argument or arguments and returns 1440.
however we do have a higher order
function
which takes an operand just like we had
this selfie symbol which took a function
that took two arguments and made it into
a function that took a single argument
using the same argument twice we also
have a higher order function that
doesn't take a function but takes a
value in this case 1440 and turns it
into
a function that always returns that
value no matter which arguments you give
it
happens to be it's the same symbol
there is no contradiction or ambiguity
here because
this symbol this operator always takes a
single thing on its left
in order to derive a new function if the
thing on its left is a function then it
does that which we said before of moving
arguments around
and if it is a value then it derives a
constant function
so
we can give this function arguments
on one of both sides here we don't need
to parenthesize this last part because
remember APL functions have long right
scope and so the division sees
everything to its right as its right
argument
and this will then create a constant
function 1440 constant function apply it
to these arguments
and return 1440.
this is of course Very verbose and
unnecessary
but now we can switch from explicit
to test it and we do that simply by
eliminating all mention
of the arguments and we don't even need
our curly braces anymore we do need a
pair of outer parenthesis though
here's an argument let's get rid of that
that's another argument we're getting
ready
um over there then there are these two
arguments that we're getting rid of and
these arguments over here we want to get
rid of
and look we get the same result
the last step is then removing all the
Redundant parenthesis
and there we go
a tested function to compute
Circle sector areas
thank you for watchinghi here we are to take two
texts and we are to split the one on the
right such that um the first character
of the second segment is the first
character that is found in the left
argument let me illustrate
this so let's say We've Got U this is
the the splitter
characters and this is the actual
uh text that you want to split so D
doesn't exist on the left y exists on
the doesn't exist on the left a does
exist on the left so we want to split it
here we want to get Dy and we want to
get a
log and there are a few different ways
that we can uh we can do this let's get
started so what we can do is we can find
where we've got
and elements in the their
positions so if we look up
um so this is a lookup
function and but this will look up
elements of the right in the left and we
want the left in the right so we can
flip its
arguments so we can see that a is found
position three p it says seven because
it doesn't actually exist there so it
goes to the next index over here and L
in position
four we're not interested in all these
positions we just want the smallest
one so we can apply the
minimum uh reduction on on this that
gives us the
three however um three is not actually
the index we're interested in we want to
get one less than that because we want
to split it so we only get the first two
so we can add1 to
this then we take this
number and we use it to take this many
elements from the right argument and we
can also use it to drop this many
elements from the right argument we want
both to take and to drop and we want
them joined
together so the
take and the drop and we could
concatenate them together but that
doesn't do anything because then we're
just rebuilding the text from the right
no we need to encapsulate them so we
need to pre pre-process the arguments to
the concatenation function with an
enclosure and that gives us our result
there's one little issue here and that
is if the right
argument and which is the place where we
look up elements from the left argument
doesn't have any Dimensions that is if
it's a
scaler then we get an error and we can
fix this by pre-processing the right
argument with a comma uh which is Ravel
this makes it into one element Vector
instead and then it
works
so we can give this a
name this is
f a different way uh to approach
this um is begins off the same way
this's time uh let's stay
explicit so we've got
dialogue and
APL and we're going to do much the same
thing as before
let's look up the left argument in the
right
argument we saw this before let's take
the
minimum and
now we want to petition the right
argument and the way we petition is
using
um or actually partition inclose is the
more correct term is but using a Boolean
mask that is as long as this or shorter
could actually be one limit longer but
that's not really relevant
yet we want a one every time we begin a
new section and zeros for everything
else so this is a three that's where the
second position begins we also want to
begin at a partition a section position
one now we just need to create a buan
mask that has and these values now there
is a function in APL that goes the other
way if we write one Z 1 0 0 then and we
can use the where function to say where
are the ones but we want the opposite we
want to know we want to start with one
and three and do the inverse of
where luckily there is an operator in
APL which is is called the power
operator which can apply a function
multiple times including a negative
number of
times so this creates the shortest
possible Boolean
result
um that satisfies that when you apply
where to it you get one and
three so if we go in here and we use
where in inverse on this that gives us
the MK that we need and then we take the
right argument and do a partition in
close only the mask needs to go on the
left so we flip the arguments of this
and that gives us our
split there are still a couple of issues
as we have had before if we have a
scaler on the right of course then we
get a rangar and but we can we can fix
this by putting a
uh Revel over
there and another problem
is what happens
if the left argument contains the first
letter
interestingly this actually works but
how is that even possible for that we
let's take our part our solution
again we generated these two so we get a
one because we want to start a position
at the first position and then we
generate the lowest index where D
appears where the uh a letter from the
left
appears which is also
one so what happens when there are
duplicates for the where
inverse ah then it says that there are
two here maybe a little bit obscure
what's happening but let's say that
we've got 1 1 3 4 four four and five so
these are the positions of and our boans
that means that we want to have three
times
A1 at position four that is exactly what
the wear inverse
does so similarly we can go take this
one and put where in front of it so it's
saying where are the ones well there are
two ones at position two and there are
at position one and there are no ones at
position two there's one one at position
three there are three ones at position
four so this solution actually works
even though and we finding a match at
the very first uh position
we can also take the solution and turn
it test it like the other one so in this
then we would have the
reversed and index of we put left
argument on the left and the right
argument on the right we can join the
reduction to that so we're doing the
minimum of the re
flipped index
of then we apply this
and then we have to
apply this derived function to the
result of the concatenation which one
way we can do this is like this you can
test it this still we still explicit but
we've prepared all the pieces for ATT
tested
conversion you you see that this
works and now we can get rid of um all
mentions of arguments
and this wants identity function applied
to the right
argument and we can call this G oh we
still need uh the comma over here we
need to um we need to pre-process the
right argument using
Revel so now we can
write and and it also works for
scalers thank you for watchinghey
we're given a list of heights
of buildings
and imagine that we're standing at in
front of that list and looking
unto these buildings
then we cannot see a lower building
that's behind a taller building but we
can see a taller building behind a lower
building
so just needing to see a little piece of
a building in order to count it as being
seen
how many buildings can we see
let's have some test data
so here we have two buildings that have
the same height that means that the
second one is entirely obscured by the
first one
and here's one that's lower
which means you can't see that either
then there's a higher one that one we
can see
and again the lower one
and that's obscure is behind both this
number 10 and the fives over here so
suddenly we can't see that then there's
a 15 which is bigger than the 10.
and that's our third building we can see
in the 10 is obscured behind the 15.
but we can do this by hand we want to
write an API function that does this and
let's start by defining an a function so
this is an anonymous Lambda and we're
putting the test case on the right
referring to it with Omega which is the
right most letter in the Greek alphabet
and therefore is indicating the or is a
symbol for the right argument in defense
or lambdas if you want
okay now we can start computing
and what we want to do here is we want
to Traverse from the left to the right
and all the time looking at
how high a building have we seen so far
and what we can do is we can do is it's
called a scan using this backslash
and it's a cumulative reduction and in
this case we're using it the maximum
function so
maximum of five and five is five maximum
of five and two is five and then we can
see that so here we're getting a five
and then with the 10 we go up to 10 and
the 10 continues until ruling rolling
over the three because we're doing
maximum until we get the 15. so let's
try that
foreign
all we need to do is to see how many
different numbers are there because any
you will never get a lower number after
a higher number but we can get some of
the same
we're not interested in these are the
same we only want to count the first one
of each and a simple way to do that is
simply taking the unique
from that
so these are the heights of the
buildings but the problem statement is
to count how many there are so this
Telemark
counts how many there and there are
three
so let's call this F this is a very
short neat solution to the problem
and there are other ways that we can
solve it let's start again with
this cumulative maximum
and
this time we're going to look at the
mathematical relationship between these
numbers
so we are interested in whenever we go
from one Building height a plateau like
this to the next one we want to find the
places where
we're looking at consecutive adjacent
elements we have an increase
and we can do that by comparing
pairs five five five five five ten ten
ten and so on
so we want to reduce using less than
so reduction is the forward slash the
cumulative reduction is the back of
Slash backslash but we don't want to
reduce over the whole thing we only want
to reduce over sub
arrays of length two so that's what the
two on the left means
and we can see that these numbers then
correspond to the spaces in between so 5
is not less than five five is not less
than five but yes five is less than 10.
there is but one problem that since
we're looking at the change here then
we're missing
the
um we're missing one because there's
only one one for the change from this
size to this size and one one from this
size to this size
that's one less than what we have so we
could
um we could solve this in a couple
different ways but a very simple way is
to add a zero in
um in front
note that we cannot just add one because
if we
if we try to use an empty list of
buildings and we added one then if it
wasn't for giving issues with the with
the pairwise reduction we would be
adding one to because there would be no
buildings and then we'd add one we say
there is one building but there aren't
any but if we put a zero in front
then we will get an increase from 0 to
5. there the problem statement says that
these will be
positively and positive height buildings
make sense and so let's put this in
again
and then we can see that we get a one at
the beginning
and all we need to know now is how many
ones are there and we can do that by
summation so this is a plus reduction so
we're using a plus reduction a pair Y is
less than reduction and a cumulative
maximum reduction
and this gives us the three as well
let's let's call this G
now
if you think about what is the
performance going to be of these then F
has some pretty bad issues we're using
unique here even though we know a lot
already about
what this array looks like we know that
it's a non-decreasing
list of of numbers and unique will have
to it doesn't know this it doesn't know
this property so it will have to compare
all the different numbers that are in
the list which if it was a big city
could be a lot of numbers
um and it might do some hashing and
things but it's still not going to be
very efficient because it doesn't and it
doesn't know that all we need to do is
look at where the numbers increase
um and then it produces these numbers
which we actually don't need anyway so
even that will take up memory
um just for the a new array containing
all the unique numbers only for us to
encounters we're not actually interested
in the result of the unique we just need
it for the counting so that's really
inefficient whereas G is much more
efficient
um we
we keep we started off the same way so
of course that's that's the same thing
uh we'll get back to the zero comma for
a moment is concatenation then we switch
to a Boolean array
and as soon as you do that APL is clever
enough to compress this into using one
bit per element so that means we're now
down to an eighth of the memory used for
to represent all the data we need to
compute on if
we have one byte integers in the in the
Heights if we have even higher buildings
for multiple byte integers internally
then it's going to be even more extreme
difference it could be effective 16 or
32.
um and then the summation of this
Boolean is going to be really fast
because the inter because um the
processor has instructions on Counting
how many ones there are how many bits
that are set in the a byte and we can do
this in enormous chunks as well we don't
care about the individual bytes we just
want how many unbits are there in the
entire memory that we give it so that's
going to be really fast
however
um there is one issue
and that is the zero
quantization here this is our original
data that we get in and if we
concatenate the s0 on the left that
actually means
that we have to rewrite everything in
memory because the numbers are stored in
their order
and we have a packet so even even if
there wasn't the issue of preserving
this array which we would anyway we have
to rewrite an array of almost the same
size to one one element
more rather than doing the computation
directly on the data as given so this is
going to be a quite expensive operation
just in memory right time and in today's
computers
um the X very often the actual highest
cost is memory read and write
the processors are now so fast
um and so smart that they will just sit
idle waiting for us to give them work to
do all the time and many operations just
happen at memory throughput time and
this is
yeah this is uh the real bottleneck and
we want to avoid memory rewrites like
this so how can we code around this we
can
make a copy of of G where we want to
avoid this remember I said before that
there's an issue if we have a an empty
list where we can't just add one that
becomes wrong but let's ignore that case
for a moment
so here we know that we are off by one
we're not with missing a count of one
which is the initial going from zero to
the first building that you can see so
we add that back here and this gives us
the wrong result if the argument is
empty but we can do the check if the
argument is empty
um so
let's make two statements this is the
the Diamond this is a statement
separator and then we have what we call
a guard it's like an early out condition
and we're going to take this this is a
short formage of writing the empty
numeric list and if that matches the
argument then
we know that there are zero right there
cannot we cannot see any buildings if
there aren't any buildings to see
so this is a really quick check there's
we're not comparing any data we're just
immediately looking is are these the the
same we don't even
um
yeah we would I think even internally
it's represented as some constant that's
always there but even if it wasn't we're
talking about looking at the data type
of the array that they're both numeric
and looking at the shape of the array
and they're the same shape so we're done
that's there because there's no actual
content to compare
so this is a really quick check of
course that does have had some overhead
and it does add a branch point where a
branch particular could fail but it's
going to be dwarfed uh by
and the actual computation that happens
in the in the general case and of course
here we are saving ourselves even one
comparison
um everywhere and we get a single number
and then we're adding one which is
really cheap obviously as well okay so
let's see if we can
um actually see
the difference in performance
we have some a tool called cmpx or
compare execution uh we'll copy it in
from the defense workspace
and then let's generate a cityscape with
a whole bunch of numbers
um
let's do a thousand buildings and then
I'm going to randomize so the first one
is going to be a size one building and
the second one is going to be a size one
or two and then the third one is one or
two or three
and so the question mark role it takes a
number and generates a random number
between one and that number and the Iota
generates a sequence from one to a
thousand and this because we give it a
thousand and this and the right
and what this means is that in general
the buildings will become bigger and
bigger and if we made them all the same
then pretty quickly we would not see
anything more very little likely of the
senior so this ensures that we'll still
even at towards the end we'll still be
seeing more buildings
right a thousand random buildings
um and then we write our Expressions
that we want to test
so we want F applied to S and the g
applied to S and H applied to S and now
that we wait a moment for it to run
these Expressions a whole bunch of times
and comparing
them to each other
and we can see here that there's quite a
significant difference in the
performance between them but also
the
the definitions are Maybe
getting more and more complex and and
certainly longer
so sometimes you just have to wait
between how neat you want the code and
how performant you want it you can
always have both
thank you for watchingwelcome to the apl quest capl wiki for
details
today's quest is problem six from the
2015 round of the apl problem solving
competition
we're given two rectangles as two
coordinate pairs and we have to check if
they overlap
and that can be a little bit hard to
think of just in terms of words so let's
illustrate it here are two rectangles
and we can label their corners
in order to not continue to in order not
to get confused which rank that we're
talking about we're not just going to
use x and y like normally would we want
to use an alternately named coordinate
system for one of them um
where the horizontal axis is a and the
vertical axis is
b
so we got the xy rectangle and the a b
rectangle
and we can see here that each one of the
of the elements in the coordinates
are defining an edge so the left edge of
the xy
rectangle is defined by the x1
coordinate
and the bottom edge is defined by y1
similarly a1 defines the left edge of
the
other rectangle and b1 the bottom edge
now we don't know what order these are
given in and that's something we have to
keep in mind but for simplicity you just
keep it like this
and here we can see that
the vertical edge left edge of the x y
rectangle which is defined by the x
coordinate x1
and the vertical edge the right edge
defined by x2
fall in between so to say the range
between the vertical edge
a1 and the vertical edge of
a2
and similarly but oppositely
the edges defined by b1 and b2 fall in
between the edges defined by y1 and y2
and clearly these two rectangles overlap
now when a b is entirely contained we
have still the edges even though they
don't intersect the edges a1 and a2 are
in between x1 and x2 b1 b2 are in
between y1 and
y2 and even though there's only a
partial overlap like this
we still have at least one edge
vertically x2 between a1 and a2
and both of the horizontal edges b1 and
b2 are in between y1 and y2
now there's only one of each
so the edges x2 and
y2
are in between
the corresponding vertical and
horizontal edges on
the other rectangle but also a1 and b1
are in between
and here we have both x1 and x2 in
between and only
b1
in between
the other and then
2 in between b1 and b2
now there's no overlap anymore even
though x1 and x2 didn't move and they're
still in between a1 and a2
it isn't the case anymore that any of y1
and y2 are between 1 and b1 and b2
so we can see that in order for there to
be an overlap there must be at least one
horizontal edge that is of one rectangle
between the horizontal edges of the
other rectangle whichever one it is and
there has to be at least one
vertical edge from one direct angle
between the two vertical edges from the
others
of course if you move the rings entirely
away so that nothing has been in between
each other then there's no overlap
either
here there is an overlap
vertically in that b1 is between y1 and
y2 but there's no horizontal overlap
because both a1 and a2 on the same side
of x1 and x2
and so while close there is no overlap
here both conditions have to be held and
we're going to use this as our
case where it is false there's no
overlap
moving
x1
and moving the xy rectangle a little bit
to the left there will be an overlap
just in the corner and we can see that
we have the edges x1 x
and
y2
in between the corresponding edges under
the rectangle and also of course
follows with that that b1 and a2 are
in between the corresponding edges of
the xy rectangle
in the code we're going to
use labels for these it's the same
rectangle a b but we'll have x y one and
x y zero for the one that should give
true and the one that should give
false
and then in order to give some of them
some concrete values that we can work
with
let's just set an origin point which is
where the a1
sorry where the
b1 and the x1
edges would meet had they continued out
that gives us some nice small positive
numbers to work with but this of course
will be
very general
right
so
a b will have 0 2 and
5 9
x y 1
4 0
11 3
x y 0
zero and thirteen
three
and now we'll start building things up
so let's just make a placeholder
function for now the concatenation of
the encloses that just juxtapose
the two arguments and we're going to run
our test cases every time so we have
a b with x y one
and then let's output a little line and
do a b
with
x y
zero
so this gives us our arguments so this
these are simply
x one sorry a one and b1
a2
b
and 2
x1
x y 1 x 2 and b
and y 2 and the same thing in the at the
bottom
this encapsulates
a and b values together and x and y
values together and we really want to
consider them separately because the
condition is
that there are separately r overlaps
horizontally and vertically so the first
thing we'll we're going to do is we're
going to mix these to get
nice
matrices to work with
and then but we still have each row
being a mixture of horizontal and
vertical values we can fix that by
transposing
now that we have transposed we have
a1 a2
x1
x2
b1 b2 and y1 y2
we can start working on these and so
what exactly was it that was our
condition we're going to work on each
row separately so
let's use rank one
and then we're going to
start stating what exactly is it we're
looking for
so
for each row that means we're
considering uh the
horizontal component and the vertical
component and they're being run
separately because of the rank one so
you can just talk about one
um let's talk about the horizontal
component that's the x1 x2 a1 and a2
on the left we have
a1 a2 on the right we have y1
y2
so
the lowest sorry the lowest one
on the left
because remember we don't know what the
order is going to be so we can't just
say it should be
the first one which in our case is a1
and is the lowest one but maybe it's the
it's b
it's a two that's the smallest value
so we take the smallest one of those so
the smallest one of
of
a1 and a2
has to be
less than the greatest one
of the corresponding on the right which
is
x1 and
x2
so if the smallest one
on the left
is
below
the greatest one on the right then
then they might overlap
but that's not sufficient
because we also that they could both
both of them both a1 and a2 could be
below
x1 and x2 so we have to have an
additional condition which is
that
the lowest one
on the right
so that's the lowest one of x1 and x2
also has to be less than the highest one
of a1
and
a2
so now we know that
they overlap in this component and since
we're doing this for each row in our
matrices we're doing this separately for
the horizontal part and the vertical
part
and then
with the only thing we need to know then
is is it both true is there an overlap
horizontally is it an overlap
vertically so if both of these are true
then
there's an overlap and we can see here
that the a b x 1 x y 1
case gave us a 1 and the a b x y 0 case
gives us a 0 which is exactly what we'd
expect so this is one solution
but we can clean it up a bit
because think about it
we're using
we're doing things rank one on each row
and
after we transpose
so if we don't transpose
then we need to do things on each
column
instead and we can't do that with the
rank operator but we don't need to
because each
doing things down
so that's a reduction
vertically we can do that with reduce
first instead
so that's one simplification another
thing we can see is that there's a very
strong symmetry here the component on
the right of the inner end and the
component on the left of the inner end
in this fork
are pretty much identical
except one thing
this points to the right this points to
the left this points to the left and
this points to the right
so
they're doing the same thing but they're
swapping
their arguments
and so if we give a name
to this inner component
then
on the left we can just use it with
swapped arguments
and we can even get rid of
these parentheses here
so this is a very nice solution to the
problem
let's
go for an entirely different one
this time we'll start writing a
different
and again we just start off by
just opposing the arguments
oops
of course we need to put
g over here as well
there we go okay so here are our
arguments um again
and instead of doing this whole mixing
thing
now we're just going to use an outer
product
because we want to compare all these
values and see which ones are
um are
below each other
so this is this is an outer product
between the pairs
of
a1
b1
with
x1
and y1
so this is saying
so for each one of these comparisons
we get these two values one for the
for the horizontal component one for the
vertical component so this is saying
that a1
is less than
x1
and
b1 is not less than
y1
and this is saying that
a1 is
less than
x2
and b1 is also less than
y2
and then we go on to the next
a b coordinate so that's a2 is not less
than
x1
and y
and b2
is not less than
y1
and finally
a2 is less than
x1
2
and
b2
is not
less than y2
okay
now
remember that we want
edges to be in between
the edges from the other
um from the other rectangle
but it could be any of them so
since
less than shows whether or not we are on
the left or
below
and so we need to have one that is
we need to have at least one edge for
each that
is below and one that is above some
other edge in the same
along the same dimension from the other
one then the only thing we need to know
really is if they're different we don't
care which one it is we just need to
know that one is less and one isn't less
than
so by applying
a
different from reduction we're going to
again compare element-wise so we're
going to compare this element here
whether um a1 is less than
x1
with
this element over here which is whether
a1 is
less than
x2 which is exactly what we want right
if
this is if the a1
edge is the one that that is the
determining one that is in between the
other two then these two values would be
different which we can see it isn't here
and same thing here we go for the
vertical components that is the one uh
that's going to be different
and same thing here this is uh
a
two will be is different from
um so a8 sorry a this is a two versus
uh x one and a two versus x two and so
being that they are different that means
that the a
two edge does fall in between there and
then we can see that it is
here in the top right and the and the
bottom left those are the ones where
they are different so those are the ones
that will give a
that cause the intersection to be there
so because this is in the right side so
this is the vertical component this is
the left side this is the horizontal
component so this is saying that the
edges that are in between
are
b
1
which falls in between
and
y1 and y2
and there's also a2 which falls in
between
x1 and
x2
so the only thing now we need to know is
whether we have at least one horizontal
component and at least one
vertical component that's uh where this
is going to be true however
and this isn't enough we also want to
know whether this happens in what it
doesn't have to be
that it is uh
that it is the
uh the a b which is
uh in between
x y it could also be x y that's in
between a b
so how would we
know that well we just reduce in the
other direction
and then and we can see if any of those
are true
so we could write this as
one or
the other
however we can be a little bit clever
about it they're actually the same
except we could transpose first so we
can write
the
leading axis one
as
the reduction over the transpose
and now we just we want to know if any
of them of the one that's transposed and
not
and are going to be
true so we can do all the reductions in
one go
if we just concatenate along the first
axis
with
its transpose
its own transpose
then we get this
borrowed table and so really the bottom
two rows are the transposes of the
others of the first two rows
that means we can
just reduce across and then the last two
across reductions are actually
equivalent to vertical reductions
so now and we can
do our different from reduction across
to see if
there is a different relationship to the
and to the edges on the side
and once that's
done we just need to know whether there
is at least one
and vertical at least one horizontal
component and where this is true so we
can mix it all and then we so the left
side here are all the horizontal ones
and the right side is all the vertical
ones
which means we can get whether any is
true
with a vertical
reduction
and then we just need to know whether
both of them are true
and that gives us the solution which is
also very nice
and finally
let's start over yet again for another
approach
this time we're not going to do the
direct comparison the
outer product with less than but we are
going to
start with an outer product
this time we're doing a subtraction
why is subtraction because
we can actually see on the sign
whether or not something is less than or
not so if you get a negative value it
must be
that the alpha component here was less
than
the omega component and since we're not
actually interested in the magnitude of
their overlap we're just interested in
whether or not they're overlapping or
not we can take the sign of that
and here
this means that
a1 was
less than
x1 and a1 was less than
x2 and
b1 was less than
y1 and
a b 1 was less than
y2 and so on
now we need to think a little bit
so
we need to know
whether
there were any
that were
in between
in order
let's state the opposite let's say that
they were not in between
so if
if one component
was
so you say if if both
horizontal components of one rectangle
were on the same side
of the corresponding components from the
other rectangle then all of these
numbers that in that dimension would be
the same
so really all there's only there are
only two ways in which we don't have an
overlap and that is if you've got for
each dimension
four negative ones
or
four ones
if there's any
value which is of the other sign than
its companions then that means that it
has the other relationship and then it
lies in between
so
let's flatten that out
and then remember that the first element
in each of these pairs corresponds to
the same dimension so these are all the
uh
the a's
and
the
um
so the a's against
the x's and there are two and one of one
and two of the other so that gives us
all four
and now if we sum this
then
we get added all the
first elements together
and all the second elements together
giving us these two
and remember that the only case where
there's no overlap is if they're all the
same that means the sum
has to be
four times negative one meaning negative
four
or four times one meaning four
in other words the magnitude of the sum
is four
so if we disclose this because we got an
enclosure when we did a reduction over
these
pairs
and then take the absolute value
of this
then and
only in the case when there's four
there's no overlap
and we can see here that uh horizontally
and there's no overlap
but
vertically
there is an overlap
what you're interested in
of course
is that there is an overlap
so there is an overlap if the sum is
different from
four
and these are the horizontal and
vertical components and we have a full
proper overlap and if both horizontal
and vertical components are true
we just need to say that both of them
are true
which we can do with an
end reduction over them
okay now that we have
this
and all these different solutions
let's look at
um
some comparison of performance here it
can be quite varied
and for that we need some test data it
doesn't really matter what the values
are as long as we get a bunch of
different
values relative to each other so that
and their magnitude doesn't
really matter
what we're going to do is
we want to
to create some
abs and some xy's
and then
and
let's
make some random numbers
and so we have two variables here the
abs and the xy's
let's let them have a hundred pairs each
where um
so the pairs are the the
two element vectors of two element
vectors
so because we need the the two for the
uh for one corner two for the other
corner so two
with two in each and with zero here then
this would give us just some random
notes between zero and
and one but we'd want it all to be
nested so we'll
split it this gives us a two by one
hundred by two
array of
pairs we split it again now we get a 2
by 100 array of pairs of pairs
and we split it one final time and now
we get a
two element vector of 100 element
vectors of pairs of pairs
let's copy in cmpx from quad c
from
defense
and construct the expression that we're
going to run so this is the abs
joined up with each of the function
names f g and h
with
the x y's
let's check that this
looks good yeah that looks fine and then
look at the performance for that
and turns out that
our initial uh implementation
that was very much based on
how we phrased the problem is
significantly faster than trying to do
any of these clever tricks
that's all thank you for watchinghi
let's remove text that appears between
Pairs of double quotes in a larger text
we start with a test case
that needs to contain some of these
quoted
things
and a very obvious approach is to use
regular Expressions it's great for
matching and manipulating text
so we can write this directly we're
writing it as a derived function using
the quad R that's the regular expression
replace
operator it takes two operands and
derives a new function which we're going
to assign to R for regular Expressions
the left operand is the pattern that we
want to match we want double quote
followed by
any characters that are not double
quotes and we want zero more of those
and then a final double quote and we
just replace that with empty double
quote double quote
this works very nicely and it also works
in the case where when you have some
some text
with empty and empty double quotes
and this is important for the regular
Expressions if I had used a plus here
instead then we would have only matched
double quotes that actually have content
in between and this might seem like an
optimization but it gives the wrong
result because
what we'll do is we'll not match this
empty quote
and then we'll try to match beginning
with the next character and that will
match but now we are out of the parity
and we can see that here
this is with the star
and this is with the plus and that's not
correct
okay now we're going to do the same
a job in a bit more of an APLE way
before we do that we're going to define
a helper function just to let us see
what's going on
and it's a bit involved but not really
important for this problem so we want to
apply this function on each character
and we simply want to add put the
character adjacent to a space
we print that out without a new line and
we do that by assigning to the special
quote variable
and there is the pass-through result if
we use it of this assignment is the
value on the right which is the
character itself because we have applied
this whole Lambda to each character this
means each
um and so we're going to get the
character itself followed by a space but
we only want the character itself this
has the effect
of
printing out as a side effect
the spaced out text
but returning the original text
so we take this whole thing and call it
P for print
and now we can start working
so we're making a different a Lambda and
applying it to the text but let's print
it out
and in here we refer to the argument
and compare it with the double quote
this gives us a Boolean mask and as you
can see why I want
the letters to be spaced out so they
line up with the corresponding Boolean
and we can see we have a one a true
because API represents
true and false as one and zero and they
are just actually numbers
and every time we have a double quote we
have a one because the equality Maps
automatically from this one character on
the left to all the characters on the
right
and that means that every time we we hit
a one we need to flip state so to say
we're switching between being outside
the code to be inside the quote
um and we can do that with an xor scan
or a cumulative xor
xor just means when only one
argument is true not the other one that
is that the different
so we use in APL the unequal and scan is
the backslash so this is a cumulative
xor or extra scan
and this means
that we have we're outside of quotes
until here and then we're inside quotes
and then we go outside quotes again
there's a little bit of an off by one
error in that the final quotes are
considered outside and they should be
um outside and the leading quotes are
considered inside but they should also
be considered outside because we want to
keep the quotes but want to get rid of
the content and also the content that we
want to get rid of should probably be
marked as false because then we can use
compress to remove it
so we can start by and Flipping The
Chosen fonts so this is a Boolean nut
and then
we only need to
um
include the quotes as well but we
already created
a mask that indicates where the quotes
are
and it doesn't matter that it has zeros
for places and not codes if we do an or
so then so if
this gives true or
this gives true then that's what we want
so we can give this a name mask and then
we can do this mask or
this over the right note that APL it
doesn't have a precedence order for
these Boolean functions everything just
flows from right to left or another way
to look at it is every function
including a derived one like this XO
scan and takes this argument everything
to its right
so now we get the mask that we want we
can see we have zeros for the characters
that are inside the quotes and the ones
for the quotes themselves and characters
that are outside the quotes and that
means
um
that we can use compress
but before we do that
I just want to note this or not
that can actually be optimized a little
bit let's have a look how so if we
create the function that just does the
or not
then we can use the outer product which
is the all combinations between 0 and 1
which are all the possibilities in
Boolean algebra on the left and zero and
one on the right so this is like a
multiplication table
but only for zero and one so zero and
one and over here it's also zero and one
for the columns and there's that
multiplication it's or not
and that's reason about this a little
bit
we can see that there's only one case
where this gives false that's when we
have zero on the left and the one on the
right that is
it gives false if then less than it's
the only case when you in Boolean we're
restricted to only zeros and ones where
we have zero where we can give true from
less than
but we don't want true from this one
less than we want false from that and
true from everything else so we want
something that's not
less than or it's not less than is going
to be greater than or equal to
so we can go up here and replace the or
not with greater than or equal to
and we can see that gives the same
result
so now we have
shown that using the laws of Boolean
dungeon then we can replace the or not
with a greater than or equal to
okay we continue on our way
um
and we use this
to mask out
the
argument itself
and this gives us the result that we
wanted
however this but a single symbol on the
right of the compression function
whereas we have a whole expression on
the left that then needs to be
parenthesized because as I said before
we flow from the right to the left
we don't have a function that does the
same thing just with flipped arguments
but we can create that for ourselves by
using the commute operator
which commutes the arguments so now this
is a derived function which takes the
mask on the right and the data to be
masked on the left
and that means we don't need the
parenthesis anymore
because as a derived function it's a
function and takes everything to its
right as its argument
so this is a very nice solution and we
can call this
um let's say x because it uses the xor
scan
who can apply it to argument
and of course this works just fine when
we have adjacent quotes
because it just flips between the state
of being out of close to inside quotes
and then inside quotes outside quotes
every time we see a quote it doesn't
matter whether there's anything in
between them
finally we're going to implement a more
General solution an actual State machine
here we used xor to carry a state along
and this works fine for this very simple
type of coding but let's say we had
different types of quotes single quotes
and double quotes and Escape characters
and so on
then this method wouldn't work and we
need an actual State machine that
traverses over our string and keeps
track of and where we are and what state
we're in now we inside quotes every
outside quotes are we in the middle of
an escape sequence and so on now we're
not going to implement all those
features I'm just going to implement the
framework for the stick machine the
simplest form
so let's start again
with the mask
and print that with the argument itself
so these are our the the points where
we're going to switch state
and then we're going to start with a
starting state which I'll call
um l
for um it's a letter that we're going to
keep and everything else is like in
quotes
the state initial state is one
and Diamond separates the expressions in
the APL so this is the Lambda with with
two expressions in it we start off by
setting the state L to one and then we
produce this whole mask now this has
looks exactly the same because assigning
L to one it doesn't make any difference
however now we can start working our way
through this mask
so we want to apply to each one a new
little Lambda and that little Lambda
will update this initial State here of
course the first character could be a
quote in which case we immediately flip
it and the way we're going to do it
is we're going to use
um
a very nice thing we have which is
modified assignment right you might know
about augmented assignment if in other
languages often written like this this
will increment
like that now we don't use
equals for as I mean we use an arrow and
this works in APL but not only that we
can use absolutely any function to the
left of the assignment and then that
essentially means
um that function
um with the argument left argument of
the variable that's being assigned to
and the right argument whatever is on
the right
and as any other assignment the
pass-through value is going to be
whatever is to the right of the
assignment Arrow so the result of this
will be one even if L now has a
different value than one now we're not
going to use plus we're going to use
well xor again
because we want to say
um
this the state
if it's equal to one and it's already
one
then we want it to become zero and if
it's zero and we have
um
sorry this is this shouldn't be a one it
should be an argumentative so so we have
going over this mask and we want any if
we say it's different from zero
for Boolean
that just keeps their value
right because
if it's zero different from zero is
false so it becomes zero if it the value
right now is one different from zero
it is different from here so it produces
one so we so by doing different from
zero we preserve the current value
so as we Traverse over this we're not
changing State as long as this is zero
now if there's a one and the current
state is zero zero different one then
that's one so we change from zero to one
and if it's currently one is one
different from one no it's not so that
the answer is zero and then we switch
the state so whenever one here we switch
the state of L we can't see that
anything happened here because we have
just updated the state we didn't
actually use the state
for anything
however
this if we continue and return the state
value at every point then we can see it
and effectively we got this xor scan as
we had before
again we have the problem that the
initial quotes accounted as being inside
because we switched the state
immediately at that point
but luckily the argument here is
actually
whether or not the current character is
a quote and that means that we can
we can again say
um
the state
or
the argument whether or not the current
character is a quote
and this means that we get the quotes
always marked with one
we can however be a little bit more
clever about this because the
pass-through value of this assignment
is the argument itself
and by the time we're done with the
assignment then L has been updated
so this Omega over here is the same
thing as the expression over here we can
take the rest of the expression
and add
over here instead
and now we have the states as we
Traverse and of course this is Lambda
couldn't have a whole bunch of code that
decides what to do based on what
character we are in now and what one or
more different types of states that are
being updated as we go along are we in
an escape sequence are we in this type
of string are we in that type of string
are we inside braces and so on so this
is a
um a completely General system it can
decide what to do at that point and
update all the various states that we're
tracking we could have multiple states
that we're updating
um and so on
and this gives us our mask which means
we can proceed just as we did before
we'll
compressing filtering by this mask
and that gives us our result so this is
a state machine implementation it's
going to be much slower than using the
built-in Excel scan but it is a more
General solution
this is a state machine and it works
thank you for watchingwelcome to the APL Quest Capel Wiki but
details
today's Quest is the 8th for the 2016
round of the APL problem solving
competition
we're giving some numbers
and we need to return
a two element list
the first element contains
all the negative values
and the second element contains all the
non-negative values
we can do this
by filtering the values so let's start
with making some values
okay
APL
has implicit mapping
over
arrays that means if I make a comparison
like where 0 is less than or equal to
these values
then it automatically Compares all the
values
also
one and zero are used as
true and false
they are actually the same
we can use this to filter using this
slash we're filtering V
and similarly we can filter V with the
values that are less than zero
okay now we just need to put these two
formulas next to each other
this is an expression for the solution
let's make this into a function
we put braces around it and this makes
this an anonymous Lambda also known as a
defen
put V over here and inside this we
represent the argument
with Omega which is the right most
letter of the Greek alphabet because the
argument goes on the right
and so this is one solution that we
could use but it has a lot of
parenthesis it's an
even inside these braces and it's a
little bit hard to read like that so I
prefer avoiding the parenthesis
now that means I need to have something
like the slash that text the arguments
in opposite order that takes the mask
on the right
and the data being filtered on the left
there isn't such a function in APL
but any function can be modified by this
modifier or operator
called commute or swap which binds
together with the function in the slash
function
and
create a new function which is exactly
the same but with commuted or swapped
arguments
so now we can take this mask and put it
on the right
and put and take the
data on the left and since APL has long
write scope
in other words we start Computing at the
right end of an expression then we don't
need parenthesis around this part of the
expression anymore and we can do exactly
the same thing over here
so this is another solution
one thing is a bit of a Pity is that
we're comparing all the elements which
could potentially be many twice and we
could actually infer the result of one
of these computations from the other
so let's say we save this as the mask
and we can do that inline the result of
an assignment in API is always whatever
the values that's being assigned is
so now we have M available and we
continue to the left and we can use M
over here
um but we need to negate it because we
want all the values that are not those
so this also works
we can actually get rid of
this swapping simplify things a little
bit if we had a positive mask instead of
a mask we need to negate
foreign
but then that's not this then we need to
make the opposite
comparison over here and then we need to
negate it over here before we apply it
so this also works
we could also just take this mask and
put it in a separate statement first
diamond is the statement separator it's
strong like a diamond separating things
into parts and then we could write it
like this
foreign
or we could say that these are the this
is the negative mask and then we could
have a separate positive mask if we
wanted and then we could write it as
positive mask over here for symmetry
oops
open the negative mask of course there
we go notice how he appeal points me at
the name and tells me which name it is
and that's missing so I can do something
about it
and so this is an another solution to
the problem
which kind of looks nice finally and
let's make a little bit of a variation
on this based on set computations
so we're going to start by Computing
um the positive values this time
and we do that as as we did before
but now
um instead of saving the mask we're
saving the values themselves and the
return value of this assignment of
course is that value
then the negative values would be all
the values except the positive ones
and we can express that as all the
values
without
the positive ones
so this tilde when it's used with
arguments on both sides it means without
and when we used it with an argument
only on the right it means not so how
are these connected to each other we can
remember this by thinking of without or
set difference as but not
so we want all the values
of the argument but not the positive
values
whereas here it just means not
and that's our final solution
to the problem
thank you for watchingwelcome to the appeal Quest cap Wiki for
details
today's Quest is the sixth from the 2016
round of the APL problem solving
competition
we are to take a list of arrays specific
the list of vectors or possibly scalers
and sort them by that length the
shortest ones are in the front and the
longest ones at the end
this is really simple
let's make some test data
okay so this is a list or vector as we
call it and it has six elements let's
try printing it
and we can see that there are some
numbers that would have the length of
one and then there are some strings in
here that have the length of two and
five three and five and then there is
also a list of numbers which has length
four
and the way we get the length is by
using the tele function
and it looks kind of like a Telemark you
would make into a counting stick
but we don't want to tally D because
that will give us the number of elements
in D instead we want to tally each
element in D so we use the each operator
or higher order function which is kind
of like a map
so we are taking this function which
we're applying
to each element of d
and here we can see the length
what the number one has length one the
word two has links three and so on
and now we can use this to grade
grading is a it's a very apla operation
really but it's kind of like the more
fundamental form of sorting it doesn't
actually reorder the elements but rather
it gives us the indices of elements
as we would need to take them so that
they should become ordered we're not
doing the ordering quite yet and this
function exists like this because then
you can use that information to sort
something else which allows you
basically to sort some data by some keys
for example
so this gives us
that if we want it to be sorted by this
information the length of each
then we first take element number five
that's this empty string
and then element number one which is a
number and then element number four
which is this number four then element
number two because it has links three
and then element number six because it
has length four and finally
element number three because it has
things five
and then we can use this information to
index into d
so with square bracket indexing
which allows us multiple indices and
when we give it multiple integers it
just reorders the elements or picks out
those elements in that order
that gives us this
and that's the result that we want but
this isn't actually a function that does
the work rather it's just an expression
we can change this into a function
Anonymous function the Lambda and by
putting braces around it and then
denoting the argument with Omega because
the argument goes on the right just like
all the other functions we applied so
far
and the argument goes on the right and
Omega is the rightmost character of the
Greek alphabet so we put Omega instead
of the D's and this gives us a function
we can either apply it directly
or we can give it a name so this is uh
sort by length for example we use left
arrow for assignment equal sign just
means equality
so now we've given the name and we can
then call it on D
and it's Source it correctly for us and
that's really all there is to it thank
you for watchinghi today's Quest is to find the set
difference between two sets but the sets
are given as um any type of
arrays and um the difference has to be
symmetric so it's not just all the
elements from one element from one
argument that's not in the other
argument it's only those elements that
appear in exactly one of the arguments
but not in both of them
let's get
started we have here a character vector
and here's another character vector and
we can see that both of them have an A
and both of them have an L so those
characters should not appear and what we
should get instead then is a d a y and O
and G and P from this one over here and
let's make an anonymous Lambda a defin
um here in we refer to our left argument
as Alpha and our right argument as
Omega and we want to consider all the
elements and then remove the ones we
don't want and all the elements we can
get by using the
union of these two so the a set Union
we're treating these character vectors
as
sets and the ones that we want to remove
are the ones that are in both so that's
the intersection between
them and then we can use the set
difference uh between the
union and the
intersection and for symmetry we can put
parenthesis here that's not strictly
necessary
right this however is a really great
example of what is called a diic fork
notice that if we think of the functions
involved in the algorithm we have here
the Union function applied to the
argument and we have the intersection
function applied to the argument and
then the results of those two function
applications become the become the
arguments for the set difference or
without
function and for that we can use the for
construct which does exactly that for
construct is just three
consecutive functions in
isolation and it reads nicely the union
without the intersection and that's
exactly what it
does so this is a neat way to write
it um another approach that we could use
is to say that we have all the
elements from one argument it except
those that appear in the other
argument and similarly all the elements
in the other argument that are not in
the first
argument and then all we need to do is
to merge the two and that could be using
uh a union or just concatenation and
there's no really any reason to write
um a union because we know that they
must be all different so we can just
concatenate them
together here we have something that
looks like the for construct with the
same function on the right and the
left
and the trick is that we have the
arguments swapped otherwise it would
have been exactly the same on the right
and the left so how can we do this in
order for us to apply the fork construct
then we need to have the left argument
on the left and the right argument on
the right we can modify using a montic
operator the set difference function
which is not symmetric to swap its
arguments so this till the diis it deres
a new function which is the same as the
old one except its arguments are swapped
so now we can put the alpha on the left
and Omega on the
right and with that we can clean up to
get just the function in
isolation use the nice Fork syntax ahuh
but there is a catch and that is that we
not guaranteed that our arguments are
vectors or scalers they might have
higher rank for such a thing um let's
say
we we put in the comma bar function
which then applied to this argument over
here and it gives us a column Vector
let's try that for a moment so if we try
to do that then we get an
error and the same thing would be if we
use our other uh function over
here same kind of problem a rank
error so what we want to do is before we
start applying the main part of the
function we need to pre-process both
arguments to make sure that they are
just vectors and we can do that because
we have a um special operator thetic
operators it takes two functions
combines them and the comma when used
with just one argument which is what
this operator will do uh it is a
flattening operation or Revel it
destroys the outer uh shape but it keeps
all the elements intact so if you do
that it will work and the same thing
goes for our other function over
here this will also work so these
two are the two solutions we can give
them
names
and then we could apply them in line as
before like that thank you for watchinghi we are to take a multim
multi-dimensional array and
interchange the horizontally adjacent
elements here is an example
multi-dimensional array it is a
three-dimensional array with a two
layers and each layer has two rows and
then we've got five
columns and our task here then is to
Interchange adjacent element so Gela is
being interchanged with opton they
switch places Prospero with Lysa and
then uh there isn't anybody to uh switch
position with toaza so that just stays
in place there and the same goes for
every row and
actually note that we can really operate
on individual rows we don't have to
worry about the overall shape of the
array though we'll get back to doing so
anyway so just to develop our algorithm
let's focus
on uh just the first
layers and first row and then all the
columns from
there we have those
here and so we'll start by the finding
or wrapping our Anonymous function
de and we
can take advantage of the partition
inclose function to pair up these
adjacent elements and flip the positions
and merge everything uh back
again and the the petitioning close
function it takes a uh for our purposes
a mask have one when we are to start a
new section and then zero when we are to
continue a section so we want a mask of
one Z One Z onto the length of uh this
Vector um so we can get the length of
the vector uh with or the shape of it uh
with uh the shape function of
Omega and then we can use this to
reshape uh one Zer so we keep using from
this array one Zer uh cly until we have
the shape that we asked for and that
gives us this mask then we can use that
mask to partition uh the argument and
here we have the pairs that we going to
flip and we now can uh reverse each one
of these and notice that the last one
that only has one element it's still
Vector of of character vectors here but
it its reversal doesn't have any
effect and now what we need to do is
merge these back together again so we
use a concatenation
reduction but uh the concatenation
reduction uh has to reduce it is a
reduction and reduces then the the rank
number of Dimensions from one this is a
a list Vector of vectors to zero so this
is a an enclosure of uh the actual
Vector result that we want and we need
to then disclose that uh to get the
result we want this took care of
the simple uh case where it's just a
vector and we want this to apply to all
the vectors that can be found as
subarrays of our overall um array so we
had the entire n here and we can very
simply do this um that's we can we just
Define our function here e uh for uh
partition
inclose and specify that it should be
applied on rank one so it's not really a
specification It's actually an operator
that takes a function as left operand
and a rank specification as right
operand and saying this function must
never see any argument that has rank
greater than one so in effect the rank
operator will iterate over our given
argument and apply the function to every
subarray of rank no more than one which
is in fact always going to be present
because the problem specification says
that it will be a vector or higher rank
array so we can try this let's uh print
out the names again just so we can
compare them and then we apply uh the E
function to that and we can see that uh
we got exactly the result that we
wanted so this is one way to approach it
um but there are many others I'll go
through another couple um another way we
could do this is by indexing so we could
build up up the
indices uh of the elements reordered
such that we get the result that we want
and that takes um a little bit of an
algorithm so let's start again just by
the vector case and then we can apply
rank one to get the full uh thing so
here is our
vector and again let's define a uh
Lambda
a and and this time uh we again we have
the the shape of
that but now what we really want is to
find out which order should we put them
in in order to sort them but not just
sort them by say alphabetically but sort
them such that we interchange adjacent
elements and um we can start by
generating the norm noral indices right
so what we want here is the uh the
reordering but we need to adjust our
values because these are already sorted
so that two becomes uh less than one or
one is greater than two and three
becomes greater than four and so on and
we could do that by just adding two to
every other element so if we add two to
one we get three and that doesn't Clash
with the next three because this three
will also have two added to it and
becomes five and it won't clash with the
five because five becomes seven and then
and then the two and four stays and then
we just have to sort by uh that ordering
the ordering that would sort those
numbers enough talk and we can do this
in exactly the same way as before so we
uh we take the length and we use it to
reshape uh this time it's two and zero
and then we just need to add that to the
um to the indices that we computed over
here and for that um easiest thing is to
make a little train uh Fork so we do the
indices plus the reshaping of to
Z and we apply that whole thing to the
shape of uh the argument so we first
compute the shape and then we get the
indices of the shape and then we use the
shape to reshape to zero and then we add
those together they now have the same
length of course and that gives us uh
this we can see the one was incremented
up to to three and the two stays in
place the three became five four stays
in place and five became seven now we
can H we can grade this to find out what
indices elements should we take in order
to make this
sorted and so here we can see that we
want F the the smallest element is uh
the second one that's the two then the
next one is the first one the next one
is the fourth one and the next one is
the third one and then the fifth one and
that effectively gives us um these flip
pairs for indices 2 one then 43 then
then five All That Remains now is to use
these indices to index into the argument
and we have gotten um our reordering as
we
wanted so here we're using indexing with
grading um we can call this I and then
specify that this goes on uh vectors and
that means that we can let's just print
out our um example names here again and
then we apply our
function and we can see again that we
have the correct uh flipping of
Paris
and finally I want to show how to do
this uh using the stencil operator the
stencil operator is normally associated
with cellular automatons Game of Life
things like this um it processes Windows
of an array um it's it's almost an edge
case that it can have Windows of size
two and the movement the window moves
over by two steps and that effectively
isolates and adjacent pairs
this time uh let's do it tested and we
again we can start with uh the first
layer's first
row so we use run parenthesis instead
for a a train or a tested
function and um we can we start with a
stens operator and then the idea here is
that we use an Windows of size two with
a movement also of size two so we need
to make this into a matrix because every
row has serves a different purpose in
the right oper stens the first row
specifies the window size the second row
specifies uh the window movement if
there were additional Dimensions we were
traveling along then we would have
additional columns in this
table and we can and we can isolate
these so we
can uh this the oper end function to
stencil is given uh two arguments and we
don't need the left argument so we use
the the right function and then we
enclose
that and uh we can see that we got the
pairs but stencil cuts the argument
short if it can't complete a window uh
with the specified
movement so we will have to address that
but for now
um we don't have to necessarily enclose
this we could also increase the rank uh
by not
enclosing so that gives us this table
and that can uh conveniently
be uh
reversed and then and we can Revel it
and
again right
there now and there is missing something
and and then is the last column so we
can read that column but of course this
only happens when uh the rows have an
odd length so here we use a a right
reduction to get uh the rightmost
element and that add this back again if
we had an even number of elements then
and
our and code here would add one more
column that didn't need to be added so
we can do this by cutting short and our
argument to just four not five uh names
and we can uh see
that and we have an extra Delicia and
over here because that was the last
element before it was moved one step uh
to the left this is of course wrong but
we can counteract this uh by taking the
uh the
shape so we take using the original
shape and that ensures that we chop off
the excessive uh element if it
exists and then if we use the odd
numbers here five then we also get uh
the right
result so this works um again on uh rank
one and we can call this s for stencil
and we can try to apply that on and our
whole multi-dimensional array and we get
the desired result
result um it would be interesting to do
a speed comparison of these three
approaches so let's copy in the compare
execution uh facility from the defense
workspace and then uh I also have a
larger and here we only have 20 names we
have a larger many dimensional array uh
called a
uh we can see that
and a has
20,000 elements instead of um just 20
and it's distributed over five
Dimensions so it's a relatively large
array um and well we can also look at
the whole whole shape of this it has an
odd length and long last axis where
we're going to do all the the actual
computation so uh and we're going to
compare the execution and we've got e
with a as argument and we've got I with
a as argument and we got s with a as
argument and then we let it run for a
little bit to see how they stack up
against each
other and well those are some
significant differences we can see and
and if we reason about it we can also
see why that is
and the stencil operator and is
optimized for certain cases but not for
what we're doing here and so it goes in
and actually applies a function and to
every window and and moves around and
that is expensive to
do the partition inclose function
generates an intermediary further nested
array that isn't otherwise necessary
and the indexing just directly goes in
and computes how we want the result
reordered and that then ends up being
significantly faster than other
approaches
but that
said we can do this much
better because if we look at our
definition say we we look at s here we
are treating every row separately and
potentially there are a lot of
rows and even though rank is optimized
again for certain Primitives and
constructs and when we have a complex
function like this there's nothing The
Interpreter can do and it just has to
Loop through um all the rows
individually if we could treat the whole
array and in one go then that would give
us a significant speed up and uh this is
what array programming languages like
APL are really good at
so let's try to reformulate this s into
a uh a function where we do not need to
specify that the rank uh of the argument
is restricted to
one and here well we still kind of want
to do that but we don't have to do it on
the entire
function because we do want these
windows and on rank
one but we can do that all the way in
here
instead so this takes care of the
reordering of individual rows then we
might be missing a column we add the
rightmost column so to say that's the
last element of every Row in the entire
array to this potentially
multidimensional array that comes out
after running on rank one and instead of
doing the take operation on every row
individually we take the shape of the
original array the multi-dimensional
array and uh restrict along all X's
which won't have changed except for the
last one potentially um so that's just
one operation to cut short in our
array and now we can try to
compare uh our original s with our S2
and see if that made a
difference
so we can see that uh that became
somewhat faster um it still doesn't get
rid of this Loop for of the um the rank
one we could potentially get rid of this
one as well by specifying a window size
that is one and a movement of one in
every Dimension except for the last one
where we have a window size and movement
of two but it becomes a lot of
computation to get that uh window size
right and to then reform the argument
back again to the original so let's that
leave that there because as we can see
up here the stencil approach is anyway
much slower than the other one so this
will be more interesting and with and
our other approaches so then we had and
our function
e and let's try to define a new and
E2 that
and
does this on the whole array instead so
we want to get rid of the the rank one
here now this gives us the shape of the
entire array but we only want the
trailing uh element of the shape which
is
the um the number of columns so the
lengths of the rows and uh we can get
that for example like this to do with
get the less element uh the the
rightmost of uh the
shape then we reshape to the mask uh
that we want and actually this works out
very nicely because by default the
petition inclose Works along the
trailing axis so this is going to uh
split up our array into should we say
vertical slices of uh with two and so
everything else just works out we
reverse these two column and
multi-dimensional subarrays and then we
join them all together adjacent to each
other and since we use the reduction to
do that we disclose they should just and
work out so now let's try to compare e
and
E2 and we can see that just this little
bit of modification gave us some very
significant
savings okay let's see if we can do this
uh with the I function as well so we
want to have an a new I2
function and we don't want to apply rank
here now we end up in trouble
immediately because the square bracket
indexing requires us to know the rank of
what we're indexing so we have to
replace it with something else um and
for that there actually if you take
these two square brackets um and we we
merge them together uh then they become
the squad function which is then a
proper function
indexing but again we don't really want
to generate the indices along and every
dimension for all our elements so we can
use the slightly um unpleasant looking
square bracket access to say that all
the indexing that we are going to do we
are going to do and along the last
axis uh so that is the same thing as the
rank of uh the
argument and now and the what we're
indexing is on the left but it normally
takes it on the right so we swap that
and in order to just reorder and so to
have multiple indices along the same
axis then we need to enclose um the
argument over here and then of course
this is the entire shape so just as
before uh we want to get the length of
the last Dimension and the rest should
stay the same we get the mask we do the
grade and then we apply that there so
now we can compare and remember that I
was the fastest one before and now we're
doing I versus and I2 where we not going
over the individual rows with the rank
operator we are treating the entire
array at once and we get well similar
savings as we did with e so uh this I2
is by far the fastest solution to the
problem thank you for watchingwelcome to the EPL Quest
cap Wiki for details
today's Quest is the first from the 2017
round of the APL problem solving
competition
we're given a number and we're supposed
to generate odd numbers and that many of
them
this is a really simple problem in APL
we start off by creating a Lambda or a
different and let's say we give it the
argument five so that goes on the right
just like you could have say a minus
with a 5 on the right
inside the function we refer to the
argument with Omega because the argument
is on the right and it's the rightmost
character of the Greek alphabet
and this separates it from all
identifiers that the programmer makes
which are written in the Latin alphabet
okay now since we are supposed to
generate a sequence of this length then
we would use the index generator
function denoted iota
and this gives us numbers from one to
five but we only want every other number
so we need a multiplication factor of
two
multiplication
automatically applies to all the
elements generated by the iota
however we our values are too large we
need to subtract one or alternatively we
could add negative one
note the high minus which API uses to
distinguish between negative numbers
from subtracting and negation if I'd
used a low minus we would have gotten
this result instead which is
twice the indices
one added to that and then negate the
whole bunch which is not what we want
so while this is a solution
it follows a very simple pattern here
where we have a function that's magnetic
applied to the argument and then at the
addict function with a parameter on the
left and then at the addict function
will parameter on the left
and we could keep going like this as
long as you have this pattern that where
every other thing in the expression is
adiatic function every other thing is
either parameter or it could actually be
something else but not right around here
um then we can convert this very easily
to a tested function the way we do that
is by not mentioning the argument hence
test it and we can just put parenthesis
instead
around so this is a new derived function
which is negative one added to twice the
indices
and that works very nicely and we need
parenthesis to distinguish it as a
separate function but of course an
expression would work as well
if we want to give it a name then we
don't need the parenthesis either so
we could just write it like this
and that's it for today thank you for
watchingwelcome to the apl quest
today's quest
has us imagine two circles that are
touching each other
and
one of them
stays where it is
the other one
rolls on the first one's surface
or circumference
all the way around until it reaches the
place where it started
now obviously um
it
depending on the exact sizes of these
two circles
then it may not
end up in the same it might while it's
in the same position relative to the to
the stationary circle um it may not have
the same orientation may not be pointing
in the same direction again and so
today's problem which is the seventh
from the 2014
round of the pill problems on the
conversation
is to see how many times do it does the
circle who that's rolling need to go
around
um until
how many times does it need to turn
around itself so that until it has
rolled all the way around the stationary
circle
but also is pointing
um in the same direction
and i mean same orientation as the way
it started
there are different ways that we can
attack this um let's just start by
actually simulating
the problem
and we can use and since we have two
arguments here we have the the size as
left argument of the stationary circle
and then we have the size of the
um
of the
mobile circle one that's rolling around
um
they and officially they're given as as
diameters but it doesn't really matter
because the circumference of course is
just a a constant times the diameter and
that's the same for both so that kind of
goes out of the equation
and but what we wanted to see is whether
the amount of revolutions that we have
done on the mobile circle um
times its size
ends up with something that
that we can divide the stationary
circle by
sorry something that the
um
that can be divided by the stationary
circle
okay so the way we can we can write this
up
is we are done
if
there's no division remainder
when we are dividing by the state a
stationary circle
um and how far we've gone so far well
we're going to use an operand for that
so that's how many revolutions we've
done
of the diameter well actually the
circumference
of the mobile circle
and in if that divides
then we're done and so that's the number
of revolutions
otherwise
we are going to try again
but this time we're going to
increment
the
um the counter of
revolutions so we take one more
revolution of the
of the mobile circle
and then we feed that in to the same
operator so it doesn't operate another
function so the the arguments stay
constant
and the upper end stay
increments every time and then we just
need to
start with a1
so this is a recursive solution uh it
keeps
incrementing and calling itself
so
we can say a state a stationary circle
of uh diameter or that's it
circumference 10 and then we have a
mobile one that's five
so the five
after it has rolled one time around
itself and then it's on the opposite
side
and then it rolls one time again around
itself and it comes back to to where it
was
if we try to
flip the two
then
we only need one
revolution of the mobile one what's
happening is that it only needs to go
half away a half a turn to come back to
where it was
but it will keep going for another half
a turn in order to
come come back and face the same
direction that it
started with as well
and we can we can try all the
possibilities by making a table of this
so this is an outer product and then
all the
all the numbers up to 10.
and then this gives us a full table of
uh the revolutions and there's one
interesting issue um and that is
zero
now
it doesn't really make sense that the
mobile circle should have a diameter and
therefore circumference zero it's point
shaped because it doesn't matter then
how many times it will turn around
itself it's never going to get anywhere
so every time around it will move zero
it will not move at all
unless also the the left argument the
the stationary circle is
uh point shaped in which case nothing
can really move and it doesn't really
make sense to ask how many times i mean
any number of times would be good zero
one two infinite so you could say the
number the result is zero or you could
say that one or after zero times it's
also turned one full revolution around
uh the zero zero case doesn't really
matter however if the stationary circle
is zero
then
the result is most certainly zero
because we don't need to get anywhere
even though the
mobile circle has the ability to revolve
it doesn't actually need to revolve
so we can we can handle this additional
case by adding in an extra guard
so if
uh
the left argument that's the this
circular standing still is zero
then the result is zero otherwise we
just continue as before
and now we can go and
make a test case where there's even a
zero on the left
but not on the right as that doesn't
really make sense
and we can see you get the row of um all
zeroes there of course
right so this is one way to do it um
another so this and this was recursive
let's try to do an iterative way
here we just start off with a count of
zero and then and we we increment as we
go along and until it works out it's a
little bit it's much shorter but it's a
little bit more involved
so the way we can do it is
we start off with
with zero and then we need to increment
it and we want to increment it until
our condition has been fulfilled now
what is that condition that is that
the left argument
because we are comparing
the previous and the next
iteration and so that would be the left
and right argument of our comparison
function which is one that determines
when it's true then we have fulfilled
our condition
um so and
when that multiplied by
the circumference of
the mobile circle
evenly divides
the circumference of the
of this circle that's standing still
then we're done
and so we should get exactly the same
here
as well
but again we have a problem with zero
because if we start off with zero on the
left
then we're going to um
we can try it
if we have
zero on the left and say two on the
right then the first time around we'll
try to
to apply this function
so we add and add one so we get one and
zero
and then
we want to check
if it divides
division remainder so let's let's try
that so we can we can just do it like
this
right here
so if we start with uh with zero here
and say we have two and and
then
we get
zero and
then
we want to stop however once we
increment it
then we get the full remainder because 0
doesn't add up to anything
in effect
what happens is that
if we try to run this with a
with a zero
then
we'll go into an infinite iteration
we'll never get there
so let's interrupt that
and then we can and we can redefine i
to have the same kind of stop guard as
we did with the recursive version so if
there's a zero on the left then we stop
with a zero right away otherwise we can
start iterating
okay how do they compare in performance
to each other the iterative version and
the recursive version
let's copy in cmpx
from defense
and then and we can compare them we can
make the table a little bit bigger and
try them so let's say the stationary one
is zero and all the numbers up to 100
and then the mobile one are all the
numbers up to 100
and then we can compare
all the possibilities the requested
version
and all the possibilities with iterative
version
and the iterative version is much faster
and that's probably because
we're not entering into any new uh
functions trying calling again and again
not binding together an operand with
with the operator over and over again
which is staying in the same place just
running
the power operator
but we can do much better than this by
using some number theory because
think about the way that
we're describing this if
this multiple
divides so really and what we want to
find out
is
what is the
um
what is the smallest number
that we can multiply with
to
um to end to be divisible
and so we can express this in terms of
the greatest common denominator or
least common multiple it actually comes
out very much the same
so
um
we want to divide so let's say again we
have 10 on the left
and then
on the right we have five
and so
the least common uh sorry the greatest
common denominator between the two
is
five so that means we can uh divide both
of them by five
and then uh we can see well if if that's
the case then how many times five do we
need to get in order to get all the way
around the
stationary one so we just divide
the left argument by that
so that's one way
to state it
using the greatest common denominator
what's greatest common divisor
opposite we can also look at
look at the least
common multiple so here we are asking um
what is the
um what's the smallest number that we
can multiply up with these two numbers
in order to
to match each other so that's 10 that
would be 1 times 10 gives 10 and 2 times
5 gives
10 as well
and then we can
divide that by the right organ so so
this is saying that in order for these
to match up then we need to have
traversed 10 or to go all the way around
and since the right argument is this
actual size that of the moving circle
then the total distance divided by its
circumference will give us how many
times we need to go around
and so we can define this using the
least common multiple as well now
there's an interesting thing about these
two functions g and l here and that is
they are really really amenable to write
in a tacit
version
why is that
because let's look at g
we if we think of things in terms of
functions then here we have a function
application between the arguments
and
then we have a function that
takes that result as its argument now
the only problem is here on the left we
don't there's no function being applied
between the left and right arguments
giving us a full fork
however we could say there is one namely
the density function
of the left argument
so if we wrote it like this instead
then effectively this function would
select the left argument which means all
this we can
um we can remove all mention of our
arguments making everything point free
or tested
like this
oops
and then a parenthesis function it is
just the function itself and then we
have parenthesis around the fork that
gives us
this fork as well and we can do exactly
the same thing for the function l
here again it's
there's an
implicit and
identity function that selects the right
argument so we can remove all the
mentions of arguments and then we're
done
and now if we
compare these so we know that i was the
fastest one of two before the iterative
version so let's
compare
the fastest of
of those of
r and i
with
these two number theoretical functions
g
and l
and we should see that these sort of say
built-in functions where pretty much
everything we need to do is always built
into the language are going to be much
faster
if we try to just raise them against
each other
then we'll find that
it doesn't really make a difference
which ones
they that we use
they are all built on the same exact
principle thank you for watchingwelcome to the apl quest see apl wiki
for details
today's quest is the fourth
from the 2014
edition of the apl problem solving
competition
the idea is that we're given a text and
it may have spacing that we don't want
and we want to normalize this in the
sense that any training
spaces that spaces at the end of the
text
are removed any leading spaces that's
spacing
at the beginning spaces at the beginning
of the text
are removed and also if any words are
separated by more than one space and
that will be compacted down to be a
single space
so let's start with a sample
what we the basic thing that we want to
do here is we want to compare adjacent
spaces uh in order to remove those extra
spaces in the middle and then we need to
take care of the spaces at the very end
because they might not be addition to
another space if there's just
one space or rather if we don't do
anything but remove adjacent spaces then
we also reduce the leading and training
spaces into a single space
but and let's get started
so
the first thing we want to find out is
where are our non-spaces
and then and
what we can do is we want to make sure
to catch also the spaces at
the end
so we want to make sure
um
we want to make sure that as if the last
space is also adjacent to another space
and so that would be an extra zero at
the end
and now we can do adjacent that be a
pairwise reduce or two wise
reduce and we want to see if any of
those
are
none spaces
so a space that's next to nonespace is
something we'd want to keep
so that gives us
that gives us this we can see that we
we start off with a couple of two spaces
and then we have a space which is
adjacent to the t in this
and then we have the four letters of
this and then the the first space and
there is some a
and then
and we have the
um
and then we continue on with and we can
see that we have ones for num spaces and
also for the single spaces of between
the words and then we have the training
spaces
okay now we can use this
to
filter and
the text
and that almost solves the problem now
there are no spaces here at the end
because we made sure to add that extra
zero at the at the end but there is a
problem of a leading space
and we can drop this conditionally
if we know
that the text begins with a single space
and with one or more spaces that means
we also have to drop and one more space
that otherwise wasn't caught
so we can easily check that
if a space is equal to the first off
and
of the the argument text
then we drop it so this would give one
if it is we could also we could also
invert for me here just by negating
the vector credit here but this is very
very little work to do the only real
work that we have here is dropping that
leading space because that would mean
rewriting everything in memory
so
that solves the problem let's give this
the name a because we're going to have a
lot of different solutions here
okay
and
let's
then for our next solution
take this and generalize it i mean
and
and while we're making it also test it
just to see some some possibilities what
do you mean by generalize it is that
instead of taking space as this element
that needs to be removed from beginning
at the end
and deduplicate it in the middle and
we're going to
allow you to specify that character as a
left argument and then we can bind space
as left argument in order to make it do
our specific task so to make this tested
is actually
quite simple
because we're going to put out the space
as
as a left argument
and that means that this different from
is just going to be
a different from like this and then we
have to of course this is becoming a
test function another defense
and the rest of this will just work this
is a dyadic function here the static
function here there's one problem is
that
replicate or compress here doesn't
behave like a function when it is next
to
another function
and the right tag here but we can fix
that with a right tag top
and then here we have
uh the left argument and the right
argument and that means that we
essentially have it equal except we want
to pre-process the right argument of
equal with
a first and we can
write that just with a uh
with the beside the composition
so that's what the entire thing comes
out to here we can try it with our
sample text
and that means we can give this a name
and just remember to either bind a left
argument here or we could have put a
right tack on the right to make it
a fork
it'll be interesting maybe to see which
one is faster of these two so let's try
that and at the same time let's also
generate some
some test data and test data is going to
be a bit interesting um
because we want to
try all the different cases that may be
with
so there'll always be some internal
duplicator spaces but we also want some
with some leading spaces and some with
some training spaces and and all the
combinations of that
so how might we do that well
and there are different ways we can do
it but let's start by generating some uh
some spaces so we want no spaces and uh
yes spaces
and we can't actually see those but we
can
it helps maybe to do it like this
right so we got no spaces and and yes
spaces um and then we want all the
combinations of that so that be an outer
product
of all of those
and it's still not really going to
be very visible here
but
now we're going to use these as prefixes
and suffixes
so on the left we have the prefixes and
on the right we have the suffixes and
then we're going to have some
garbled text in the middle um let's take
4d overtake on the alphabet that gives
us the alphabet with a bunch of spaces
at the end and then we just want some
some random numbers
there
and let's say just for now for the
display we're taking 20 reshape
40
so yeah not again not very visible
um
this up oops
there and this helps a little bit
actually we should probably use display
as to to see it entirely
um so here we can see yeah it goes over
the edge of the of the screen but we can
see that
we have added spaces in the beginning
and the end
um but the problem is that our
randomness here it caused us to have
some space in the beginning that we
didn't want to so how can we make sure
that we have a non-space in the
beginning and the end well we can just
stick an a at the beginning and the end
right there
and actually let's turn rows on
as well so that we don't
so we don't run over the edge of the
screen
and maybe make these a little bit
shorter also so we can see it
there we go so now we have our test data
we have and
one that doesn't have any spaces
beginning in the end and one and and
then we have
uh one that has only beginning one at
the end one at the beginning and the end
and we can see we're getting some
internal space here of course uh in the
first three cases there are no multiple
internal spaces because they're very
very short but we're going to generate a
giant test data
um
so that's not a problem it'll definitely
be multiple internal spaces so that's it
so then we're going to to test things
when um for
speed comparison then we'll be testing
it all four of these
i'm copying in the
performance comparison from the defense
workspace and then we can run cmpx a on
each of these four cases and b on each
of these four cases
and we can see the a is
somewhat faster so maybe it wasn't so
good to try to test it after all
okay
another a whole different way of doing
this instead of
using this adjacent uh with the
difference from from a space we could
also rotate things around and that gives
us uh so if we compare the ebola vector
with it it's rotated by one step that
also gives us this adjacency but it at
the same time allows us to rotate uh
cyclically and that
lets us get rid of um
of
having to deal with it with the edges
so especially
so we can try this
um let's take our our sample here and we
start off with the exact same way
um
actually we can we can start even making
it general so let's just put it outside
so this gives us our
vector of
none spaces
and we have the same thing with adding
one at
the edge
now the important thing that we're going
to do next is we when we rotate this and
one step
here then
because we've added
a zero at the beginning we know that
when we rotate it one step to the end we
are now getting a zero at the end
instead
so if we um if we now take
these two together so we want the one
rotate and also the original and we can
write that
um like this
let's uh let's actually begin with well
so we want to combine combine these two
but let's just stack them on top of each
other first
um so we can do that with
mix up top comma over in close
we can see these are the two that we're
going to combine so now what we want to
do is we want
where to preserve anything
that
um is
true in either one or the other so
either it is a non-space or it is an
adjacent to a non-space
so these are the ones we want to
want to keep
and then we just need to to do the same
thing as before
and remember to stick an
attack on top of that
of that slash
now there's one problem here that we've
added one element and that means that
what we can't just do is compress
because it will be a length there we
want to
take the not the right argument but
rather the concatenation of the space
and the right argument
and that gives us this and because we've
added a space on the left then we need
to drop that and we can do that
like this
okay let's
give this a name this is going to be c
don't forget to
bind the argument here to the function
so that's one way of doing it uh
cyclically but there are other ways that
we could do it let's uh
let's look at this again
so uh we can we can optimize the
performance here there's a problem that
we uh are concatenating and with a big
argument on the right it's going to be
expensive having to write over the data
in memory um all again and we could
possibly um save ourselves and some of
this work
by working on the
on the boolean vector over here removing
one element from um from that
and instead then we don't need to
concatenate we can just take that
right argument and like this
only problem is then we're back to and
so that's uh
we are back to
another problem that we get that space
at the beginning um if the first element
is a space if it's not
then we don't get a space because now
we're not considering uh
the spaceness or not spaceness of the of
the first element in
anymore and the way we can we can fix
that is much like we did we did before
namely that
if space the left recommend is equal to
the first element
of the argument then we drop from there
so
that
then this works and let's give that the
name and d
okay um but
there are plenty of uh of ways to do
this we can also
start by the concatenation and and go
with that so
let's start by having this the left
argument here this the space
and then concatenate it in the beginning
of
um
beginning of the argument the right
argument the main argument that we're
working on
and then we're going to generate a
vector
the compression vector for this
entire thing
so we can we can start by saying there
we
which they're different
um and then adding a zero
on the front like we're doing before we
could say give that a name for a mask
and then rotate it and then use
um
or that so this is this would be just a
different
it's it's an explicit version of what
we've done before
um
this is of
c
and then
we're doing it doing one drop and on
that
so things look a little bit different
when we can assign temporary variables
like this
okay this is e
and now again we have a problem that
we're concatenating on the left and we
know that that's potentially slow
canceling on the right when the
interpreter will reserve additional
space for the array to grow and then it
can just write into that space so that's
going to be much cheaper than rewriting
the whole thing
so how can we
reformulate this
to concatenate on the right instead so
we're concatenating here on the right on
the space on the right
and then that just means that we have to
move our corresponding zero over um on
the right as well
and that and then similarly we have to
rotate the other direction
and then dropping
from the opposite direction
and then no more spaces here at the end
so that potentially should be faster f
should be faster than
than e
okay there are even more ways we can we
can play we've got plenty of ways to
write this so
um
let's
start off with again our normal
comparison
and now we're adding uh that
um that spaces as
as always
so it's it's a space indicator in our
boolean vector so
zero
and then we're going to to process that
in much the same way as
we've done before
we are
rooting it rotating it one step and then
doing an or with itself so so far
so good that's the same as what we've
been doing before we're just writing it
in line here rather than taking the one
um outside
but the trick i want to get here is this
gives us this gives us this
um
then
we also want to make sure
to
to not catch anything at the beginning
so if we start here with
um
well i'm going to explain this
this is a test
so the these are all fine
um
but if we have one space here
that's not right because it's adjacent a
a um
a space adjacent to a none space and we
want to get rid of that if we have more
spaces
then we start detecting that it's a
space addition to another space that's
not okay so
the cheap way of of fixing this
is
by saying that any space
any character that appears before the
first
none space
shouldn't be regarded at all and of
course any character before the first
nonspace is going to be a space
and
we can do that
by
taking the
running
and
i'm sorry no the running uh running or
and because we have we have our our
comparison vector here are the num
spaces so that means we start with zeros
for all the spaces and then we get a one
so
so this means as soon as going from the
left as soon as we hit the first one
then any character after that
will also have a one
and and similarly any
character up to
uh the first one has then a zero so this
is a strict condition we can then take
that and put it up here that we only
want
we only want the ones here but we have
remember we have this problem here with
this one
if it's also true that it comes after
the first one
so now this gives us a good mask that we
can work on
and then we just use this
to filter our argument
we can try that with uh with s we had
before
uh what am i doing wrong here oh yeah of
course um we have to drop
the
drop the zero from the end after we're
done with our with our logic
here we go
alrighty then
we could also
use this kind of method of this
cumulative or
or scan and to
in a way spell out all our conditions
so starting with that same vector here
let's spell out um our conditions and
then
we don't need to worry about this
cyclical thing
and the way we're going to uh to
spell it out
is again we're saying that it is
this is the adjacency to a uh to a
non-space
so it so it has to be
um a non-space
or
adjacent to unknown space
and we all and it also has to come after
the first non-space
and it
and
it also
has to come before the last
non-space so the last known space we can
write as as a little defend itself we
reverse the argument and then we do our
and
or
scan and then reverse it back again
so here we've just spelled out
with the conditions for keeping a
character
is that it is adjacent to a non-space or
it's a non-space
and it comes after the first one and it
comes before
the last one
okay and one final way that we can
you could potentially use this
is if we take this uh the non-spaces as
always
and then and we let's give that an a
name the mask
and then we
we use the less than scan it's a bit of
a a tricky one you kind of have to
know this but what it does is it turns
off
all ones that appear after the first uh
one so let's say let's say we have the
the mask like this
um
oh
yeah sorry uh here's our mask and we can
see that it it leaves only a one at the
first one and all the all other ones in
this whole vector are turned off so
that's uh that's what we're doing
now and then we can specify that we
some for something to be preserved it
has to be a non-space
and it's and it
now what we're going to do is we're
going to say a non-space
and not
but and not is only so we could write an
end
not like this
but and not is only true
if this is one
and
this over here is zero and so for
boolean that just means that it is
strictly greater than so that's a way to
write and not
so effectively what happens here is it's
exactly the same vector as before the
different from space vector except that
we have
forced the first one that's there to
become a zero
and now we can use this to cyclically
rotate and that is safe because we know
that the first element cannot be a one
that means that
when we rotate it one step we for sure
get a zero added at the end
and then we can compare that with our
mask
and
now compare that and combine that with
our with our mask so it has to be at and
on space
or adjacent to a non-space as before but
adjacent to does not
wrap around
so it looks much like what we had before
but we don't have the problem of
wrapping around and messing with uh with
the training
and
the training ones rather and
we we're wrapping a zero around there
and then we can use that to filter it
over here
and and
even and even if we use something that
doesn't have spaces at the end that it
doesn't matter they're not um
it does nothing interferes here because
they they are still adjacent to the neck
to none space that's being rotated one
step to the left we're not
nulling that out
okay
that's i
so now we for for comparison of all
these different ways of with using the
cyclic rotation
um that were all the letters from c to i
let's instead of having to spell those
out let's use another utility from the
defense workspace
and
it's the generalized iota and not only
does it handle non-numeric data it also
handles a start point and an end point
rather than starting always at one or
zero if you're using code i zero
so that means that we can write for
example
k to
iota
g
w we get all the letters
from k to j w
inclusive
and that means that we can say uh we
want letters from c
you would say uh iota g and we want them
all the ones to i
and then we want each one of them
concatenated to
an each
and
the t
that gives us all our the expression
that we want to run and then we can run
cmpx and on that
and it's pretty clear that it's our last
one here the the
clever one that avoids
the problem of this of rotating the
wrong data around that is and the
fastest one
good to know
okay hey how about regex we can pretty
much guess that right it's going to be
slow but there are different ways of
doing it they're interesting to to see
how we could do that
so
for regular solution
um
one way we can do it is by defining
exactly
which spaces to remove and which spaces
to condense so the ones that need to be
removed
are
in the beginning of
and our text
any number of spaces or
any number of spaces at the end of the
text
the only thing that leaves us is getting
rid of the multiple internal spaces so
now we can say once all of those are
gone
then we also want to remove
any
any run of spaces
with a single space
we could also say any space followed by
um by any number of spaces but it's
probably not going to make a big
difference so that solves the problem
um and let's call that j
another way we could do it is using a
single pattern just to specify all the
spaces that need to be removed
so
these this just moves
all of them replaces with nothing but
what exactly
is a space that we want to
remove well we can start off like we did
before
any number of spaces in the beginning or
any number of spaces
at the end
um but there's one more possibility
that's the internal spaces that are uh
that are redundant what does it mean
that there are redundant it means that
they're adjacent to another space just
like we've been using
pure apl to do before so we have a space
and then we want to look ahead and see
that
there's another space so if there is
another space coming up but not included
in this match
then we should remove that space and
that just leaves the last space in every
group of spaces
so this solves
our
problem as well
and finally
we can make a solution where
we
i call it like exception
pattern solution
and that's when i start off by
protecting certain things
in that i replace them with themselves
and then anything that's left over using
a different pattern and is then
changed
so what we want to and what we want to
keep
those are
spaces that are in between
two non-spaces so how do we and how can
we do that well
we could use a look behind and look
ahead and but that it doesn't really
matter
and so if we have
a nun space
followed by a space
followed a and an upcoming
so that's a look ahead
any number of characters
so
the problem here is that uh
this could be the last character the
last letter
in our text and it will be followed by a
space and then we say any number of um
of characters that come after that
and that will also match that there
should that um
a space at the very end
but we don't want uh we don't want to
keep that so and we need to to make sure
that something follows and after and we
can't
because consume a non-space because then
that we then uh you might have
non-space space non-space
space and we need that middle uh
non-space to be used to justify both of
the
of the spaces that are adjacent to it
but what we can say is that follows any
number of uh
of characters
look ahead
and and then there is something
somewhere after that which is also a nun
space
and then and
and those are the spaces we want to
preserve any other space that we want to
uh you want to remove
let's just try this out
like that
um
we could also say that
well you might think that we could also
say that that we want any spay any
number space followed by space by any
non-space
um but that would only preserve those
places that are
just a single space
but we don't want that we want to
preserve one of each of the spaces that
are in sequences of
of spaces as well but so this is this is
another way
of doing it with regex so three
different ways of doing it
the first one
was to
to do two different patterns to do the
two transformations leading leading
training and then we had and then
separately treat multiple spaces and
make them one there's the one where we
are specifying exactly which spaces to
be removed using
well it's an ore and three different
patterns and then there's this one where
we are accepting the spaces that we want
to keep and then removing all other
spaces
so
let's try that and we want
and
j
each of
uh
k a h of t and
k each of t and l each of t
three different ways of doing regex and
and to see which one is faster in our
case well yeah pretty clear that
using the two transformations would be
faster in our case this might not be
true in every case
okay now
here's a fun thing
because of our problem being very
specific we're only dealing with spaces
and none spaces and we want to get rid
of any runs or spaces other than them
being a single uh space inserted there
then we can use a little trick
um and that is using the classic way of
of splitting on spaces
or on any other character really so we
partition
by where we have none spaces
and
the
because
none spaces are indicated by zeros and
any element that corresponds to zero is
removed
um
using when we're using partition that
means that all the spaces
are removed
leading trailing all the internal ones
now we remove too much because we want
to
to have exactly one space between each
word
but that's not so bad
because what we can do then is join on
spaces adjoined with spaces
we could write that as
the left argument followed by space
followed by and right the right argument
but this will fail um if we have an
empty vector because that will attempt
to that will need the identity element
for this uh function of for which uh
there isn't one because well firstly api
can't figure it out for none primitive
functions but secondly there is no
argument you can give to this
on one side so that we preserve the
argument from the other side because it
always adds a single space
so we can see we get an error there
instead what we can do
um is we can and just add a space to
each one
and it we know that it's probably faster
to add things on the right so instead of
just doing
doing this space concatenated to each
one will bind the space on the right
side of congratulations so this just
adds a training space to each one we
could also use commute for this but but
this will work
oops yeah we should use our sample of
course
and now we just need to
flatten it all down
and and
then we have a training space that comes
out here and we just need because we've
added a space to each one so we
and
drop the last one we know that's going
to be a space
and that gives us
um our results right there
so this is one way to split and join
um
given it i didn't give a name to this
one this should be good and while it's
not really valid but it'll be
interesting to see if there's a
difference in in speed as well between
join on spaces and add a space to each
one
and then
flatten it all out and removing one so
we can still compare them even if we
know that it's not really valid
should be
okay
it should really be the other way around
the alphabet there yeah let's fix that
okay
fine let's uh let's
try to generalize this in a little bit
that's that's really trivial if we take
uh this one then
we can just
use the left argument here and a left
argument here
um so that would
um that would be a generalization of it
just to show how we can do that so this
is actually a kind of useful thing to be
able to bind an argument
with a function it's just what i want to
demonstrate
um but
this form also has a uh
an additional benefit and that it is
extremely amenable uh to uh
becoming tested
okay so how might we write this as a in
tested form
well this is just application between
the arguments and this is uh the right
argument so we could write this as a a
right tech here
but since we're just flipping and the
arguments of the partition and we have a
single primitive over here then there's
no point in writing it like that so we
can just in in flipping them around so
we can write that in the proper order
and now
we want to add and the left argument
concatenated
on each
but flipped around
and then we uh we
flatten this
and then we uh okay we need to to change
our
braces to parenthesis
and then we could combine this
um
so because this is a magnetic function
so we're just pre-pressing the red
argument to the negative one but instead
of that we can actually just let it be
on the top i find it on the top here so
we have this fork here which has a fork
right right argument a right time and
then a single function so that's on the
top and then we can just state the
negative one drop um outside as well
so it saves us from this
somewhat awkward
um we call it composition
of it
so we can try this
and this this works as well in a test
form
so these were all
based on splitting and
joining
let's
compare them with each other
so let's do
this was
m
g
p
and each one is with an
enclosed and each of t
so these are all the split and john
they're probably not going to be fast
but we can still uh compare them with
each other
oh something is wrong here and what i've
been doing oh yeah of course um the
reason um it's wrong is of course it's
not it's not actually wrong the problem
is
no is it hold on
um
oh
i miss missing something
ms up here
join on these
what did i mess up here
oh this this looks right you join on
this on the sample
oh of course yeah silhouette and we're
doing a reduction here so we and we
should so this becomes an enclosed
that's that's what it's trying to to
show us here with the extra space it's
been enclosed so we need to disclose
that of course
there we go
that's m
okay so this is a good feature of cmpx
that
it indicates that an
element an iron result is different from
the other
results
okay now the matches are there and now
you can see that
first one was very slow that's the one
that's doing the reduction and it wasn't
completely right anyway because it could
handle the empty argument so that's good
and the other ones are much faster than
that
finally
a function that's often overlooked is
the find function and the find function
and
indicates the beginning of any sub array
in them in a an array so we've got our s
here
and then we can say we want to find
places where we have doubled spaces
so this is we can see that we have three
spaces at the beginning
and that means there are two instances
of
double spaces here there's a double
space over here and then there are all
the trailing spaces that that cause
double spaces at the end
and uh we can use this
so let's start off with with something
uh that
just like we've been doing uh doing it
before
different from um
from space and then we're going to uh to
do something like that and then so here
when we have different space we are we
want to look at places where we got
zero zero so this corresponds to
and where to what we're doing over here
we just do it using it on the boolean
instead of using it directly on our text
okay now and we'll we'll come back to
this uh let's just do the basic thing
and first which is going to be
that we want to make sure that we so so
this will yeah this this thing will take
care of the double spaces eventually we
can we can see that already here so if
we negate this
then that indicates all the
and all the places except for a space
that is followed by another space which
are the redundant spaces so if you use
this already to compress here that gets
rid of our double spaces but doesn't get
rid of our
leading and training spaces other than
compressing them down to become single
spaces but we can fix this
and
leading a chinese spaces
we can get rid of by with the same
method we did before
with the scan so we want to find any
thing that that is
that follows the first one but not
anything before that and anything that
comes before
the last one
so
we can and
any we can do this reversal and then we
do it in or
on that and then we do
and reversal again that gives us a mask
show indicating ones all the way up onto
the very last one
and that's that takes care of all the
training spaces and then we can combine
it with a with a regular uh or scan so
we want both of these to be true it has
to be true this after the first one and
before the last one
oops
uh yeah we need to bind these together
as well so too because this is a
magnetic so we need to pre use
we do that by pre-processing the right
argument to end
and that gives us the internals there
and then the only thing we want to also
be true
is
that
it isn't
a a space which is followed by another
space
oops we forgot to bind by the argument
to that
and
um oh yeah this is um this is wrong
anyway because we want
this has to be false it has to be not a
space that's next to another space and
this has to be true it has to be in the
internal part so we so it's like we the
the end not but backwards so the mean so
this has to be on the right has to be
greater than what's on the left
and that gives us our and our mask and
then we can use that to filter the
argument and that gives us our result we
call that q
okay um another idea we can use now that
we know how to take care of duplicate
spaces
then we are free to explore other ways
of getting rid of
of leading and training spaces and now
there's this thing called idiom
recognition where certain phrases are
and are not actually taken at face value
but are um
interpreted as a single kind of are seen
as a single token and then the
interpreter internally
uses a very fast algorithm for doing the
same work that this function would have
done
and one of them is actually exactly this
to remove spaces apparently that's
something apls do a lot and they
and they want
and to run fast so if we type this up
notice that it turned a different color
here that is indicating that this is an
idiom and therefore going to run very
fast
and the problem is of course this only
removes leading spaces this is exactly
that mask on the leading
leading nun spaces
and we also want to do it from the
reverse but we can do that simply by um
reversing our argument
and then
applying this which removes leading
spaces and then reversing it again back
again to how it was before and removing
the leave space meaning that this whole
thing
just has to run twice
um
and once that's done so we can try this
on our sample so this gets rid of all
leading and training spaces then we can
apply atop that
this exact method that we had before we
want the argument where it is not true
that we have adjacent
a space that's adjacent to another space
on its right
that gets rid of that so this may be
fast because we're using this idiom for
the in
for the leading and training spaces even
though we're using find for the uh
for the
middle spaces that need to be removed
let's call this r
and then
finally let's
let's try to use an
a bit you work with if we'll find
straight on the bit mask
in a bit different way
what we're going to do here
is
we're going to start for once with
things that are spaces
so this is exactly the opposite of what
we what we did before
and but the good thing about it is that
we can then
do an
n scan
that gives us
all the leading spaces
and
then we can do the one one find that
gives us
um all the
duplicated spaces
and we don't want any of those
so neither this nor that
we can try this
in fact let's put it in here that's what
we're going to do
so
um
so all the
all the leading spaces
were removed and all and now we only
have training spaces it's a little bit
hard to see that we've got training
spaces here but if we use display
and then we can see that we've got a
training space there'll only ever be one
training space because we've reduced any
runs or spaces to a single space
that means that the only thing we need
to do is remove
a trailing element which is a very fast
operation
if
we the last character of our input is a
space
so how can we find uh the last character
of uh
of the input well if we reverse it
and then uh take the first that's the
the last and then we need to to drop one
if that's true so that since it's from
the end we can do negate
on top of that
now and
this might be a bit faster if we allow
the interpreter to use its idiom like
this
but we can't do that when it's uh when
it's tested
so let's just write it
like this instead
and now it should be and it should be
able to recognize it as an it's
interesting it's really not written
yeah
it thinks it's not an idiom when there's
a
an adjacent space it seems like a bug in
the syntax color
um okay so this finds uh the the
trailing space and
um
bit attack here just a piece oh
oh so interesting okay it wants a space
there
oh well this should be fast anyway
um so if we have an a the last element
being a um in this vector of indicating
where their spaces then we negate that
if it's zero it just stays zero and then
we drop that many elements on the right
and that should and we can try to
display here we can see that there are
no spaces at the end
and we'll call this s
and then we are
ready to test our find based methods
so this is cmpx and we've got a qh on t
and rh on t
and
sh on t
and we can see that r is by far the
fastest one of these which one was r
and that was the one where we were using
the idioms
to remove leading and training spaces
so that's interesting to know okay so in
each category we found out which one was
the fastest one
and if i recall correctly those were a
from the category of
um
adjacent characters it was i
from the cyclical rotation
um actually we can have a look at them
it was
k
from the regex it was p
from where we're splitting and joining
and now we had r here where we are using
defined
so that that's these
we'll take
these and compare them to each other
oops
missing a comma there
and
that shows us that a and i are fastest
but they're so close to each other and
that it's kind of hard to decide when
when it's being drowned out by other
things
so let's try to just do these two
and turns out that a very first solution
and
is actually the fastest one
very nice
thank you so much for watchinghi
our task today is to shift some Boolean
data
we are given an amount that we're going
to shift in from the left so if it's
negative it goes from the right
and then we're giving the Boolean data
as a vector or possibly a scalar so we
just have to end that as well
and there are many different ways that
you can do this
I'm not going to go through all of them
just one
if you want to get inspired by other
ways that this can be done go look at
the transcript for the chat event that
happened in preparation for this
presentation
so let's start with some data this is
the sample that we're given in the
problem description
and we're going to
shift it by three different amounts
we're going to shift it three steps and
then zero steps and also negative three
steps so that's the other direction
and let's do all of this at once so
we're doing we're writing a Lambda here
so we're going to Define
inline Anonymous and then we're going to
apply it to each we wanted to map over
these three shifting amounts but each
time we wanted to not apply to separate
elements of this Boolean data we want to
apply it on everything so this encloses
it and then apl's scalar extension it
takes when we have an each it takes the
one scalar on one side for example and
three elements on the left and then it
pairs them up appropriately
so by taking this entire thing and
making it into a scalar then everything
gets paired up correctly and we can see
that by having our function just create
a two element vector or list of the left
argument and the right argument left
argument is denoted Alpha right argument
is denoted Omega
and we can see it pairs up the left
argument elements with the entire thing
on the right okay so we're going to take
this in three steps
the first thing is we're going to
identify which data it is that we want
to keep so when we do the shifting to
the with a positive number to the right
then as if it were we're pushing in on
the left three zeros and the data moves
to the right and the last three elements
then drop off the edge on the far right
so that means that the data we want to
keep
is all but the last three elements
we can use drop
but
that gives us the drop from the wrong
end because three drop drops on the
front and negative three drops from the
rear
if we negate the number then it goes to
the correct way so we can see how these
are the initial five elements and over
here we have the training five elements
and for zero we didn't drop anything
we can save ourselves this parenthesis
if only we had a function that's like
drop but takes the arguments in the
opposite order so the data goes on the
left and the amount on the right that
doesn't exist but we can Define it in
line anonymously by putting this
confused frown called commute
next to it and that commutes the
arguments of this adjacent function so
the arguments are given the order
I like writing it like this
so now we are have the correct data that
we want
next step is identifying where we want
to put this data in the final result
so if we get the length of the right
argument
and then enumerate the indices there
then we can see that we when we shift to
the right with the positive three
we want these five elements to end up in
these trailing three positions
and when we're not shifting then
everything stays the same and when we
are shifting to the left pushing in
zeros from the right we want the first
positions
so in essence we could say if we look at
the indices we can take this amount and
drop
that many elements from the in from all
the indices and that gives us just the
subset of indices where we want our data
to end up
so that would be the left argument
dropping
the in indices from the right argument
but we also need somewhere to should we
say draw our our picture we have the the
data we want to put into the picture we
have the positions in the picture where
we want to put it but we need a canvas
where to draw it and that would be a
array of the same shape that just has
all zeros
and there are various ways we could do
it but a very simple way to do it is to
do a zero multiply by because these
booleans are just numbers or we could do
a zero end which also nulls it
um so
this works
and now we can take uh all the pieces
and put them together oh there's one
more step before we do that there we're
also given the case where uh the
argument is a scalar in that case we
want to normalize it to become a vector
which we can do is just by reveling so
in magnetic comma it Revels it's mix it
flattens the array into a
um just a simple list a vector which
means if it's a vector already it stays
that way if it's a scalar then we make
it into one element Vector so now that's
done then we take the data that we want
to put in
and we stick it in at
the indices that we computed by dropping
elements from all the indices of an the
length of the argument
now we can see how we have shifted in
three bits from the left
and three bits that have fallen off on
the right
and then we preserve these for zero
nothing happened here
and for negative number we're shifting
in from the right
and if we try this on
a scalar case and let's say a one
then we it gets normalized to a vector
and in the case where we are we are
shifting out too much there's nothing
left we still just have a single one
zero
and in the case we're not shifting
anything we preserve the one as it is so
this is
um our solution
but
just one of many possible solutions so
go have a look at the transcript from
the session
and
maybe you even want to join in on a live
event happening every Friday
thank you for watchinghi
where's your check which
of the given words contain consecutive
letters that are identical
let's start with a word that does have a
duplicated letter that is the lowercase
l
the easiest way to go about this is to
do a pairwise comparison so we want to
compare every letter with its neighbor
for that we use the dynamic form of
reduction so this is an equal reduction
and this is a pairwise equal reduction
we go over windows or size 2
and compare
so we can see that there are four pairs
one two three four and the third pair
has the same left and right so they
equal to each other
we're not actually interested in knowing
where they are or how many are there are
we just want to know whether there are
any so we want to ask are there any
which is an or reduction so you're
putting or between these so you're
saying 0 or 0 or 1 or 0. and that gives
us one yes they are
If instead we try a world
then we don't get any because there are
no duplicated letters
okay
this solves the basic part of the
challenge but
there are a couple of catches one is
that we need to be able to handle
scalars so this is not a string or a
list of one
character rather it is a single scalar
character without dimensions and since
this Paris reduction needs to Traverse a
dimension it fails
as there aren't any Dimensions to ruse
it's saying rank error a scalar has
ranked zero there are zero Dimensions
but we need at least one dimension a
vector in order to do a reduction
we can fix this however by reveling
reveling means taking all the elements
that are there and like a bunch of yarn
we are revolent or even a sweater where
you pull a loose thread and it becomes a
single dimensional list of the elements
and that is magnetic comma so
it will appear the same but this
actually has a dimension that we can
then reduce over
so I doesn't have any of course and no
one element and
word will ever have duplicate letters
because there's only one there
now that this is done we need to fulfill
the whole spec of the challenge which is
to handle multiple words so
I of course as we know doesn't have any
and Z doesn't have but feed has and
bookkeeper has multiple duplicated
letters
so we take this
function that we have created it just so
happens that we can just parenthesize it
and apply it to each one
and this works fine
one more catch is that we have to be
able to handle a single word so this is
the each
and if we try to do this on single word
then we get the wrong result and that's
because the each now traverses over the
word itself and adds and applies the
function to each letter
what we want to do here is if we have a
single word we want to enclose it but if
we have multiple words then we don't
want to enclose it to treat it as a
whole and for that we have a very
convenient function that is often called
inclusive symbol or just nest
is because it does exactly this it
encloses if the argument is simple so
this is a simple single word and it will
then enclose it but if you have multiple
then it will not enclose it we split it
like this all right it's the include
symbol with an extra underbar also
called nest because it guarantees that
your result will be nested if it isn't
already it will add an outer enclosure
so now we get the right result here and
if we try to do it over here
then we can see and which which words
are
have duplicates and which ones do not
and so this whole thing we can just go
and give a name
and now we can apply it on both
lists of words
and single words
thank you for watchingwelcome to this very last APL Quest
video see APL Wiki for
details today's
Quest is to
split a text on
spaces and there's a specification left
argument which tells us how many
segments to cut
into and basically
we want to be greedy and split at
leading um at the first coming spaces
until we have as many segments as
required and if the number of segments
required is larger than and what we get
just by splitting on Spaces then we need
to add empty segments at the
end so let's get started here is a a
sample text and um let's first try this
as a test it
function now there's a a couple of
classic ways to uh to split on
spaces and this is one of
them so what we can do is we can we can
start off with the argument and
concatenate another space in
front we can kind of make out the space
over here here the reason we need and
this additional space um is so that we
can compare with the
space and that gives us this mask that
we we can then use to
partition the right argument and this
gives us
um a a cut
off set here but um we're a bit off and
that's because we added an an a space at
the beginning so that we would include
the leading text so instead of splitting
the original we can split the
concatination
okay that looks more sensible to work
with here's a trick though uh since we
want to potentially add empty segments
at the end we want this nested array to
have a prototypical element which is
such an empty character vector and we
can do that by
injecting a um an empty one at the
beginning we could do this manually but
we can actually do this kind of what I
would call
automatically and how can we do that
well if we go back and to how we created
this
mask then we can say in we added a a we
concatenated a a space in front so that
we would get a
one but we can also
add a two manually or for that sake a
one but by adding a one that tells
partition function that we want two
segments to begin here so we get an
empty one at the
beginning and now we can use this to
petition the concatenation of that space
with the original
argument this has the benefit then that
if we take too many elements say six
elements
here then we pad with empty elements at
the
end if we didn't do this and we try to
take too many elements say um six here
it would actually be five to be similar
then we pair with elements that are not
empty because they're based on how long
the first element
is so this solves that
problem and now really All That Remains
is uh to take this and
merge as many trailing elements as
required so that we have the right
number um and then finally we need to uh
remove this leading element that wasn't
there and possibly we're going to take
more elements than they are and they
will be paded automatically so now uh
let's add the left argument let's do
three for
now and so we can take uh the left
argument and
take from here that gives
us the leading elements that we're
supposed to
preserve and then we can use a drop and
that gives us the trailing elements that
we we want joined together so we can
combine this by saying we take the
leading ones followed by the trailing
ones this is of course the whole thing
but before we do this concatenation
we're going to postprocess the drop with
joining them together that's a
concatenation reduction so we insert
concatenation between all these elements
we do that on top of the result of the
drop so now we've joined the
last and we get a total of three except
of course the leading one that we
inserted just temporarily to get the
right
prototype this means that we can strip
the leading one and we can drop the
leading element from each one because we
had that one
space um here that we don't want want
includeed now that we have split on
spaces so this works for three and for
four you get the exact fit and for five
we have the
take add and additional elements and so
to for any higher
number so this is one solution to the
problem here's another solution to the
problem we can start off the same way
Way by
concatenating a space on the left and
let's call that s for eding edit a
space and then we can make our mask
before we did that uh with a tested sub
function but now we can do that
explicitly like this the the pass
through value of an
assignment is the value that's on the
right of the assignment Arrow so we can
use that directly the first element of s
is going to be the space then we don't
have to repeat ourselves this gives us
our
mask and now we want to change this mask
essentially we want to get rid of ones
that are over here if we don't want a
new segment to start there so rather
than creating all these segments and
joining them together we don't want to
create them from the
outset how can we do that we let's run a
an addition
scan that gives us the running count of
ones here and then we have a left
argument which is the maximum number of
segments that we
want so if we
clamp here then all these fours become
threes but we actually wanted a mask how
can we get back to a mask well all these
numbers are necessarily unique since we
are always um increasing or staying the
same that means that we the ones
correspond to uh the first time that any
one of these elements occur so there's a
one at the beginning of the ones there's
a one at the beginning of the twos and
there's a one beginning of the threes
and we can do that using the unique mask
unique mask indicates the first time a
unique element
appears so now we're back to the mask
but the one that indicated where the
four we supposed to begin is gone if we
put in a four then we preserve all of
that and if we put in a five then
nothing more happens we're not clamping
anything okay with this we almost ready
to petition the problem is that if we
take this text and we try to petition it
it all works nicely for uh for this case
oh actually we shouldn't be using the uh
the original argument we should be using
the one that has an S at the beginning
so that we stay consistent but if we
have too many segments that we want then
we don't get
enough we want empty segments at the
end we can do that by telling partition
in close that we want trailing
elements we do that by adding a number
at the very end of the Mask that's uh
the one element beyond the corresponding
to the last element of the data which is
the count now we could compute how many
are necessary to add but they're all
just the same empty elements and it
doesn't really matter the maximum it
could possibly be is the number of
segments that we want at
all this is of course too many so we can
strip down the ones that we don't want
simply taking as many as we do
want and now all there remains is to
drop the the leading space on each
one thank you for watchingwelcome to the epl quest capl wiki for
details
today's quest is the fifth problem from
the 2014 round of the appeal problem
solving competition
it's a pretty simple problem we're just
to find out whether a given text is a
palindrome slight complication is that
we need to make sure to ignore things
like case and punctuation
let's start with some test data
okay
so we need to get rid of
of case differences so that for example
the first a and the last a in panama
match each other
and we can use quad c which is
case fold for that
now and
we just need to sort out the
characters that we need to compare and
get rid of those that we don't want to
look at at all and one way we can do
this is let's uh let's put this into a
function so we can try this
this is the case folded one and then we
should look
which characters are members of the case
folded alphabet
oops
uh
yeah of course it should be
omega here there we go
okay
and then and
we can
filter by that boolean vector
let's call this
just the letters
the last step is to see if the letters
match themselves when they are reversed
we can see that amanda plan and so on is
a palindrome whereas hello world is not
this works
but we can do it a little bit more
elegantly by making some observations
about what we've got here
firstly
filtering by membership
is the same thing as intersection so we
can actually substitute this whole thing
in
and say
then the intersection
between
the case folded
argument and the case folded alphabet
notice that we are applying intersection
after preprocessing both arguments with
case folding this calls fun over
finally we are comparing
this l to its reverse
an operation between
um the identity of some value and
some pre-processed
value and that we could call that a hook
construct
but really what is
another way to think about it
is that we are applying
the match function between l and l it on
itself
so that means we're doing a selfie
only that before we apply match we
preprocess the right argument of match
with
reverse
and then since we're only using this
variable once there's really no point in
assigning it so we can just put it in
line
there's also possibility of making this
a fully tested and function
it's quite simple here because we just
have a dyadic function applied between
the argument
and a constant
and then we apply another function
magnetically on that so clearly this
whole thing is in the top
one thing applied and another thing
applied
only that we have here a dynamic
function where the one argument is
constant so we can bind the alphabet as
a constant right argument to it
and that gives us
a very neat tested solution
let's call this a
it does have however a little bit of a
performance issue namely that we are
case folding a potentially very large
argument
all we need to do is we want to see
to to
only keep those characters which are
uppercase and lowercase letters and the
whole reason we're case folding the
whole argument is just so that we can
take the intersection with the letters
now
the input might be of an unknown size
but the alphabet is of a known size
and so and we can optimize this a little
bit by simply keeping
the intersection but instead of case
folding both arguments we only
case fold
the alphabet now this is a problem of
course because
this only gives us lowercase letters and
that we might also have uppercase
letters so let's just supply the
uppercase letters as well this is a
one-time operation when we define the
function generating an uppercase and
lowercase alphabet and then we just do
the intersection on that so that might
that saves us from doing the case
folding on the entire argument and that
might speed up things a little bit
so these are the basic solutions but we
could actually go a whole different
route and that is to compare ranges
so instead of looking for intersection
which is a set function
we can look at where in the unicode
character said
do the characters fall because all the
um in unicode and ascii all the
uppercase letters are contiguous and all
the lowercase letters are also
contiguous
and so if we look at
the values for the beginning of the
uppercase alphabet the end of the
uppercase alphabet and also
the
beginning of the lowercase alphabet
and
the end of the low case alphabet
oops sorry we need an each there
okay so we can see from 65 to 90 from 97
to 122. now interval index is what we're
going to use for looking up ranges and
it
made it is inclusive on the left and the
beginning and exclusive on the end so we
need to go one up at the end and then we
can look at what
what those characters are so this is the
these are the characters that we want to
use for cutoffs
and so we can see that um some
characters fall
inside this interval here that's number
one between these two and then zero is
before the first one and then some fall
um over here and then there might also
be something that falls in punctuation
the force here but that's pretty rare
um which means that it's every other
interval which
we want if it's zero it's outside we
don't want it if it's one it's it's an
uppercase letter if it's two it's
lowercase if a it's it's some
punctuation and it's if it's three it's
uh lowercase i mean if it's four uh then
it's beyond the lowercase and small
punctuation that we don't want so we can
take the division remainder when
dividing by two
and that gives us a
a one for all the odd ones which is
exactly where we have uppercase and
lowercase letters
and that is what we need to use to uh to
filter with
so that's another way of
of doing the filtering and then we can
apply uh
the actual
palindromic
testing uh as we've done before
oops
oh and we've of course been missing the
case folding that's once we're done with
that
there we go
let's call the c actually we can we can
make this one and test it as well
um
before before we give it a name let's
just try that
so there's an interesting problem here
with uh
with the slash which is a hybrid
operator function
we can we can begin by fixing that
within a top and then we have a dyadic
function with a constant left argument
so we can just bind that over here
and then we have
the argument over here
case folding
and then
comparison
so we could we could write all of it
like this
see
but since we are anyway post-processing
the result from uh the replicate or
compress
here then we don't actually need to use
an identity function to do uh
with the top to force it to be a
function we could take this whole thing
and move it in here as well
so let's call this c
but this whole business of uh case
folding and that means that you need to
consider every character whether that
needs to be case folded that is
potentially expensive and if we can
operate on raw code points we might get
a significant
performance advantage now how is that
going to work
so if we start immediately by converting
all the characters
to code points if they are all ascii
then that's really cheap because that
means we can we can because the code
points are
essentially
unsigned
um byte values on-site integers
if there are some characters that are
outside of ascii then we'll end up
having in
values larger than 127 and we'll have to
go to two byte integers because the
integers internally are
um are signed but still is going to be
pretty uh pretty cheap operation to
switch to code points
like this
and then uh we need to check whether
they are in this range that we used
before
and we can we can write this in a tested
way that i i really like for uh for
ranges
um so there are two ranges we're looking
at
and we want to know if it's in either
those ranges and so the way we can api
doesn't allow you to write
x uh or something like a a is less than
x is less than b because
less than is just
a function and it would bind wrong but
we can write
that
65
is
less than or equal to
and
the value is also less than or equal to
90 so that's the upper bound and this
kind of reads nicely right 65 is less
than or equal to and it's less than
equal to and to 90. so that's the upper
case and then lowercase is 97 is less
than or equal to and it's less than or
equal to
122. so this i like writing ranges in
apl like this
so this again gives us um
the
elements that we're interested in
and then we need to use that to filter
but we're not filtering the characters
now we are filtered because then
uh we need to case fold we're filtering
the code points so we give this a name u
and then we'll
filter you with that and that gives us
all these uh values now it might not be
easy to see what's going on here but if
we just temporarily apply
quad ucs to it we can
do each again
then we can see all letters that we
interested in
now here's the thing ascii and then by
extension unicode
because it's just a superset is
constructed in such a way that there's a
single bit difference between uppercase
and lowercase and that's the
that means that we can do a
division remainder with 32
and that since we're not it's it doesn't
matter that there are many other values
that would collapse to the same division
remainder with 32 because we only look
at uppercase and lowercase letters so
anything we need to do to know is like
the offset from the beginning of the
alphabet and 32 gives us exactly that
now this these aren't useful byte values
but we're not interested in byte values
we're just interested in these um should
we say labels on the characters and see
if they are
the same
and then we can
check using the exact same thing as
before whether or not we've got a
palindrome
so by working on on code points the
codis is significantly more involved
but we might potentially avoid some
expensive operations there
okay let's have a look at the
performance
we're copying cmpx from defense
and then we're going to uh
we need to
create some test data of course
so let's uh let's create some test data
say
we overtake from the upper case and the
lowercase alphabet much like we did we
let the application look
alphabet before
um followed by a little bit of
punctuation that might happen there so
because this adds up to to much less
than 70 that means we'll get some um
some spaces uh as well so it kind of
looks like natural text
and there are obviously 70 here and
let's just to do 50 of them for now just
to see what what this looks like
so this kind of looks like natural text
with a little bit of punctuation there
it's not really very important
and
so let's so this is a case so let's
let's put it over here
one
five should be enough
and then so this isn't obviously isn't a
uh a palindrome but we can we can create
one that that is a palindrome
uh and we can do that simply by let's
take
take half of this so this is
five e4
and then we can
just so it's the same kind of construct
this the hook contrast we are
self-concatenating it
um and then we are reversing it and
before we concatenate one of them so
this
concatenated to its reverse could be
read as competition it's reversed and
this is obviously a palindrome
and now we can say cmpx
on
a b c and d
each one of them
with the entire argument of t
so this is on a nonpalindromic
case
and we can see that um
our solution where we avoid case folding
the input instead of instead having a
both application lowercase alphabet for
the intersection that did save us
significantly and doing the intervals
with raw characters that's not worth it
however switching to code points gives
us a significant speed up in this case
and we can just for good measure you can
try this with the palindrome as well
we'll probably see similar
results
yeah that looks very much the same
so that's all for checking for
palindromes thank you for watchinghi we're giving an area and we're
supposed to make a
rectangle which could even be a
square that has that
area the Restriction is that the length
of the rectangle the size of the
rectangle must be integer and then if
there it's not a square then the
smallest side has to be listed
first so let's take 12 as an example
it's a good example because there are
many different ways to multiply two
integers together to get 12 say 1 * 12
or 6 * 2 and there's only one result
that's valid here and that is 3 * 4 it's
not a 12 not a square so we can't be um
well a square um but 3 * 4 are as close
to each other as possible another ways
other way to describe this is that we
want to make the rectangle as Square as
possible okay let's start by looking at
our candidates these are all the
integers that could come into
question um of course it can't be larger
than 12 there's nothing you can multiply
with to get 12 it can't be zero unless
our actual uh area that we need to get
to is zero as
well and then we want
to find out which of these numbers
actually divide 12 evenly um so we can
take the division remainder or
modulus and this takes the whole
range
and
dividing the number
itself and then we get these remainders
so we can see that 1 2 3 and four they
divide 12 cleanly five gives us a lift
over of two cuz 2 * 5 is 10 and then
missing two and so on
[Music]
um we are not interested in what the
remains are we interested in whether or
not it divides so 0 equal to that and
that gives us a mask showing the uh the
numbers indicating the numbers that
divide
12 the next step is then to find out
what these are and choose the middle
ones of these numbers so we can see that
there are six of them 1 2 3 four 1 2 3
four and six and 12 and if we were to
put them together then three and four
would be the middle two and that's the
method we're going to use it's going to
be a little bit inefficient to do it
this way but it makes it kind of
neat so the first thing uh we can do is
find out what these numbers are and we
can do that by asking where are the ones
which are the indices of the ones which
are the same thing as the numbers that
we started off
with so 1 two three uh four six and 12
and and the middle two are three and
four and now we could try to compute the
length and get the middle but there's a
much easier way to do that and that is
replicating all of these so we've got
two of
each and we also know the length of this
which was and which is
six and now if we remove the first six
from here that's a 1 one 2 to um 3 three
then we get to over here um so then if
we take the next two elements after
moving the first six we get four four so
all we need to do is either subtract one
or we could just insert a Dy element at
the beginning and then would get us 34
and it's a good way to do this as well
to not try to index in because if the
list is empty because the argument is
zero or if the list has too few elements
because uh well actually maybe that's
not problem but if it's zero then then
uh if you try to index it we get an
index error but if we uh if we drop some
elements and take the next ones then we
can overshoot and will p with zero which
is exactly the result that we
want so let's um pad with an element
that's going to be removed in a moment
so then and now we can remove the first
six from here 1 2 3 4 5 six and the next
two are going to be three and four how
do we get the number six uh remember
we're passing in The Mask here and
finding the indices here we don't need
to find the indices to get the length of
the IND es because we there are as many
ones in this list as the list of indices
so the sum of this is going to be the
length so we could take the
sum and
drop some number of
elements and then we just need to take
the first
two there you go that's our solution and
it works for um for zero as well which
is all nice
thank you for watching bywelcome to the apl quest c apl wiki for
dear sales
today's quest is the second from the
2015 round of the apl problem
solving competition
we're giving some numbers and we are to
find out
what the
longest run of intervals
are where the intervals are all
increasing in volume
let's start with some test data
so
we are to find which intervals that is
these spaces so to say in between
numbers and that are increasing
what we can do is we can subtract
any number with the number before it
this is an end wise reduce and because
of the direction we want we want the
rightmost element minus the leftmost
element so we can use a negated window
length to clip
the
subsequence backwards before we apply
the reduction over it
there's a little catch that if
and this is one of the the
example
arguments if
the input is a scalar then the invoice
reduction will fail
but we can fix this simply by reveling
the argument
okay so going back to our sample data
we got these
differences and we want to find out
where they are strictly positive so
that would be any of them that are
greater than zero
now we have a boolean mask
indicating and which intervals
are
growing
and then we can use
a partition
on any data really
but conveniently we can use it on the
same data and the way partition works
is
that
when the argument is booted left
argument is boolean is that any runs of
ones become
segments and any elements that are
zero get dropped out and that's also
where new segment begins
so we can see how we are getting these
groups of uh the first the one and then
the zero drops out and another one and
then the zero drops out and then we have
the three
and now that we have the segment lengths
these are the runs of
growth so we can simply
take the length of each one
and then
do the maximum over that and that gives
us our result
for this case which is
three let's put this into a function
like that
right
um there are some tricks we could do to
make this shorter
let's have think about this we're
finding a difference but we're not
actually interested in the difference at
all
what we're interested in is whether or
not we are growing so instead of
comparing elements
in size we can just compare them
directly so we want to know if the left
argument is less than the right or well
left element is left and then less than
the right element in this
two element sequence so we can just do a
two wise oops a two ways uh
less than reduction and that would work
as well
there are um
other should we say golfing tricks we
could use to make this shorter but that
doesn't mean it's better just for the
fun of it
let's try this
so
let's say we have this
vector of
vectors
if we
mix it
that is we make it we stack these
vectors on top of each other
to get a matrix
then we have to pad the short ones with
zeros but that doesn't actually matter
we can see what this looks like and then
we can see that the longest
sub-vector is the one that determines
the number of columns so if we transpose
then
the number of
rows is going to be the original width
and that's the length of the longest one
so we could just tell you that um
alternatively you could get the second
element of the shape but this is shorter
just not better because
transposing can be a bit expensive so
for code golf version
this works fine
but what is a good way of doing it see
the problem is that we are petitioning
into these sub vectors creating
potentially a huge amount of
vectors in a in a large vector that's a
lot of pointers and a lot of ways to
space for information that we actually
don't need the only thing we really need
is the length of each
and so let's think about it for a moment
let's start off again
with this comparison
what we want to find is the length of
sequences of
ones
okay
well
let's normalize
this by padding with some zeros around
it
now we can more clearly see these runs
of ones that we want the length of
um and now we know that we begin with a
zero end with a zero as well
what we want to find out here is
whenever we are switching from uh from
zero to one and one to zero that's a
cut-off point we just need to know the
distances between the cutoff points in
order to get the length of the runs
so we can attempt to do that um
the cutoff points the the places where
we when we switch from zero to one one
to zero that's when consecutive elements
are different from each other zero
different one one is different than zero
and of course one one is the same zero
zeros is the same
so it would seem that we can
we can do this and
the pairwise difference
and now already now we can kind of see
our result here that would be
this sequence here with three
so we can take the
indices where there are ones
and then
we can measure the distance between
consecutive ones
and then we can see our three over here
and we might think that we can then just
do a maximum here
to get the three
but
if we try that
then
we have pulled ourselves and the reason
for that is
that remember
here we're looking for the cutoff points
between consecutive between runs um but
you would find the the cutoffs between
uh
from from a change to from a one to a
zero and then back from zero to one just
as much as you will find what we're
looking for um from zero to one and one
to zero
so we can illustrate this with an
example that's not going to work well so
let's just have some descend lots of
descending numbers here but very little
uh
increasing numbers
and if we try this expression here
then we can see we get seven
and this is because if you go back and
look at um our differences well we can
start off with this actually
we can see that and here are our
increased runs
and if you look at the
where the differences are and sure
enough there's a difference here we go
from one to zero and then zero to one
over here
and then asking for the indices
of that and the consecutive differences
between them it gives us the length of
the longest run of identical items but
we only want the runs that correspond to
that are all zero runs so this approach
doesn't quite work but we can modify it
to make it work let's go back to our
boolean vector here
this indicates where we are growing now
um
instead
if we
if we look at the opposite of that where
we are non-growing
then we get a bunch of ones whenever we
have a streak of
zeros
that is none growing and we only get
zeros where we have a streak of ones
now if we ask
for
the indices
and compare
consecutive elements
then
since every time there's zero followed
by zero and there are complete adjacent
that gives us a length of two in between
sorry a length of one in between them
because it's just one element over the
next one
since we are counting
the intervals not the elements involved
in these streaks then we have
overestimated by
by one
so we'll just have to
subtract one
and estimate over over computed by by
one
and that gives us this one at the end
indicating
the uh this original sequence of zeros
which is our and
growth
and so we can put this into a function
and we can try it
on
each well we still need to take the
maximum here
um of that you can try it on each of
this n and x
and that gives us correct result three
for the first one and uh
one for the
uh example with a long decreasing streak
but short increasing streaks
then before we give this a name
we can
[Music]
simplify some things so let's just run
it again every time we simplify some
things to uh to make sure that we're not
changing anything notice here that we
are applying a boolean
nut
um and
that means we instead of applying that
nut we could just initially compute the
values in exact opposite so
not less than is the same thing as
greater than or equal to
and not on these
zeros would be one of course so we can
get rid of that and see that we get the
same result
and here is interesting we are flipping
around the subsequence before we're
applying minus reduction that is uh
since it's only an x2 so that's just
b minus a instead of a minus b
that means if we don't flip it around
then we get negated values
so if we're getting negated values then
we have to subtract them from here
finally we could move
this over because here is a reduction
over a bunch of numbers
all these numbers is being are being
processed with negative one minus that
and since we're just finding the maximum
then
we can do the addition subtraction
afterwards just have to remember that
these numbers have been negated so we
don't want to find the maximum anymore
we want to find the minimum
there's a negative at that point
so this gives us a very nice
solution that should be also efficient
did you assign remember to assign b yeah
i did assembly okay great so um so now
we've got these
uh three different
definitions and we've got the a which is
very much a the way we think about it
we're finding the
streaks we're finding the lengths we're
getting a maximum one um there is one
issue with a that we haven't taken into
account and that is what if there aren't
any streaks and that's so that's a bit
of an issue so let's try that on
some decreasing things like that and
that doesn't look right negative well
kind of infinity negative the smallest
possible representable number and that
is because
we um are finding these partitions and
if there aren't any that gives us a
length zero array getting the length of
each one so still an empty array and
then we are reducing with maximum over
an empty array and that would give us
the maximum functions identity element
which is negative infinity or as close
as we can get to that and we can fix
that simply by requiring that the length
is at least
zero
so let's reset that and now
we are ready for some comparison in
performance let's generate some test
data um i find it convenient to use
a thousand integers in some random
permutation
that should give us about five uh on
average as the
longest streak of
consecutive growth
importing cmpx from the defense
workspace
and then we're simply applying that to
our test case
right there and if my predictions are
right
then
the golfed version is being exceedingly
inefficient by creating this matrix that
we don't need so it's going to be a bit
worse
than
the original solution which was the more
intuitive solution and then there's the
entirely flat solution where we never
create
the partitions we rather do the
computation directly of them which is
going to be hugely more efficient
definitely the one you want to go for
for speed
thank you for watchinghi
let's use APL to make sure that all our
odd numbers become even numbers doing so
by incrementing them making them one
larger
that is three would become 4 and
negative 3 would become negative two
let's start off by defining an array a
and we're going to give it the numbers
from 1 to 16
um for now
and we can then take the array executed
we get this
and we can also
um
modify this assignment and subtract a
bit so let's uh subtract five
okay now we've got some negative numbers
and some positive numbers
let's further modify this by shaping it
into an array of shape four by four
here we go good this is some good test
data
we're going to write our first function
which is going to solve the problem
let's develop it
piece by piece
this is a function it's enclosed in
braces to markets limits and Omega
refers to the right argument because
Omega is the right most
letter
of the Greek alphabet
so this is an identity function it
doesn't do anything
now we can divide by two
um to kind of scale down
and we can see how
apl's arithmetic automatically maps to
all the elements of an array even a
multi-dimensional array like this one
if we now round up
that will add a half and we've scaled
down to half the magnitude that we had
before which means we can then scale
back up again to the full magnitude and
we will have added
um
a whole number rather than half to all
the odd numbers which gave us 0.5 as
decimals
of course the even numbers we divide
them by half by two it gives us a whole
number again and then rounding up is not
going to do anything
so here's the rounding up which uses a
function
um that's the same symbol as the left
side of the special brackets the
rounding up bracket ceiling brackets
um used in mathematics when they appear
every symbol it stands on its own it's a
function at its own and take everything
on its right as its argument so we don't
need any parenthesis here either they've
Roundup or ceiling function which kind
of looks like a wall with a bit of a
ceiling
takes everything to its right that's
Omega divided by two
as its right argument
and now we can continue
with multiplying by two
and this gives us the result that we're
looking for all the odd numbers became
one greater and all the even numbers
stayed the way they were so we can give
this a name f and we can apply F to a
and like this no parenthesis or brackets
or any sort necessary to apply this
function
so this is one way of solving the
problem
let's take a different way of solving
the problem
we mentioned briefly here that the odd
numbers they give a half as decimals
um when divided by two so that would be
the remainder when divided by two that
has already been divided by two it gives
us a half and we can exploit this
by taking the remainder when divided by
two we write that with the vertical bar
which is borrowed from mathematics as
divides right so instead of saying the
two instead of expressing the predicate
the two divides
um Omega we're asking what is the
remainder when two divides Omega
as you can see that all the odd numbers
they give one as a remainder and that's
great because what we want to do is take
um and add one to all that numbers and
add zero such as a leave them as they
are all the even numbers so we can just
take all the numbers and add their
remainder when divided by two
and that gives us the result that we
want
so let's call this G and we can apply it
with G of a
so here two really neat solutions to our
problem
thank you for watchinghi
we're going to convert a Gregorian year
number
to the closest matching Chinese zodiac
animal
and we have to be careful because the
prolactic regarding calendar doesn't
have a year zero
now there are various ways that we could
scrape the data off the website
however
um I'm not going to go into that now I
have defined a
Matrix which corresponds to the table
that is on the website including being a
little bit should we say dirty
so the first thing we're going to do is
that we're going to
clean this up a bit so we have some raw
data that we can work on
we don't actually need all the columns
so we're going to index into this and
choose columns one and four those are
the year numbers
but notice the spacing here they're
actually giving this text and then we're
going to take the animal names which are
columns two and five skipping the empty
column four which was apparently just
there for spacing
now that's all very nice but we can see
here there are at least spaces at the
end of the rooster
and there are also spaces at the end of
the years
that's not so much fun
so what we can do is we can do a without
this is a like a set difference function
on each of these with space so removing
spaces from them all since there are no
internal spaces we need to worry about
that looks better
now we can transpose it
and that gives us a the reading order is
a bit better
but we still have two rows for each
thing
so we're going to reshape this
we only want two rows in total one for
the years and one for the names so
that's going to be two row 12 columns
reshape so this is Greek Row for reshape
and that gives us a much nicer looking
table it's also in backwards order so
let's mirror it
and finally
um it's a matrix but we would rather
have two lists so we're going to split
this
into a vector of vectors and we can see
that we have this even though it goes
beyond the screen
um two vectors and now we can assign
this we assign the first one are the
years and the second ones are the signs
and now we have the year separately and
assigned separately but the years are
not numeric we could do something about
that but it's not actually necessary we
really just want
um
and the signs because it's very easy to
generate these year numbers as well you
can just do 2016
plus Iota 12 where Yota generates a
sequence of numbers from one onto that
number
and then we have the years
okay
let's get started
we're going on a 12-year cycle
oh it's actually not even 2016 it should
be 2006 but that doesn't matter we're
going on a 12-year cycle
and it would be nice to know where the
origin point is for these so we can see
say the 12
divides these numbers how much is the
remainder
and then we can see there's one where
there's no remainder so it's uh evenly
divisible we can identify that one by
comparing to zero
and there's exactly one and then we can
find its index
it's index 10. so it's an index 10 and
we start with index 1 that means there
we have a an offset by nine if we didn't
start with
um with this 2007 if you started nine
years later then we would be better off
so we can do a rotation so the same
symbol that means the mirror if you use
it with an argument on the left it means
a rotation a cyclic
moving of the elements
so we're going to rotate by
um for nine steps the signs
now we start off with the monkey so if
you is divisible by 12 then it's the
monkey and if it's divisible with uh if
you divide by 12 there's one left over
then it's the rooster and then if
there's two left over it's a dog and so
up until 11 left over
we need this data into our function and
it's a little bit awkward to have it
like this we could
transform it into an APL expression that
generates this Vector of character
vectors and we have a user command
called wrapper that would do that for us
it's still very verbose though so I
think it's more fun to pack it all
together this is the in list function it
just takes all the characters and jams
them into a single character vector
that can fit on the screen that linked
and once we have this
then we just need to know how to expand
this into our full Vector of character
vectors that we need to
to select from
notice that all these names begin with
an uppercase character and that's
actually really useful if we look for
membership into and here's a special
system variable called Quade or the
alphabet so this is just a character
Vector containing the alphabet and if we
look for every character here is
membership of this this is the uppercase
alphabet it should say then
we can see that we get a 1 for the
leading characters in each of these
now
we can transform this in this function
into a so-called train or Fork which
means that we are referring to the
arguments in just in terms of function
application
this is a membership and we want to use
this membership to Partition
the left argument so this points at the
left argument so this is the membership
partitions the left argument
and then we reconstitute this so every
time there's a one we start a new
section or segment every time it's a
zero we just continue the previous
segment so this is a
um more dense way of writing the same
array although we might need parenthesis
around it
like this
and now
um what we could do is we could rotate
then by the division remainder when 12
divides the year let's say 2018
oops what's going on
oh yeah of course
um the problem is that the rotation
takes the argument remember we had the
nine rotate it takes the argument on the
left so
and we need to swap the argument so this
higher order function or operator takes
this function and swaps its arguments
such that the rotation amount is on the
right and the data is on the left
okay so now we've rotated it to be dug
and
um if we
look at our original table
then we can see that 2018 is indeed the
dog so that that fits we got the right
right amount however
um we don't want an entire thing we just
want the first one so this selects the
first one
and that gives us our dog so this is the
solution for the basic calendar
um
here's a cool thing
we
took the remainder and divided by 12 but
there are also only 12 elements in this
list of animals which means if we rotate
12 times then we come back to where we
started
and it also means that any multiple of
12 gets us back to where it started and
the only thing that actually matters in
the rotation amount is the remainder
when divided by 12. so there's no reason
to even compute that
because if you just rotate it over and
over and over again then we get back to
the uh to where we started and then the
last remainder that's less than 12 is
what actually gets us to a new position
so
this works as well
and it's not even inefficient because
the API system itself will compute what
the final result will be we don't need
to do it for it
now here's one issue then
um and that is
that
when we get down to a the small numbers
when you get to one so that's the
division remainder
the four one if we subtract
one more we get down to zero but there's
no year zero so the animal that we
would give year 0 actually needs to be
given two year negative one
in other words if we have a negative
year number then we need to add one
so let's say we have some negative
numbers
and we don't have any zero that will
never appear but we do have some
positive numbers as well
then we can
compare this to zero so if zero is less
than that and then in order to make this
a single function we bind or compose the
left argument to the greater than
function
and this gives us
A1 or true for the negative numbers and
a zero for the positive numbers
if we then take the right argument
remember this is this pointing thing
just like we had a
um up here that we had little little
finger that points to the left for the
left argument so this is pointing to the
right for the right argument
and we add that to
the result of this comparison then
effectively we increment negative
numbers adjusting them back as if the
calendar had a year zero so if you use
this instead of the actual year number
then we've compensated for the lack of a
year zero
okay so we take this whole formula here
and we put it on the left
um
and that means that we have the year
number over here
and we don't even need parenthesis
because APL functions have long right
scope so this is the
negativeness added to the year itself
we use that to rotate this entire thing
which computes this 12 element list of
names and then we choose the first one
after we have rotated them into place
and this will be our function it's a bit
long to see here
but now we can say to 2018
and we can also say Year One
and we can say yeah negative one
and we can look at our table up here
that f is the rooster and the year
before that sorry uh year one we said
was the rooster and your negative one
should then be the monkey and that is
exactly what we got so this is a
solution to the problem
you probably don't actually want to
write it like this it would be nicer to
have this thing saved as a constant
so let's try that
we will
um save this as our list of signs
and then we can just go up and say
the list is this
and now we can use the function f
exactly the same way it will there's no
difference here it's just in fact the
definition becomes the same thing
because we take the value and substitute
it in but it's a bit easier to see
thank you for watchinghi
we are given two dates in vector format
and we are to determine what the
relationship in time
are
whether one is before the other one
that would then we have to give the
result negative one where the one is
after the other then we have to give one
or whether
they're the same in which case we have
to return zero
there are different ways to approach
this
but I'm going to go at it with um
date manipulation in order to show the
tools we have available
one fun thing we can do in dialog APL is
to use dot net
I've prepared some test cases here
is always the same date on the left but
three different date and on the right
and we're supposed to say that the first
one is
earlier because we can see here it's the
same date but it's an earlier time 12
instead of 16. these are exactly the
same and this one is a little bit later
um we
because it is a different year
so
in order to
use.net we have to set our using
statement let's put in our arguments
first and then we create a little
different or Lambda to compare each one
of these on the left with each one on
the right
we can try this
so this pairs them up
the first thing we have to do is set our
our using and we want to use the net
system so we write that
and this gives us access to a namespace
called date time
in that time we can do various things
there are some functionality that we can
use and we can also create date time
objects whereas these are just normal
APL vectors we can create scalar
entities which are times so we can
create
and new date time based on
say the left argument
so these are they're now formatted for
human consumption but they are just
scalars
we want to do that on both of them so we
create a little inner Lambda that we can
apply to each one of the left argument
and the right argument
now we have two date times
we cannot component directly but
we can in the daytime
Library we have something called compare
and this Compares these two
and this gives us the result that we
want
using.net is great but a lot of
functionality comes built into APL as
well
in this case we can use something called
quad DT
which converts between time formats and
it understands that we have a vector
format
and we just want to convert it to it a
serialized number which is which
progresses through time so that we can
do a comparison
so these are the day numbers actually
the number of days since the last day of
1899 but that doesn't really matter and
we could use any such format that has an
offset from an epoch
and now
we can compare these two
if we subtract them
one from another
then we find the number of days between
them
and all we're not interested in how long
this is we're interested in which
direction does it go is it before the
same or after so we can use the Signum
or sine function to get the result
so this also solves the problem in a
much neater way
we can restructure this function a
little bit
and make it test it instead of explicit
by observing that the main operation
here is actually a subtraction we don't
want to subtract the arguments we want
to subtract the
date time in format number one of each
one of them
so another way we can express this is
that we want
the subtraction over that is we
pre-process both arguments first with
the conversion of the entire Vector to
format number one
and then this
is a two train or in a top
and we can give it a name without the
outer parenthesis
thank you for watchinghi here we are to find the difference in
area
[Music]
between a square that's inscribed inside
a
circle and the Outer Circle so it's
actually the Outer Circle area minus the
inner squares uh
area and there's not much to figure out
here with regards to algorithm these are
known formulas so this video is going to
be a little bit different than usual in
that it's mainly going to be a symbolic
reasoning in tacd
APL so first a little bit of um Theory
we going to find out what are the areas
of these two components the circle and
the square and what the the input that
we're given is the diameter of the Outer
Circle so if that's the diameter of the
Outer Circle and the square inside is as
big as possible that means the square
inside is exactly touching with its
corners on the
circle also means that the diameter of
the circle is the diagonal in the Square
it's a straight line that goes from one
corner to the opposing corner
diagonally okay so with that in
mind we have the Pythagorean theorem
that states that the square of the
length of the longest side in a right
angle triangle is equal to the sum of
the squares of the shorter
sides however here we know it's a square
so the two shorter sides are identical
in length
now we're going to do this entirely
symbolically so let's do this with a
comment we're going to say
that the
square which is the same thing as the
multiplication of self so multiply by
itself um of
the
diameter of the circle which is the
diagonal in the Square
is equal
to the sum of the squares of the smaller
sides but since they're the same it's
then it is also the same as twice that
so if we take the squares of the smaller
sides and multiply that by the constant
two so this is a two that's made into a
constant function and and we're
multiplying that with the self
multiplication which is the square then
the equality
holds now we don't actually want to
compute it this direction we want to go
uh the other direction we want to to
find the um the smaller
sides such that we
can compute the area which is just the
small sides multiply by each other oh
but since they are identical then the
same thing as the square of the smaller
side and that's in fact what we're
getting here so in order to make this
work remember on the left we had the the
term that represents the diameter or
diagonal and on the right is we have the
squares for the smaller
sides all we need to do then is
eliminate this doubling on the
right so we can do that by dividing by
two on both sides that eliminates this
one and instead we divide by two
constant on the
left this equal sign is not to be taken
as a function here we just stating that
these two things are equivalent the
diameter diagonal and of the circle
square divided by the constant two is
and so the square of that diameter
divided by the constant two gives us the
square of the smaller sides the square
of the smaller sides that is the area
that we want so this formula is what we
need to apply to the original argument
in order to get the area of the
square okay now we need to get the area
of the circle here we don't use PR
Pythagoras we use Archimedes and
Archimedes says that the given the
diameter of um a circle the area of that
circle is going to be pi
times the
square so the self multiplication again
divided by four it could also be stated
simpler in terms of the radius but given
that we have given the diameter this is
what we
get right then the next step is going to
be
to combine these two areas we want the
area of the
circle
minus the area of the
square and now we want to combine these
two
things and we can observe a pattern here
but it's not exactly the same because
we've got here the square of the
argument divided by the constant four
and the square divided by the constant
two if we change this two into a four
then we have made it half as big as it
needs to be but we can compensate by
that by doubling it and while we could
write two times this we can also observe
the doubling just like squaring is the
self mul ation doubling is the self
addition right now we have these two
parts that are exactly the same so we
have for whatever this gives the squares
divided by four we have pi times that
minus the doubling of that so we can
break
out this part of the expression outside
a
parenthesis
let take that part and we put it here
and then we apply pi times
that minus twice
that and that gives us um our for our
finished formula which is very elegant
we can try
it and then we get the expected results
so very elegant formulation and an
example of reasoning entirely in tested
APL thank you for watchinghi this task is to group up a list of
integers by which other integer they are
divisible
by so here we start with two lists and
these on the left are their targets we
could say where that numbers have to be
divisible by and on the right we have
our selection of numbers that we're
going to test so the idea is we are
returning a vector vectors or you could
say list of lists the first list will
contain the numbers from the right that
are divisible by two so that would be
the even numbers 8 12 and
10 and then we the numberers divisible
by four that's 8 and 12 the ones by
seven that's just seven the ones are
divisible by three
which is just 12 and then one's
divisible by nine which there aren't any
so we need to have an empty list of
there so we're going to have a list of
uh five elements because we have five
elements on the left and each uh sub
list then can have up
to this many six in this case elements
but in our case there won't be any
because then we would have to have a one
on the
left and we can do this quite simply
actually so we want to do this this
looping thing we want to try for each
one so makees let's make a little Lambda
that we apply to each one on the right
but we want
to um apply it not pairwise that won't
work anyway because they have different
lengths we want to apply every time
around the loop with the entire right
argument as our right argument so we can
do that by pre-processing
the right argument with an enclosure so
this makes the right argument into a
single element which is then mapped with
each one of the elements on the left we
can try this and see it so if we just
refer to the left argument as Alpha the
right argument as
Omega then we can see how two got paired
up with the entire list and four got
paired up with the entire list and so
on okay now we're ready now we can start
by uh finding out if the ible or not we
don't have a direct test for that but we
do have a remainder um and if the
division remainder is zero then it's
divisible so this is commonly known as
modulus and so you can see here this
says yes uh this says the
remainder when dividing five by two is
oneing seven by two is 1 we're dividing
8 by two is zero and over here when we
divide 5 by 4 we get one left over seven
it gives us three left over eight
divides cleanly so if we just compare
these numbers to zero that will give us
a Boolean mask for the ones that are
divisible and all we then need to do is
filter the right argument by that mask
so this is a filtering function it takes
a uh a list of of ones and zeros on the
left and they take some data on the
right but this higher order function
flips the order of the arguments right
and left such that we get it um our
expression a clean flow from the right
to the left of the
data and this gives us uh the correct
answer we can see that the numbers from
the right are divisible by two are the
even ones the ones that divisible by
four are 8 and 12 and so
on however there's also a uh a very
clever solution that someone came up
with in the chat event leading up to
this
video and that used
and some unusual constructs let's have a
look at uh that as well so let's start
up with our numbers here and the way
we're going to do this is we're going to
to build up piece by piece
um first we're going to start with an um
a divisibility table for all the numbers
with all the numbers cuz we need to
check all of those anyway we can do that
in one swoop so we use an outer product
which is kind of like a multiplication
table but instead of using
multiplication we're using the
remainder so this is a remainder table
and we can see that we have two 4
7 3 and 9 going down and then 5 7 8 1 uh
and so on going across and then we can
see corresponding numbers whether the
divisible so we can see for example here
that
uh that if we have the third number
which is um seven and we are dividing it
into seven then the remainder is zero of
course and with eight we have one over
here and then we can do just like before
comparison with zero because a is rank
polymorphic so we can just do
comparisons between this scalar and this
whole
table and that gives us our divisibility
table rather than a uh modulus or
remainder
table okay now we need to take each row
here and use it to select the
corresponding elements from over
here and the way we can do that there a
couple of different ways we can do it um
but we can use a construct with
rank so the rank operator specifies What
sub arrays we want to be given to a
function so we use the slashes before
for the filtering and then we want to
filter using rank
one and that means we're going to
conceptually at least Loop over every
row of these and pair them up with also
a rank one that's a a vector from the
right which is just the right argument
oops uh yeah there's a problem here we
need to parenthesize this otherwise it's
not going to
work okay now we can see there's a
problem that in order for this to fit
into an orthogonal array
then and we pad with additional numbers
because the length of each of these
results isn't the same um so rather than
having this be an orthogonal array we're
going to post prod process the result
from each application of uh this
replicate function or compress or filter
if you want with an enclosure to make it
into a Scala make it into its own
Standalone
thing and that gives us uh the result
that we
wanted now we can be really clever here
and we do that by um
realizing that this is is actually
What's Happening Here is actually a
pairing up of
corresponding
um rows from the table on the
left
with everything on the
right and then a concatenation of the
individual results so that really makes
sense here because this is the first
result from the filtering and this is
the second results from the filtering
and they're just concatenated together
not joined but as separate elements
they're joined into a um a single list
and then we can write that as an inner
product so normally an inner product is
the sum of
multiplication some people like to call
this a uh map reduce we start off by
mapping with multiplication and then we
do a reduce which is a
summation but APL generalizes this
um as the dot it's also known as a DOT
product to any two operations that take
two arguments so here instead of
multiplication we're going to do the
filtering and instead of doing the
addition we going to do
concatenation this is a very clever
insight and uh you can look in the
description of this video and get a link
to the chat transcript where this was
discussed for even more details
and discussion of
it now we can simplify things a little
bit we don't actually need parenthesis
at all around this inner
construct and since we only have a
simple thing on the right but something
complex on the left then if we could
swap the arguments of this derived
function this
concatenation with filtering inner
product then we could eliminate the
parenthesis for a nice clean look so we
do that as we did before and this has
long left scope so it takes the entire
thing here and flips it which means we
can get rid of this uh Tech over
here and move everything on the from the
left to the right and eliminate the
parenthesis for a beautiful solution
thank you for watchinghi we given two specifications of
time and we're going to find the
difference the absolute difference um
between
them the twist to this is that the
specifications of time are not
necessarily consistent uh they may might
include just minutes or they could be
hours and minutes or they could be days
and hours or
minutes so we have to normalize that and
then figure out how many minutes we've
got so the example we given is uh 213 on
one hand and uh 515 so this is 2 hours
and 30 minutes and 5 hours and 15
minutes and we want to find the
difference between them the only problem
is that we need to figure out first how
how many minutes are each one of them so
before we do the difference and
let's just concatenate together so we
can see we pre-processing both arguments
with a little pre-processing
function um and that's going to be
referring to the argument as
Omega and then we need to make sure that
we've got three elements so we padding
we need to pad with zeros on the left so
we get the um the dat days hours and
minutes and we can do that by taking a
-3 take so this takes the last three
elements padding with zeros on the left
so and now we're concatenating them
together that doesn't make so much sense
of course but we can see that we added a
single zero on the
left and now we need to convert to
minutes and conveniently we have a an
ability in APL to evaluate mixed radex
number systems
so we specify the base that's why we
have this base symbol and we specify a
base where there are 60 Minutes to the
hour 24 minutes uh uh 24 hours to a day
and no higher unit than
that so this m zero indicates that
there's no overflow to any higher unit
we just stay uh with days counting up
forever so this gives us the number of
minutes and we can now replace the
concatenation with a
subtraction we can see that the result
is negative so we need to take the
absolute
value it's this one um and apply that on
the
result that gives us our solution thank
you for watchinghi
the problem of
taking a Boolean vector and leaving only
the very first true
while all subsequent trues become false
is conceptually really simple
and the APL solution to this is also
extremely short
the challenge is really to understand
how this works
so let's say we have false false true
true false
what we want to do is change the second
true into a false because only the first
true is going to survive
and the entire APL solution I'll give
you right away is just this these two
characters
but why is that
for this we have to understand what
exactly
the backslash is doing which is a scan
or a cumulative reduction
and then we have to understand some
properties of using less than which you
normally would associate with comparing
numbers
but it's being applied here as a Boolean
operation
okay so first scan
scan is actually
reductions over the prefixes
so let's say that we take the first
three elements of our data
we if we also want to take the first
four elements of our data then we would
have to take each and each one of them
shouldn't apply to individual elements
of our data but rather to an entire one
so we enclose it to become an entire
whole
so here we have the first three and the
first four
but we want all the prefixes
we can get the length
and we can get the indices of the length
and so these are all the prefix links
that we want to take
we'll compose these two functions
together and then we use them to take
each from the entire argument
okay so this gets us our prefixes
let's for convenience give this a name
right
and now we can do a reduction
over each one of the prefixes
so this is a less than reduction on each
of the prefixes here
and yes indeed that gives us the same
result because this is the definition of
the scan
but why is this and for that let's take
a bit of a closer look at the properties
of less than when used in a Boolean
context
so
there are only two possibilities for a
left argument for for less than zero and
one the false and true and there are
only two possibilities of a right
argument
zero and one the false and true
let's do all the combinations that's an
out of product so we do an outer product
but it's not a multiplication here it is
a less than
can be a little bit hard to understand
what this result represents so let's
decorate it with some headers I'm going
to put the less than character in the
corner and then I'm going to add a
header row on top with three columns the
zero and the one right next to the
symbol I'm going to put that on top and
then we're going to put a heading for
the rows as well which are also the zero
and the ones so they go on the left of
this and now
we get a kind of nice table
it's a like think of it like a
multiplication table but it's a less
than table so zero less than zero that's
zero
one less than zero is zero why because
it's true and false so is one less than
zero no it is not so false zero
and we can see that there's only one way
that less than can give us true
that's this one over here
and it happens exactly when the left
argument is zero and the right argument
is one
so in order to
get a final one result
we must have a condition where we at all
times have one on the right and zero on
the left
okay let's go back and look at our
prefixes then
so here
we remember that APL reduces
from the right because reduction really
means you're inserting the function in
all the spaces between the elements so
we start from the right
the first one is just a single element
which just stays the way it is there's
nothing to insert here here we get 0
less than zero which it's not so it's
false so that's a zero this is the one
is and here we have zero less than one
which is true
so in a sense this one
moves over one step it takes the place
of
these two elements and again we have
zero and one
and we get
A1 which fulfills the condition so this
prefix which is the third prefix results
in a one and if we look at our data
that's the first one we get a one
now for the next one we have two ones so
that according to our table at the end
that gives us false
so
the new value 0 takes the place of these
two elements and we've got zero zero
zero
zero less than zero that's also false
zero less than zero it's also false so
the result for this corresponding
element number four
is false
and over here we have a zero but again
it's the wrong way so one is not less
than zero that's false and then that
takes a place a zero takes place of
these two elements so again we have one
and then zero and that's again false and
then we're back to the same cases we had
before zero zero zero we get false
another way to think about it is the
only way a one can survive
moving towards the left towards becoming
the end result for this corresponding
prefix is if it has all zeros on its
left
if it sees any one they will clash and
we get zero and everything is canceled
out from then on
which means only the very first the very
leftmost one can survive
because the first one necessarily has
all zeros on its left
and what if there's nothing to its left
well that would mean it's the first
element if it would be a one then a
reduction doesn't do anything and we
just get that one back and so it
survives any subsequent one will hit
that first one and be canceled out
there's a lot of talking let's try to
illustrate this a bit so I'm going to
implement some a little bit involved
lambdas or defense
um but when we run them then we'll draw
a nice diagram so that we can see what's
going on and all I'm going to do here is
I'm going to write covers for the
built-in APL
so let's write a cover for the less than
function
and we'll start off by printing out what
is going on so we're going to print
and I'll start by printing a little bit
of indentation you'll see in a moment
why
then we print the left argument
followed by the less than so that we
actually doing a lesson operation
then the right argument and then we'll
use an arrow to indicate that this gives
us a result and then the result is going
to be left left argument less than the
right argument
so this just prints it we don't want to
return this nicely formatted thing for
human consumption we want to just return
Alpha less than Omega so left argument
less than the right argument and yeah
we're Computing it twice but performance
is not what we after here it's just
illustration
okay then we had the less than reduction
that we were applying let's define less
than reduction and we're going to do
very much the same thing this time it's
one level out so we're going to give it
a little bit less
indentation
and then we want
to print out that we're doing a less
than reduction and there's just one
argument and then we can print out the
result then less than reduction of the
argument
and then
we'll actually do the less than
reduction
but let's use our comma function
because this will have the side effect
of printing out every time
the reduction invokes the less than
function
and finally we'll write the less than
scan
in much the same way this time it's the
topmost level so we don't do any
indentation we'll write out that we're
doing it less than scan on the argument
leading to the result of a less than
scan of the argument
and now we're going to use our cover for
the less than reduction for each it
would be this
but we instead rewrite less than
reduction on each of the prefixes
of the argument
okay and now we can run this so we did a
less than reduction on our argument zero
zero one one zero
and now we're going to do exactly the
same thing but we're going to use our
cover function less than scan
on this argument
and we get a whole lot of text out
so what is this illustrating
this is illustrating that the overall
operation is like a hierarchy overall
operation is taking
this argument here
and applying a less than scan to it and
getting this result
and as part of that there were multiple
steps the first step was reducing the
first zero
that's the the prefix there
and that immediately gave the result
there's no indented line below this
because there are no further steps
there's no actual invocation of the
function less than we just directly
derive the result without applying
anything because there's nothing to
reduce
then we took the next prefix which were
the first two zeros
and got the result zero how did we get
the result zero well we inserted less
than between these two zeros which gives
us
zero
and then we go on to the third prefix
that has a one
and it gives us the result one when we
do the less than reduction on it how
does this work well we start off from
the with the right most two elements
0 less than one that gives
A1
and then this one becomes the right
argument over here with the Zero from
the left going over here
and with the lesson between them we get
a one and so this gives us the first one
in the result that we can see up here
that result there
and then we take the prefix with four
we start off with the two rightmost
elements
that gives us a0 according to our
truth table that we computed before for
lesson
this zero survives into the right
argument of the second invocation of
less than with a new zero on the left
that's the zero gives us zero that goes
into
here and we pull down the
leading zero
and zero less than zero gives zero and
so too for the last element we start off
with a zero on the right and a one on
the left
and then the result which is a zero
survives into here we have the same
situation and the zero propagates on and
on and eventually we get zero
and so we get the full result
where the first one is only one that
survives because any other one will
clash with that one when it hits it
being reduced from the right
and this is why
um less than
scan is an idiomatic expression for apls
when dealing with Boolean data and you
need to filter out so the only the first
one remains once you have some
experience with this then you stop
seeing this as a lesson reduction which
otherwise will require a lot of
reasoning why it exactly gives the
result we want and you just start
reading it as a whole
as keep the first one
in fact there are additional Boolean
scans like this that are really useful
for performing various operations but
this one is a very famous One
thank you for watchinghi
we're now going to figure out
or a set of years given as any type of
array
which years are leap years and which
years or not
leave your rules are quite involved
the rules are like this
every fourth year is a leap year
except
every 100th year
which even though it's divisible by four
is not a leap year
except if it's also divisible by 400
then
even though we just said it then it
wouldn't be because 400 if divisible by
400 it's also divisible by 100 and then
it wouldn't be a leap year then it is a
leap year nevertheless so it's an
exception to exception
and Rule
so we say
every fourth year
and then every 100th year and then every
400 is here
what we want to know is
R is the current year number that we're
dealing with divisible by
the these numbers here
we don't have an is divisible by
function in APL but we do have
a division remainder function and if
there is no remainder when you divide
then
it's divisible so let's take year 2000
for example
that was a very special one
we can see that it has no remainder for
any of these
and if we take year 1900
then
it was divisible by 104 but it wasn't
divisible by 400 and if we say 1904
then it was only divisible by four but
not by
the two larger numbers and 1905 of
course will not divisible by any of
these numbers
okay
so what we want to do here is compare
with zero zero means and that there's no
remainder and therefore it is divisible
and the rule is that if we have a one
here
then it's
um
then it is a leap year if we have a one
here then it's not a leap year unless we
also have a one here so it's a kind of
yes no yes thing
and that can actually
be expressed quite neatly using an xor
which just means this one is true or
that one's true but not both of them
so if we think about inserting a
different from that's what X1
represented as in APL
then we start from right to left
um and say well we have this one
but only if
this one is false if they're both true
then it becomes false again
and then we continue here
this has to have been true
but only if not
this one
has to be different from that so that
gives us that every time we proceed one
step to the left it's another flip as
but not if that one that gives us
exactly the exception rule
so we can do an xor
reduction that just inserts this
different from inside
the vector
and you can see that this says that 1905
is not a leap year 1904 is a leap year
1900 not a leap year and 2000
is a leap year
so this really solves the problem for a
single number
but we are told that we should handle
any array so
let's
um modify this a bit
we'll start over here
and we're going to have a an array of
these numbers 1905.
and we also had 1900 and 1904
1904.
right there and you can really let's
make them into a matrix so so this is
going to be our argument
and we want each of these to be paired
up with each one of these no matter what
the ship is over here that calls for an
outer product so
vertical style that's the outer product
which combines the axis here this one
axis with the axis over here uh two x
two x's and that gives us a
three-dimensional array
like that we can see the layers here so
this is
um
for the first one
and so this are the the remain just for
400 with each one of these so this the
entire layer
it corresponds to this Matrix that we
have over here
for 400 and for 104. 4.
that means correspondingly that which
which are the numbers that correspond to
1900 that's the top left corner of every
Matrix so the 300 and the zero and the
three are zero and for the 1904 it's the
one in the top right corner
of each one and in order to do our extra
reduction we need to go down through the
layers so that's along the first axis
the first axis enumerates the layers so
we want to go through the layers here
that means we need to switch our slash
which was the last axis reduction to a
slash bar which is first axis reduction
that gives us a matrix just like this
Matrix over here saying which years are
leap years now we all just need to make
this into a
sorry this is wrong in this missing the
the zero equal there there we go
um
this gives us a an expression but we
need to change it into a function we can
easily make this test it just by adding
um array attack here and then we can add
parenthesis around it or we could have
added an Omega and braces either way
um this tells us that the two right
column ones that's 1904 and 2000 those
are leap years but the two left column
ones 1900 and 1905 or not leap years
we could actually be even more clever
we've got here a scalar comparison and
then we've got a reduction and we could
combine these into an inner product
where the way this works then is if you
go up to
um to over here we say 0 equals
this one
different from zero equals this one
different from zero equals this one
um and so on and then we go through
um the whole array like this it's
slightly faster
um I think at least it can be slightly
faster because it allows The Interpreter
to know everything that's going on it
doesn't actually need to look at
uh first a comparison and then do the
xor it could do that total in one go if
it understands how to optimize that so
this is a quite nice way of expressing
it
but we also have a build way built-in
way of doing this there is a function a
system function called quad DT for date
time
and quantity is normally used to convert
between various formats
however and there's a special and it
uses format codes on the left
there's a special formal code which is
zero which doesn't convert to any
particular format instead it asks
whether this is a validate it's a date
time validator so all we need to do here
to test whether that date is valid is to
sort of say convert to
format zero and a normal timestamp
with year month day that is format
number negative one
so that means if we and we need to make
sure to enclose the argument so if it's
a one vector is one Element so then we
can for example say
um is the
um the 30th month and the 100th day in
that 30th month is at a validate
of course it isn't
um is the
uh January 1st is that valid
yes it is and what about in February 29
that's the one day that determines if it
exists then it's a if it doesn't exist
then it's not a leap year so in 1900
that didn't exist but what about in 1904
then it did exist
so all we need to do when we have an
array of years is to add 229 to each one
of them to make it a full date and then
we ask quad DT whether that's a validate
by converting so to say to
um
format number zero which is just
validation if we go and take our array
over here
then we can
start making a function for this let's
forget this part for now
um we want to concatenate with a
constant right argument to concatenation
and we want to do that on each one
so this gives us a matrix of these four
vectors and then we just need to say to
quantity which already handles arrays we
want to convert from the normal
timestamp
format to
validation numbers
on
all of these
and that gives us
our results from before so that's a very
neat way to write that as well
and that this works on anything and um
including on a single number because of
the each so it will go into so to say
this scalar and then the result will
still be a scalar and we have that
enclosure that we needed above so I'm
going to see that this works as well
thank you for watchingwelcome to the APL Quest
cap Wiki for details
today's Quest
is to find the mode
that's the most frequently occurring
element
let's get started with some test data
okay
there are many different approaches we
could take to finding the most common
element
however and we're just going to try a
couple this time
so one way to find the most common
element would be to remove one of each
of the unique types of elements that are
there
until there's only one of each left
that would then be the most common
element because any elements that occur
less frequently
will have been removed in the process
let's try this
the way we're going to do it is we're
going to start by writing a Lambda it or
a different little function
um and we're going to apply that to each
of the elements of D so these two dots
here that is like a mapping operation
if we have a an inside a convention that
says that Omega because the argument is
on the right Omega being the right most
letter of the Greek alphabet
Omega is a placeholder for the argument
that we're being fed or just the name of
the argument being fed
now we have a very convenient function
called unique mask or we could also call
it indicator first
it's denoted by the magnetic unequal
sign let's try running it
so for each element we get
um a mask and these are bullet masks
booleans in APL being represented with
one and zero for true and false
and it indicates for each element
whether or not that element is the first
of its kind so for the first of our
three cases here we begin with one six
one eight
and we can see we have one one zero one
indicating that the first one is the
first of its kind it's the first one
um and then the six is the first of its
kind then the second one is not the
first of its kind so we get a zero and
the eight is the first of its kind and
we can see there's a the last element
here is an eight and that gets a zero
because it's a a subsequent eight
so this is really nice this indicates
exactly one of each unique element and
if we then remove the elements indicated
by the ones here
then that's equivalent to removing one
of each element
now we have a function in APL called
replicate or compress denoted by the
Slash
and then we can it takes a mask on the
left and some data on the right and
keeps only the elements where there are
ones it actually keeps as many copies
of each element as there as indicated on
the left but since the left is Boolean
it will either keep it or discard it
so we can see this keeps exactly one of
each
but
and and the first one of each but we
don't want to keep the first of each we
want to remove the first of each so we
want to flip it around the ones that are
indicated with ones here we want to
discard the ones are indicated with zero
we want to
um to keep so we use Boolean negation
the tilde is Boolean the gate
and this
keeps exactly one of each so we can see
we uh sorry this removes exactly one of
each so we can see that there are no
more nines left in the first case
because there was only one in it got
removed same thing with the six and the
zero and that gives us actually our
result for the first test case one three
and eight are there
um
and most frequently occurring elements
occurring two times each in the second
test case
we can see that we removed the seven
and we kept the 281 but there are more
eights and two is one because we only
removed one of each she would have to
repeat this operation
and this that's the case because you
removed three four and five and one of
the two ones so then there's one left
and that's our result so we actually
have to apply this function
um multiple times
and we can use the power operator and
this is in traditional mathematics
written to a superscript number on the
function name and applying it that many
times but APL is all inlined so we write
it with this star there is this and a
number so we can apply it twice
and again on each of these and that is
good for the middle test case but
destroys the first and last test case
because there's only one of each and
left and we're removing one of each
there's nothing left after that and
we're still not even done with a middle
test case because there are now two
eight eight and only one two the modes
being eight the most common element here
and so we have to apply it three times
and that doesn't change anything for the
first and last they're already empty but
the middle one you get the result so
we don't want to apply this function
a fixed number of times we want to apply
it
um
a custom number of times when it depends
on where have we gotten so far
actually what we can do is we can apply
If instead of applying a fixed number of
times we could actually apply it kind of
like an infinite number of times what
actually happens is
if we give a function on the right of
the star diocese instead of a number
then that function will be applied
between meaning taking as arguments to
subsequent
iteration values from applying this
function over and over again and it will
keep doing so until the result is stable
that is until two subsequent values are
fulfill this condition that we give it
so the normal thing to do is to use
equality or
um
um equivalence as in this case so we're
saying keep doing this until the result
is stable and if we do that we get empty
all together
um empty list because we keep doing it
the only time that we keep removing one
of each occurring element and the only
time that becomes stable is when there
are no more elements
so how can we modify a function such
that it stabilizes when there's only one
left of each
before we get to that let's move things
around a little bit in our function we
have a parenthesize expression on the
left and we have just a value on the
right
APL functions have long write scope that
means they take a right argument as much
as they can going to the right until
they get stopped by either the end of
the expression or the end of a
parenthesis or bracket and so on
and so we can get rid of this
parenthesis on the left if we had a
function that was just like slash just
like replicate except it took the mask
on the right and the values on the left
now there isn't such a built-in in APL
but we can easily construct it
if we put this to there is this looks
like a frown because they're confused
about which side is right and which side
is left that modifies the replicate so
that it takes the uh the arguments in
opposite positions that is the mask on
the right and again we have long right
scope so everything on the right
of this derived function
um is its right argument
and then we take the value on the left
and of course this gives us the same
result but it makes it easier to
manipulate this mask
now let's say we put
instead of having
um
this mask which varies by what exactly
we have if we just had all ones then
nothing would change
we can actually use a single one and it
would work as well then it stabilizes
immediately because we're not changing
anything
so we want this mask
in the general case but we want a mask
of all ones or a single one for that
sake
um in the case where
there's only one exactly one of each
element
so how can we do that
well we have this mask here
oops
we have this mask and here indicating we
should get rid of this stabilizing or
we'll go to infinite Loop
um
indicating which elements are the first
of each
and we want to find out whether and
every element is
it's the first of its type and that's
very simple we just need to check if
it's all true
how do we check if it's Ultra in APL we
use a reduction we just need to reduce
with and
and so and we use slash again this with
a function on the left it means
reduction and this is logical end so we
just say this one and this one and this
one this one if there any zeros we get a
zero but if all of them are one then we
get one
so we want to combine this mask
with our previous mask
so that if this one is
a single one
then it forces this Max to become all
ones
and if it's zero
then it doesn't make a difference
and we can do that with an or
so
if you have
ones and zeros over here or one
then we get all ones and if we have some
ones and zeros over here and we have
zero here then it doesn't make a
difference because
false and something gives that
something
and so this is the mesh that we
um that we want we can try running it
and then we can
um we can try to use it to compress the
argument
and now if we apply this two times
we can see that this did not empty out
the first and last element so we can run
it as many times as we want and now it
stabilizes
so we can also say let's run this until
it's stable
and this actually solves the problem or
at least almost solves the problem
um because there's one issue here if we
look at
the original test cases
here we have first one and then the six
goes away another one here then eight
and then three
problem was that our result has three
then eight why is that
that's because we removed the first
occurrence of each element so the first
one goes away we keep this one that's
fine the first eight goes away the
second eight it remains at the very end
and the threes are next to each other so
we end up having three before eight and
we really want to preserve the original
order
how can we fix this
well see
this indicates the first element
of every type
if we reverse it then so this is a
reversal function remove and this
reverses the argument before we get
indicate the first of each
now we're going to indicate the last of
each but count it from their ear and we
really want to keep it from the front so
we can reverse the result of that mask
as well
and now we get the correct order and
this is a proper solution
albeit a little bit inefficient because
we are Computing this unique mask twice
so let's give it a name instead
like this and now we can use this over
here
and the flow again is from the right
so we compute everything from the right
reverse unique mask reverse again stick
that into M negate it do an or with and
then we compute this because it has
parenthesis around it
we can beautify this a little bit by
applying uh some laws of
of logic
but always a little bit hard to reason
about so because we want this to be true
or not this
let's change the or into an and using
the Morgan's laws so we can express and
or in terms of each other by negating
the arguments and negating the result so
we change it into an end here negate the
right argument negate the left argument
and negate the result as well
so this knot takes everything on its
right as its argument
okay clearly we can remove these two
this is just negation of negation
and so and here we have
not what's on the left
with yes and yes what's on the right now
booleans remember in APL are just zeros
and ones which means we can treat them
either as numbers or as booleans
whenever we want they are one and the
same
so
if we have a 1 on the right
and we have to have a zero on the left
because we want not this one that and
those are the only values for which we
get true that just means that the right
argument over here has to be greater
than the left argument so we can change
this to a less than
and now we have a negation of the result
of a less than well what's the opposite
of less than if it's not less than then
it's got to be greater than or equal to
so we can put everything together in a
very nice solution to the problem it's
iterative
but it's pretty elegant it's not the
most efficient way to do it and we're
reversing every time we could start off
by reversing and then at the very end
and finish up by reversing again instead
of reversing every time around the loop
but it this is my elegant
okay let's do a a better approach
again we'll start with mapping this
Lambda over the test cases
and here
um
we are going to use a special high order
function called key which is extremely
useful for and our purpose it takes it
takes a function on the left so we can
give it a little Lambda on the left and
then it derives together a new function
that's then applied to our argument on
the right
let's look at what it does how can we
look at what it does we just give it a
um it's kind of a dummy Lambda that just
returns a two element list of left and
right argument to see what are the
arguments that we're given
and key returns us as left argument uh
two so four it returns here a matrix and
each row of the Matrix corresponds to
one unique element of
the right recording by the way the
unique elements we can compute
like this
so you can see the unique elements are
one six eight zero three nine as we know
and we can see the corresponding numbers
one six eight zero three nine in the
leftmost table and then on the right it
tells us the indices
where these values occur so we had a one
at positions one and three and a six at
position two and the eight at positions
four and nine and so on we're not
actually interested in the positions
that they're at
however we are interested in how many
there are because we want to find out
and
which ones there are most of
so we can return
the count of the arguments together with
of the count of the red argument
together with the left argument which is
the unique value
so we can see that there's for the value
1 there are two for the value six there
are one and so on
and we don't actually need the value
itself we just need the count
so here it counts per unique element in
the order of their appearance
we want to find out which elements which
unique elements occur the most often
so we can find out what this number is
so we can see that the highest number of
currencies of a single element in the
first test case is two and then four
then two
we want to find out which elements
appear that often so over here we got
the counts let's call that c and we just
need to know which counts are equal to
the maximum now what's going on with the
maximum here is again a reduction like
we did the end reduction before but this
time we're reducing with the max
function which is a function that given
two arguments one in each side just
Returns the larger of them you can kind
of see the symbol showing a vertical bar
um and then
horizontal bar at the top indicating
we're wanting the top of the two values
so now we have a Boolean mask indicating
elements unique elements that
appear the most often
and we can use this we'll replicate that
we had from before so this is just a
mask and but not on the argument itself
rather on the unique elements of the
argument
so this gives us the modes and directly
again there's a bit of inefficiency here
because
we're Computing the unique values here
and then when key operates on the
argument it has to compute the unique
values as well
internally in order to be able to figure
out well how many there are in our case
so how can we fix this well remember the
key returns both the indices and in our
case we want the counts and the unique
values themselves so we just need to
mangle out this resulting array in such
a way that we can
get both the unique values and the
counts out
so here the unique values and the counts
in The Matrix for each test case
and what you want to do is we want to
combine these values here into a list of
and
of unique values and we want to combine
these values in here into a list of
counts
and so what we need to do is a vertical
concatenation so we're concatenating
this column together and concatenating
this column together
concatenation in April
is the comma and then we've used
reduction before but that was horizontal
reduction now we're going to use
vertical reduction which is the slash
with an extra bar
so we can see that we transform these
matrices into the individual column
vectors and now we can give them names
so the left one we're going to call the
values and the right one we're going to
call the count
we assign them here we use diamonds to
separate statements because diamonds are
Unbreakable
and now
we have we need to know where the counts
are equal to the maximum
of the count
that's the same mask as we had before
and then we can use that to compress
swapping the arguments of compress and
not not the right argument we need to
compress the the unique values
right there
and that's a very nice solution
but we can actually take this a little
bit further and if we look at this red
expression
let's think of it as a function in terms
of v and C
so what we've got here is
let's put this into braces as a little
Lambda so we got we got C on the right
we got a v on the left
and then we can use just like over here
we used Omega last letter of the Greek
alphabet and Alpha the first or left
most letter of the alphabet for the left
and right argument so we can do that
over here as well V is on the left
and C is on the right
now this might seem just unnecessarily
verbose and it still works
however notice this we have this little
function in between V and C
and on the left we have V and c as a
pair we just need to insert
this function
between V and C and inserting a function
between that's really what a reduction
does
oh but notice the extra boxes
that's because reduction needs to reduce
the rank of the argument
VC that's a list it is a vector it has
rank one it has one dimension and the
result we want and we get from that
needs to be a scalar but actually we get
a list of values which is a vector so
how do we have a vector which is a
scalar we enclose it in a scalar
encapsulation but we don't want that so
we just extract it with this close this
opens up
that enclosure
and now we can see we have VC and we are
playing something to it
this function the derived function which
is our little Lambda together with the
reduction takes as a right argument this
list of VC and VC is exactly what we get
over here
so we can just take this expression
because everything flows from the right
to the left like this we just apply that
on the left and we get a very elegant
solution
there's one more thing that I'd like to
do
and that is
this little
Lambda over here we can actually
simplify a little bit by using tacit or
0.3
and programming
we have the left argument concatenated
to the tally of the right argument
and that is something we can use a
function composition for
so
let's say we have 10 and 20 and we want
to concatenate 10.
to the negation of 20.
so this is a type of concatenation but
we want to pre-process the right
argument with
negation and there's a combinator for
that we call it beside because
it is as if the comma and the minus are
next to each other beside each other
and this makes a new function
which we can apply
and so too
if we had on the left a value and on the
right a list
then we can concatenate with the tally
note that this looks like a Telemark
and we can just insert that
into our expression here instead
so we concatenate with the tally and we
don't need to mention the arguments at
all
I think that's pretty elegant
thank you for watchingwelcome to the API Quest cap Wiki for
details
today's problem is the last from the
2015 round of the APL problem solving
competition
we are to generate Pascal's triangle
which is pretty simple but the catch
here is that we wanted to also look nice
for human readers and a triangle doesn't
fit nicely into a rectangular array so
instead of having it numeric as Pascal's
struggle consists of numbers we are to
create a character Matrix where the
lines are approximately centered
there are two steps to this problem the
first is generating the data and then
they're centering the lines so let's
split it into those two parts
Pascal's triangle has a classic
elegant solution
it is simply the binomial coefficients
an outer product on all the numbers from
0 to n
there's a problem though with this
triangle it's sideways and it's padded
with these zeros
we can do something about that of course
but it makes it a little bit less
elegant so first we transpose it and
that gives us the rows at least as as
rows
and then we need to remove the zeros
so
on each and row that is on each sub
array of Frank one we want to be without
zeros
but the problem is that we want to pad
again with zeros if we try to apply this
just like this
so that didn't get us anywhere therefore
we must immediately format it as a
character array and now the padding will
instead be done with spaces
and this gives us
um the first and flat approach to
creating
the data that we want and the next part
is then
to align the rows so that to be centered
and we'll come back to that
another approach is a nested one
we start off the same way by generating
all these indices
but instead of doing an auto product we
kind of doing half an hour product
so again we want the same indices up to
whichever end that we are at now
combined with that
number
and that gives us kind of a triangle
with each row getting longer and longer
and then since we're going to deal with
character data and have it equip the the
nested equivalent of the previously
previous shown flat result when we're
going to format each one looks the same
but these are actually character vectors
and this we can call n because it's the
nested solution
we can also
um avoid repeating ourselves we have
here zero comma Iota and we have over
here zero comma Yota so we could uh say
this is kind of like an inclusive
um Iota in here
and then we can use that name over here
it's it comes out and it represented
exactly the same but just the way of
stating it is a little bit shorter
and now uh that we have the data let's
look at actually centering it so let's
go back first to our flat Matrix
with the training spaces
so one strategy for centering it is
looking at how many training spaces are
there there are four in this line and
there are six on this line so if we take
half of those on each line and then
rotate the entire row so we'll remove
the training less training spaces and
put them at the front we'll do and here
we we have six we're removing the
training three we put it in the front
then we end up having something that
looks centered
how can we do this well we need to count
how many training spaces there are
if we make a Boolean Matrix of where we
have spaces
and then make sure that it is we do that
in the reverse so now it becomes leading
spaces we can do end reductions on each
line
to see to isolate the leading spaces
which are actually the training spaces
and then we can sum that to see how many
leading that is Trading Spaces they are
and then we want only half of that
so these are how many steps to rotate
um it could be that the number is is odd
not a number of spaces on and therefore
we get a half so to be safe let's just
round this off and the problem
specification also says that can be one
more or less so it's not important how
exactly we round it up or down
there's definitely no reason to run off
to closest because it's always going to
be a whole number or a half
okay so and now we want to rotate this
many steps but rotation the normal
rotation API rotates from the front to
the rear
but we need to rotate from the rear to
the front so we need to negate this
and then if we give a name or an
argument namely to the The Matrix that
we're operating on then we can simply do
a horizontal rotate using these values
as the rotation amount and that gives us
our
centered Matrix
so this is rotation using the flat and
this is the whole thing is one large
atop where the right function right time
is this F generator function that we
created before and then the left chain
is this in a centering thing and we can
even see this classic approach
um the ID is highlighting this to be an
a dialogue idiom which means it doesn't
actually go through each of these three
operations
um instead it recognizes this as a whole
idiomatic expression and computes the
trailing space spaces directly for some
extra performance benefit
foreign
we instead started with the the nested
array
now here aren't any spaces that we can
that we can count and operate on but we
can look at the length and remember that
these are character vectors so if we get
the length of each one of them then we
have those here
you can see that even though it's only
two numbers it's like three because
there's a space in between as well
and so
um what we want to do here is we we want
to rotate
around on the whole Matrix and we can
create the Matrix the flat Matrix simply
by mixing
so here we have it with the spaces so
we're still going to rotate but we're
going to compute the amount of rotation
based on the nested representation of it
so we have the length of each
and then on the length of each how much
do we need to rotate well the full width
is the length of the last one
and all the lengths are
it's just the same thing that's the
argument here
and we want half of the difference
between them to be the amount that we
rotate with
so this is the the length and this is
the length of the longest one and this
gives us these negative numbers
and I've done it negatively like this of
course we could we could if you subtract
the other way around we get the
corresponding positive numbers but since
we're going to do a negative rotation
amount we might as well just keep it
negative from the beginning
and then we divide that by two as before
and we can round it off again it doesn't
really matter how we we round it so this
is the amount of rotation that we need
to do on each one
and then and we use this to rotate but
not the argument itself because that's
nested we want to rotate the mix of the
argument
and then since this is a uh yeah so then
we have in the top over here and then we
just need to to
swapped arguments over here
we have it here and this is in the top
two pieces we can use the top operator
here because the left function is
complex
but ins since this is the post
processing on the result of the tally of
each it could also be the pre-processing
of the swapped and rotation so we can
replace this with a job over here and it
would be the same thing
so this is a way of using rotation with
a nested representation again at the top
this is the centering function and this
is the generation generating function
so now we used rotation but we can also
use a take so take has this interesting
thing that you can what I sometimes call
overtake so let's say we have ABC
if we take the nest five elements from
that
then that pads us with
two spaces at the beginning and we can
use this to our advantage
um if and the same as it goes if we take
from the beginning and then we get
training spaces right here
so for this to work we can't already
have the more all the rows be the same
length in the flat representation so we
have to use the nested representation
and now and we are going to start off
the same way we get the length of
of each one
and then we need to compute what is the
length that we want to take from the
rear of each one which is going to be
the next it already has plus half half
of the difference between the longest
one and the current one
that's going to add half of those
potential spaces on the left okay so
let's state that
the current length Plus
half of the difference between the
longest one which is the same thing as
the last one
um minus the current length
so these are the lengths that we need to
take from each one
of course this needs to be negative
and then we need to make sure that we
don't have any halves so we can round
that up as well
and then the only thing that's missing
is that we take
from each one with this amount
um and these are the nested things so
now we have padded them with leading
spaces so that they will fit each other
and then we can just mix and we get the
character Matrix that we're looking for
however we can simplify this quite a bit
actually
if we think about it
then we have the amount itself
Plus
half of the difference between
this constant value so to say the last
one
and the amount itself
in other words we
are here
um
removing
from the part that we are
adding
which means that we can also see this as
half of
the last element the longest one
plus only half of the value itself
because we're adding the whole thing
and then we're subtracting half of it
so then what we can do is just
add have to begin with
and not
add a whole one and subtract the half
one
and we can keep going
we are here negating
this half
will be include so to say this this sign
change in the division which is the type
of multiplication so if we divide by
negative 2 instead that's the same thing
but another way we could do it since we
only think we need to affect is a sign
change
then instead of adding so to say these
lengths we can add their negation
instead of adding
the last one we can subtract the last
one so that affects also a sign change
um on the whole thing
and we get the same result
and this is another very nice way of
of creating our Matrix
so we can call this
um the
the overtake
so it uses take on the nested
representation again and the top this
time we have a different on the left and
then our original generating function on
the right
okay so how do they compare to each
other well there's not really any other
limit to what we can do here but let's
increase the print Precision to the
maximum that our 64-bit floats will
allow and then we can do triangles up to
say order 50 or so
copy in cmpx from the defense workspace
and let's try everything for ends up to
50.
we can stick a zero in front as well
and then we want to compare
um this was the rotation using the flat
on each and we want the rotation using
the nested on each
and then we wanted to have the using
take on the nested
oh so we can see that the nested
approaches here are
well approximately half the runtime of
the flat approach and that's exactly
what we predicted to begin with because
we are generating only half the triangle
slightly more than half the triangle
because we need a diagonal
um and that is the overwhelming amount
of computations then two here and we are
using just slightly over half of the
runtime in the rest of the approach so
even though it's a good rule of thumb
that when you're doing APL you want to
stay flat you have to also recognize
when is flat actually flat in this case
we were processing each row separately
and that really negates all the benefit
of staying flat
thank you for watchinghi now we're going to be given a square
Matrix and we have to check whether it's
magic magic means that all its row and
column sums and the diagonal anti-
diagonal sums are the
same I've predefined a collection of
matrices the first one is trivially
Magic there's only one number so
whichever we sum it we get the same
number second one we can check that it's
magic 4 + 9 + 2 is 15 3 + 5 + 7 is 15
even diagonal 4 5 6 is 15 and so on the
third one is easy to see it's not magic
plus 1 + 2 is three but 3 + 4 is not
three so that one is out and for the
same reason we can see the last one um
we keep having increasing sums both
vertically and horizontally so can't be
magic either so first two are valid
magic ones and the second two uh are
not let's apply a Lambda on each one of
these we refer to the argument as
Omega and instead of trying to do all
the summing we'll stack together
everything we need to sum and do all the
summing in one go so here's the argument
concatenated with its diagonal how do we
find the diagonal well if we Traverse
the array and in order but every time we
go to the right we also go one step
down then we find the
diagonal effectively if we map both axes
of this uh Matrix to a single axis so
that we force walking along both axis at
the same time then we get the diagonal
and therefore we can do this with a
transpose the generalized diic transpose
Maps AIS to different locations and if
we map both X's to uh the first
one then we get the
diagonal so here we have the 456 it's
been concatenated on the
right next up uh we want to do the
summation of um the rows but since we're
going to sum vertically then we just
need to transpose the argument
to so that when we are going to sum here
4 92 that actually corresponds to the
original
row
and finally we want the an diagonal
which we can get by flipping the uh The
Matrix horizontally and then taking
diagonal so we can flip it
horizontally using the uh reverse
function so we can see that we got 294
instead of 492 and then we take the
diagonal just like
before so this gives us all the columns
that we need to sum so we do a plus
inserted
vertically and the only thing that
remains is to check whether all the
elements are the same so we can find the
unique elements and then count them and
then check if that's equal to
one so this is a very straightforward
translation of the problem statement to
um
APL but there's
some duplication of code we could say
this something seems very redundant we
we taking the diagonal here and we're
taking the diagonal over here and
flipping things around it's actually uh
a way to compress this a bit which is
rather neat so let's try
that let's start off by and combining
the
transpose
and the flipped
horizontally version of the um array
because if we if we think about
it this reversal
here allows us to take the diagonal if
we do a
transpose then it doesn't matter for the
diagonal diagonal stays the same so if
on each of these two we take the
diagonal that gives us the two diagonals
and if on each of these
two
and
we take the um the sum then if we mirror
it horizontally then this the vertical
sums are just in a different order but
it's still the same vertical sums and
the vertical sums of the transpose that
gives us the horizontal sums so all we
need to do is do all the combinations of
uh
transposing um sorry of of taking the
diagonal and taking the vertical sums
with the Trans uh combined with the
transposing and the mirroring in order
to get all the four different
combinations that we want so we're going
to uh combine these and we're going to
take the the union of them because we
need to get that final set of how many
different sums are
there um we need to be careful not to
have any duplicates uh because they
would persist in the Union uh but before
we take the union of course we have to
actually find the sums so we pre-process
the argument to the union with a little
function an inner
function and that function is going to
be taking the
diagonal and we concatenating that
to the array
itself and once we've got that that
means we've got one more column which
consists of the diagonal and then we can
do the vertical sum and take the unique
of that it's important that we both take
the unique here and take the union over
here because if we didn't take the
unique and there were multiple on the
left multiple sums they would persist to
the end um but they could
be all the same even though they're
multiple right because if our array is
larger than just a 1 by one there will
be multiple sums um actually even if it
wasn't because we had
both the diagonal and the r sub so
always have two but this will make sure
that in the case where it is Magic in
this halfway respect we only get a
single element and then we get if it's
magic we get a single element from the
left and the single element from the
right and then the union of them will
either be a single element or not if
they don't uh match um in case there are
any uh other elements than any other
sums then it doesn't matter where they
appear here we'll always have something
that has length more than uh than one
because the union will not be able to
take away any duplicates from
here
so this gives us um all the different
sums and then Remains the thing that we
did before of 1 equal to uh the count of
that but since we're doing things tested
here we we still want the diadic the two
argument form of equality but we want to
pre-process the right argument with the
counting with the
tally so this is a very neat compressed
solution without any duplication going
on thank you for watchingwelcome to the apl quest capl wiki for
details
today's quest is the 9th from the 2014
round of the apl problem solving
competition
we are computing how far an object
reaches
based on
the angle at which it is
thrown
and
how fast it is being thrown
now that doesn't actually matter because
we are given
the formula
ready to use all we need to do is
translate that into apl
so the distance
is well we use 9.8 we're given as the
gravitational constant so we need to
divide by that eventually it's the
square of the
velocity
times
the sine of
2 times and then we need the angle but
it needs to be in uh in red the ends for
sine to work correctly and we're giving
it in degrees so we just need to
translate that so we multiply by pi
and
divide by 180
now and we can simplify this a little
bit i like to get rid of parentheses and
multiplying by a square of a number same
thing as multiplying by that number
itself we're multiplying by two over
here
um so and we're dividing by 180 and
there's no we need to do both we can
just divide by 90 instead
that makes it look kind of nice with the
two circles
some test
velocities and some test angles
this doesn't give us quite zero for the
90 degrees angle
but that's due to floating point
inaccuracies of course if you throw
something straight up then it comes
straight down and it didn't move from
the origin at all
so this is very simple
to spice this up somebody came up with a
challenge of doing this without the
circle function we're using circle
function twice here for the sine one
circle and for multiplying by pi just
magnetic circle
and it's a bit more of a challenge to do
it without circle
but
we have some ways we can do this
first let's do the sign
so we can use a taylor series
for the sine function
that's
the alternating
and sum
and then we start off with the odd
numbers
we don't even need very many terms
before we get a very accurate result
and then on those
odd numbers
we
raise
the
argument
to those odd numbers
and divide them by
the factorial of those odd numbers
and then and alternating some of that
should give us a correct result
let's try this out
and compare with
the native
sign
that looks very accurate indeed
okay so we've solved that part
now as for um
pi
so if i we could start with earnest
identity
that's in the apl
0 is equal to
1 plus and then we need e to the power
of that's the exponent just magnetic
power and then
pi times the imaginary
unit so this holds and we need to break
out the circle from here so to say well
let's start by
removing that so subtracting one on both
sides of the equality
and then we can we have a
e to the power of
uh so we can change that by removing we
can get rid of that by taking um the
logarithm on both sides so that cancel
each other out
and we just need to take the logarithm
on the left
and now we have
i times
the imaginary unit so if we multiply by
imaginary unit again then we get
negative one
and then we can multiply by that over
here
and then we just need to negate
and we can for example do that by
negating this over here so now we've
broken out pi and that means we can just
assign
this
and
you might consider this a bit of
cheating because
the building constant pi is of course
hidden inside this formula inside the
whole arithmetic implementation of uh
logarithmic negative numbers and and
dealing with complex numbers
so how about using a series instead and
then we have some might have a series
and the very simplest of those
is not very accurate but it's very
simple
it computes a quarter of pi so multiply
by uh by four it's the alternating sum
simply of the reciprocals of negative
numbers
beginning with one
and even if we take say a thousand of
those
it doesn't give a very good result i
mean it looks kind of okay but if we
compare it with
the actual value of pi you can see that
it's it's quite a bit off
there's a a little bit more complicated
formula which gives is much better
converges much faster
and and and here we are computing
pi
divided by the square root of 12 so we
start off by uh
taking multiplying by the square root of
12 to get actual pi
again it is an alternating sum of
reciprocals
this time we have to start with 0
and then we just do
natural numbers and 100 is actually
enough even much less than that would be
enough
rage one of these we take three and
raise it to
that power
and multiply it by
the incremented
two times that number now two times in
this number same thing as
adding it to itself
so this is one plus two times okay
and then
times three to the power of k
and this looks really good
if we
compare it to the number
let's build in
then it says it's equal
and if we try to subtract them to see
what is the actual difference
within the floating point accuracy that
we that we have here 64-bit floats then
they're actually equal so that's that's
very nice now we have signed that and
that means that we could um
substitute these into
our formula
so
9.8
divided by alpha times alpha times the
sine
m of
pi times the argument divided by 90.
of course we could compute that constant
of pi divided by 90 but it doesn't
really matter
and then we can try we need to use um an
each here because
and we're using a series
computation
oh well this was the wrong one this is
deep it doesn't matter and then e is the
is the new one
and we can see that we get pretty good
values um
for
the numbers that are
zero or far away from zero and a good
enough value
um
even for the one that's supposed to be
zero
thank you for watchingwelcome to the apl quest see apl wiki
for details
today's quest is the ninth from the 2015
round of the apl problem solving
competition
we're giving a word
which is a character vector
and we are to swap interior letters two
and two so the first and last letter
always stays in place
the second the third gets swapped around
and then the fourth and fifth gets swept
swapped around
if there's a final interior letter which
doesn't have a companion letter next to
it
to pair up with then that just stays in
place
and there are a few different approaches
we can take to this
here are some simple test cases
i'm
going to uppercase
the letters that are go they have to
stay in place the casing doesn't have
any significance it's just for us to be
able to see easier if things are
happening the way they're supposed to
and then so here
oh
actually i wanted this one to be like
this um here we have two fundamental
letters that stay in place
let's also make sure that
a single letter case works it's easy to
end up writing code where that doesn't
work where like you strip off the first
and last letter and then you put them
back together again the first last is
actually the same letter
and then the two-letter case where
nothing is moving around
okay the first approach we're going to
do is quite literally
pairing up and flipping around and
putting back together again we're going
to use the petitioning clause for this
and so what we want is
that
the first letter becomes a
section by itself and the next two
letters and the next two letters and so
on and then finally one or two single
letter sections at the end
we can do that by taking the length of
the argument and using that to reshape
zero and one
one at one zero that's because we want
the first one here for the intermediate
part to be on the first of the two
letters in this pair over here
once we got that we just need to adjust
so that we have an initial one and
always a
a final one and this corresponds to the
f and that will just stay in place
because it's a one element partition
so we put an
1
at position 1 and also at the position
the length of
the argument
we could also
give this a name
but it doesn't really save anything
okay this is our position vector
and
then we use that for the position in
close on the argument
flip each section and the one element
section stay as they are when flipped
and then join them back together again
within list
and that's our petitioned enclosed based
solution
here's a trick you can do when you want
to generate alternating sequences of
zeros and ones um then you can
start off with all ones and do an xor
scan on that or for the opposite effect
start with all zeros and do an x nor
scan of that what does that look like
well let's say that we have
some letters
and we want to generate this alternating
sequence so first for all zeros
what we can do is we do a zero constant
for each
but a code golf trick is to do a self
and
or we can do a a uh one constant you
should get all ones
so the code golf trick is to use a
comparison with itself
so here all these uh
characters when
we ask which one is different from the
cells that would give us more zeros and
if we ask which ones are equal to
themselves that would give us all ones
and then and
xor for
booleans is the same thing as different
from we do a scan
then that will give us the alternating
one zero one zero and if we flip things
around so we start off with the zeros
and then we do x north scan on it we get
zero one 0 1 which is what we wanted
in this case
so we can take this
and stick into our solution over here to
get 0 1 0 1
and then we just have to use the single
instance of the count over here
and this would also work
but
it's
computation for no particular reason and
it obscures matters but it is a trick
you might see sometimes
okay the next approach is going to be
using stencil because stencil can
traverse an array and chunk it up in
pieces which is exactly what we want
here
classically you'll see
a stencil with a window size of our
stencil size of 3 and a step size of 1
which is the default
but we can actually set what the step
size is going to be and we allowed any
window size as well
so
we can start off with the stencil and
then we need a matrix the first row
specifies
the size of the window in each dimension
here's only one dimension and that's
going to be two and the second row
specifies the step size here we don't
want
an overlord an overlap between these as
we would have in a
pairwise reduction
we want to use every element exactly
once
so
we're going to
use a step size of 2 as well so we
overlap with
so have no overlap between them
and this is going to be on the argument
and for now let's just use the simplest
operand which is the enclosed
neighborhood and that oops using the
wrong characters here
and then we can see that we're getting
pairwise and elements but this isn't
quite right because we are
pairing up the first element with the
second element whereas we want the
second and the third so we can offset
this so to say by sticking a space at
the front and then we can remove the
space later
now that's done
and we can see that
we have these pairs correctly
but there's an issue where we're
including the last element as well
um and then the second to last one so we
can get rid of it temporarily by
dropping one from the end and we can
just remember to put it back at the
front when we're done let's put it back
at the end when we're done
now removing that also removes the
second to last one
which is a bit of an issue because
and
the stencil if you cannot create a whole
neighborhood you will just drop trailing
elements called shards
but we can fix this by putting a space
at the end as well
and now we get it there and so other
than the spaces
ignoring those for a moment if we
if we reverse every
little window here then we get the
result that we want we just need to
remove spaces and join everything
together
however we've got a vector of vectors
for each one of these and we don't
really need to do this enclosure if we
don't do that then things get mixed we
get a
a collection of vectors that is a matrix
and then
this little function
just chooses its right argument so we
can just put a right tech instead of
that
now we need to reverse the left and
right and we don't care about these and
then we talk at the end at the beginning
because the space isn't going to be
counted so it's safe to reverse
everything
and then we need to ravel it
to get it back here and the only thing
that's wrong now is that the spaces are
there we'll have to remove those and we
have to add the last element as well
so one way to remove spaces is with
without
another clever way to do it is using
intersection
because there are no spaces in the word
and so the only letters that are kept
are the ones that are already there and
that's exactly what the intersection is
doing finally and we just need to add
the last element
from the argument
to the end
and that gives us our result so this is
a distinction stencil based
approach as well
next we are going to try to do an
in-place reordering of elements
so we can use the add operator to change
things
in the positions where they already are
let's try that
for that we need to
get the indices of
the
the medial elements and then we're going
to manipulate those with the left
operand of that operator so let's start
with this
so here's the count of elements
and we need to
drop the first and the last so we need
two less than
than that
or we could subtract 2 for that sake
and then we need to subtract one more
if
we are going to
um
if we have an odd number of elements
because we don't want this uh this f
over here to
to be included in medial elements that
are going to be flipped around so
we can we can add one more
if the length is odd
and now there's a problem uh short words
will end up with negative numbers and
that's not good so we need to make sure
that we have
no less than zero
and then we can generate the range for
that
of course this doesn't start at the
right position because we want to start
with the second element so we'll
increment it
right this gives us the indices of the
elements that we want to operate on
and we can be a little bit
clever over here look at this we are
having the the length twice and we got a
number two twice we should be able to
put this together to become a neat
little train so if you put the length on
uh left
and two on the right
then we want
the length
that be the right argument
minus
the 2
that's the left argument
plus
well that's exactly the remainder
between two and the left and the next on
the right and we've got the length on
the right and we've got two on the left
so that's the remainder
you see the symmetry
well it's this is plus so we can move
the terms around as we want and
i think this looks a whole lot cooler
okay these are the indices that we want
to operate on
now what are we going to do with them in
order to flip every other one we can
reshape them into a two column table
and then
swap the two columns
these are all the elements
two columns
and then
half
of the number of elements
would be the number of
and of course this gives us a matrix so
when we're done
we need to
revel them again so so far there's going
to be no change the only thing we need
to do now is just flip the table right
left
that's it we're done
that's the stencil-based approach
sorry that's the
add-based approach
reversal
but if we think about it
all we're doing here is reordering
elements
so
really the result is a permutation of
the argument
it should be possible to build
this permutation vector
from the ground up and then just use
indexing to permute
indeed
let's try that
so
if we think about it
we start off with the first element
and then we want to get to the third
element
and then the second
and then the fourth
sorry the fifth
and then the fourth
okay
so the first
then
the third
then the second
then the fifth
then the fourth
what are the distances between these
ah
we can see the beginning of a pattern
here if we were to continue
then and we would want
after the we've used up the the fifth
here you want the seventh
and then the sixth
oh now we can see the pattern
okay so we want
the distance from one index to the next
one is alternating the negative one
three negative one three negative one
three
right
and then at the very end
we are going to have either the last
element
or
uh the two last elements
right that's two and one is the distance
here
so we should be able to
create these
distances
and then
the
then we can because this is just a
cyclic reshape
and then the opposite of doing the
pairwise difference is the running sum
and this will allow us to get go back
again to these numbers that we had here
possibly offset by a little bit
so let's try to do that
we can start off actually in the same
way because we already
have written the computation
of
uh how many intermedia how many media
letters there are that was
this formula
and then we need to reshape this vector
three negative one
and at the very end we wanted adjacent
differences of
two and one although there might only be
it might just be the two and not the one
but let's just put it there for now
and then we can do the running sum on
that
so this gives us
numbers that we're looking for the
indices up here
just the one at the beginning is missing
so let's put the one there
now we might have too many elements
because we always add two and one at the
end
so we could selectively add the one
by looking at the parity whether or not
we need to include it
but
since we already have the length here
we can also just take the length
from these and that will shorten it down
when necessary
that's our permutation vector
let's use it for indexing
and we get the results we want it's a
nice flat solution
but it is pretty verbose
another approach to this
would be if we can just get some numbers
that have their relative
sizes such that if we
were to try to sort them we would need
indices that would put them into this
order then we can use grade to create
the permutation vector because grade
always creates a permutation vector
so let's try that we start off the same
way
get rid of the last one
but now we'll add that at the end
because the last one always goes at the
end
so this is the length up until
before the last
element
and now a common trick in uh array
programming is using negative one to the
power of
because that with
uh with indices gives us alternating
negative ones and ones
how's this useful
well let's look at the indices
themselves and put these
and alternating negative ones and ones
next to each other
so for now i'm going to just stack them
on top of each other by mixing the
concentration of enclosures
and now we can see if this is an
adjustment value and we adjust one down
to
zero by subtracting one we adjust two up
to three
three adjusted down to two so that
effectively flips these two next one is
four adjusted up to five and five
adjusted down to four
so if you just sum these up
then we get these values
that are very close to
what we want
in fact in fact
all we need to do
is adding the value and at the end and
then we grading this so grading it
gives us the one here
and then we can put the n at the end
and that's our permutation vector
so now we can take
index with this
and we get our result
but
we could possibly also
note that
all the grade did because we already had
the right values here was change the
zero into a one
so maybe we could do that as well
so we just want to place a one
at one
on this
nope that's not working
what's the
problem the problem is that
in the case where
there aren't any elements that are that
we need to to deal with so if we go back
to
to this then we have
an empty here
and that's not going to work
we could do some clever trick about
assigning to a one take of that but it's
going to become very
complicated so let's leave it at that
with the grade
okay we've got a bunch of different
solutions let's compare them to each
other let's generate a bunch of random
words
so that we can time them against each
other
we've got the alphabet
we want some random letters there are 26
letters in the alphabet and we want
between 1 and 10 letters say
in each word
and how many words do we want let's take
a thousand
what do the first 10 look like
that looks pretty good
what do the next 10 look like
that's nice too we got some two two
letter words and one little words
good
copying in cmpx from defense workspace
and then we need to generate the
expressions that we're going to run
against each other
each one of these functions is going to
be called in each of the words
looks like that that's nice
and we're running this and see how it
comes out
oh dear that stencil solution
that doesn't look very good
but the fastest one is actually the last
one
which was a nice and short one as well
that was the indexing using grade i
would have maybe thought that
creating the permutation vector with the
running sum would have been faster but
turns out that
it isn't
so that's our conclusion
use grade and indexing a very apla
approach for the optimal
performance
thank you for watchinghi we given a list of numbers and we are
to find the length of the longest
consecutive
subsequent where the values are either
consistently increasing or decreasing or
constant here's sample data now it might
look like this sequence here is the
longest
one that because the values here are
constant are easy to spot but this is
actually only two steps because we go
from here a five to a five and then from
a five to a five whereas over
here we have four elements in a row that
are consistently
increasing even though the increase is
not consistent so we go from one to two
and then 2 to three it's still
increasing 3 to 5 it's
increasing okay let's begin our Lambda
uh with p as argument and we refer to
the argument as Omega because that's the
rightmost letter of the Greek alphabet
and
here we are not actually interested in
the values we're interested in their
relative sizes so we can start by
subtracting consecu uh adjacent elements
so this subtract this does a 1 - 2 and
then 2 - 3 and 3 - 5 this might sound
backwards but it doesn't actually matter
CU we're only interested in whether
we're going up or whether we're going
down
or whether we're constant and it doesn't
matter if we flip around up and
down so here we can see that we
going up because the left element minus
right El is negative and we're going up
we going up and then we have two
constant ones going down going uh and
then uh up again and then down down okay
now we're not interested in how much
we're going up or down we're just
interested in whether whether it's up or
whether it's down that is we're
interested in direction or the sign so
we can do
that and now we just want to find out
whether adjacent elements in this
indicator list are equal to each other
so we can use the same exact technique
but this time instead of using
subtraction we're using different
from so this tells us that the first
element is not is the same is not
different from the second one the second
one not different from the third and so
that's these three and then we have one
here uh where the zero is equal to the
zero for this space over here and so
on okay so how do we convert this to a
list of lengths one way to do it is by
cutting this into pieces that begin with
a one the only problem is the first one
begins with a zero it's missing kind of
the one that the very first
uh directional change is of course
different from anything before it
because there was nothing before it so
we can fix that by inserting a one in
front and now we can use the petition
function
to that takes exactly this kind of
element uh this kind of argument on the
left and cuts the data on the right into
partitions that correspond to uh
beginning with a one and then continuing
with a zero but here it doesn't actually
matter what data it is we're cutting
because we're only interested in the
length so we could just C cut the data
itself and for that we have the self
operator also known as
commute so now we've cut into segments
that begin with a one and then we can do
the T which it looks like a T mark on
each and this Maps the tell over every
segment that gives us the length now we
just need to to find the largest one
which is a maximum
reduction and that gives us um this
solution which is very nice and easy to
understand however there's a principle
in APL that if you want things to run
fast then you've got to stay flat and as
we can see here on the boxes this result
is not flat it is a list of lists rather
than a single list so we could actually
do this using a single list instead
single flat list let's take this again
and this is the point where things go
not flat when we doing So-Cal nested
arrays let's go back and look at what we
had
here all we want to do is find the
distance from the beginning of one
segment to the beginning of the next
segment so we frequent find the indices
of these ones and subtract them from
each other that would give the adjacent
ones from each other that would give us
the segment lengths the only thing
missing of course is the ending point
for the last one so let's fix that by
adding a one to the end now the same
symbol as we used before doesn't apply
the concatenation with a single argument
used on both sides rather it flips the
arguments around so this becomes the
left argument and this becomes the right
argument in effect it just as this was
preened a one this becomes end
one okay now we convert this Boolean
indicator Vector to a list of
indices these are indices of our ones we
can see that this one is in position
four five and six over here seven and so
on and when we just need to subtract
adjacent elements this time it is
important which way we do it so whereas
this will give us the opposite of what
we want actually if we negate the two on
the left then it flip flips uh the sub
vectors before we apply the reduction on
each sub Vector of length to so this
flips the sign for
us and then the only thing that remains
of course is taking the
maximum that works let's call this G and
to see what kind of difference in
performance this makes we need to have a
little bit uh of a larger data set so
let's do a
million uh
numbers from one to 10 so this is a
million reshaping a 10 get a lot of tens
and then the question mark changes each
10 into a number between one and
10 we can look at the first 10 of
them right now we can copy in the cmpx
compare execution utility from the
defense
workspace and construct a a couple of
Expressions that we want to compare in
performance against each other so we
have f with the argument of Q and we've
got G with the argument of Q then we let
that run for a little
while and we can see that with a million
elements we get a very significant speed
up thank you for watchinghi
we're going to translate telephone
numbers written as digits and letters
into their corresponding
plain numbers
so first
here is the telephone keypad
if you look at the letters they are
sequential
and they kind of split the alphabet into
the curse into groups
kind of sub alphabets
and since that's the case
then
we can see the alphabet as a range
and have some cutoff points
and then we can just say between which
cutoff points does any particular letter
occur
so
the cutoff points would be the first
letter from each key
so this is the first function and the
each operator
and then our keypad
we don't actually need this to be a
matrix anymore so we're just going to
well I can actually just flatten that
Revel it
and then we have
some
spaces in the beginning at the end
we can do the intersection
of
the alphabet and these
and that gives us just the letters that
we wanted
and we can give this a name if you want
so these are the cutoffs
okay
so
now we have the letters of the alphabet
and we can use the interval index into
these letters that we have stored in C
and these are the correct numbers for
the individual keys but offset by one
we can fix that either by adding one
or we could
add a place hold a character that
doesn't actually appear on the left so
we need to use something that keeps the
increase the increasing or at least
non-decreasing series of letters we can
use the character that in Unicode comes
right before a which is the ad symbol
okay so now we have the correct values
for the letters of the alphabet
what about the digits well the digits we
have here in in Quad D is a constant
we can look these up in itself
and even though each interval here is
just a single one that works fine
but we're off by one again we need to
subtract one and there are various ways
we could do that one thing that's
interesting to observe is a character
that appears before the first cutoff
gets an interval index of zero
so if we drop one from the alphabet
disrupt the zero then when we do the
interval index we get the correct values
okay now we can put all of this together
if we take the digits but draft one
and we concatenate it doesn't matter
when we concatenate if we concatenate
first or drop one first because it's
such a short amount of data here
um
then we have a full vocabulary of cutoff
points
anything from here is nine then this
becomes ten this becomes one oh but
there needs to be two so let's insert
yet another at symbol or some other
symbol that appears between nine and at
or a
and now we can try looking up all the
values and so these are the digits
and these are the letters
but now they are too large by 10.
we can
fix this be since everything needs to be
mapped between 0 and 10 by taking the
remainder when dividing by 10 or the
residue we could also call it so that
just takes all the tens away
this is the also known as modulus but we
take the
number we divide by on the left
so this fixes
the issue for letters and digits stay
just the same
and that's really all there is to it in
order to make this into a proper
function then we
we want to apply the static function
with a constant left argument so we can
bind that left argument to the
interval index function and then we just
assign that to f
and now
we can
see that telephone numbers get mapped
correctly
and digits as well
get mapped directly so
we get the values that we asked for
this isn't the faster thing to do
because
if we think about it this is a simple
mapping there is a mapping where we look
up a particular value and then we give
some other value
and we can Define a function that does
this as a simple mapping so let's first
generate all the values that they could
be
these are digits and these are the
characters so this gives us all the
values for all the digits and letters
that could appear
we can call that n for now
then we can look up
the input
in
the list of all digits and letters
like this and we can Define this as a
little
Lambda or defen so this just gives us
the indices and doesn't matter what
exactly they are because we take that
result
all the indices that correspond to the
input letters and characters
numbers
and we look those up in n
and then we can try that as well
Let's see we get the same result and
this of course going to be the fastest
solution because we're not Computing
anything we're just looking up
um
if we want it's self-contained solution
here then we could
take all this
um well do two parts
and put in the literal number here and
we want 999 at the end it's a bit long
but uh
it works the same
thank you for watchinghi
we're going to be given a vector of
points as X Y Pairs and we are going to
compute the area inscribed by this
polygon
we're going to use something called the
shoelace formula which briefly described
it says that the area is half the
absolute value of the difference between
the sums
of the
diagonal products and the
enter diagonal products this might sound
like a lot of steps but we'll take it
one at a time
here are some sample points
the first thing that is specified in the
instructions is to stack them on top of
each other to become a matrix here's a
little Lambda for that
and this is the mix function it's called
mix because the points you're given as
an one-dimensional array of one-dimensor
arrays the inner Dimension is hidden
inside the array
mix mixes together the outer Dimension
and the inner Dimension into a
two-dimensional array that is a matrix
Omega refers to the argument
so here's our Matrix
now
there is a slight problem that we can
also be given just a single point which
isn't a list of lists it's just a simple
list so we need to normalize the input a
bit
we can see here that it might look like
we have a table but if we ask for its
shape then it has the shape is just two
it has two elements whereas if we ask
for the shape of the mixing of this list
of points then the shape has two
elements the number of rows and number
of columns so we need to normalize and
the best way to do that in a case like
this
is
to use the in close if simple function
or Nest function guarantees that the
result is nested if at all possible
so here
this becomes a single element of two
elements
and then we Ravel that
straighten it into a list of such pairs
now we have a one element
list of spare and then we do the mix and
then we get a one row two column Matrix
which looks much the same as before the
trick here is that if we use our list of
points then this function doesn't do
anything because it only encloses if the
argument does not already have
enclosures and since we already have a
vector then reveling into a vector
doesn't do anything either so this takes
care of the normalization
now the next step is we want to get the
diagonals we want two paired up with
negative eight three paired up with two
and one paired up with four
APL works very much orthogonally with
erase rows columns layers not along
diagonals the easiest way to get to the
diagonal is to rotate things so skew the
array into place such that what was
previously diagonal is now straight
if we could only rotate up this column
one step with the four circling around
to the bottom coming in next to the one
then we have achieved
straightening out the diagonals into
horizontal rows
good thing is that we have a rotation
function which can either take a single
value to rotate the entire array here we
took the row containing 2 4 and rotate
it down to the bottom or we can give it
one row one number per column
we want the First Column to be rotated
zero steps and the second column one
step and now we have the diagonals as
rows
we also want the enter diagonals
and we can just do that by
rotating the other direction with a
negative number
now we have two paired up with two if
you look at our original array up here
two with two
and we've got three with four so that's
diagonal in the other direction and so
on
right that means we can take these two
formulas here and put them next to each
other
giving us a
Two element Vector of these rotated
matrices
you'll see that there's some code
duplication going on here this
normalization and making into a matrix
we're doing that twice
really should move that out of a
function as a kind of reprocessing
in order for this to become a proper
function in the end we need to bind
together these functions here so it's an
a sequence doing this after doing this
after doing this we can do that using
the top operator and it looks cute too
okay
the next step is that we want the
products of these diagonals pairs which
are now just rows so we can
use a multiplication reduction
horizontally
and that gives us these three products
so negative 16 is 2 times negative eight
then we need to sum them
and then finally we have to subtract one
from the other
once you have this number we just need
to take the absolute value it's negative
here so we make it positive
because the area is always positive and
then we have to divide that by two I
like to write that 2 divides so this
operator here takes the division symbol
and flips its arguments so that what
we're dividing by goes on the left
and that gives us seven which is our
correct result
this is a solution but it bothers me
that we have some duplication here we
can see the the sum of the product and
it really shouldn't be that we repeat
ourselves
what's going on here is that we have
subtraction
but we want to pre-process both
arguments to the subtraction by doing a
product and then doing a sum
so we have something called over which
is
a pre-process both arguments operator it
takes a function here on the right which
is something we're going to apply to
both arguments before we proceed to the
main function which is on the left so we
want the sum of the products
that means we can remove those over here
right we still get seven
but I'm not quite satisfied yet
because
we still have
some duplication here
all of this is really
the same two we're just talking about
the difference between in the two
arguments are just the rotation amounts
so we could put things together here
and say that the arguments are just the
rotation amounts and they will be used
to rotate
the actual argument to our function as a
whole
how do we do this
well
I mean let's put the argument name in
here and a
rotation function
now we want to bind together this
argument as a constant argument to the
function so instead of this being at the
addict function it takes an argument on
left the rotation amount and the
argument to the right what's being
rotated it now becomes a magnetic
function that's being applied to each
argument
it is a rotate
Omega function
so that means we can get rid of these
two
um the S light here up here is that this
is a tested function that we're using
and that's necessary because we want to
refer to the argument of the outer
function if we used braces here to make
a little Lambda then Omega would now
mean
the argument that's being given to this
over construct
so being that is tested we can't just
have three magnetic functions after each
other that would mean something else
but we can the same way we did over here
with the pre-processing we can glue
together these two with this top
operator
this is looking better now we're just
giving the rotation amounts as arguments
but can we go one step further yeah I
believe we can because we're not
actually interested in not needing to
rotate the First Column the only thing
that's important here is rotating the
second column
so how can we get rid of
that zero there
let's restructure what we have got in
here a little bit
we have the insert the amount being
inserted here on the left
with what's being rotated on the right
we can instead of having it the whole
thing as a compound function the product
of the rotation on
Omega
we're going to make this into a fork
construct instead
where
the right argument goes over here we
have a central function that
is applied to the result of fetching the
right argument and this constant on the
right problem is that in a tacit context
we can have a an actual constant on the
right which has to be a function on the
right so we'll use this operator again
um but now with a an array on the left
it doesn't flip around
arguments rather it changes this
constant into a constant function
so this Returns the
um other argument
and this is the rotation amount with a
post-processing of a multiplication and
this refers to
the arguments giving to the whole over
construct which is going to be negative
one on the right and one on the left
we don't want just that
one or negative one we want the
concatenation of zero
and that one or negative one so that is
zero and concatenation and just the same
way as we did before
using the the bind operator to bind a
right argument to the rotation function
we're now going to use that same binding
operator to bind the left argument to
the concatenation
so
we're going to evaluate
this constant function that gives us the
outer argument we're going to apply
the zero concatenated two function to
negative one first and then we're going
to use that the result of that for S
rotation amount
for the vertical rotation post process
using the multiplication and then we sum
up and then afterwards we're going to do
that with a 1 instead of negative 1.
and then we do the final subtraction
so this is about as
a compact and
non-repetitive as I can put it
we can give it a name
and apply it to the points or to a
single point when the area then is zero
thank you for watchingwelcome to the apl quest see apl wiki
for details
today's quest is the first from the 2015
round of the apl problem-solving
competition
we are given two character vectors
and are to check whether or not these
are anagrams
here's a simple test case
what we need to do is we want to compare
these two character vectors to see if
they're the same
but we want to ignore
a lot of aspects of the character
vectors we want to ignore capitalization
punctuation
and spacing
in other words we just want to look at
the actual letters that are present
let's start to do so by filtering
the letters so we want the letters
where
those letters are members
of
the alphabet
but
they can be members of uppercase
alphabet or lowercase alphabet so we
want to do this membership case
insensitively
finally
we also want
to paste fold these letters so that we
can compare the ones from the two
different character vectors
but we could observe that filtering by a
membership that's actually the
definition of intersection
so we can substitute this phrase
with the case insensitive intersection
and gives us the same result
now we need to
give put these letters into some given
universal order
so that if we do so with two letters
that are scrambles of each other
shuffles of each each other so sets or
letters so to say
then they end up being the same order
and we can compare them so one order is
the sort order that works fairly well so
if we call these the letters and then we
index the letters by their grade
that gives us a sort of them
and we get the same thing on x
and so we can define a function
with this definition
but we it's not enough of course to just
do this normalization we want to compare
them so we want to compare the two
arguments
pre-processed by
this normalization
x
and y are now considered the same they
are anagrams of each other
and this might well be the shortest
solution that we can come up with
however it does have some issues that we
can have a look at
for example
um
grading can be a rather expensive
operation while sorting can be done
faster in order to get the fastest sort
we want to use
one of the idioms for sorting
so here's an example of that
we can see it gets colored differently
because we
are going to use the fast algorithm for
sorting
so
this works as well
furthermore
um if there's a lot of punctuation
then we are case folding the punctuation
in order to look at the intersection
with the alphabet when it wasn't
actually necessary to case for that
so we could look at the intersection
first and only case fold afterwards
for that purpose
we would have to
look at intersection with both the
uppercase and lowercase letters and we
could do that by taking the
lowercase letters and then putting the
uppercase letters before that
and finally notice that we are computing
the
this total alphabet
of letters every time we run the
function if you were to run the function
multiple times
then it's kind of wasteful to compute
that alphabet so we might want to do
that once and for all
one way to do that is using a tested
definition
so by changing this
brace here into a
parenthesis now it's a tested function
and we have to modify a little bit
what's inside here so we don't want to
mention the argument it's tested but we
can take this
constructed alphabet and tie it as an
argument
right argument to the intersection so
this is one magnetic function that's
being applied then we have another
magnetic function being applied and the
third magnetic function being applied
you can't do three magnetic functions in
a row like this but if we
compose these two together then it will
be just fine
so this should save us a little bit of
uh of work if we're using the function
many times let's uh let's give it a try
and see how they stack up against each
other so supposedly
a b c d they should become faster and
faster if i've done the thinking
correctly okay let's start by
constructing some large test case here
um we can start off with letters the
alphabet and let's both have some
uppercase and lowercase letters so if we
if we concatenate the alphabet to its
lowercase then we get this so these are
all the letters
then we can put in some punctuation
and
that gives us that gives us this
then we're going to
have a lot of that let's do a thousand
characters in that so this just repeats
them over and over again
but we also want to shuffle them around
and we want to add some spaces as well
so we can do that with a little function
so we want to
take the argument
and add some
spaces around
so we can just overtake it by let's say
we add
20 spaces
on the length
and then
we might want to
round that off so we don't end up with
fractional characters um
this would allow us to to change this to
a number that would
cause trouble
so
this just gives us a
a bunch of non-spaces with a bunch of
spaces afterwards so now we can
um
we can make a proper anagram of those by
shuffling them so we take
the argument and then
we take all the indices but in any order
of its length
on t
and let's create something
that's not an anagram
and of it and we'll do that
by putting in the dash which is not
something we had before at the first
position and in in t
so now they are
not
and against each other
copy in cmpx from the defense workspace
for the timing comparison
and then let's construct the uh
expressions that we're going to use
so
we want to compare
we want to run these functions a lot of
times because that was one of the things
that the d was a benefit over and over c
so we can start off by saying we have a
thousand
and copies cyclically of t a and t b so
these are the endograms and the and the
nut anagrams
we want to run on each of these
and then we want to have the functions a
b c d
and concatenated to the entirety of
those that gives us these expressions
here
and then we want as left argument and
you want a constant so we can say we're
binding t
and as
left argument
to each of these it gives us these four
expressions here
and then we can run cmpx on that
and it will take a little while
but if i have done my thinking correctly
then we should get
progressively better and better
performance and that's in that indeed
what we did get so we can see that we
got
some speed ups more and more
however and
here's the thing
an anagram
is
not so obviously just looking at the
letters
it's actually over defined in the
problem specification
it says using all the letters
and it also says ignoring spacing
civilization and punctuation could have
said using only the letters or they
could have said
just
an anagram of a string
and ignores word spacing capitalization
implementation so there's actually some
freedom to interpret this whichever way
we want
but that let's uh have some
more
interesting examples
here i'm using some letters uh that are
not so in the first two
character figures here there are some
letters that are
not in the just plain latin upcase and
lowercase alphabet
as well as
writing
with some punctuation here
but the important part is that i'm
adding digits
and digits are not letters
so we could say that they shouldn't be
included because
they're not letters but if you're only
removing
spacing and
punctuation capitalization
you can't say that digits are spacing
you can't say that they're punctuation
and they're certainly not capitalization
either
so it could be
either one of these
in either one of these definitions of it
so how can we do this
right um
there are a lot
of
characters out there and we don't want
to
write a list of all of the characters
that
have different properties luckily
unicode does define a whole table of
properties for every character and we
can hook into those kind of sneakily by
using an quad r or quite s because they
allow
pcre or pearl style regex's including
character properties and those are
exactly the unicode
properties
so what we can do here is
we can say and it's nice to state it in
the negative because we want to not ex
we can't really extract the letters as
much as we can easily remove letters
so we are going to remove letters from
from say from u and we and we can remove
any character that does not have the
property of being a letter so the
uppercase p here means the opposite a
normal lowercase p is having the
property of being a letter but here
we're removing things we want to keep
the ones other letters so we are
removing anything that is not with the
property of being a letter
and we can do the same thing for b
of course
so we can see that
both the punctuation and digits are
considered not letters but the special
characters that are not in the latin
alphabet those are still considered
letters and they are being kept and we
can incorporate this into a function
similar to what we had before so we want
comparison
over and then some preprocessing so we
start off with the sorting idiom
and then we want to
case bold so that we are case and
sensitive
and sensitive but instead of doing the
intersection we are now keeping this
function here
which is
just extracting anything that's the
letters and removing everything that is
non-letters
so that's one way of
understanding it and we can try this
oops sorry we should have an each here
so what we can see is that and the first
two are obviously different because
they're using different letters
the next two
removing the punctuation
and capitalization then they are
considered the same even though they are
using letters that are
and not in the latin alphabet
and then
we have the the two that are using
digits
both of them are considered anagrams of
each other so the first one is pretty
obvious the one two three three two one
the order doesn't matter percent and
minors are considered punctuation second
one are entirely different digits and
that's because we have removed all the
none letters and all digits are not
letters and therefore the only there's
nothing remaining even the dot goes away
because as punctuation we're comparing
two empty character vectors to each
other and then they're considered the
same
but we can also define some define it
the other way where we are
not interested in actually what's a
letter what's not a letter
rather we are looking at
and what is
uh at removing certain types of
characters
so we want to remove characters of a
certain class there are multiple things
we want to remove any character that has
the property of being a
mark
and so this
is like a spacing mark things that
adjust the spacing
um so that's part of being spaces
we want to remove anything that has a
property of
being a space in itself
of course and then we want to remove
anything that has the property of being
punctuation
punctuation
and we can use look at and what happens
when
well we can we should before we run this
we should really take this and try it
out
so here we can see that we kept all the
digits for example
and now we can try it
and now we can see that the last one so
let's look at u and v again
the last ones are considered different
from each other because we now keep the
digits even though the punctation has
been removed
and i think that's all there is to say
about this problem thank you for
watchinghello and welcome to the appear Quest
see APL Wiki for details
today's Quest is the second from the
2016 round of the APL problem solving
competition
we are given
some numbers
normally as a list but it could also
just be a single number and we are to
compute the median that is the middle
element
if you order them by size
and if there isn't any middle element
then we take the two middle ones and
take the average of those
first let's start with some test data so
there's a difference here between even
and odd length lists because of there
being a middle element or no middle
element
so the first example we're going to do
is we're going to have an odd number of
elements
and here if you order them we get 1 1 3
4 5 and so the middle element would be
the three
then
in this case there is no middle element
because we have four elements so if you
order them one one three four the two
middle elements would be one of the ones
doesn't matter and a three and then the
average of that would be two
then we could also be given a single
element
in which case we're supposed to just
return that so this is not a vector
another list and we could also be given
an empty vector and the problem
specification then says that in that
case we should say that the median is
zero even though there isn't any
elements
so the empty Vector empty list numeric
one is written like this in APL and
finally we should also make sure that we
handle the one element case because
that's not empty but and there is a
middle element but you can't just go and
take two elements because there aren't
two there's only one in order to get a
one element list we take
a number and then we Revel it so this
flattens it out to be a list of all its
elements which is just that one so this
magnetic comma is called Revel and then
also note that APL denotes negative
numbers with a high minus and normal
minus is for subtraction and this
removes any ambiguity
so now we have this list
of lists and we're going to try out our
code on each of them so what we're going
to do eventually is we're going to use
the each operator if we use that to the
immediate the right of a function it
will be applied to each element
basically a map
right so how we're going to compute the
median and there are a few different
ways and and
one way we could do it is to sort
and then we can remove the elements that
are before the middle ones and the one
that's after the middle one so let's
just get started
so
we defined a function in the braces and
we're doing the each here on this
applies the function to each element so
we're trying out all the different test
cases
and then the argument inside the braces
is denoted with the Greek letter Omega
and it's because the argument is on the
right and Omega is the right most
letter in the Greek alphabet
and so the way we sort in the APL and
there's no direct sort function in most
dialects of APL but what we do have is
something called the grade so this is
the grade function and what the grade
does oops Yeah so here's a problem our
first problem is it won't grade our
arguments because we don't we one of
them is a scalar it's a single element
and it doesn't have an ordering so we
cannot error you cannot change the order
we cannot create it either
and so much like we did
um when we were to write one element and
list we use the comma function the rebel
we can do that here so we could do a
revel on each and then we could we can
apply our function here grade on each
and this will work
however we can also combine these simply
by parenthesizing them and so this is
called an atop it's a sequence of two
functions
um and we only need parentheses here
because we are calling it in in place
and we want the each to apply to both of
them together so we're grouping them
with a parenthesis and then what this
just means is apply the first function
that the one that's the right and then
on the result of that apply the second
function so now we can try this
um and that works as well
so this is great what grade means is it
gives us the list of indices that would
put the array into order
so if we have a look here the first one
three one four one five
so then if you want the smallest element
then we need to go to position two that
would be a one
and the next one because it's a stable
sort which means that if things are
equal then
um
then they they preserve their relative
ordering from from how they came so the
leftmost one becomes the first one and
then the second one which is in position
four is becomes the second one and then
we want element number one which is the
three then element number three which is
a four and then finally limit five which
is a five
as well and so too here and that means
if we take these indices
and use them to index into the original
array that will be a sort
and API allows multiple indexing in one
go so we don't need to map over the
indices and then index rather we can
just take all the indices that we want
and put them into the square bracket for
the indexing and that gives us those
elements here so now we get the sorted
list
representation of these arguments
and we should also note here that
um what we're seeing is a zero here for
the empty list but these arrows indicate
X's that are available and so there's
one axis in each there's a
one-dimensional array and this uh
Circle bar thing indicates that there is
an axis but it's an empty axis and the
zero is only here to indicate what type
of array it is so it's a numeric array
okay so now we've got uh the sorted list
and what we could do then
um is we we know that
the first and the last element are not
the ones we're looking for we want the
middle elements
so we could drop the first element so
this is one drop and we could drop the
last element so negative one drop means
drop from the rear
of course this isn't entirely correct
for our very short arguments over here
but we'll fix that in a moment
and we could keep dropping until we have
one or two elements left
so we can see here we have three
elements left so we could do this again
one drop negative one drop
and then we have the three which would
be the median and over here when we got
two elements left then we want to
average the two so all we need to do
really is keep dropping from the from
the front and from the rear uh until we
have one or two elements and then that
gives us our result
and we can do that in a recursive
function
um but before we we start with the
recursion let's just set up our stop and
condition otherwise we might end up
going Forever by mistake and so our
custom condition
um is and this is we separate the two
statements here with a diamond because
diamonds are Unbreakable
um and then the colon here is a
conditional and so we have a condition
on the left and then the immediate
result on the right of the colon and if
the condition isn't fulfilled then we
continue after the diamond with the next
statement which would be this
um and so here we're going to take the
tally of the right argument of Omega and
this looks like a Telemark so this is
counting how many elements there there
are and then we say if that is
and if 2 is greater than or equal to the
tally that means we have zero or one or
two elements then we're done we don't
want to remove anything more so then we
could return the argument as it is now
if you try this
we can see that we're preserving now we
didn't drop anything from these last
cases because they already have uh two
or less elements
of course we're not quite done yet
um and if we keep dropping we can try
this one drop negative one drop here
then
um
you can see that we don't that only
happens on the long
um and the long arguments but we don't
want to do that we only want to do one
step
and then we have a either zero elements
left or one element or two elements left
eventually once we
um we do our recursion and we'll take it
from there in a moment so how do we
recourse it's very simple we use this
upside down triangle which is actually
upside down Greek letter Delta or Del
which is like
um it's called Del or nabla
um and it's kind of like a d d stands
for definition so it kind of calls its
own definition and this allows us to
recurse in an anonymous function
Anonymous Lambda that which is what we
have here
um so here we recurse until we have the
length and less than or equal to two
and that is what we get here so you can
see then we had the odd links we're
getting just the middle element and
we're done
uh if you have even lengths we end up
having two elements left and if we and
otherwise if you start the short we just
returning the right array so now we want
to compute the average
um of these and there are a couple of
ways we could do this
um
but there's a problem with the empty
list for computing averages so a really
neat way I think is to do a cyclic
reshape of this we know that we only
have zero or one or two elements and if
we
do a this is a Greek letter rho which is
like an R stands for reshape so this
reshapes to length two and it does so
cyclically which means that if you have
one element it becomes two if we have
two elements it stays as it is if we
have no elements then it will use that
type remember this indicates the type
which is the zero that's a prototypical
number
and we will use that instead of any data
because there isn't any data there so
here we can see that we end up always
with two element
um lists or vectors and then it's very
easy to compute the average of that we
can sum them so this is a plus reduction
and then we can divide by and two
to get us our result so this is the and
these are the medians for all of our
arguments and I don't particularly like
parenthesis but we need a parenthesis
over here because APL goes from
um has a long write scope
if only we had a division function that
had swapped arguments so instead of
dividing the left argument by the right
argument it would divide the right
argument by the left argument then we
can avoid this parenthesis and while we
don't have that built in we can
construct that using the commute
operator or swap operator so this takes
the division and flips the arguments so
now the two goes on the left and then I
like the way it looks like this
so we can assign this
so this is the recursive version of
median
okay let's do it a different way this is
not a very good way because of course
We're looping over in or recursing here
over and over and over again
um you know we have tail recursion uh
telcro uh till call optimization
um still this is a bit silly to Loop
through like this and you know it should
peel off elements instead we could we we
had this one drop a negative one drop
and we don't have to use one we could
use any number so if we can compute how
many elements we need to remove that
would be much better and turns out of
course we can compute
that so if we look at number of elements
let's have a look at our original D here
so here we have a length five
and we need to remove two from the from
the beginning to from the end if it had
six there would be two middle elements
so we also needed to have two elements
from the beginning or two from the end
then four we need to remove only one
um and if we had
three we also need to only remove one
and then we'll end up with a single
element in the middle and then if we
have
two elements or less we don't need to
remove any elements at all
so clearly this is something that has
something to do with the length but
flattened down so to say to to by half
so we have and if we start making our
next longer it will be zero zero one one
two two three three and so on
and we can compute that we can try it so
if we start by generating all the
indices so this is the index generator
Greek Iota Iota is like an i i for index
generator
um then we can divide
by two
and we can kind of see it here how uh if
we round it off we would get two of each
but we are a little bit off
because this was
um this is one and two and three
and really what we need to do here is
um drop less than that so if we
if we add negative one so you can see a
case where the high minus does is good
now for one and two we want to drop zero
for three and four we want to drop one
for five and six we need to drop two and
so on and that's exactly the formula
that we want
so and we're going to use the length of
the argument
and then and this is uh yeah should be
obvious before this is round down Laura
um and then we uh this is the amount
that we want to drop
so we computed that this is we're
assigning that to D
next statement we're going to use the in
and in much the same way as before so
we're taking and and sorting
first and then we can do a d drop
and also in and negated the drop so this
drops the first and the last we can try
this on our on our arguments those is
here the scoping so even though our test
data is called the we can use the D
inside and there's no problem because
inside we're using Omega for the uh as
the name that's the special name for the
argument
oh
again we have the same problem that
we're trying to do this on a scalar so
let's do the same trick as before
and and this works very well we can see
that we get either one or two elements
which means we are almost done we just
need to do the same thing as we did
before we can do a cyclic reshape to
size two
and then we sum that
n divide by 2.
this gives us our median
so this was the median computed by
dropping and Computing the amount that
we need to drop
but in fact we don't need to modify the
data At All by dropping elements and
what we could do instead is
compute the elements that we that we
want the indices are the elements that
we want and then we can just go and pick
those out directly instead of having to
chop our way until we get to them so how
would we do this
this time let's make sure to remember to
Revel first
Okay so let's think about it here and if
we have length
three we want
element number two if we have links four
then we want element number two and
three
um and if you have five elements we want
element number three so it keeps going
um up and down like this in fact if
you're going to sum them and divide by
two we probably want them twice so if we
have three elements we want element
number two and then element number two
if we have four elements we want element
number two and number three and so again
it's going to be this kind of increase
by and half all the time let's start off
by the length
um and instead of adding and
or subtracting one as we did before
we're going to add zero and one and so
this
um this is list is being added to the
single number which is the length
and then we divide by two
and then we can almost see where we're
getting and remember the first one has
five elements we wanted element number
three element number three
and here we want uh this is with four
elements so we want element number two
and number three and we can see we just
need to round that up just like we did
the floor before corresponding
symbol going up that is the ceiling
and so these are the indices that we
want except for our short uh the two
short thing when when the length is zero
then it isn't working right in that case
and we should just return zero because
we can't get the indices in of uh in
this index number zero index number one
that doesn't work
so a couple of different ways and we
could do this we could do this before we
could say if one is well actually we
only need to do it for that and
for that is one Element so if zero is
sorry for that zero element length if
zero equals the tally of the argument
then and we return 0.
and then we need to
use these indices so this is then we're
done that's our result over here we need
to use these indices to index into our
argument so we use the indexing
and then we we just need to sum
and divide by 2.
oh something isn't right here
oh of course yes do you spot what I've
missed we're indexing into the
um
into the original data that hasn't been
sorted yet so we need to sort that first
um of course so we use the grade just
directly and index and so this is the
sorted argument and then we're indexing
into that to get an
our result so this gives us
um our result
in fact we don't need to check the
um the length at all we could just
compare to the empty list itself so if
the argument is identical to the empty
numeric list then we return a zero so
that's another way that we could write
this
and so this is the median using indices
and that's three ways of computing the
median
there are a lot of different ways and
that it could be done I'm not going to
go through anymore now I'd like to
mention
a variant of this
so far we've been sorting the numbers
and then we've been either
peeling off from the outside or we have
been dropping from the beginning uh or
from the end
and and finally we've indexed directly
into
the sorted list
a different approach a little bit in
getting the right elements out since
we're Computing the grade would be
um to index into the grade itself
and then
use that to index into the main data so
let's modify this me and this median I
and just a slight little bit
and the reason for that is because when
we are sorting here and we are
it could be that we have a data type
that's inefficient and compared to
indices for example the floats that use
of multiple bytes per element whereas
the indices themselves for at least for
small array would just be one bytes per
element or maybe two bytes per element
and so what we could do here is we could
index into
and into the grade
and then that gives us the indices that
we need to get from our full argument
like this
so we can say median I2 on each of the
data that gives us our correct result as
well similarly for the other two
solutions we could do something like
this
right that's all for today thank you for
watchingwelcome to the apl quest ca pill wiki
for details
today's quest is the first from the 2016
round of the epl problem solving
competition
we are
simply to compute the mean or
arithmetic mean the average
there are a couple of gotchas here but
for the very basic part of the problem
this is extremely simple
now the mean is defined as the sum
divided by the count
so we could define
the parts
of the mean and then combine them
for the whole thing
we could do that like this we can define
small lambda functions in apl
using curly braces
inside the curly braces the argument
is denoted omega
and then we need to actually compute the
sum
and we do that by inserting plus between
the elements also known as reducing
using plus so this is plus
and
this is a reduction
and this function then sums
let's define
so this is a list or a numeric vector
you can
sum the numbers
like this
now we want the count
and there's actually a built-in function
for the count
in apl
it's also known as tally that's why it
looks like a telemark
next we can combine these
so here we define a mean function
and we want
the sum of the argument
divided by the count of the argument
now i put parenthesis on the left here
and i didn't put parameters on the right
and this is because
apl's order of execution is such that
any function
of
these functions for example and also
built-in functions every function takes
as right argument everything to its
right as far as it can see until it gets
stopped by say the end of the expression
or the end of parenthesis
whereas as left argument it only takes
what's immediately to its left
so
we need to make some
take
as argument just
the right argument to this outer lambda
and but we and we want count to take its
argument this other argument
and then the right argument to
the division function should be
everything to its right so that's the
entire expression on the right that's
the count there so we could parenthesize
as well the count but we don't need to
we do need to parenthesize the sum of
the argument because otherwise
without this what some would take as
argument would be everything to its
right
in fact it would give the same result
because we would be dividing all the
elements by the count first and then
summing them but that's
less precise and
not less performant either
okay so now we've defined the mean and
we can
apply the mean to p and we get the mean
of these
numbers
but there are some notational niceties
we can do in api as well
there's something called tested
programming or point speed programming
which basically just is a fancy name for
meaning i'm not going to mention my
arguments
so here
we have a mention of the argument and
over here we have another mention of the
argument
and basically and
what happens if we go test it is that we
express everything in terms of functions
so we have the sum function applied to
the argument
divided by the count function applied to
the argument and this can also just be
expressed as the sum function divided by
the count function
so we can get rid of a lot of noise we
don't even need the outer braces anymore
that's the indicator that we're going to
use the
the argument name
and so we can write it just like this
the sum divided by
the count
so these two outer functions are applied
to the argument
and the middle function is applied
between their respective
results and the function still works
what's interesting here is that
we've defined sum and count in fact we
can redefine them as tested functions as
well so we can we can redefine sum
we defined it as
the plus reduction of the argument but
again we're mentioning the argument and
we could omit the mention
and remove the braces so we could write
sum like this
and we could write count
similarly just like that
and then we can redefine mean in terms
of these new sum and count
and it still works
of course this is a bit ridiculous why
would i give a name sum
to something that's shorter than the
name itself some is three characters and
we probably can't really find any
any name that would be as short as two
characters which is the definition of
some count here is five
current uh characters but we only need
one character to express it so we could
just take these
and
these values and substitute them in to
our definition for the mean
so we can just write
the sum
divided by
the tally of the count
and then we can compute it like that
in fact we don't even need the spaces so
the entire mean definition
can be written
like
this four characters
at which point you might then question
why would you even bother calling the
function mean when you could just use
the four characters
for that means the mean and then
everybody can see exactly what it means
anyway
this is a short way of defining the mean
and there's a problem
and that is that the problem
specification you can look there
and says that this also has to work on
the empty list
and if we try that so we have a symbol
for the empty list which is called zelda
because it is a combination of
a zero
and the character tilde and
you pronounce them together as zelda and
it basically means
there are no numbers it's an empty list
like that so we can see that this means
this picture here means that it has a
single axis the axis has
no elements um and
when we have it being numeric this means
the type is numeric and this is just an
example of what such an element would
look like it would be a zero if there
had been elements there but aren't any
you kind of see the zero tilde thing
now if we try to do the mean of the
empty list we get one which might be a
bit mysterious but what's actually
happening here is that when we sum it we
get zero and we count how many there are
elements there are we also get zero and
zero divided by zero is traditionally
defined not as an error but as one in
apl for consistency such that all
numbers divided by themselves
give one
however in this case that's not very
good we want the problem specification
says it has to give zero
so we can fix this because
we have only in the case where there are
zero elements we get the sum divided
which is zero and then divide by zero
which makes it too big
but if we were dividing by one instead
then we have zero divided by one
and then
that would give you zero and that's the
result that we want
so we can fix this
by
taking the maximum
of one and the count so if the count is
one or more then it doesn't make a
difference if the count is zero we get
one so we basically clamp it to become
one or
more and how can we do that well if we
go back again to our very verbose
definition of of the mean
where we had
and let's now substitute in here
the sum of the argument
divided by the count of the argument
well then we need a maximum function
which we have in apl it's denoted by the
up style
and you can kind of see that
it's like this vertical bar and then it
has a bar at the top indicating that we
want the maximum correspondingly the
minimum would be this it's a vertical
bar with a
indicator at the bottom but now we want
the maximum
and then we can put in a 1 over here and
keep in mind the order of execution in
apl every function takes as right
argument
everything to its right as far as it can
see so
maximum here takes the count of the
argument
and the omega
as its right argument and its the left
argument is to its immediate left so
that's just this one
and division takes the result of this
entire expression on its right
and now
mean works as before but if we do it on
the empty list we get 0 as required
but we can actually do this testedly as
well
again in terms of just function
application on the argument so here we
have the count
and then we do the maximum of 1 and the
count that still works like that
and then we have a division and what we
want to be divided is the sum so this
says the sum divided by
1
maximum
count and the count
we can again substitute in here
and this gives another again we could
remove spaces if we wanted to and this
gives us the mean which works
on p
and mean which works on
um
on the empty list
and this is a a very good solution to
the problem and let's just demonstrate
some features of it because actually the
problem wants us to
make this applicable even to higher rank
arrays
so apl arrays are
not just lists of things but they can
actually multi-dimensional they can be
arranged along
multiple x's
let's define a second number
so
now we have p and we have q these two
lists
um and they are one dimensional there's
only one axis that can be collapsed by
taking the average over that axis but we
can combine them
in various ways
and one way to combine them is to
combine them into a a table or a matrix
of two columns
and we can do that by making each one of
them into a
a one column matrix or a column vector
also known as that
and then
concatenate them together
so we have this
function comma bar
which is called table
and it takes an argument say q
and it makes it into
a
matrix so here this arrow indicates that
there's a single axis along which the
elements are ordered
and here we have two arrows which says
that there are two axes
along which the elements are ordered so
this is the the first x's
which are the rows and the second x's
which are
the columns and we could of course do
the same thing
for p and then we could combine the two
of them with concentration
so we can take the table of p
concatenated with
the table
of q again i don't need parenthesis on
the right because
the concatenation function takes
everything on its right as its right
argument
now we have a two column table
we could actually write this in a much
neater way because what we can see is
symmetry here
we see that we are concatenating the
tabling
of these two arguments
p and q
and we have a way to write that in apl
we can write p and q
concatenated
with each other but we don't want to
concatenate the p and the q we want to
concatenate a certain aspect of p and q
namely their table form
and for that we use what we call the
over operator
you could
see this as pre-process the arguments
as
um
in a certain way
and so this is not a function this is
called an operator that's a higher order
function it takes the concatenation on
one side and it takes the tabling on the
other side so these are two functions
and it
it combines them into a new function
which isn't concatenation it is the
concatenation
of the tables
so this does exactly the same thing as
the previous expression we wrote it does
a table on each one of them and then it
concatenates them together
and so with this new array which we can
call a
we can take the mean of a
and this gives us a two element vector
or list one per column
and what's why is it why is it doing the
average vertically so to say
because it's
the tally
counts
along the leading axis
how many
elements or sub-arrays are there along
the leading axis
and so for both of these um and it
couldn't be otherwise it can be ragged
there are five
and also the summation that we did which
was the the plus reduction so this was
the reduction symbol um which actually
also isn't a function it's an it's an
operator higher order function which
takes this plus
and modifies this
much like the over operator modifies the
concatenation
modifies plus to become a plus reduction
or a summation
and this also works
along the leading axis which is over
here
so we're summing each column and then we
are we have the two column sums we can
try this
and then we're dividing by the tally and
the number of
rows and that's why we get the two
averages apl automatically
pairs up
elements of arrays when we're doing
arithmetic so 2.8
and um
is the result of 14 divided by 5 and
3.2 is divided the result of 16 divided
by 5.
what if we wanted to
to sum
and count along
the rows
well then there's another operator a
higher order function that we could use
to modify
a function and it's not just built-in
functions that can be modified even our
and our own function mean can be
modified
so we count the number of dimensions
this has two dimensions this whole thing
but each row in itself only has one
dimension and we want to apply the mean
function not to the entire table but
to the one-dimensional
sub-arrays of this table and for that we
have
this which is called the rank operator
it takes this function on the left and
then the specification of the
dimensionality or rank
of
the argument that we want just this mean
function to see
and so
this says the mean
on each subarray of rank one that is on
each row and if we do that
then we get five results so two is the
the average of three and one and three
point five is the average of one and six
and two point five is the average of
four and one and so on
and so this by defining a function in
terms of the leading axis this allows us
later to also
have a function available that we can
apply on other axes simply by using this
rank
operator
and that's all i wanted to show for
today thank you for watchingwelcome to this second episode of the
apl quest check out apl wiki for details
today's quest is called making the grade
it's the second problem from the 2013
apl problem solving competitions phase
1. here we are to write a function which
takes a list of numbers representing the
points that people scored on some type
of test
if they scored 65 or higher then they've
passed in the test and we are to compute
the percentage of people who passed
let's start off by generating some test
data so here are 10 scores between
1 and 100 and those that's
succeeded in the test had scores 69
and 72.
so
we know how many
scores there are in total
and we can compare all these scores with
65 so
if the
test scores
are greater than or equal to 65 then
they have
succeeded and this gives us a boolean
vector indicating the ones and zeros
the ones that have
succeeded
then we can sum the boolean vector to
find out how many have succeeded
and then we can
divide that by the total number
so this gives us a fraction and we can
multiply that by 100 to get a percentage
putting all this together
we have the function f
and
and we take 100 multiplied by
the sum
of the scores that are larger
than
65 divided by the total tally of
scores that's the argument here not the
variable t
and we can try this on t and that gives
us the correct thing now there's
something here that's worth noting
and we are doing a bunch of different
operations on our data and while
mathematically equivalent it is
important which order we do this in in
order to have the maximal performance so
here are some variations of things that
we could do
in f
we started off by the comparison and
then we summed
however we could also
start off a bit differently so
let's say that we start off by doing the
comparison
and then we divide
by the total count
then we sum
and then we multiply by the 100. so this
is mathematically equivalent but we'll
see in a moment and it makes a big
difference
what we could also do
is we could start off in the same way
by computing
the numbers
greater than or equal to 65
we could divide by the total number of
numbers then we could multiply by 100
and then sum again mathematically
equivalent
but this makes a difference in
performance let's generate a bunch of
test data
so
um
here's some test data we're going to do
random numbers between 1 and 100 but
this time we're going to do a million of
them
i'm not going to print these out
let's get in the com
pair execution time utility from the
defense workspace
and
then we're going to run
f on these test scores and g on the test
scores and h on the test scores
and we'll see in a moment
that there is a
quite significant difference in the
performance here
so
what is it that's actually going on
in f
we are
doing
if we call the number of uh
of scores n we're doing n comparisons
first
and then we are doing
n minus one additions
we're doing
one
division and
one multiplication so we can write this
we're doing
n
comparisons
right like this
and then we are doing an
n minus 1
summations
and then we're doing
one division and one multiplication
in g
we again start off the same way we're
doing
n comparisons
and then but then we're dividing every
comparison with
the tally so that means we're doing n
divisions
and we're doing
the summation after that so that's n
minus 1 summations
and finally we're doing one
multiplication
and in h here we are doing starting off
the same way with
an
n
comparisons then we're doing the
n divisions
and then we're doing n multiplications
as well
and finally we're doing
n minus 1 at
additions
so
while these are mathematically
equivalent we can see that there's going
to be a big difference in the
performance and indeed an f is the one
where we're doing the least amount of
work
so
looking at
f again
we can come up with some variations and
in the live chat event that happened
last friday and there were a bunch of
variations and they were all over this
same theme and trying out various ways
of expressing this
so here we're doing dealing with a
scalar the cutoff point 65
and a vector these are all the scores
we should notice this pattern we have a
sum over a comparison of vectors so it's
two scalar functions a reduction over a
vectorized operation
and we have that and we're doing apl we
should think inner product
so we can take these and combine them
like that
and we can call this i so this is going
to be
the same
we give the same result as before the
test result here now why am i doing this
this is because this allows us to move
on to a tested solution that's really
really neat
notice that
a
tested solution
expresses everything in terms of
function application on the argument
rather than
explicitly stating the name of the
argument
so the argument here is omega
and the function that's being applied to
omega is the tally
here the function that's being applied
to omega is the inner product
with 65 as a bound constant
right argument to the inner product
and that we can express as a tested
function really neatly
so we get rid of our braces
the application of tally on the argument
becomes just tally
the application of the inner product
with a bound right argument we use the
bind operator to bind that right
argument to the inner product and that
allows us to get rid of
all the noise
right there it's going to have about the
same performance but for those that like
test programming this is very nice
but we can also spot a thing here we
bound
the argument which is the cutoff point
what if we want to generalize our our
function such that we can take the
cutoff point as an additional argument
in apl it's common to have the main data
as the right argument and various
parameters as a left argument if any
so we really want to move the 65 or
whichever number we use as the cutoff
over to the left side
of course we can easily do this
by flipping
the direction of the comparison
then the 65 can go on the left so the
same but it's a tested function
the problem is that we want the tally of
only the right argument
if we left it the way it is now it would
be
the mismatch whether or not they're
different and of course they are
different and we'll be dividing by zero
which is not what we want
so what we can do is that we add a
little construct here and a top
right
so this applies tally magnetically
on the result of choosing the right
argument
another way
that we could generalize this is by
saying the default cutoff point is 65
so we can go up and say instead of
using 65 as a constant in here we supply
it as a left argument
but if no left argument is given then we
use 65.
so now we can say
that the cutoff point
is 65 we get the same result
if instead we make the cutoff point 50
oops i made a mistake here
oh yeah of course not t 50 and apply the
function l
um
then it's 40 of the scores that are
that pass
and we have here 69 60 63
and 72
i'd like to show some some interesting
different approaches to this problem
since everything we did now was using
the same empathic method basic method
these are not efficient but nevertheless
they're kind of eye-opening in
completely different ways you can attack
the problem
the first one
makes an assumption that all our scores
are integers between 0 and 100 so we can
generate our scores
that would not pass
and then we could
remove all those scores that wouldn't
pass
leaving only those that do pass
and now
between this set difference um
the the ratio and of the length of the
set difference and the original is then
the ratio of
winners
so we can take
the winners
and the original
and
do a ratio
of
length
so this is the over operator we're
applying tally on both arguments and
then we're dividing them and that gives
us
our ratio and we can multiply by 100
so we can put this into a function
here's our argument
and a different
approach to this
is
in using the interval index function
so if we have our test scores here
then we can put some
interval cutoffs so let's say we put a
cutoff of
20 and a cutoff of
65
and this gives us the indices of the
intervals that these numbers fall in so
4 is below 20 so that's index 0. it's
before the first one
and 69 is
is after 65 so this is
one in the middle and then to the right
of the last one is number two
and 22 is right there in between
however we only want one color so we can
make a vector that has but one element
and this gives us
they're still indices but they also
happen to be boolean because either
something falls before the first cutoff
or
in the interval that's formed to the
right of that cutoff
inclusive
so now we could sum this up and divide
by uh the total number of
uh of scores
but let's do it a little bit differently
instead we can use iota algebra again
but this time magnetically and that's
where this computes the indices of those
that
fulfill the requirement of being above
65
and now we can use the same method as we
did above where we
take this result and divide
with uh
over the tallies of
the original
and then we add
the last thing so this is using
where and the interval
index
so we can say it's 100 times this
and of course
for both s and t we could
modify them to take an optional or
required left argument
so here are all the definitions that we
did today
compare them don't forget to
check out what the performance looks
like on the kind of data that you're
running with
thank you so much for watchinghi
this time we're given a list of numbers
and we are going to check if it fits
into this pattern where
we have a
non-decreasing segment followed by a
non-increasing sediment this might sound
backwards to say non-decreasing
non-increasing but that I don't really
want to say increasing and then
decreasing because plateaus are fine
it's okay if the value stays the same
as long as it's not going the opposite
direction
okay
how are we going to do this
let's have an example of something that
does go up and then down again
okay this is very simple
and a very neat way of doing it
is by
by doing a normalization we could say do
a transformation
of this
list such that it will only stay the way
it is
if it abides by the rules and if there
are any breaks to the rules then it will
be changed and then we can compare the
original list with
um the modified one
if they're the same
then it abides by the rules and if not
then it doesn't abide by the rules
okay we're going to do this test it from
the outset that means we're only
applying functions and never mentioning
our argument by a name
and so the trick here that we're going
to use is we're going to do a maximum
scan so the maximum function is a
function that takes two arguments and
Returns the larger of them and we're
going to insert it between the elements
here
but over the prefixes so we're going to
insert it first we'll have just one and
then do one and two that gives two then
two and three that gives three then two
three four or one two three four
actually and that gives us four one two
three four five gives us five one two
three four five three
now the maximum that we have seen is 5
which means that the corresponding
element of the result to 3 will be 5 and
same thing goes for one so we can try
this this is a maximum scan
so here we can see that after we hit the
highest value we don't go down again
and this is a nice way of
um expressing the idea of being
non-decreasing
what about the other way what if we're
going to
start from the right
and do the same thing that means after
we hit the highest point we stay with
the highest point going left
well we don't have a scan from the right
but we can pre-process
the scan
argument with a reversal function
so now we reversed
the argument one three five four three
two one
and then we did the scan and that gave
us and the one three five five five now
we just need to turn it around back to
its original order
and here we have a scan from the right
okay
how can we combine these two because we
want to preserve the array the way it is
if it divides for the rules there are
two parts to this
but for this particular problem
we can combine them by taking the
minimum value if we now compare
this list here and that list there
then the minimum of one and five that's
one the minimum of two and five is two
three and five four and five up until
they meet and then we go down on the
other side the minimum is not going to
be down here that's the three and the
one
so we take another maximum scan which is
the one that goes from
left to right and this is the scan that
goes from right to left and we take the
minimum of the two
but the pattern here that for tested
functions is that an outer function is
applied
and the inner function is applied to the
results of the outer functions
so that pattern is broken if we try to
put the reverse function in here this
should be the inner function altogether
but notice the pattern here is very much
like this where we want to pre-process
the right argument with a reversal
so pre-process the right argument with a
reversal that's this operator
and that gives us the back the original
array
now let's try if this indeed holes if we
make any modifications so here after the
end we go back up again
and we can see that
the
the three and the one the four got
smeared out so to say by the four coming
in from the right when we when we are
um doing the scan
the maximum scan from the right we get
four four and then five and we go from
the left we get three four five five
five and then we take the minimum of the
two that's going to be the four that
came from here and that means that
there's a difference there
we can also try doing it with a value in
the middle we can see that kind of got
painted over by the three from the right
and the four from the left and therefore
it became a three the minimum value
what if we turn the whole thing upside
down
here the five coming in from the left
with a maximum scan paints over fives
until we get to a larger value and the
Seven makes sevens all the way to the
left the minimum of that is going to be
all the fives with a single seven so
this looks good now the only step that's
missing is that we compare this to the
original argument so we need to do a
comparison of all the elements together
in one go
with the original value which we can
represent with the identity function
applied here so the way this this
executes and binds is every other
function is applied to the argument
and the intervening functions
are applied between those results so we
do scan from the right in the reverse
we do the scan from the left
and then we do the minimum of those two
but reordering the right side to become
its original order
and the result of this is compared to
the result of the identity function
which is the original argument and so
this doesn't hold
but if we did
something like this
then it does hold
and in fact we don't even need this many
spaces we can we can remove all of that
save some
horizontal screen estate
this works
very nicely
thank you for watchinghi we're going to write a cover for the
diic Iota or index of primitive in
APL which behaves exactly like the
original except one thing so when we use
D goota to look up things from the right
argument in the collection that's the
left argument and what we're looking for
isn't found it will
give the next index after the last
position to indicate that something is
not found this is a really useful
Behavior because it allows us to take
indices where things are found and use
those to index into another substitution
collection so we can do a mapping from
one thing to another and then we can add
another element at the end which all
missing elements will be mapped
to but the problem here is to change
that behavior so instead of getting the
next index um after the last element we
are getting a zero which um only makes
sense when we using one based indexing
which is what APL does by default um
because that means that zero will also
be a unique result it will indicate an
element before the first one instead of
after the last
one and there are a couple of different
ways that uh we can do this let's first
look at
just the normal behavior so here we've
got the adota we have character
vectors and we can see
that the a was found at position three
that's this one and then there are six
letters on the left we're looking for p
there aren't any so we are indicating
position seven and then position four
for the L over
here okay so there are a couple
different ways ways that we could
approach this and one of the ways is to
Simply check whether or not the
um index that we get is larger than the
length of the left
argument so we can do this if we say
that uh the index that we
got is
larger than the length of the left
argument and then we can use this to map
the seven to a zero so an easy way to do
it would be using multiplication but
then it's doing the wrong thing because
we're multiplying the three and the four
here with zeros if we instead invert
this uh conditional so instead of being
greater than and then not greater than
that's the same thing as less than or
equal to
and then we can take this and multiply
it with the indices themselves over here
so this goes from the right to left it
binds like this that is the length of
the left argument and then we have the
index and then we have the comparison
then we multiply that with the index
itself and that gives us a result that
we want however there's a bit of an
inefficiency here in that we actually
finding the indices twice and we can fix
that in various
ways one of the ways would be to take a
new function that takes as arguments the
indices and the length
of the length left argument which are
all the data we need we don't actually
need access to our original arguments
and apply a function to those
so here we have the indices and the
length of the left
argument and then we want to have the
same formulas we had above but instead
of taking the indices and the length of
the left argument we can just refer to
those arguments so here less than or
equal to that is applied between these
two arguments and then we multiply by
the left
argument so this is one way it could be
written we we could also have passed in
the left
argument directly and then we could have
this was still referred to the indices
then we could have compared the indices
which come from the left with the length
of the right argument that means we
would want to take this function and
apply it between these two arguments
versus the left argument and the indices
but pre-processing the right argument to
the comparison function with the length
so we can do that as follows and it will
still
work a whole different way to do it is
to
postprocess the indices that we
get
so essentially what we want to do here
is we want to wrap around when we hit
the limit which is the length of the
left argument and we want to wrap around
to zero and this is exactly what modulus
or division remainder
does so if we take the
indices and then we want to wrap around
where the cut off is one more than the
length of the left argument so we could
write that in a tested Form 1 plus the
length of the left
argument and this would still
work um we could also eliminate this
parenthesis by swapping the argument of
the modulus
function so this operator modifies this
function such that it takes the
arguments in reversed order and then we
take the indices like
that another way to do it is to Simply
Define this as an explicit
function and that might actually read
nicer and it's no longer
so these are some good solutions to the
problem thank you for watchingwelcome to the appeal Quest Capel Wiki
for details
this is the seventh problem
from the 2016 round of the APL problem
solving competition
where to take a list of numbers and
filter it such that the only numbers
that remain are those that can be
cleanly divided by either 3 or by five
or well by both
let's get started
first let's
create some data that we can test on
so
here's some integers
and just for the fun of it that also
have some numbers that are not whole
numbers
okay
before we go to look at what actually is
divisible by three or five and let's
have a look at a very special feature of
APL which is called the outer product
conceptually it's actually really really
simple
um and especially in its basic form
where we just give it two lists
so here on the left we have a list of
numbers and over here on the right we
have another list of numbers and all the
other product does is
make a combination
from all the combinations of every
element on the left with every possible
element on the right in other words
we're making a table of such
combinations
the most common example of such a table
would be a multiplication table
and the syntax in APL for making a table
or an outer product is this jut and then
a DOT and then we put in the function
that we want to make the table for so
multiplication multiplication table
would be jut dot times
and here we can imagine that we have the
headers going down the left side and
across on the top so one two three four
on the top and 10 20 30 we also see the
10 20 30 because we're multiplying them
by one
now instead we can use a different
function than multiplication in our case
we want divisibility
now there isn't a
divisible by function in APL but there
is a remainder that is if you divide how
many do you have left over after you try
to distribute evenly with whole numbers
and so we can take our numbers and then
we can take three and five on the list
on the left and create a divisibility
table
um that shows the remainder whenever
we're dividing
so here you can imagine three and five
going down and these numbers 1 through
16 across we can see that the remainder
is 0 1 2 0 1 2 0 and 2 because we keep I
think one for when it comes to three and
zero one two three four zero one two
three four and so on for five and then
we can see that
for numbers that are not wholly
divisible then uh the non-integer part
the fractional part is also part of what
remains because we cannot divide that
cleanly you see that the three went away
from three and a half but there's a half
missing whereas for five the whole three
and a half is the remainder
and so something is divisible if the
remainder when you try to divide it is
nothing if there's nothing left that is
if we have zero
so we can compare zero to this and APL
uses long write scope what does that
mean it means that the equality function
takes us the right argument whatever is
all everything that's under its right
all the way to the end of the expression
and so we don't need any parenthesis
here
and so and we have
a table
that shows us a one which means true in
APL
whenever something is divisible
and a zero when it's not divisible and
we're not actually interested in whether
or not it's divisible by specifically
three or five we just want to know if
it's divisible by any one of them so we
want to say yes keep this number if we
have a A1 at the top or we have a one at
the bottom or both
and we can do that by using the or
function and we're inserting that we're
using a slash bar after that it means a
vertical reduction so we are sticking a
or an or in between so to say the space
between the first row and the second row
and that reduces this two-dimensional
array which you can see is two Dimension
over these axis arrows and introduces to
a one-dimensional array so here's a mask
indicating from the numbers in this
variable D which ones are divisible by
um by three or by five
and we can use this then to filter and
we do that with a slash
so we filter d
and that gives us just the numbers that
are divisible by three or by five
we can actually get rid of the
parenthesis if only we had a function
that was like the slash but with swapped
arguments which isn't built in but we
can construct it with a higher order
function called commute
and it looks like this frown because
it's all getting confused which side is
what
and then
it modifies the function on the left to
swap its arguments so here we have
exactly the same thing
and finally we can make this into a
function which would be our solution to
the uh to the problem by substituting a
special symbol which is the Greek letter
Omega that's the right most
letter in the Greek alphabet indicating
the right argument so that's whatever is
over here on the right in this case d
and that solves our problem
like this and we don't actually need
this much white space in in our code and
so if you prefer you could get rid of
all of that of course we need a space
between three and five to separate them
so we can write it like this as well
thank you for watchinghi
we're going to take a character vector
and check if every single character in
it
is one of the letters a c g and T
here's a character vector
this one does consist of
a t g and z now
let's define a function a Lambda where
the argument is referred to as Omega
because it's on the right side and Omega
is the rightmost letter of the Greek
alphabet
we can then use membership
and then write just letters that we are
interested in looking for
and this Maps automatically so every
single element
in the left argument
is checked individually to see if it's a
member of this set on the right we treat
the array on the right as a set
and they all are
the only thing we need then to do is
ask are they all that is an end
reduction so and and then a slash means
reduce
and then that's true if we remove the
and reduction for a moment and put in a
character which is not valid
then we get a zero there and the end
reduction gives us
zero
now we can Define this as a function
and apply it
but we can actually remove
some of the syntactic elements in this
function definition
by defining it in what's called tested
or points free
how do we do that
let's observe that we have two function
applications we have first a membership
and then we have the and reduction
if you were to express this only in
terms of function application
then we would need to do something about
this function because it takes two
arguments and we only supplied one
argument
the other argument is a constant
the easiest way to do this is by binding
or carrying one argument to the
membership function
deriving a new magnetic function a
function that only takes one argument
which is then applied to the overall
argument of our function
and we do that with the bind
operator which is a jot so this derives
a new function which is membership of
acgt
now we don't need to mention
the argument and we don't need the
braces for the function definition
either we have two pure functions
the membership of a c g t derived
function and the end reduction derives
function also y derived because the
function here
the core function is and and it's the
reduced operator which then derives the
end reduction or the
wall
so we can call this G
and then we can
apply G
let's see when there's an X here and
remove that
and we get A1
thank you for watchinghi we're going
to take a character
Vector that contains a notation custom
notation for multiple key value Pairs
and then we're going to parse it and
create a matrix with a key column and a
value
column here's an example of such a
notation customized such that uh the key
value pairs like this key value pair are
separated with slashes and the keys are
separated from the slashes by
colons this really calls for a very
commonly used short uh so-called
Fork which uh Cuts text or really any
data this is how it
works let's say we want to cut on these
slashes so we have the slashes left
argument
and then we can do an unequal with this
and that gives us a Boolean mask that
has ones for all the characters that are
different from the Slash and zero for
the characters that are equal to slash
that is the slashes so these ones here
um of which we start with uh 10 it
corresponds to these 10 characters and
so on okay now we can also take in an
identity
function
this is the right function it just
returns Its Right
argument and then we can put this all
together with a partition
function so what happens here is that we
compute The Mask we compute the right
argument you can call that compute it's
just the right argument and then the
partition function isolates runs of
characters from the right
according to runs of ones from the left
and the separators that are indicated
with zero those are descried but they
still cut at that point so we can see
how that works over
here now and we're not done yet because
we also need to cut each
individual and key value
pair so we can we can copy this and
whole expression
and use a colon here but this time we
want to apply this whole thing to each
we have an each operator a higher order
function and be cutting each
one and this gives us um a vector or
list of key value pairs but it isn't
quite a matrix yet so the last step to
make it into a matrix is the so-called
mix it takes the outer axis there's one
outer axis um and it takes the inner
axis that we have here and combine them
into an overall
array uh that has two
x's and so the rank the number of
Dimensions increases which is what the
up Arrow tries to indicate that we are
upping the rank the dimensionality and
we do that by consuming inner axes and
adding them as trailing AES to the outer
axis
and that's the result we're looking for
but this isn't a function yet in order
to make it a function and we have to
take this slash and colon as our left
argument as the
specification and then we put braces
around the whole thing uh right argument
is um represented by Omega left argument
is represented by Alpha so here we want
the second element of Alpha and here we
want the first element of
Alpha and this solves the problem but it
bothers me a bit this code duplication
can you really see there's a a pattern
here that's being
repeated so what can we do about this
well isn't entirely identical because we
have the each here which we don't have
over here but but I think we can fix
that so let's for now just remove this
part we but remember we want the right
part to also have an each and still do
what it's supposed to
do so this gives us these uh key value
pairs that haven't been pared yet we
want to put an each here but really
there isn't an each to apply we don't
want to apply on each of these
characters so how can we make this work
if we enclose the entire right argument
now it's one thing but it's still a
collection of um of character vectors
it's just a collection that's Dimension
that doesn't have any dimensions and the
each will then go into this inclosure
and apply the
function and then this works but we have
this extra level of uh of enclosing that
happened now we don't want that so we
can do a disclose
and now we're back to the um original
which means we can uh we can go up and
fetch this thing that we that we removed
before and insert it
here okay now um maybe we should uh we
should give this right argument a bit uh
key value pairs so it's not so wide
okay uh let's try this again just for
good order so now we have the same
function
here um
except we we can't just apply this over
and over again because there's there's
this disclose in between
them but over here we have a mix the
funny thing actually is that this close
and mix is exactly the same when applied
to a scalar and that's exactly what we
have here we have a single thing without
any dimensions that's a scaler why is
that because dis close just takes that
first and only element and opens it up
whereas mix remember I said and it
concatenates the outer Axis or in this
case outer axis with the inner axes
which here there aren't any in AES so
that just means that we take all the
data from inside and bring it out one
level and and there aren't any more X's
being added because there were zero X's
to begin with so we can replace this uh
disclose or actually first we call it uh
with a mix and it still
works now we have exactly the same
pattern over here but it's not one
function it's two functions there's this
train within each and then there's uh
the mix and it would be nice if we could
like combine
these but we can't immediately just take
this mix and stick it in here because
then that would make the mix also
subject to the
each now the thing is that we actually
don't need the each on uh the whole
function we only really need it on uh
the partitioning function why because uh
the inequality is a so-called scalar
function it penetrates all structure and
that means that explicitly trying to go
into each element doesn't make make any
difference and the right function well
it just Returns the right argument and
it doesn't matter uh if it's each
element separately or if it's and just
the collection of and of elements so we
can move in the each into this
expression right here and it will still
work and now that the whole parenthesis
isn't subject to the each anymore we can
safely take the mixes and stick in
here now we truly have three elements
the inclosed
argument followed and on its left the
first element from the left argument and
on its left uh the second element from
the argument and we simply sticking this
function in between that looks a lot
like a
reduction so in order for this to be a
an a proper reduction we have
to to put all these elements together
first so we'll take this function make
it into a reduction now this also means
that the reduction reduces the number of
dimensions and there's one because it's
a list of the second element from left
argument the first element from the left
argument and then the enclosed right
argument and you're going to reduce that
to a scaler binding closure so we have
to disclose it as
well um so then we have the second
element and the first element and then
finally we have the
enclosed and right argument so we can
see this this also works this is of
course a bit uh silly we can uh we can
get the second element the first element
in one go and then we can concatenate
that with uh a first further enclosed
right argument enclosure of the right
argument we need a double enclos because
the element we want is the enclosed
right argument and here we're
concatenating a two element Vector with
it has to then be concatenated with one
more item and that is the enclosure uh
then of this enclosed right
argument now being that the left
argument only has two elements we can
also write this as the Reversed left and
argument and that and it's a pretty neat
solution and if I may say so
myself there is an entirely different
approach to
this which is to not do two steps of
parsing we can simply look at
directly if any of uh the left argument
elements have been
found because we know that these
separators will always occur as first a
key value separator and then a pair
separator and then a key value separator
and then a pair separator and key value
separator and so
on so um we
can use membership but membership looks
up elements from the left in the
argument on the right so we can commute
its
argument and this tells us uh where any
separator was we can let's let's print
this again just to uh to remember how it
looked so we can see there are three
characters uh that are not separators
then there's one separator then there
are six characters that are not
separators and so
on we are not actually interested in
here in which ones that are separators
we interested in the not separat
remember that's just like the uh the not
equal that we were using before so we
glue a logical knot on top of the
membership
function that inverts that and this is
the exact mass that we the type of mass
that we had before so we can use this
with the partition function and the
right argument is the data that's being
petitioned that splits into key value
key value key
value the only thing we need now is to
shape this into a
matrix so we know uh how many there
are and uh that means that if we divide
this by two so this actually two divided
by because we're commuting just like we
did over here um then this gives us how
many rows we want then we can
concatenate two two so two comma would
be two concatenated to but we are
concatenating with swapped arguments
again so it goes on the right this gives
us the shape three rows and two columns
and then we can use that to
reshape the argument to this inner
function and that gives us um our
solution but and I find this a little
bit clunky in this case when we just
want pairs there actually a neat trick
that we can use and that is uh the
stencil operator so stencil operator is
often associated with things like Game
of Life at tomons um in this case we're
using it for something very simple so
stencil with a window size of two and
all we want to do is just collect the
individual windows that gives us this
which is almost right but we can see
that the problem here is that we are
overlapping so we we correctly took the
first two elements but then we took the
the next two elements was beginning with
the second element we want to begin with
the third element
that's because there's both a window
size and the movement and the movement
is by default one but if we change the
movement by giving stencil a matrix
right upper end where the second row
specifies the
movement then we get exactly what it was
we wanted so this is another solution
and I think this one is uh pretty neat
as
well and finally uh this whole statement
we can actually it won't we can't make
it any shorter but uh there's another
elegant way to compute the same thing um
so
let's look at this
again we got this splitting done and
that was done with uh this
mask so we want a One
wherever and we have something that's
not a separator and a zero whenever
there's something that is a
separator if we take the characters from
over here instead of doing a membership
to see if they're there we can do a
lookup so this is and which position do
they occur in and that has the
interesting property that if it doesn't
occur at all like say the C here doesn't
occur in this list at all then we give
it the next index after the last index
here so anything that's a slash becomes
a one anything that's a colon becomes a
two and anything else becomes a
three you can see that here so we begin
with the two and then we have put the
threes here and then there's a one and
all we want to know here is whether or
not something and is a three so if it's
a three we want it to become a one and
if it's not then we want to become a
zero and that is simply comparing three
with that
so here's our mask and now we can use
that as before
with and this time a commuted partition
function because we have now the mask on
the right because it's a little bit more
of a involved expression not just um a
single
function and then we are petitioning the
right argument and that gives us this as
before and then we can use exact same
construct with uh with reshape as we did
or we can use a stencil as before to get
our key value pairs in a
matrix thank you for watchingwelcome to the apl quest cip wiki for
details
today's problem is the seventh from the
2015 round of the apl problem solver
competition
it's very simple we just are to extend
membership a bit so that it is case
insensitive
now let's start with two arrays let's
just take the first six letters of the
alphabet and also
some random four letters here
and if we try to do a membership here um
it doesn't work it says that none of
these members are none of these letters
are members even though clearly c and d
are and that's because they have
different
letter case
so
what we need to do is we have our two
arguments and we need to
case fold them which is a normalization
procedure done so that we can compare
kins insensitively
and so we
apply quad c which is case fault on
the left argument and also on
the right argument and now we can see
that c and d are indeed
members
but we can
make this look a whole lot nicer
let's start by
converting this to a tested function
so instead of using omega we're using
write tech instead of using alpha we're
using
left tech and that still works
but
this is a 2 train those are our tops and
we can then use the top operator instead
now we can observe that we are
we are
pre-processing
the left argument and the right argument
in exactly the same way
instead of doing of using the function
called c twice you can do it once just
using the over operator
so that's on the right and on the left
we don't need to state that
and we don't even need any parentheses
because this isn't a train anymore it's
a simple derived
function
however
the
problem statement says that
we should also it should also work for
high rank arrays
and that
doesn't work here
let's make this into a high rank array
here
three rows two columns and we also over
here two rows two columns
and now we should say that these rows
here are members
so the cd row is indeed a member of
the
matrix on the right and we should get 0
1
0
but if we try it
then we get a strange result
and that is because
membership works on element by element
basis so it says is a a member of this
matrix over here is b a member of the
matrix is c a member and it's d a member
and that's not what we wanted even
though we might think we could do an n
reduction across but that
and that doesn't work though because
that
would give us the elements even though
they're in this wrong order it would say
they're members
and that's we need the entire row to
match
what we want to do is we want to do a
membership between the major cells and
we can do that by
starting off
in isolating the members
the major cells with it over again so
we can say um membership
of
uh
case insensitively
on the enclosed major cells
and that works and there are different
ways that we could mix and match this
and
however
they're actually
a better way to do it and that is by not
using membership at all
instead
let's look at the result of tyadik iota
which is index off
with opposite
argument order
what this is saying is where do we find
the major cells from the right that is
now left on in the other argument and so
what it's saying here is that a b is
found in position three on the right
that is the next available index after
the last one meaning it isn't found and
cd is found in the first one and ef is
found well it's not found so three again
and
that means since we're not interested in
the actual position
only whether or not it's there then
if it's within the range that means it's
a member if it's outside of the range
then it's not a member and we're
interested in whether it is a
in the range what does it mean in the
range that means uh no more than the
length of
and of the element that we're looking
for so this is the length of the right
argument that's 2.
and so we can put this in and we can say
if
the index
of each one
done case insensitively is less than or
equal to
the maximum
then we know it's a member
and that gives us
our solution
we can give it a name
then we don't need parentheses
and then we can use the name in here
that's our solution thank you for
watchinghi
we're going to
find the locations of
characters in a given text
where those characters are followed by
an identical character immediately to
the right we don't want the characters
themselves we don't want the indices we
want a mask
that indicates where such pairs begin
classic example of a text processing
things in APL is using Mississippi
because it's got a lot of duplicated
characters and identical characters
spread out but it only however has two
identical characters in a row so let's
add a little bit more
where we have three in a row and we'll
have overlapping pairs what we want to
get here is
these are not the same that's a zero
these are not the same that's a zero
these are the same that's a one and so
on at the very end we want that these
two are not the same that's a zero these
two are the same one these two the same
um that's a one and then this character
is not followed by an identical element
because there are no more characters
there so we always end with a zero
let's start with Lambda and
we can refer to the functions argument
with Omega it's because the argument is
on the right and it's the rightmost
character of the Greek alphabet
and we always have the whole solution
right out of the box with an ny is
reduced this means we go over all the
windows of length 2 in this case and
reduce them using equality which
effectively just inserts the equality
between the two elements the two
characters and that gives us this which
is almost correct the only thing we're
missing is because there is no pair of
the less character with one more
character after it there's no zero at
the end
now and we might think that oh that's
that's easy to fix we can just stick a
zero on the end
and solve the problem however if the
argument is empty so it's the empty
string let's apply this Lambda on each
one of these
then we get a length error on the
invoice reduction because it cannot
find any pairs of link two
so how might we solve this instead if we
extend
the argument with a character that
doesn't appear anywhere then we can
solve the problem and we see that the
empty string indeed gave us an empty
result
however this is of course problematic if
the string ends with a plus we get the
wrong result we can never get a 1 at the
end because that last character even
though it's a plus here is not followed
by a character that's identical to it
so we need to solve this problem and
there are a couple of ways that we could
do so
um here's a little bit of a clever one
let's take the reverse of the argument
this gives us all the reverses and then
we take the first one which you can
actually see by the color here is
optimized so we're not actually
reversing and taking the first we
directly take the last one it's just a
way of expressing it
and so here we get a one
um and notice that we get a space here
and that is because the first coerces
out an element when it's there aren't
any elements it takes a prototypical one
which for text is a space
um and then uh the Plus for here
so this is the last element or a space
if there aren't any and then we can take
some filler characters that we can add
to the string to compare it just like we
did with plus before but we need a
couple of different ones because if the
last one is a plus we want a different
character
and then we can use a set difference so
this takes this set of plus and minus
and
removes all the instances of the last
character so we for the first one we
remove all the eyes then we remove there
aren't any so it doesn't sorry not the
old eyes the the ones there aren't any
so that doesn't matter the removable
spaces the holes aren't any and then
remove all the pluses and that gives us
just the minus left
and then we can select and the first one
of that
and this gives us an a filler character
that we can safely use the next
character cannot be both plus and minus
at the same time
in fact we don't actually need plus n
minus here because just like we used
first before and it coerced out a an
element when there weren't any using the
fill if we just use plus by itself
then we can see here we get plus when
plus is not the last character and we
get nothing when plus is the last
character if we do first on that then we
get a and
a space at the end and space is not
equal to the last character so it's a
safe character use even though it's hard
to see
okay so now we can take the argument and
concatenate it with this safe filler
character
and we can do the two wise reduction
and get a correct result
so this is one way to solve the problem
let's start over for a moment and try
something else
again we'll do the NYS reduction
but let's we know we want a zero at the
end
let's add a zero at the end so this is
concatenation with swapped arguments and
therefore we put it at the end we saw
before that
if you try to do this on an empty
argument
then that's not going to work we get an
error there
so
if we run the the NYS reduction here on
something with just one more character
then we get oh sorry we need to make it
into a vector and then we get an empty
result
and that would be appropriate result for
the empty case
so really all we need to do is if it's
empty we need to add one more element
and how can we do that well we can take
the length of the argument and let's go
back to the case that we had before
so here we have the length of the
argument and we don't want it to be zero
we want it to be at most at the least
one so we can clamp it using the max
function so this is the maximum of 1 and
17 and a maximum of 1 and 0. and that
gives us that this length
then we can use this to take and we need
to take it from the other side so
normally we take would take the length
on the left and the data on the right
but we want it Opposite so we swap it
around with the commute operator from
the argument itself
I know now we can see that we've added a
space only in the case where we have an
empty
okay now it is safe to do the NYS
reduction
and this gave us the correct result for
the empty case but we're still missing
the zero over here
what we can do then is to we know how
many elements we want namely the length
itself so we can take the length again
of the argument
and take with that and if take doesn't
have enough elements it will pad with
the appropriate prototype and that would
be a zero in a numeric case that we have
here
so this gives us a correct result
or both of them
now we can
this function happens to turn out really
nice if you convert it to a tested form
which means that we don't mention the
arguments explicitly rather all
arguments are the only argument here is
referred to
in terms of function application on that
argument
so it's pretty easy to see here that
what we're actually using is should say
an aspect of the argument which is its
length let's parenthesize this just for
clarity so referring to the argument in
terms of its length over here we're also
referring to the argument in terms of
its length here we're not referring to
it in terms of any function directly
applied to it and
but that would be the same thing as an
identity function applied to it and
luckily we do have an identity function
it looks like this it points as at the
argument
so now that we have
um
crystal out so to say indicated what are
indicated what are referring to the
argument looks like in terms of function
application we can then go ahead and
remove both the braces that indicate
this explicit Lambda or decent as we
call it and the actual name of the
argument
instead we're going to replace it with
round parenthesis
and so here we get rid of the names
and this works we don't actually need
these parentheses or around functions we
can just use the functions directly
this is a very nice
and clean looking train or tested
function for solving the problem
thank you for watchinghi the task here is to write justify
some
text and truncated it on the left if
it's too
wide if you want to read the full
description here then you can pause the
video okay let's start with a very
simple
example this is just a character vector
and we going to build a little Lambda a
function that takes the right argument
represented with the letter Omega that's
the right most letter of the Greek
alphabet not much going on here now the
important part is that we have to handle
a lot of different types of data so we
know need to normalize the incoming data
we can do that using very convenient
little function which is just like
inclose which wraps this simple
character Vector in an outer array but
it only does so if it's not already
nested so if we were to give multiple
elements of character vectors then uh it
wouldn't do the enclosure and we can
illustrate this so here we have it
enclosed if we give it multiple
things like this then we can see how
it's already nested and this does not do
any any further action
so let's go back to our simple character
Vector now we have this for later and we
know that we've got one level of
nesting we need to take a left argument
let's say uh five and that is the both
the the width of the final result but
that's also the how much we should
truncate
to and we need to right justify so that
means we need to um trunk it on the left
that is we want to preserve on the right
also know as to take from the right and
there's a take function in the APL in
order for it to take from the right we
need to negate the left argument so we
do that and then we need it to apply to
each of the arguments on or each of the
elements on the right so in this case
there's only one but that's fine so we
can see that gave us person and finally
we need to stack on top of each other
the very the individually trunk it
results if there are um more
so uh we do that with the mix function
that combines a nested uh array into a
flatter
array and that looks very simple if we
try it with
multiple then we can see that it it does
the right thing um as well now it's also
interesting to think about what happens
with a single and scaler because that
cannot just be enclosed but it really
works according to the spec very nicely
because it just stays the way it is and
then we take from each that makes it
into a vector um and then we remove that
enclosure if there is any so we can see
this happening
here we paded with spaces that's what
the tick function does if it if there
isn't enough data on a character data
and then the mix um takes care of that
extra enclosure and we get a vector like
we were supposed to get so this just
works this is a very nice easy to
understand Solution that's called that
F however um it isn't the most optimal
solution when it comes to Performance
because it uses these nested arrays and
modifies these nested arrays um looping
over them with the each operator and in
general that's an anti in APL let's see
if we can do better of course the
argument we get in is already
potentially nested this we can't change
that but we can try to get rid of that
nesting as soon as
possible so instead we're going to take
that
argument uh
here
we going to do the conditional nesting
again to normalize but this time we're
going to take advantage of mix padding
short
elements however the padding would
happen on the right which is not what we
want we want it on the left so we can do
this by reversing every element
first and then we do the mix which does
a p in and then we reverse the whole
result back
again and that gives us what we want but
it's not it's when it comes to
justification but not when it comes to
the truncation so all we need to do now
is the
truncation we
could negate the left
argument and then do a take this time we
don't want to take from the rows of the
result a matrix we want to take on the
individual rows um and that means we
want to apply to vectors those are rank
one so we do a take rank
one this could
work however since we
already uh doing this reversal then this
reversal happens on the entire data and
then we truncate it would be more
efficient if we could first truncate our
data and then reverse a lesser amount of
data so let's wait with that over here
now all our data is in Reverse which
means we need to take from the left
instead of from the right and then we
can do the reversal at the
end this gives us our result as well so
let's try to compare these let's call
this
G and let's copy in the cmpx the compare
ution facility from uh the defense
workspace and then we are going to
construct some sample data of course
three words is not enough to notice the
difference here so let's take the
alphabet and from the alphabet the
entire alphabet we en close that we're
going to uh to take over and over again
a prefix of the alphabet with some
random numbers so these are 100 random
numbers of length
uh of length 10 oh 100 random numbers uh
would be like this so these are 100
numbers that are 10 and then we change
them into random numbers from 1 to 10
and we use that to take from the entire
alphabet now I don't want to print all
of that to the screen uh let's get the
first 10 of that so we see some words of
various lengths of course it doesn't
matter what the actual letters are which
is why we're just using the alphabet
here good let's give this um a name
words and then we can use the compare
execution facility to do a five F words
and a five g words and see what um the
execution looks like give this a
moment and well that's significant and
we only talking about 100 words here if
you we were to increase the number of
words then and maybe their length this
would potentially give us even greater
speed
up can we do better we can but it will
get a little bit involved let's try
this so we want to take those words we
want to
normalize um normalize them into a list
of words in case there's only
one and we want to get rid of the
nesting as quickly as
possible so we want to do this
mix now however uh we have we lose the
information about how long they are they
could have potentially spaces at the end
and that information would be lost so we
do need to access the length of the
individual words in this nested list now
we know that it's uh
nested all we want to do then
is if we just take this as an
example
is we want to do a rotation you want we
need to rotate um these letters into the
right position where we can uh then chop
accordingly so how much do we want to uh
rotate them
well we want them to be in an aligned
such that the a um the longest word
stays in place and every and every
letter get sorry every word gets rotated
to the right by as much as the
difference is between its length and the
longest word's length so we can express
that rather directly
here we going to
rotate this so the way rotate works when
we already have a matrix because we're
mixed is it rotates each row separately
which is exactly what we want
and the amount that we want to rotate by
depends on the length of each word so
this is a now a fork so this gets
applied to this nested array and this
gets applied this gives us the length of
each to this nested
array and then we use the result to
rotate by of course this isn't right we
want don't want to rotate by uh the
length of each we want to rotate
by a function of the length of each
which is the density those lengths minus
the length of the longest one this is a
maximum
reduction so now we have rotated
everything to the right to WR justify
them but staying flat the only step
that's missing now is the truncation
which we know how to do
already there we have it yes it's a bit
involved
let's see if paid
off let's do
cmpx with f on the words and G on the
words and H on oh I misnamed
this should go up and fix that we still
want this
one and then this one should be
H you go h on the
words
that happens because I forgot the left
argument and we try
again now we're talking this is only for
100 words if it was larger amount we
would save a lot more so sometimes you
have to weigh off uh you want to keep
the code simple or do you want to keep
everything as flat as possible
and in order to get maximum performance
or could you find some on a balance in
between that's good enough performance
while keeping the code reasonably simple
so these were our and solutions we
had and we can see that yeah maybe maybe
this is good enough for your needs um
but with some reasoning you can find
ultimative flat solution thank you for
watchinghi and welcome to the apl quest c apl
wiki for details
today's quest
is the ninth problem from the 2013 round
of the fpl problem solving competition
the problem is to find
the average over a sub-period of a
year's worth
of data of numbers
so starting off with some data these are
some cells
the obvious approach here is to use
n-wise reduction
and maybe the simplest at least for
simple data way to visualize
invoice reduction is using the addict
reduction
using concatenation
so we have the sales
and then we can say for example a
three-wise reduction
of the sales
using concatenation where that just
concatenates together
groups of three elements moving over one
step each time
you can see we get these
little windows
and now what we want is the average of
each one of those so we can use
the very idiomatic epl expression for an
average
which is the sum divided by the length
and apply it to each one of those and
that gives us the solution where the
left argument is three and the right
argument is sales
however we should really package this as
a proper function
so we can do that these are two function
applications there's
the
comma slash using the 3s left argument
and we should probably use slash bars to
make this more general for a higher rank
in general
arrays
and then there is
the post-processing which is the
average function on each one so the
three can go outside here and then we
have on the top
the
ny's reduction is applied between these
arguments between three and sales and
then the average each is applied to the
result
of that so this is a basic solution but
by far
not the
best solution
and this is because we can actually go
in and apply
something directly to each one
because what we do when we do uh to each
sub
sequence
what we do here when we compute the
average is again and again we take
something of length three sum it
together and then divide count its
length which is always three of course
and then divide the sum by the length
instead what we could do
is we could
we could just do the
three wise reductions
and then all of those could be divided
by three
that was would give us the same
and we can express this as a little
defend
so what we want is
the left argument which is the size
that wise reduction over the right
argument
and then we divide that by the left
argument
that gives us the result and this is a
much better way to do it
and certainly much more efficient
and we can even express this as a tested
function because it comes out very
nicely that we have
a function applied diatically between
the left argument and the right argument
and
a middle function and then
a selection of the left or right
which can be expressed in terms of
function application as the left
function
applied between the left and right
argument and that is a fork so we can
simply get rid of all these mentions of
the argument
and
get this beautiful solution
and that is as as good as it gets for
the specific way that this problem has
been stated
however there's an interesting edge case
which uh
the testing framework if you look on
problems.trypl.com it does sorry
probably the tribally dot org does not
include but we could say that
the n the window size is larger than a
year
so for 12 we get the entire year
averaged for 13 we get no averages
and for 14 we get an error so how do we
handle
things that are
so window sizes that are more than one
step larger than the entire data that
we've got and there are many different
ways we could go about this i will have
a look at
some of them for this particular problem
an average obvious approach
would be to go back here and simply
clamp
the argument so we have the left
argument but the under no circumstances
will should it be larger than 13 if it's
larger than 13 then we just want it to
be 13. so we take the smallest value
of
the left argument and 13
and
and replace it with that
and
this works like normal as long as the
left argument is small
and it works fine with 13 and it works
fine with greater values
as well
now you could observe of course that
when we're dividing by a number
if ever the left argument is 13 or
greater then that
means that what's on the left of the
division sign is an empty vector in
which case it doesn't matter at all we
divide by there are no divisions going
on so we can remove this clamping from
the right and it will still work
we can also generalize this of course so
that it works on any number of
elements in cells
and we would do that by
simply adding one to the length of the
cells so this is a more
general purpose
solution
we could also use our original
formulation
and using
the
little train that we had before we
simply used the clamping size on the
left
and then
the fork which was the end wise
reduction divided by
left
and then the data on the right
and this will work as well and it works
for
these values that we have been using as
well
and we can if we want we can
get rid of this parenthesis by moving
things around
so we can put
this plane argument on over here and we
can put this formula on the right and
then we could swap here
and this would work
however um since the only thing that's
inside this train is a tech right or
left
and another function we can also move
this
over on
and
on this function and simply turn the
tech around to be on the right and that
will still work
we can also unroll the whole thing
because we can see that
what's actually happening here is that
the n-wise reduction
where this is the n
and then over this and finally we divide
by the left argument so we don't even
need a train here inside the stephen
then we can go ahead and make this tacit
if we want
and there are various different ways we
can do that but here we can say we want
the tally of the right argument
and this is the left argument
we want the n-wise reduction over the
right argument and then here's division
by the left argument and this would be
the uh that's acid equivalent
it's not necessarily better but it's
possible to write it like this
and then there is a
a code golf trick for those that want to
make the show the code as short as
possible and that is when we
add one to the length
then
we could
actually get that out here where we are
anyway applying the function
tally
atop
the selection of the right argument
we can include this one plus by
concatenating the arguments since the
left argument here is always going to be
a single number concatenating it to the
right argument gives something that's
not meaningful but it has the right
length namely one longer than the
original right argument and so we can
save a little bit of code here
by doing it this way but it's obscure
and we are and it's not efficient either
because we are
we are inserting an element at the
beginning uh of potentially a larger
amount of data um but if short code is
what you strive for and you want people
to and not understand what it is you've
written then this is the way to go
a whole different approach to dealing
with
with this problem of the length error is
to simply try it and then catch the
error when things go wrong
so we can
again write our formula as we did before
uh where we say that we
divide by the left argument and then we
have this n wise reduction on the right
argument and that works fine but when we
do something that gets too big
then we get a length error now length
error
is
error number five
and so we can say we set up an error
guard whenever any error number five
happens return the empty vector
and then it will return the empty vector
but this you might also wish for
a specialized operator
and one that allows you to choose what
happens when an error
happens how should we react to that so
here we had an explicit
guard but we could also use a
function that can't handle the error and
instead combine it together with some
kind of error handling function for an
overall function that does handle
an error
and this exists for example in the j
language where it's called adverse and
we can actually use apple cart to find a
definition for adverse
and we find this definition i have to go
into exactly what it is but we can just
give it a name
adverse
and now we can use it with any
definition that we had from before so we
can say we want the sum divided by the
left argument
but
if anything goes wrong then instead we
apply a function which returns the empty
vector
and so this works as before as long as
nowhere error happens and when an error
happens then we apply the empty vector
function
and we get an empty vector result
however
i prefer when i do apl to not rely on
catching an error and continuing rather
i test my
my input and make sure that everything
is okay with it so i would do that in
this case by writing
an
assumption that if
the left argument
is greater than
the length of the right argument
then return the empty vector
otherwise we can do whatever we've been
doing before
and that works um as well no error
handling include involved here
finally there's an issue here if
the
if the input has higher rank we're
already using slash bar instead of slash
in order to handle higher rank things
but
if the length doesn't uh is too large
and we end up with this guard the
results from the guard
then the result isn't actually correct
yes it has to be empty but not the empty
vector
say that we have the sales
in a matrix
with a single column
and then we're doing this uh
with this
end wise
average
down the columns
that means we are
reducing the number of rows in the table
but the table is still a one column
table
this means if the left argument is too
large we should be getting a zero row
table but not
a empty list
so if we make
sales into a one column table then
it might look okay
but if we look at the shape of it it
isn't quite right whereas if we do 13
here
um
yeah so this is also too large and 12
would be
a one by one table
if instead we redefined our function
such that
and
that it can be
larger than one because we know that
when it's one
one larger than so
then it's the end wise reduction still
works
if we define the function to only go
into the special guard when it is more
than one
with the left argument is more than one
larger than the length of the right
argument then we can observe here that
we get notice there's no blank line um a
zero row one column table
and that this function doesn't work work
for
the problem is of course that we
universally just return the empty vector
if
the left argument exceeds the length of
the right argument what we really should
do is preserve the entire shape of the
argument only compressing the
height of the table to have no rows
if it's a two dimensional table or if
it's a larger array we want to compress
the first axis to have no content and
the way we can do that is instead of
returning this empty vector blanket we
use zero to compress along the first
axis the leading axis and the right
argument and then we will see that
it now works even for large arguments so
this is the
ultimate
industrial solution
thank you for watchinghi
now we continue
from the previous problem where we were
making the grades and here we compile
some very simple statistics in a table
on a given set of grades
so we are supposed to have three columns
the First Column is just the grade and
that will go from a to d and then F and
then we have a column that says how many
of each there were
in the given list of grades
and finally we want the percentage but
what we do want it as a number we also
wanted to round it off to look nice
so up to a single decimal position
here are some sample grades
now it happens to be that all the grades
are present and they're all in groups
but it doesn't matter as we'll see based
on the algorithm
here's a little Lambda
a different
we can take the right argument here
with Omega the rightmost letter of the
Greek alphabet
we could also take a left argument
and if you were to do that then I would
for generality you use the alphabet of
letter grades
like this
however there is a
um so here we have the left argument and
the right argument next to each other
however there's a trick we can put in a
special little statement diamond is the
statement separator because diamonds are
Unbreakable
if we try to assign to Alpha which is
the leftmost letter of the Greek
alphabet indicating the left argument
when there is already a left argument
and then that whole statement is ignored
however if we do not supply of left
argument that statement is executed
so I think that rather than using a
regular variable to keep these letter
grades we should use Alpha because then
if you want to override it with a new
system that uses different letters that
will work too
hmm
okay now we are ready to get started
we've got our left argument which are
the letters of all the different grades
that can appear we have the right
argument which are the greatest in
question that we're going to compile
statistics on
and the first thing we want to do is
find out how many there of each then we
can use that to compute the percentages
and one way to do this is to do an outer
product well it's called Product but
it's really not a multiplication here
but an outer equality that means we take
every element on the left those are the
letter grades and compare to every
element on the right those are the
grades coming in and we get a comparison
table
so here we can see that since we begin
with a bunch of D's and each row here
but since one grade A B C D we get a
bunch of ones here and then we get a
bunch of A's they are up here
and so on
of course this means that we can do the
count of each one simply by summing and
rewrite that as a plus slash
so here are the sums or counts if you
want we can call that s
in order to compute a percentage we want
to know how many letter grades are there
in total we can use the tally mark to
tally the number of elements in the red
argument
then we can take the sums and divide by
that giving us fractions
in order to get percentages we want to
multiply by a hundred
and then we want to round off to a
single decimal and here's a neat way to
do it but maybe not the best we'll fix
that later
we can use the format function which
converts numbers into characters so this
becomes one giant character Vector with
digits
you won't be able to see a difference
because it has the same texture
representation however we can give it
the left argument which is exactly the
number of decimals
if you were using a negative left
argument it would be the number of
significant digits
we can try that for a moment so if we
say we want
two decimals
we can see that we get 9.68 but 25.81
if you do negative 2 then we get a
scaled format so that we can indicate
the Precision exactly and we say we get
exactly two but for now we just need a
single decimal
this is not a num an array of numbers
this is an array of characters so we
want to convert it back again to
numbers
and
with that we just need to construct our
table
this is a vector and we need to have a
matrix that is a table a two dimensional
array
we can use the table function to create
a table from a vector
so here we get a column vector or single
column Matrix and with that we can
concatenated together with the sums or
the counts of each one and finally we
can concatenate on the far left
the letters themselves
and this solves the problem
however
going via a character representation
seems a bit iffy just for rounding
especially since the way we're going
back again is actually execute or
evaluate so we're taking this whole
character vector
which are all these rounded numbers and
executing them as APL code
that's generally a better idea both for
performance but also for safety if
somebody were to somehow inject
something in there that's dangerous then
our whole system could fall over
let's do this the arithmetic way instead
we don't have a round to a specific
position function in APL however we do
have a flooring function we can write
rounding in terms of flooring we don't
want to run to to whole numbers we want
to round to Tenth of numbers so instead
of multiplying by 100 let's multiply by
a thousand that gives us tens of percent
now we just need to do the rounding but
flowing is not going to give us the
right result this is floor you can kind
of see there's a wall and a piece of a
floor
and that is because we need to round up
when we have seven and eight here in
fact from five and none of us we want to
round up and this just runs down its
floor
if we lift up all the numbers by a half
then anything that is ends with 0.5 or
higher will be lifted into above the
next higher number
and now we can see how
96.7 and 225.8
were rounded up whereas everything else
was rounded down so this is the type of
rounding and that we want to do but our
numbers are too big now we want to
divide them by 10.
of course this is 10 divided by but the
commute operator can swap the and the
arguments to the division function so
this is
10 into
whatever we have over here
rather than the opposite
and this solves our problem in a safe
and efficient manner
thank you for watchingwelcome to this episode of the apl quest
c apl wiki for details
today's quest is
generating an identity matrix of order n
very simple task
um but a lot of interesting ways we can
do this
and let's go get started with some
serious solutions and then look at some
more fun innovative solutions after that
so the first thing we can do
is
that we have a number n let's
for argument 6a that n is five and we
want to make a matrix that is five by
five so we can calculate n to itself
giving us five by five
next up we can generate all the indices
of an array of shape five five
and we can take these indices and look
at where the horizontal and vertical
index are the same by comparing each
this gives us our identity matrix
however we can do this in a simpler way
we only need to generate the indices
until
n
and then make
an
inequality table using the outer product
and the selfie or
commute operator to use the same indices
on both sides of the quality
and in fact this is our
simplest solution
so just
the outer product
selfie on the indices
it isn't a very efficient solution
however because we are comparing a lot
of numbers in general that we have
generated when we actually know where
the ones are going to be in advance
so what we can do is we can start off by
creating an empty matrix
of zeros so we take n
and
use that twice to reshape zero this
gives us
a big
empty vector like this an empty matrix
like this no it's not empty it has big
zero matrix like this
then we can use dyadic transpose which
selects the
um
it can collapse dimensions so that we
get diagonals we can illustrate this by
saying 5 5 reshape iota 25
and then we can use the attic transpose
mapping
both dimensions to a single dimension
and that gives us the compromise between
them diagonal
so now we can use this with a selective
assignment
we say one one
transpose of s
gates one and the one that gets
distributed over the entire s
and now s has been updated to become an
identity matrix we can put this into a
function
as
s gets
omega omega reshape zero
and then the diagonal of s gets one and
then return that s
and we can now give it the argument five
fine
and
this is verbose but it works it doesn't
have the best performance necessarily
and it's a bit awkward because we have
to have this middle statement where we
update s before we then return s
we can also use the add operator to do
something similar
we can start off by generating all the
indices that need to be set to 1. how
can we do this well if we start with
uh
with this iota n um in in our case then
we know that it is the
uh the elements of position one one two
two three three four four and
that need to be set to one
so what we can do is we concatenate
selfie concatenate to itself each one of
them and these are the indices
that we need to
set to one
and then there
we can
use this
setting one at
those
indices
in
the array
that is n and reshape zero
and that will give us
an
identity matrix
we could also use these indices in a
different way
and namely we could
say give me a boolean matrix that has
ones in those positions so
where are all the
ones in the boolean matrix is magnetic
iota underbar
and the inverse we can use power
negative one
on that and that gives us an identity
matrix as well
there are even more things that we could
do
along these lines instead of using a
matrix we can use a vector
and
the way we can do that is by observing
that this is kind of an encoding
of
in in a special radix
so
we want
ones
and then when we do things like that we
we need to see set coordinator to zero
otherwise it becomes too complicated
so what we can do is we have the indices
um iota n here
and then
we can multiply those by n
and
so this corresponds to
um
let's see number zero is this element
and number five is this element and
number ten is this element in revel
order
however we need to offset one for each
one so if you take these indices and add
them to this that gives us in revel
order
that diagonal we can actually see this
if we say 5 5 reshape by yo to 25
we can see that 0 6 12 18 24 those are
diagonals
and once we have those we can then use
the add operator as before so we can set
the ones
at that
in a vector
which is
zero
reshaped
to the shape
of n squared
and this is our flattened identity
matrix now we can take the proper shape
and reshape it and we get our identity
matrix
let's change back to quarter one index
origin one and then actually do some uh
the best performing solutions
and and that we can observe similar to
what we've done now we can see that
there are exactly n zeros onto the next
one and then again n zeros to the next
one
so what we can do is we can begin with a
one followed by n zeros
and then we can reshape that cyclically
into our full full shape we'll use n
here
and this is almost as good as
it gets there's one problem for a very
large
n
and we create a boolean vector of all
zeros and then by inserting one at the
beginning
it gives us sub-optimal performance
because we need to copy this entire
array one step over shifting everything
by one bit to insert that leading bit
how can we avoid that
well
we can use overtake so if we say n take
of one it pads with additional zeros at
the end
and the only thing we need to do here is
really adding n plus one
and this gives us the full row and now
we can reshape into that shape so this
is going to be the best it gets we can
put this into a function
as omega omega reshape
omega plus one
take one
and we can also make this into a tested
form and we can play some tricks there
so let's split up the problem omega
omega that is the self concatenation of
the argument
then we reshape that
and then we want the argument plus one
so we can tie
or bind
a 1 to plus making a magnetic function
so that's an increment function and we
use that to take from well we need a 1
here but we can't have 1 at the end of a
tested function
because it's a constant not a function
we can transform it into a function
using uh the constant operator
so we can try this as well
and that works
and then for a little bit of uh of
trickery we can actually
avoid this construct of one constant
by observing that the
sine
of five
is one
and the problem was that we needed on
the right hand
to have a function not a constant
so this is a function applied to any
number that's relevant and we get one if
we want the zero by zero it doesn't
matter that the sine of zero is zero
it will still work because we it becomes
an empty array
so it doesn't matter that we are taking
from 0 there so we can do this we can
say i5 like this another possibility
is observing that how many elements are
there in a single number there's only
one and that applies even to zero
and so we can
we can do that as well
so this is a
this is the fastest solution that we're
going to get this is a proper solution
whether you want to use a tested form or
a defend it should be about the same
performance
now onto some more fun and innovative
solutions that we could do
and remember again that we needed a
single one followed by n zeros and we
can actually do that using expand
so if we have
uh if we have a one representing that we
want
um
one one and then we have negative n
representing
n fill elements we can use that with the
expand function on a single one to get
the same thing and then we can reshape
that
to our identity matrix and we can write
this um in a tested form and so this is
again the self-concatenation
reshapes
one expanded
by
one
followed by
the negation
and it works for
zero as well
what happens in the zero case is
negation of zero is zero so we get one
zero that means we expand one as a
single one with no fill elements reshape
that to zero zero and we have an empty
numeric matrix so that works as well
um
here's one that almost always works like
there is an astronomically small
probability that it won't work but it is
rather fun
let's say we have a
matrix
of uh
random numbers so
with the zero as argument question mark
gives us random floats between zero and
one so they won't be zero they won't be
one
and it's
exceedingly unlikely that we'll have
duplicates here of course
now if this is a matrix
then
there must exist a matrix
such that
m and multiplication here means matrix
multiplication we can we can write that
as cluster times um
will give us but in traditional
mathematics just at times will give us
the matrix itself and that is the
identity matrix
now if we move things around around on
the in this equation we'll find that
dividing the matrix by itself should
give us the identity matrix and indeed
that is so
so we can do
m
matrix divide with m and that gives us
an identity matrix and we can write the
whole thing as matrix division
selfie
on
the random numbers
of the self-concatenation
of zero
so here's a constant zero again
you can try this
and it works
similar to what we did with sine and
tally to get a 1 there's also a function
which
for
a single number a scalar gives 0 and
that is the depth function
so the depth of a single number a scalar
simple scalar is zero so we can go up
and amend our function to this very
obscure looking thing
which works just fine and is very very
inefficient because api will have to
solve an equation system
every time we generate an
identity matrix but hey it's fun right
here's another one which is
very very inefficient
let's think about this we've got
the indices up to n
um if we subtract these from n itself
that gives us
descending powers
from four down to zero
raised two to the power of that
and we've got descending powers of two
and now if we go up and look in our
identity matrix then we can see that the
first column
is
16 spelled out in binary and the second
column is
8 spelled out in binary and 4 and 2 and
1.
so this means that if we represent all
these numbers
in a
in
base 2
then
we
we would get the identity matrix so we
could do something like this
which
auto sizes but we already know
that we want n bits so we can say n
nreship2
encode on that
and that works as well and then we can
make the whole thing tacit
by saying that it is the reshape of two
so this is a magnetic function which
reshapes two
encodes 2 to the power of the argument
minus
iota on the argument
so this works just fine
but again very inefficient doing base
conversions when we just want to create
um
an identity makes it but fun it's fun
okay a little bit more and of
fun
we can
um
we can generate the negative indices
and then we can overtake like we did
before
on a1 so each one of these will be used
to take
from
a1 so it takes from the rear padding
will
zero us at the front
oops that was too much
missing in each there there we go
and now we just need to stack them up on
top of each other and there are various
ways we could do that
we can mix
or we could
use
the rank operator so we want to pair
these up we need to do take
pair these up with one
and then it mixes everything together so
that works as well
and now we can
put all this together to create an um
a tested function so we have the
negation of iota take rank 0 on remember
how to get a 1 without using literal one
we could use tally for example
so this should work as well
and here's our density matrix in the
rather
roundabout way
another thing we can use is scan so we
can get normally prefixes
of
a vector
like this if we instead of concatenate
so this is a cumulative concatenation we
do a cumulative
swapped concatenation
then we get these reversed
prefixes instead
okay
so if we can have a way to get reverse
prefixes
and
we have a way to get
one followed by a bunch of zeros
then these give us our rows and we just
need
to mix
and so we can write this as an
as a function
the
conclusion
swapped scan
and off
the
take
of
one so this is an end take
one
and then
we mix that then we just need to put and
a top here so we have
two functions after each other
and here we got our identity function in
a very roundabout
manner but lots of fun again
and
now let's move over to the key operator
which we can also use for this
so we can generate our
our indices like this
and then we can ask the key operator
what are the indices so let's put it
like this
but now
so this is saying index one is found or
the number one is found at position one
the number two is filter under position
two only number three is found at
position three that means the alpha here
is one and omega is what
f plus 2 omega is 2 and so on
now we can use take
here
and that gives us
these vectors
and we can see how where we're going
with this
we can then reverse this
and now we just have the problem of the
sign
so we can take the sign of all of this
and we need to stack them on top of each
other as well
so we could mix it like this but there's
a better way but not enclosing them we
already get the mix for free and now we
just need to get the sign
here
and then we can make this tacit because
it fits very nicely it is the reversal
on top of the taking of these two
arguments
and that gives us
our
identity matrix it's not quite a
function yet
but we can make it so by combining the
key with the indices and now we have
our identity matrix generator in a
totally obscure way that nobody will be
able to understand don't do this in
production code
let's make it worse
let's start again with um
with this construct
and
here we are only interested in the right
argument
so that gives us these vectors
of
um
indices one by itself two beta three
beta four by five by itself and remember
we used the uh iota underbar the where
inverse to generate a boolean array and
that has ones in those positions there's
only one position in each one but
we can still do this
so
this gives us these vectors and yes you
recognize this remove the enclosure
and we've got our identity matrix
and we can combine this we can make the
operand
test it simply by saying that it's this
where inverse on top of the right
argument we have to have that because
there's a left argument as well
and so this is our function
and
that works
again don't do this in production code
but it sure is fun to look at and then
somebody asked during the live chat
event
if we can't use complex numbers for this
and of course we can use complex numbers
for this okay let's get started
so
we have these indices
and let's make a table of complex
numbers so we do the other product of
the real part
plus the imaginary part so we multiply
the imaginary units
with these indices oops there shouldn't
be n here it should be
that and that gives us a complex number
table so this is 1 plus 1 i 2 plus and 1
plus 2 i 1 plus 3 i next row 2 plus 1 i
and so on
and now what we need to do is we want to
find out the ones that are down the
diagonal
and both actually down the diagonal we
can kind of see the angle of them but it
also happens to be that in a complex
plane these will have an um
an angle or an also known as the
argument
which is 45 degrees or a a quarter of pi
so we can ask for the argument of that
and we can see that going down the
diagonal they all have
that
0.785 and so on
now we can multiply that
by
or
or rather sorry divide pi by that
so the same thing as taking the
reciprocal and multiplying by pi
and then you can see that gives four and
now we can say
where is 4 equal to that
and that gives us our identity
matrix so this is our full function
would be
to
we could either do iota
omega here or we could just use omega
and put iota outside that as in the top
and we've got
our identity matrix producing function
here in a terrible way using complex
numbers and as if that wasn't enough
let's go in and modify this a bit
so starting again from here with our
table of
complex numbers
we can also ask
what is the absolute value or the
magnitude of these numbers
and
since they are on the 45 degree angle
that means that
the horizontal and vertical parts
in this right angle
triangle
are
equal to each other that means that the
diagonal's length has to be a multiple
of the square root of 2.
so we can ask what is
the divisional remainder when these
numbers are divided by the square root
of 2
and if there is no remainder
then and we are at on the diagonal so we
can compare this with zero and we get
our
identity matrix using complex numbers
that's enough fun
and what you should do of course is use
the solution
where we take the argument twice reshape
with one plus the argument to take over
of
and of one or you can use the tested
version
where it's a self-concatenation
of the reshape
of the incremented number take off
one or as a constant or you can use
the sign or the tally if you really want
to go there but these would be the
industrial strength
versions you can also go up and if you
don't like parentheses like i personally
don't do
then you can swap the arguments of this
take as well
that's perfectly acceptable
as well
thank you for watchinghello and welcome to this apl quest
episode c apl wiki for details
today's quest is the last problem from
the 2013 round of the apl problem
solving competition
we are simply given a set of linear
equations
and
the values that
those equations add up to and then we
are to find the solution for the
variables
let's start by creating this
equation system
so we'll have a simple example of just
three equations with three variables
so this is saying um
four
x plus one y plus z
and
two of each and then six x plus three
y plus z
and they should add up to a result which
is two
six four
so four x plus
one y plus then 3z
equals 2 and 2x plus 2y plus 2z equals 6
and so on
and a solution to that is if
um
x is
negative one
and
y is three and z is one
and we can check this so
um
we have the matrix
and then we'll multiply
each
row
by
these values
and then we can sum them up
and we can see that
we got these results so indeed
four times and x where x is negative one
plus one times y where y is uh three
plus three times z where z is one gives
two just like we're supposed to have it
we can write this and a little bit
neater
as a
inner product
and so
the problem here is that we don't know
this result negative 1 3
1. we want to compute it what we do know
are these values
2 6 and 4.
so in other words we want to find
a v
and
such that
m plus dot times
this value
gives
2 6
and the missing right it gives 2 6 4.
yeah
so this matches an r
and luckily
we can actually
write this up so we can say we want
um
we want to apply this negative one time
to get this value
this is a
power negative one applying a function
in reverse applying it negative one
times really asks this question
what argument in this case right
argument we're giving it the left
argument over here what right argument
can we give to m plus that times
such that we get
r
and that solves the problem
now in
in the problem specification and r go is
the left argument and m is the right
argument so we can type up our solution
as plus the times
operator negative one
commute just swap the two arguments like
that and then the matrix goes on the
right and
the vector
goes on the left and that's a proper
solution
however
um
we
um and we can check this of course we
can check that that v matches uh matches
this oops
however
this matrix multiplicity multiplication
um in reverse it's actually the same as
multiplying by
the inverse
so
we can and the inverse of a matrix we
have in apl as a primitive
we can
then state this instead as multiplying
by and
the
inverse
yeah
the inverse like that and then we can
glue them together
so it's the same thing as
the explicit formula like this but for
now we'll have it in a proper assignable
function um like this so this is a
multiplication by the inverse and the
dyadic form of uh
of this character which is often
nicknamed domino it looks like a one one
domino
is actually exactly that
so the entire solution
can just be that
in other words
this problem has a one character
solution in apl
now that's of course uh lots of
and fun but it would be nice to see how
we could really solve this without apl
just doing all the work for us
and there are a couple of ways to do
this there's a really clever
way to do it
called the hoteling buddhic scheme if i
pronounce that correctly
and it states that we can do an
iterative approach to approximate better
and better uh
the correct solution to an inverse
of a matrix and as we had before if we
it's easy to do matrix multiplication so
if you have the inverse then the problem
is basically solved
and it states like this
that
we're going to
to iterate
um
with
this um
result
where every iteration depends on the
previous value
and the previous and
we are going and and the formula looks
like this i'm not going to go into
exactly
how
why this works but this is what they
state you can see look up their paper
so this is um this is what they say
that
the next iteration is the previous
iteration
matrix multiplied by
two times the
identity matrix minus um
the
the
grand matrix that the original matrix um
that has been multiplied by the previous
iteration
and we can rearrange this
formula a little bit
and we can
take this vi here and so to say multiply
into the um into the parenthesis
so that gives us
2vi
because the vi multiplied by the
identity matrix is
just vi of course minus and then and
vi times
a which is the original matrix times
v i again
and we can then state this in apl the
way we would write that is it's we can
write 2vi or
we can
so
2 times
vi
minus vi
plus dot times which is the matrix
multiplication
and a
plot plus times
and vi
and we can
break this
avoid the parenthesis simply by having
two v i's here instead
it'll be the same thing as multiplying
it by two
and now we can make this a function of
the original matrix on
one side so we have a
and then we make a function and we have
the previous iteration as the right
argument so we'll do it as a test
function so we start from the right here
build it up first we want the matrix
multiplication of them plus the times
and then we want to multiply by vi again
so vi is the right argument plus that
times that
and then we want to subtract this from
vi that's the right argument minus that
and then we add another one of the right
arguments we can write it up like this
so here's a
a tested way to compute this and this is
one iteration of it
um
however we actually want to keep doing
this until it becomes stable
and the way we would then
write that
we could take it as a function
where the right argument function of the
original matrix here called a so that
becomes
fed into
our
inner function as a left argument and
then we keep iterating
with the power operator until two
consecutive iterations are the same
and so we then we just need to apply
this whole thing uh on our initial guess
and that's the next problem so
the problem is it's kind of hard to find
an initial guess which will
work out for us but recently someone
named solemani came up with a surefire
way to determine
an initial guess
and
what he stated was that
transpose of the array divided by the
trace
of
of the matrix
times its transpose is a good starting
guess that will always come up and again
see his paper if you want the details of
how exactly that works out
so
we
again the trace
of the
matrix times its transpose and then we
divide the transpose
by that so first we do the trace of the
matrix times its transpose
we can
have this matrix m
and
we can transpose it
and then we can
do it matrix multiplication with itself
and then we want the trace the trace is
the sum of the major diagonal from top
left to bottom right and that we can do
as a 1 1 transpose that's the trace of
that
and then we sum
sum that up so for our matrix m here
that magic value that we want to divide
by is 84 and then we would go ahead and
and divide the transpose of
of m by 84 and that would be a good
starting value now
this can be we could use this but it can
actually be simplified a little bit and
for that we need to observe some
characteristics of doing exactly this
the trace of the um
of the matrix multiplied by its
transpose
so what we're going to do is we'll start
with a um a matrix that is easy to
recognize where the bits and pieces are
going
and instead of doing an actual
multiplication with itself
we are going to
to take
and
model the plus and
the times as functions that are just
saying what they would do
rather than actually
doing them
oops there should be a times over here
okay so so this is
this will show us that we give great
little boxes are showing us what's going
on and we need to multiply
it with itself with the right argument
to the matrix multiplication being
transposed
so here
we can see
all the results that we're getting but
we're only interested in the diagonal
so um
we're taking the one one transpose of
that
and now we can observe exactly what's
going on right and remember we the trace
is the
is the sum of these so really what will
happen is we're going to add all these
together all these little boxes and
notice that is
1 1
multiplied by each other and 2 2 3 3 and
so on
that means
every element of the entire matrix
gets
multiplied by itself squared
and then
we just sum all these
squares together
which means we can state this much
easier we can just
revel the uh the matrix
square it
and sum it or we could
we could of course square it first revel
at the summit um
many different ways
of doing that
we can also combine
this
summing and the multiplication
into an inner product
and that means that if we're doing going
to write in the training we want this as
short as possible then we can write the
revel cluster times the revel of the
matrix and that gives us that and um and
now
we just need to take the transpose of
the matrix and divide by that
so we can take the transpose divide by
this and that gives us
our starting value which isn't
very interesting
to look at but let's put all of this
together
so what we
let's go up in and get it from up here
we had this formula right here
and we stick it in here
and this is
then the inverse
that we get we can compare this
with the inverse primitive and see we
got the exact same value
and now remember how we solve this with
with v
so we can go in and
say
[Music]
v plus that times
this inverse
oops sorry
it should be must be like the other way
around
what am i doing wrong
here oh
here we go
um or instead
and this is a solution but it we want to
glue these two things together to be a
single function so this is this right
part here is the inversion of the matrix
and the left part is the
um
is the matrix multiplication so we
multiply with the uh
with the inverse and that gives us our
solution
and we can and remember this is an
iterative thing so here inside here is
the uh the power match which just runs
over and over again until two
consecutive things and match each other
it would actually be neat to see how
this
would look
we can do that by doing each iteration
separately now i happen to know that we
only need to go through 11 iterations so
on
for every one of
numbers from
1 to 11 we're going to apply it that
many times
and that then we can see the progression
of better and better values for x y and
z
to solve this system until
we're done it becomes
stable
so this is a a modern computational
approach to this
traditional way that you might have
learned in school
is the ghost jordan method
and you can find it in the defense
workspace
here is an adapted
version of what you found what you can
find there
i'll try to explain it a little bit
what it's doing here it
if you learned in the school you would
have learned that um
there are these various actions you can
take on your matrix together with uh the
the result values
to slowly uh
build up diagonal matrix and then you
um
have the solution
when we running it as computer code then
we we don't can't go by by a feeling of
what's in what's easier instead we just
go through all the steps every time so
what we're building up here
at the bottom is this is our equation
system these are the uh the final values
that we're putting next to it and then
these are the reversed indices because
uh reduction runs from the right to left
so that's what this comment is trying to
say that this is what we're going to
to reduce over so this just eliminate
here eliminate here eliminate here in
this order
and every time we eliminate
we choose before precision reasons
we choose
the row that have has the largest
magnitude so this gives us
a specific column and we start so
because we don't going down diagonals so
first we start the first column
and then
we get rid of the the first few elements
that have already been
those for those columns that have
already been
taken care of
of course with the first one that means
we're dropping zero notice that the
index origin is zero up here
and then we look at the magnitudes and
choose the largest one and that's what
we call our pivot row
and then we swap things around so where
we're up to in the nth row and the pivot
row
we're taking those and just flipping
them there's just two of them
so then reverse just swaps the two
around
and now we've got um
a matrix that's modified by having these
two uh swapped around
and then we want to um to normalize such
that in that corner or should we say of
of the
sub matrix missing rows and columns that
is uh on the
intersection of the nth column and the
negan's
row that's why we have alpha semicolon
alpha here and we we divide that we
divide all the other values
there so that
we get a 1.
and then finally we we have the step of
adding or subtracting
and the way it's been done implemented
here is we are adding subtracting not
just for that single
for single row but we're doing the
entire
matrix so it's built up using masks
essentially
we when we add or subtract
0
then
nothing happens and we're using a mask
so
2
that's right here these are all the
indices for all the
all the rows and then we have a specific
row number here which gets uh
so wherever it's different from we get
zeros and that means we only get one on
this
uh single uh single row
the then we pick out from the uh from
that column there
and uh and create a matrix
with
all the values that are in this
particular row
and then that effectively just we have a
bunch of zeros and we subtract the right
values in the right place
once that that's done since we've done a
reduction we have enclosed so we open
that up
and we're not we're not interested in
the entire matrix with uh result values
rather we can chop those away
so that's what this is doing
and
then just in case they were all
identical we used a single value we just
reshape it to have the right shape
and that's how the gauss jordan method
works we can try that it solves the
whole thing immediately and like this in
exactly the same way
and then i i happened to look up in an
old uh the old paper on apl 360
and
it was actually interesting it brought
us an example of of code and this
function which is a inversion of a
matrix
but implemented in um in old style apr
i'm not going to go
through and explain this you can do it
on your own it's really very much it is
the ghost jordan method it's very much
the same but in a
you know old style without using any of
the new and new operators i've altered
one slight thing you can see a capital a
in there
and that was an original function in apl
360. they it had some functions called
alpha and omega which were prefix and
suffix vectors so uh
alpha or which i've changed to an a here
because alpha is now meaning something
else
and you can define it like this
in the in our case here
where it's so the left argument is the
length of the vector and the right
argument is the number of leading
ones in that boolean vector
in our case it could just be a take but
i suppose uh overtake meaning you can
take more elements than there are in
array wasn't uh supported yet in at that
time
so you can actually replace these a's
just with an up arrow
and this gives us our an
inverted matrix as we can see from
before
same thing as the primitive
and that means that we could
we can do the same thing
here
with uh
multiplying the result of the inversion
with
our result
our desired result values
and that gives us our values for x y
and z in the very oldest of fashions
so this concludes the first
year of
apl problem solving competitions
and we're now going to continue next
time with the problems from 2014.
thank you for watchinghello and welcome to the apl quest see
apl wiki for details
today's quest is called floaty boat
we are to select
the numbers from a vector of numbers
that are floating point or none integers
and this is problem seven from the 2013
apl problem solving competition
it's a bit of an interesting
thing
that it's not well defined what exactly
constitutes a floating point number or a
non-integer number
because in apl a number is a number
there's not really any good distinction
but we'll do our best and any of these
solutions would be considered correct
let's start off by creating some data
for ourselves
what constitutes a and a number that
isn't an integer well
there are various ways to approach this
a very simple one and probably the best
method really um is to compare the
number to what would happen to it if we
were to round it so any number that's
integer stays the same when rounded and
any number that isn't integer would
change
so
the floor
of this vector
gives us these integers
and then we can compare
and these gives us
the integers but we're actually
interested in the non-integers so let's
go change
that and then we can use this
to filter
and this gives us the non-integers we
can put this into a function let's call
that f
and use the
name of the argument
and there you go
somebody who participated in the live
chat event
noticed that this can actually be
written as an entirely derived function
not even a train but a tested derived
function that is a function that
entirely com composed of
operators and
functions together
and we can see how we can transform f
into such a thing so let's
have this tested form
first we want to compare the argument
with
its own floor
so the way we can do it is we want to
use the function
unequal dyadically using the same
argument
on both sides so that means we need a
selfie or
commute
operator here
and let's get rid of some of this noise
um and then
we want to pre-process the right
argument to unequal using the floor
keeping the left argument just
the
the outer argument itself so this places
the same argument on both sides and we
flow the right side and then we feed it
into
unequal i like to think of the
jot or compose or beside and as
preprocessed the right argument so this
is unequal while pre-processing the
right argument
with a floor
using the same argument on both sides
and we can use that
to filter and so this is the same
pattern again
we have this
filtering function
and we want to use the same argument
but the right side is preprocessed by
this function
and the left argument is just the way it
is so we can do the same thing again so
we use the preprocessing
the right argument operator with
parentheses like that and then use
commute to
put the same argument over on both sides
so this is a fully tested
version of
f
however i don't consider this very
readable it's perfectly correct it's
more for exercise sake that we do this
conversion
now as i mentioned there are some
interesting questions regards to what
exactly is considered a non-integer and
what exactly do we mean by floating
point let's create some interesting data
let's say we take a very small value
1 times 10 to the power of negative 13
and we add it to the numbers 1 through
15.
if we print these numbers then they look
like integers and that is because by
default apl will round to
about 10 digits of precision
and then
because we've only added 10 to the power
of negative 13 to each one of these we
don't notice this however if we
format using
14 decimals
then we can see that there is actually
more to it
we could also of course say
and w minus the floor of w
and then we can see that there's a bit
of a difference there it isn't exactly
ones 1 times 10 to the power of and
and that is because
um
there are some floating point
inaccuracies at that level
and this is where things gotta be
interesting should these numbers in w be
considered floating point or not well if
you try double to apply a function f on
w
then you can see it says oh the numbers
1 through 9 are considered non-integers
but the numbers 10 through 15
are considered integers which is of
course
interesting and and odd the reason is
that apl by default has something called
the comparison tolerance which
is a multiplicative fuzz factor allowing
comparison as long as
the ratio to each other does not differ
by
more than uh
1 to the power of negative 14 or 1 plus
1 to the time 10 to the power of
negative 14. this
first factor can be set the comparison
tolerance but this is the default value
um and that is why i chose uh 1 times 10
to the power of negative 13. so as soon
as we hit 10 or more then we have we now
reached the factor of
14 orders of magnitude and their numbers
are considered equal so when we're
comparing the floor with the original
number they are now considered equal and
therefore they are filtered
away
now we can counteract that by sending
making a version of f say let's say the
comparison tolerance
including version and where we
temporarily locally set the comparison
tolerance to zero
and after that we
use the formula as before
now when we use fc on w then all 15
numbers are considered to be floating
point because we are now exact in what
we're doing
so this is the one definition that they
compare to each other another definition
is the internal representation normally
in apl you don't care much about how
things are represented internally unless
possibly you're doing some performance
optimizations but usually not for the
values themselves but we can actually
ask apl what is the data representation
of
such values and then if we go back to v
we can see that
v which we have here is stored as a
six four five six four five and the six
four means the 64 bit per element and
five means it's floating point a binary
floating point so this is a 64 bit
binary float array however quad dr also
tries to compact every argument you give
it before it tells you what the data
type is and if we apply
quite the r on each of these
then we can see that trying separately
on each element to compact them as much
as possible
the first number can fit in a 64-bit
float only and the second number 4 can
fit in 8-3 that means 8-bit and 3 means
integer so that's an 8 bit integer or 1
byte integer
and we can exploit this then we can
create a function g that selects the
argument
filtered by whether or not 645 is equal
to the data representation of each
element
and this will work on
on v
and if we try it on w
then we'll see that it also considers
all these numbers to be
flowing point values because they're in
fact restored as floating point even
when they're compacted the most because
they have this additional
1 times 10 to the power of negative 13
added to them so here comparison
tolerance doesn't matter at all
and let's make an if an interesting
one
if we take the values from v and we also
add
a very large value and it should be
noted that if i ask what is the data
representation of 1 times 10 to the
power of 400
it answers 1287.
this is not a 64-bit float because
64-bit floats do not reach such large
magnitudes instead it is a 128-bit
float and the 7 here indicates that it's
not a binary that would be 5 and 3 is
integer
but rather a decimal float so this is
using a 128-bit decimal float
representation for the large magnitude
and of course this gives a problem so
now we have we have our x
and if we try to run g on x
then
things fail spectacularly
and the reason is
that apl will internally upgrade all of
these numbers to be decimal floats and
then they get stuck there and we compare
them
so if you say the data representation of
each one of x
then
we can see that the floats all became
decimal floats and the integers are
filtered away of course and then since
we're only looking for binary floats
we're not finding anything
but we can amend
this function so let's say we have a g
which is also children for decimal
values and for that we just check for
membership in 645 or 1287
and
now we can run gd on x
and it
matches all of these so this considers 1
times 10 to the power 400
floating point which is correct as to
the internal representation however the
problem specification also said none
integer
and i'm sure you'll agree that 1 times
10 to the power 400 is very much an
integer
not in non-integer but this is depends
on how exactly you understand
the problem so a very simplistic
understanding would be
from a human perspective well it's an
integer if it's just a bunch of digits
together possibly negative and it's not
an integer if you need a decimal point
in order to write out the number and we
can write this in apl as well
so
what we'll do is we'll format each
number to a character vector
and then and we can look whether or not
there is a dot
in each of these
and if there's a dot in the character
representation of the number then it
would be a
non-integer number this is not going to
work when you use this
scaled format with an e inside but for
normal numbers it's going to work you
can also combine these two instead of
running two loops we can fuse the loops
by saying we want membership but we want
the right argument to membership to be
preprocessed with format so this is is a
dot member of the format for each one of
the numbers
and
if there's a dot then we want them
otherwise we discard them so we simply
filter by that
and and now we can try this on x and we
can see that
the 1 times 10 to the power 400 is going
to be filtered away
however if we run x on our w from before
remember w where these numbers from 1 to
15 were a little bit added and it
considers none of them to be
non-integers so it's in a way it's more
tolerant
of being close to integer
and the reason for that is because when
we format the numbers
in w they they look like this
but we can actually give a left argument
to the format function which is the
number of
decimals to add so if we add say 14
decimals to it then we can see that
we get this one at
inside the decimals
so we could depend uh amend uh the
function to do this
um if we ask for too much then it's
going to add some underscores
for digits that it cannot figure out
based on the internal representation
another way is using something called
the print precision which by default is
10 which is why we by default we'll get
10
significant digits in
in our printouts and if we change quad
pp to something large say 17 then doing
the same expression will give us more so
there's an implicit argument
to the format function let's change that
back to 10 here and
then we can
write our function h as before but this
time we make a local change to pp and
i'll set it to the maximum value that's
allowed even for decimal floats it would
be 34 digits so we take omega filter
that with whether or not a dot is a
member in the format of each of the
argument
and
now we can try it on w and now it
considers all these
near integers to be non-integers
i should probably have
given this a new name i'll do that in
the in the code that i post
okay and so much for regular ways let's
let's look at a little bit more exotic
ways of
of solving this problem
and here's one
let's say we have these these numbers v
we can take the division remainder
with
one so this is also known as modulus one
or what is left over if i do if i was to
try to
create this number just by adding ones
together and that is um a non-integer uh
if the number is non-integer and zero if
it is an integer because you can create
any zero any integer by
multiplying an integer
with one
of course that same number
and that means
that we can
compare with zero so wherever we have
zero we want to get rid of that and
whenever we have a positive value and
none nonzero then we want to keep it
so we could com you do just a comparison
with zero however we can also just take
the sign
or signum of this because we'll never
have any negative results from
the division remainder or modulus
and so this gives us our mask and we can
select
the values based on that
let's put this into a function
i
there we go
and now we can try it
um on these values so here we can see we
hit hit this problem again with
near integers
um and we could solve this by changing
the comparison tolerance locally so
let's do
ic
with comparison tolerance
so we can set that to zero
and then we have the same form as before
ic and w and now it works for all these
values and then there is a tricky thing
um which is
the represent
or
um
encode
and in code with a
takes a
so encourages is the downtake it takes a
possibly mixed radix as on the left and
represents the number or numbers on the
right as
um
in this base
however here we're not actually
interested in a full representation
we're not even interested in um
in any representation the only thing we
want to to know is that if
um
if the smallest unit in the base is a
one then would there or would there not
be a
one there and how many
ones would there be it's a bit
interesting to explain like this but
let's have a look at what it looks like
with v
and you can
notice that this is exactly the same as
division remainder which is
it actually makes sense because when
you're trying to convert to a base then
you keep subtracting as large units as
possible and then
the remainder is left over here so
what's happening here is that
we end we how many
ones are there that cannot be
represented in the larger unit um and
then we end up with a division remainder
now what's interesting with and with
encode is that it doesn't care about
comparison tolerance it's always precise
so we could actually
um
use
abuse
this
and
write it exactly the same way
without specifying comparison tolerance
and then
it would work even for these
near integers
however um i don't think this is very
clear don't write this in your
production code it's much better to set
quad ct to zero to tell the reader
what is you're actually trying to do
another way to work around it is
remember i mentioned that quad ct is
like a multiplicative uh
fuzz factor
and it's it's used to measure
relative difference between things now
if you multiply by zero of course you
get zero and the consequence of this is
that any comparison with a true zero
it the comparison tolerance doesn't
matter so even a value that is very very
small say 1 times 10 to the power of
negative 300 is not going to be
considered the same as 0.
how can we use this well if we take
these values and we subtract
their floor like we
spoke about in the beginning
and
then we can compare this to zero
and this gives us also a true comparison
so we can write now a
subtraction based version of f
that uses this system
and we can try fs on our special w and
uh
oops sorry this is wrong this should be
an unequal of course we want the ones
that are on floats there we go
and we can see that all of these near
integers are now considered
um to be
non-integers and that is because the
difference between them and
their
their floor is
very small but
it but is not equal to zero
and finally just for a bit of a joke
solution
um
if we
try to use the argument as left argument
to replicate but we're not actually
interested in using
any value so we can just replicate the
empty vector which will always give the
empty vector
then the function is subject to the
limitations in domain of the replicate
function
now the replicate function can take any
integer
positive or negative including 0 as
argument
this means that it will error if any
element
is
not an integer and that's exactly what
we're looking for so we can set up
a
error guard that says that if any error
happens it's really the main error but
let's just do any error for now
if any error happens
that means that the test
that the
argument is
non-integer and we want it
otherwise we replicate the empty vector
which gives us the empty vector
let's let's try this first so if we do
this on on v
then we get we can see the gap here so
we get an empty vector for every um
for every integer and we get the integer
and they get the number itself for
numbers that are not integers
and all we need to do now
is enlist
and that
collapses all the empty vectors away and
we just get the result we want
so
this solution also works it has horrible
performance it's completely abusing the
system
and it fails on numbers of very large
magnitude
but well
it works
subject to comparison tolerance again
like before and we now know how we can
deal with that if we want to
but that's it joking solution please
don't do thishi
we're going to check if a particular set
of bits are set in a given state of bits
this would be really trivial if not for
the fact that we're given our query bits
and our state bits as integers
so we have some conversion to do
let's take the bits that we're asking
about
um as three
and the state as 10. it'll be apparent
in a moment why I want these particular
example arguments
now these are then encoded
as normal numbers but we need to know
what the individual bits are in the
binary representation
in order for all the bits to line up
being that 10 would otherwise be a wider
number than three it's important that we
convert them together so
together let's concatenate them together
and now we can convert them to binary
we could
take a fixed with representation
and convert them to that but we can also
let APL determine how many bits are
necessary for the widest one of the two
bit patterns
we do that by using the opposite
function the the one that would converge
from the bit patterns two numbers and
running it in reverse that is applying
it negative one times so this is the
power operator applies functions
n times and this is applying it negative
one times
and we are and the way this parses out
is it's a called a fork
it means we apply this function to the
arguments 3 and 10 that gives us the
vector 3 10. and then we are applying
this function
which is the inverse base evaluation
that is an encoding two base
two
and what we get here
is one column per number so this is our
three which fits this is one times one
plus one times
two
that's three and ten is one is zero
times one plus one times two plus zero
times four plus one times eight so two
plus eight is ten
and now you can see why I chose these
particular arguments it's because then
we have all the different combinations
of bits on the left and bits on the
right represented
here we have zero with one and zero with
zero one will one and one with zero
and what does this mean that we're
querying whether these bits are set
it means we aren't interested in all the
bits on the right
we're only interested in the bits that
have a one on the left
and in that case we must also have a one
on the right
so if we go through all these these
possibilities we can see that a zero on
the left and a one on the right that is
fine that is okay
a zero on the left and a zero on the
right that is also okay
because it doesn't matter if there is
more State than what we are querying
and one on the left and one on the right
that is also okay
but a one on the left and a zero on the
right that's not okay because that means
we're querying a bit and the bit isn't
set so the answer is no
our requirements haven't been met
so
now we need to find some way to
process this Matrix
to figure out if our requirements are
met
and I think maybe the easiest way to
reason about this is to do the opposite
and say let's
look at when our requirements are not
met and that was only in this case
so being that our domain is restricted
to the booleans ones and zero
this is the only case where the left
side is greater than the right side see
here they're equal to each other and
here they're equal to each other and
here the left is less than the right
so it's only the case where the left is
greater than the right that is
problematic
which means conversely that
all the cases where it's not less than
sorry when it's not greater than and
so all the cases where left is not
greater than the right those are okay so
what is not greater than
that is less than or equal to
um let's verify this zero is less than
one
zero is well not less than but equal to
zero one is equal to one right but one
is not
less than or equal to zero it's not less
than zero it's not equal to zero
so the next step is going to be to
reduce over these rows that is we are
inserting and less than or equal to
between
the elements on each row
and we can do that with a last axis
reduction so we have less than or equal
to reduction
and this tells us that for the first
three bits our conditions have been met
Zone actually only a condition in the
third bit here
but the last one is a failure
that doesn't really matter here because
all we need to do now is to check if
they are all met we're not interested in
the individual bits so instead of doing
a single reduction we're doing two
reductions
an end reduction after we've done the
less than reduction
that tells us that the requirements are
not fully met here
okay
um this is our solution let's give it a
name
and now we can try it
do is three myth in 11.
yes it is and that's because 11 is just
like 10 but with an extra 1 bit at the
end so both of these required bits
I'm at what about 4 and 11
nope because well we have a one here
we now have in four we have one zero
zero here so that one lines up with zero
over here and then it isn't true
and that's all
thank you for watchinghi we have to count how many of each of
the letters a c g t there are in a given
character vector or scaler that's
important
here so I've redefined uh this sample
DNA string
and this is actually very simple a c GT
we want to compare each one of them with
the entire string so this is an outer
product so this does a all combinations
of elements from the left with elements
from the right this gives us this
Boolean table and all we need to know is
how many ones are there in each row so
we can just reduce here now there is a
problem um and that is if we just have a
single letter say a single C then this
outo product gives us a vector not a
matrix and then when we sum them uh then
we get a single number instead of one
number for all of them so we can fix
this by reveling this forces the scaler
to become a vector and it has no effect
on a vector and that gives us the result
that we
wanted so we can make this whole thing
into a single tested function uh like
this and it also works on our DNA
string another way we could do this is
using the key operator but that one has
a problem that things might not come out
in the right order so if you try this
with a key operator the way it works is
that it
returns uh for every element unique
element the element as a left argument
to the to the Opera function and then
the indices on the right so that means
we can count the indices and find out
how many of each there are and we can
see this is is almost right except for
the ordering here and in fact if there
weren't all the
letters then we would be missing things
so how can we fix this well if we insert
acgt before our data then we know that
they will be encountered in the right
order and we know there will be at least
one of
each and all we need to do then
is
subtract one from oops subtract one from
the result of course uh not from the
with the letters we to get rid of those
um and that gives us our right result so
here's another way that we could write
this bonus I actually have an idea for
an extension to key such that we would
be able to write this much
neater and we can import the model for
this as follows we want to get from from
GitHub from my
account you want this dialogue
vision and the symbol that we want the
model for is quad
equal it's an
operator okay now let's rename that a
bit to something that looks a little bit
more like a symbol
and now we can try it so the way it
works is that instead of taking a
um function as upper end it takes a
vocabulary as upper end so AC
GT is our
vocabulary and then
key on the DNA and it Returns the lists
of
indices just like this would have
returned if we didn't count them inside
the upper end which means we just need
to get the length of each list of
indices that would be the whole thing if
key was extended like I think it should
be thank you for watchinghi we are going to compute the next
Double critical
day um according to this bthm thing um
and all it means really is that we have
three cycles of 23 28 and 33 days and if
two of them meet each other uh then it's
called a double critical thing
um we start counting from a birthday and
then we it has to be the first time they
they meet uh any two of them meet after
a given date supposedly like the day's
date or something um and then there's a
red herring here it says the triple
critical day which you're also supposed
to check but it doesn't matter because a
triple critical day is of course a
double critical day as well there there
two and there's one more um of these
Cycles
meet we supposed to take input and give
output as year month d vectors and
that's really all does to
it so the Cycles are stated in as 23 28
and 33 days
but think of a sign curve after the
whole
period then we cross the x-axis again in
the same direction but we've already
crossed in the opposite direction once
so the actual cycle we're interested in
is um actually has half the the period
of the given
periods now let's find out uh
What uh number of days we have to
progress before we have two of these and
we can do that by finding the least
common multiple so let's make a least
common multiple table um of these of
course we're not interested in when a
cycle meets itself it does that every
time it it crosses over and we've got
the duplicates because it doesn't matter
which one comes first so we just need
the upper right corner here and then we
can we can do that so let's drain the
vectors from one to three and then we
make a comparison table and for that and
that gives us an upper right Matrix and
that's a good mask for the Matrix on the
right so we can use filtering or
compress um or replicate if you want to
call it that we just need to flatten
both first and then we get these these
these numbers are stated in the problem
statement as well um but now we know why
it is exactly these
numbers so we can uh we can call these
the the periods I
guess an example uh input
1962 uh October
31st and uh 2023 three the 1st of
January and now uh we can start coding
the first thing we need to do is we need
to transform these dates into a serial
number of dates so that we can do
computations on them um so for now let's
just say we concatenate them together
but we pre-process uh both arguments
with uh the conversion and for that we
have to treat each one as a whole we
call the datetime conversion function
and it assumes that it's a time stamp
like this so we don't have to tell it
what the input type is we just need to
tell it the output type and type one is
uh a day count from the beginning of 199
uh of
1900 so that gives us uh these and that
means we can find the difference here
between them with minus instead of
concatenation um this is negative of
course because we have a larger number
last we could swap the arguments uh to
get the positive uh difference between
them and now uh we need to find out when
the next day is so um we need to find a
whole
multiple U of these
Cycles from the first date so we can see
how how many of these Cycles are there
from and and from the first date to the
second date and then we need one uh like
how many whole Cycles are there and then
we need one more date and this calls for
a modulus operation so if we take and P
here and modulus so this means the
remainder when with this over here when
the difference rum is divided by uh
these
periods uh that gives us these values
but this is how much is left up
until the
and the last chance before the second
date and that's what remainder means
there's a clever thing in the definition
of of the remainder in APL and that is
if you negate the right argument then
instead of stopping right before the cut
off we stop right after the cut
off um we
can can't really tell that immediately
here but if we try it we can see if you
call this one b
and and this one
a then if we add
together A and
B that gives
us uh the P that we have from up here so
we can see that by negating on the right
we get one more cycle so just uh after
the cut
off so that is actually what we uh what
we after
now what
remains is that we we don't want to know
how many days after the the current date
the date on the right and it happens we
want to know the actual date so we take
the date on the right and we add that
offset we need to do go beyond that date
we need to find the first thing which
could be zero if it's evenly
divisible now we have the State numbers
and all the remains is to convert the
other way so that's negative one so
we're converting two a time
stamp and oh we forgot one thing we have
to uh we have to find the first one of
them it doesn't matter which one so we
can before we go here we want to take
this the lowest one and then it will
make the formulation easier to realize
that we're doing a reduction over Vector
uh of on a scalar function's result that
can be combined into an inner product is
exactly the same thing okay now we can
convert uh to
date and it's enclosed remember we
enclosed this to treat it as a whole and
that's the same thing over here so we're
going to disclose here uh for that
effect to get the whole thing and then
it has date and time and we're not
interested in the time so we just need
to take the first three oh first three
elements uh from that I'm binding these
two together because we have a Mantic
function here so it fits in the in the
trainer
form and uh now we
can actually go and Define our function
directly we could so we can put in the
actual value of uh over here and get rid
of these given
arguments you still need parenthesis
over
here and we have our function and then
we can call our function with these
arguments and just for good order let's
see what happens if we give it the same
argument both sides then it should say
that that date itself is uh its own
critical date because all the curves
start there so they kind of intersect
there and that's really all there's to
it thank you for
watchinghi
we're going to convert the labels that
you see at the top of the columns in for
example Excel or any other spreadsheet
manager to the number from that
of that column in the whole sheet
it might sound straightforward a to the
end of the alphabet is
1 to 26 and then you go to a a for 27
and then a b and so on
is actually deceptively simple and the
solution is also simple
but what's actually going on is
interesting
so let's start off with
um
then a and and then
those are really easy we if we look now
up in the alphabet we get 1 and then
26.
then it gets more interesting because
the next one after Z is a a
that's one one but it's supposed to be
27.
clearly this is kind of a positional
system the further left a character is
the
more significance it has but it's not
just base 26 because there's no zero
here
it does however work
if we say this is in one one base 26
because that's
1 times 26 to the power 1 plus 1 that's
27 so if you evaluate this in in base 26
we get the right result
where things get really interesting is
what actually happens when you have a z
so this gives us a 26 26 is not a valid
digit number in base 26 just like 10 is
not a digit in our normal Decimal System
we only have from zero to nine
zeros are skipped here because we never
get anything that has the index 0
in the alphabet
so what's actually happening here when
you evaluate this in base 26 is that API
allows
digit position values to have a number
that is higher than the base
and it just uh overflows with a carry to
the next position so when we have 26
ones
then that overflows to become well 26
plus 1 times 26.
um in in if it was 126 here it's
implicitly 0 26 so that overflows and
just becomes zero plus twenty and six
um and so that actually works
nope
and if we do this also with say a z
where we get 126
then this means there are 26 ones
and 126 so that's
we just add them together
um
and we get 52.
and if we had a b here we would add that
together again
um
so there's one 26 and then
226s
and if you go up to even larger numbers
here then we'll see how the the carry is
going to carry over so there are 26
plus 26 26s
and so on it doesn't matter that it will
overflow to the next position we just
add them all up we do the multiplication
with the powers and then we add it all
up so we can write our full solution to
the problem
as with binding
the alphabet as left argument to the
lookup function Iota and then we
evaluate in base 26. so that's that's
our solution we can put in anything
um here and get the right result
to really understand what's going on it
might be a good idea to you know emulate
the functionality of the base evaluation
here also known as decode
so what's actually happening let's uh go
back to these numbers for a moment
is we get these three values here and
this is all base 26. so these are the
these are the ones these are the 26s and
these are the 26 squareds
that means we can get the powers
by
starting off with
three numbers like this we can reverse
them because we have descending Powers
these are the the highest one and then
they are too high by one so we can
subtract one
here
and then we have 26 to the power of that
that gives us the weights for the
positions and then we can multiply by
our numbers
and sum that
or alternatively we could use an inner
product
to do this
and that is actually what's happening
here that we're taking
the length of the argument and finding
those powers and then just adding it all
up and it doesn't matter that they are
too large they overflow and they
couldn't really represent it in that in
that system
so we can write this here as
quad a
be looking up the right argument and
over here instead of
Iota and three we have the tally of an
argument so now we can do APL over here
of course there's no reason to actually
write this because we have the Primitive
that does this but this could help give
an understanding about why this works
even though we're using digit position
values that are actually too high for
the number system
thank you for watchingwelcome to the appeal Quest see APL Wiki
for details
today's Quest is the fifth from the 2016
round of the APL problem solving
competition
we are to find the elements of a list
that only once in that list that is
those that have no duplicates
let's start by defining a function it's
an anonymous function we're giving it a
name right now but we're going to apply
it to an argument
a very simple way to go about this is to
compare every element in this array
let's say list a vector a one a
one-dimensional array
to every element that is we're making a
comparison table
so we take
the argument
and compared to the argument but we want
to do all combinations so not just
equality
but this jut dot together makes a table
so this is a quality table
so imagine that we have the letters of
hello world going down
on the left and going across on the
right
and we can see which elements match
which elements so of course the diagonal
is all ones because elements match
themselves
but we can see that there are duplicates
when they match multiple
and so and by counting how many matches
there are for each element then we can
see which ones only appear once
and we can do so by summing so
if we Sum along the columns or along the
rows it doesn't really matter but let's
just do the columns for now then we can
get a count per element
and sum is a reduction using plus so we
use plus and this slash bar means
reduction
and you can see here that each number
corresponds to
how many ones there are in the column
above
now we want only the numbers
that are 1 so
we can compare one to all of that
and we can see here that the ones
compare we get a one true
where we have L1 and then we just need
to filter
the argument using this bit mask so we
take this bit mask and use it to filter
we can do that again with a slash bar
but this time we have a mask on the left
so now it doesn't mean reduced now it
means filtering also known as compress
on the argument itself
and we get H and E that only appear once
the L's are two of those the two o's we
skip that there's a single space w
appears once and so on
so this is one solution albeit n not
very good one because it does a lot of
computation that is unnecessary for
example this table is way bigger than it
needs to be
we don't need to compare every element
to every element we could compare just
to the unique elements
so how can we find the unique elements
well we can use the unique function
which looks like an A U
and this gives us just the unique
elements
now we can compare to those
and this gives us
a smaller table
and if we now
count how many they are of each of the
unique we get a mask we can then apply
to the unique
and we get the same result with a little
bit less computation
wait we are Computing the unique twice
that seems a bit wasteful as well so we
give the compute computed unique value
and a name U and then we can use that
over here
which is a bit better
that said API can actually do a lot of
this for you and it will do so more
efficiently by using the built-in that's
made exactly for this kind of work
so let's remove everything here we have
the argument and there's a special
operator it's called which is a higher
order function called key and it takes a
function on the left and applies this
function to
some properties of the argument on the
right
it's applying it this function over and
over again once for each unique element
so there we have it inside the unique
elements
um and the unique elements are given as
left argument whenever we apply so Alpha
is the the left argument being the
leftmost character in the Greek alphabet
and as right argument
Omega
Omega being the right most character in
the Greek alphabet
it gives all the indices where these
this unique element occurs
so we can see that the H appears only in
position one e position in only in
position two L appears and three four
and also 10 over here and O at 5 and 8.
now we're not actually interested in
where they are we're only interested in
how many there are
so
we can get rid of the left argument
and it gives us just the indices and
we're not even interested in what
exactly indices are but just how many so
we use tally which looks like a tally
marker like a counting stick
and this gives us the counts for each
one so this was the same we got before
when we made the table and summed the
columns
and then we can take it from here we can
compare
to one
and use this as a mask
on the unique elements
and this solves the problem but
this key operator actually computes the
unique Elements by itself and we're also
Computing the unique elements outside
which isn't the best
remember we can get the unique elements
as left argument in this function which
means the information is actually
available we just need to change the
structure of the result coming back so
that we can get all the information we
need and apply it
so let's try that
we have the count over here
and we can actually do the comparison
with one in here as well
then we get this mask directly
and then we can concatenate
the left argument which is the unique
element
so comma is concatenate
and we can see we get this table of
which ones are the ones that that we
want which means we really have a mask
here
and we have the Theta over here we just
need to apply this mask this column to
the column on the left
as we saw before
the the filtering function was known as
compress
takes the mask on the left and the data
on the right so we really want to have
the unique elements on the right and
this mask generating expression on the
left
we could put parenthesis around this
expression and move the comma over on
the side but we can also use a special
higher order function or operator
called commute which takes this function
on the left much like key takes this
user-defined function on the left
and the only thing it does to it is it
changes the order of the argument so the
left argument becomes left the right
argument the right argument comes
becomes the left argument and this just
gives us the two columns in opposite
order
foreign
this
a two column table or Matrix into two
vectors and we can do that by
concatenating vertically so we're
concatenating the first element over
here with the first element over here
and so on and concatening the second
element of the second elements
so we want to concatenate vertically so
just like we used the slash bar as a
vertical sum now we're using it for
vertical concatenation and that gives us
these two elements which are the mask
and the data that we want to apply the
mask to
before we use compress infix we use the
between two arguments
but now we have the two arguments in a
list next to each other so we need to
insert
the compression function
in between the elements which is again a
type of reduction but just over two
elements so slash bar here means the
um the filtering or compress and then
slash bar again because it has a
function next to it it means insert or
reduce
now there's one little issue here you
can see this box around the result and
that is because we start off with a
vector a list of two elements which has
a single Dimension we're counting one
element and then two elements and reduce
the name implies that it needs to reduce
the rank the number of Dimensions so it
goes from one dimension to zero
Dimensions how can it have a
multi-element array in zero Dimensions
so it packages it up in an enclosure
that's this box we're seeing but we can
this close that we open it up so this
kind of looks like a a mouth that uh is
away from the array and it opens it up
that gives us our result so this is
another solution
and finally a really clever solution
that somebody came up with
there is a function called unique mask
which instead of returning to the unique
elements
it returns a mask indicating the first
occurrence of every unique element
that's this equal sign with only one an
unequal sign with only one argument on
the right
so this says that H is the first
uh
and the first a the first H is the first
is H and this this e is the first e and
the this L is the first L and this L is
not the first of its type
now
what we're actually interested in here
is to remove all the elements that are
duplicate
so which elements are the ones that
are have duplicates well that would be
the opposite of the ones
that are the first so if we use logical
negation here
then yes we need to remove all the else
and this
if you use this mask it would not give
us an L but this would give us an L so
we guaranteed
for every element that has every unique
element that has duplicates we are
guaranteed to get at least one
element from this mask
and so we can apply this
to the argument itself so we're using
this compressed function but the math
needs to be on the left so we commute
the arguments
and this gives us all the elements that
we want to all the types of elements
universe that we want to remove
it doesn't matter that there are
duplicates
now we can take the argument itself
and then we use set difference so if you
use the tilde with both the left and the
right argument it doesn't mean not the
Boolean not it means but not or except
so it's set difference it's everything
here on the left but not those things
that are on the right
and that gives us
the elements that appear on new ones
thank you for watchinghi we have to compare two version
numbers each version number has three
parts and then we have to answer whether
the left one is an earlier version the
same version or a later version than the
right
one so let's have an example
here one two
3 and 1
32 now as a human I can immediately see
that the one on the right is the newer
one but it's actually a little bit
involved uh what's happening here
because I must be scanning from the
beginning to see what the first part is
that differs so the first one is
irrelevant they're the same only the
second part is important and that means
that the third part isn't important the
fact that this one has a higher number
here um this one over here has a lower
number it doesn't matter because an
earlier number is more
important so let's make a tested
solution to
this we need to compare corresponding
elements and the comparison of size that
we can do with a
subtraction and so here we can see that
this part is an earlier number than this
part and this one is a later number than
this one um that corresponds to the
negative one and one here and then the
first digit the first number is the same
that's why we get a
zero we're not actually interested in
um the the difference itself so let's
say uh that over here we had a
four then we had a difference of and of
two and we're not actually interested in
the zeros
either so
and what we can do is we can remove the
zeros so we can use a set difference
with zero and because we doing
everything in a functional uh style
everything in terms of fun uh functions
we have to mark this zero as being a
constant function so this zero is a
actually a function uh zero with this
symbol to DS is actually a function that
takes these two arguments and and value
is to Z and then we use that with as
with set subtraction from the
differences between these numbers and
these
numbers and that gives
us-12 so we've gotten rid of uh one part
that we're not interested in second part
we're not interested in is the actual
magnitude of differences we only want to
know which one it is so we use uh the
multiplication symbol with only one ARG
argument that is the Signum the sign and
that will convert any number that's
larger than uh in magnitude than one so
one or anything beyond one or negative 1
or
zero leaves them down at one or negative
one or
zero and finally we want to prioritize
the first difference right the anything
that is the same we already eliminated
with removing the zeros
um but we want the first one so we have
a first function that we glue together
with the Signum function so this is a
new function that we have composed and
we applying that to the result of this
set difference between the subtraction
and the
zero and that gives
US1 but uh we can actually do this in a
little bit different way as well that I
think is really cleverly thought
out let's go back to the Set uh to the
difference between these version
numbers and we are not interested in the
magnitude so we apply this time the
Signum function glue together composed
with this
difference and instead of trying to
eliminate the zeros and then finding the
first one
then we can uh evaluate this in base two
as a binary
number now if the magnitude in if there
were multiple differences then this
could be a larger number we can take an
example of uh of that so let's backtrack
a moment and do 625 over here and 713
over here so now
we have two differences over here where
and where the left one is larger and one
where the left one is
smaller and now we evaluate this in
binary
and we we
get um ne1 because this and and this is
a bit interesting what's happening here
because I'm saying I'm evaluating in in
as binary
but normally you use the binary being
only digits zero and
one but here we also have negative ones
so what does this mean it's actually
really not that
complicated uh what's happening is we
have these uh these numbers and they are
just values for the digit positions so
digit positions in a binary system with
three bits so to say bits not really
bits because they can be negative one
well the first one is four the second
one is two and the third one is uh one
the last one is one so we could multiply
that that gives us our total and
amount and then we just need to sum it
all up to get the final result so we can
add a plus reduction here in the front
and that gives
US-1 um of course if we had the same
value at the end then we would get
something with a larger magnitude
so uh we at the very end we need to
again take the Signum the sign um
because we don't want a larger number
than uh than negative one or larger
magnitude than negative one and
one and let's go back to how we actually
spell that so this is the the binary
evaluation of that and then we can take
the Signum of that for the actual
solution
and yeah this seems clever but do we
really understand what's going on
here it works but why is it that it
works let's go back to this example we
had before with
625 and think about it for a
moment here we have basically the worst
case um possible what we should be
afraid of is that maybe uh a lot of
trailing numbers that are greater here
on the left but smaller on the right
would weigh out they would add up to so
much that even though the first number
is smaller than the than the um first
one on the right it would still
overweigh it so we would consider this
to be a larger number what if we had a
lot of huge numbers on the left and and
a lot of smaller numbers and on the
right and the um the important thing
here to understand is that the binary
system is exactly
this it it has the property that if you
add up all the fully set bits
and trailing bits then they add up to
exactly one less than uh the next larger
bit well that's nice we know that about
a normal binary system but what about uh
we have these negative numbers well that
can never make it any
worse
because if we have any zeros on on um
negative 1es here of course that adds up
to even
less um and over here we
[Music]
and
the the negative value here is well in
in in magnitude larger than the sum of
anything that could be here so it all
works out to reevaluate in binary um
even though it's not actually true bits
it's can also be negative and then we
take the sign of that um and we get the
correct
result thank you for watching
