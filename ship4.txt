where like you strip off the first
and last letter and then you put them
back together again the first last is
actually the same letter
and then the two-letter case where
nothing is moving around
okay the first approach we're going to
do is quite literally
pairing up and flipping around and
putting back together again we're going
to use the petitioning clause for this
and so what we want is
that
the first letter becomes a
section by itself and the next two
letters and the next two letters and so
on and then finally one or two single
letter sections at the end
we can do that by taking the length of
the argument and using that to reshape
zero and one
one at one zero that's because we want
the first one here for the intermediate
part to be on the first of the two
letters in this pair over here
once we got that we just need to adjust
so that we have an initial one and
always a
a final one and this corresponds to the
f and that will just stay in place
because it's a one element partition
so we put an
1
at position 1 and also at the position
the length of
the argument
we could also
give this a name
but it doesn't really save anything
okay this is our position vector
and
then we use that for the position in
close on the argument
flip each section and the one element
section stay as they are when flipped
and then join them back together again
within list
and that's our petitioned enclosed based
solution
here's a trick you can do when you want
to generate alternating sequences of
zeros and ones um then you can
start off with all ones and do an xor
scan on that or for the opposite effect
start with all zeros and do an x nor
scan of that what does that look like
well let's say that we have
some letters
and we want to generate this alternating
sequence so first for all zeros
what we can do is we do a zero constant
for each
but a code golf trick is to do a self
and
or we can do a a uh one constant you
should get all ones
so the code golf trick is to use a
comparison with itself
so here all these uh
characters when
we ask which one is different from the
cells that would give us more zeros and
if we ask which ones are equal to
themselves that would give us all ones
and then and
xor for
booleans is the same thing as different
from we do a scan
then that will give us the alternating
one zero one zero and if we flip things
around so we start off with the zeros
and then we do x north scan on it we get
zero one 0 1 which is what we wanted
in this case
so we can take this
and stick into our solution over here to
get 0 1 0 1
and then we just have to use the single
instance of the count over here
and this would also work
but
it's
computation for no particular reason and
it obscures matters but it is a trick
you might see sometimes
okay the next approach is going to be
using stencil because stencil can
traverse an array and chunk it up in
pieces which is exactly what we want
here
classically you'll see
a stencil with a window size of our
stencil size of 3 and a step size of 1
which is the default
but we can actually set what the step
size is going to be and we allowed any
window size as well
so
we can start off with the stencil and
then we need a matrix the first row
specifies
the size of the window in each dimension
here's only one dimension and that's
going to be two and the second row
specifies the step size here we don't
want
an overlord an overlap between these as
we would have in a
pairwise reduction
we want to use every element exactly
once
so
we're going to
use a step size of 2 as well so we
overlap with
so have no overlap between them
and this is going to be on the argument
and for now let's just use the simplest
operand which is the enclosed
neighborhood and that oops using the
wrong characters here
and then we can see that we're getting
pairwise and elements but this isn't
quite right because we are
pairing up the first element with the
second element whereas we want the
second and the third so we can offset
this so to say by sticking a space at
the front and then we can remove the
space later
now that's done
and we can see that
we have these pairs correctly
but there's an issue where we're
including the last element as well
um and then the second to last one so we
can get rid of it temporarily by
dropping one from the end and we can
just remember to put it back at the
front when we're done let's put it back
at the end when we're done
now removing that also removes the
second to last one
which is a bit of an issue because
and
the stencil if you cannot create a whole
neighborhood you will just drop trailing
elements called shards
but we can fix this by putting a space
at the end as well
and now we get it there and so other
than the spaces
ignoring those for a moment if we
if we reverse every
little window here then we get the
result that we want we just need to
remove spaces and join everything
together
however we've got a vector of vectors
for each one of these and we don't
really need to do this enclosure if we
don't do that then things get mixed we
get a
a collection of vectors that is a matrix
and then
this little function
just chooses its right argument so we
can just put a right tech instead of
that
now we need to reverse the left and
right and we don't care about these and
then we talk at the end at the beginning
because the space isn't going to be
counted so it's safe to reverse
everything
and then we need to ravel it
to get it back here and the only thing
that's wrong now is that the spaces are
there we'll have to remove those and we
have to add the last element as well
so one way to remove spaces is with
without
another clever way to do it is using
intersection
because there are no spaces in the word
and so the only letters that are kept
are the ones that are already there and
that's exactly what the intersection is
doing finally and we just need to add
the last element
from the argument
to the end
and that gives us our result so this is
a distinction stencil based
approach as well
next we are going to try to do an
in-place reordering of elements
so we can use the add operator to change
things
in the positions where they already are
let's try that
for that we need to
get the indices of
the
the medial elements and then we're going
to manipulate those with the left
operand of that operator so let's start
with this
so here's the count of elements
and we need to
drop the first and the last so we need
two less than
than that
or we could subtract 2 for that sake
and then we need to subtract one more
if
we are going to
um
if we have an odd number of elements
because we don't want this uh this f
over here to
to be included in medial elements that
are going to be flipped around so
we can we can add one more
if the length is odd
and now there's a problem uh short words
will end up with negative numbers and
that's not good so we need to make sure
that we have
no less than zero
and then we can generate the range for
that
of course this doesn't start at the
right position because we want to start
with the second element so we'll
increment it
right this gives us the indices of the
elements that we want to operate on
and we can be a little bit
clever over here look at this we are
having the the length twice and we got a
number two twice we should be able to
put this together to become a neat
little train so if you put the length on
uh left
and two on the right
then we want
the length
that be the right argument
minus
the 2
that's the left argument
plus
well that's exactly the remainder
between two and the left and the next on
the right and we've got the length on
the right and we've got two on the left
so that's the remainder
you see the symmetry
well it's this is plus so we can move
the terms around as we want and
i think this looks a whole lot cooler
okay these are the indices that we want
to operate on
now what are we going to do with them in
order to flip every other one we can
reshape them into a two column table
and then
swap the two columns
these are all the elements
two columns
and then
half
of the number of elements
would be the number of
and of course this gives us a matrix so
when we're done
we need to
revel them again so so far there's going
to be no change the only thing we need
to do now is just flip the table right
left
that's it we're done
that's the stencil-based approach
sorry that's the
add-based approach
reversal
but if we think about it
all we're doing here is reordering
elements
so
really the result is a permutation of
the argument
it should be possible to build
this permutation vector
from the ground up and then just use
indexing to permute
indeed
let's try that
so
if we think about it
we start off with the first element
and then we want to get to the third
element
and then the second
and then the fourth
sorry the fifth
and then the fourth
okay
so the first
then
the third
then the second
then the fifth
then the fourth
what are the distances between these
ah
we can see the beginning of a pattern
here if we were to continue
then and we would want
after the we've used up the the fifth
here you want the seventh
and then the sixth
oh now we can see the pattern
okay so we want
the distance from one index to the next
one is alternating the negative one
three negative one three negative one
three
right
and then at the very end
we are going to have either the last
element
or
uh the two last elements
right that's two and one is the distance
here
so we should be able to
create these
distances
and then
the
then we can because this is just a
cyclic reshape
and then the opposite of doing the
pairwise difference is the running sum
and this will allow us to get go back
again to these numbers that we had here
possibly offset by a little bit
so let's try to do that
we can start off actually in the same
way because we already
have written the computation
of
uh how many intermedia how many media
letters there are that was
this formula
and then we need to reshape this vector
three negative one
and at the very end we wanted adjacent
differences of
two and one although there might only be
it might just be the two and not the one
but let's just put it there for now
and then we can do the running sum on
that
so this gives us
numbers that we're looking for the
indices up here
just the one at the beginning is missing
so let's put the one there
now we might have too many elements
because we always add two and one at the
end
so we could selectively add the one
by looking at the parity whether or not
we need to include it
but
since we already have the length here
we can also just take the length
from these and that will shorten it down
when necessary
that's our permutation vector
let's use it for indexing
and we get the results we want it's a
nice flat solution
but it is pretty verbose
another approach to this
would be if we can just get some numbers
that have their relative
sizes such that if we
were to try to sort them we would need
indices that would put them into this
order then we can use grade to create
the permutation vector because grade
always creates a permutation vector
so let's try that we start off the same
way
get rid of the last one
but now we'll add that at the end
because the last one always goes at the
end
so this is the length up until
before the last
element
and now a common trick in uh array
programming is using negative one to the
power of
because that with
uh with indices gives us alternating
negative ones and ones
how's this useful
well let's look at the indices
themselves and put these
and alternating negative ones and ones
next to each other
so for now i'm going to just stack them
on top of each other by mixing the
concentration of enclosures
and now we can see if this is an
adjustment value and we adjust one down
to
zero by subtracting one we adjust two up
to three
three adjusted down to two so that
effectively flips these two next one is
four adjusted up to five and five
adjusted down to four
so if you just sum these up
then we get these values
that are very close to
what we want
in fact in fact
all we need to do
is adding the value and at the end and
then we grading this so grading it
gives us the one here
and then we can put the n at the end
and that's our permutation vector
so now we can take
index with this
and we get our result
but
we could possibly also
note that
all the grade did because we already had
the right values here was change the
zero into a one
so maybe we could do that as well
so we just want to place a one
at one
on this
nope that's not working
what's the
problem the problem is that
in the case where
there aren't any elements that are that
we need to to deal with so if we go back
to
to this then we have
an empty here
and that's not going to work
we could do some clever trick about
assigning to a one take of that but it's
going to become very
complicated so let's leave it at that
with the grade
okay we've got a bunch of different
solutions let's compare them to each
other let's generate a bunch of random
words
so that we can time them against each
other
we've got the alphabet
we want some random letters there are 26
letters in the alphabet and we want
between 1 and 10 letters say
in each word
and how many words do we want let's take
a thousand
what do the first 10 look like
that looks pretty good
what do the next 10 look like
that's nice too we got some two two
letter words and one little words
good
copying in cmpx from defense workspace
and then we need to generate the
expressions that we're going to run
against each other
each one of these functions is going to
be called in each of the words
looks like that that's nice
and we're running this and see how it
comes out
oh dear that stencil solution
that doesn't look very good
but the fastest one is actually the last
one
which was a nice and short one as well
that was the indexing using grade i
would have maybe thought that
creating the permutation vector with the
running sum would have been faster but
turns out that
it isn't
so that's our conclusion
use grade and indexing a very apla
approach for the optimal
performance
thank you for watchinghi we given a list of numbers and we are
to find the length of the longest
consecutive
subsequent where the values are either
consistently increasing or decreasing or
constant here's sample data now it might
look like this sequence here is the
longest
one that because the values here are
constant are easy to spot but this is
actually only two steps because we go
from here a five to a five and then from
a five to a five whereas over
here we have four elements in a row that
are consistently
increasing even though the increase is
not consistent so we go from one to two
and then 2 to three it's still
increasing 3 to 5 it's
increasing okay let's begin our Lambda
uh with p as argument and we refer to
the argument as Omega because that's the
rightmost letter of the Greek alphabet
and
here we are not actually interested in
the values we're interested in their
relative sizes so we can start by
subtracting consecu uh adjacent elements
so this subtract this does a 1 - 2 and
then 2 - 3 and 3 - 5 this might sound
backwards but it doesn't actually matter
CU we're only interested in whether
we're going up or whether we're going
down
or whether we're constant and it doesn't
matter if we flip around up and
down so here we can see that we
going up because the left element minus
right El is negative and we're going up
we going up and then we have two
constant ones going down going uh and
then uh up again and then down down okay
now we're not interested in how much
we're going up or down we're just
interested in whether whether it's up or
whether it's down that is we're
interested in direction or the sign so
we can do
that and now we just want to find out
whether adjacent elements in this
indicator list are equal to each other
so we can use the same exact technique
but this time instead of using
subtraction we're using different
from so this tells us that the first
element is not is the same is not
different from the second one the second
one not different from the third and so
that's these three and then we have one
here uh where the zero is equal to the
zero for this space over here and so
on okay so how do we convert this to a
list of lengths one way to do it is by
cutting this into pieces that begin with
a one the only problem is the first one
begins with a zero it's missing kind of
the one that the very first
uh directional change is of course
different from anything before it
because there was nothing before it so
we can fix that by inserting a one in
front and now we can use the petition
function
to that takes exactly this kind of
element uh this kind of argument on the
left and cuts the data on the right into
partitions that correspond to uh
beginning with a one and then continuing
with a zero but here it doesn't actually
matter what data it is we're cutting
because we're only interested in the
length so we could just C cut the data
itself and for that we have the self
operator also known as
commute so now we've cut into segments
that begin with a one and then we can do
the T which it looks like a T mark on
each and this Maps the tell over every
segment that gives us the length now we
just need to to find the largest one
which is a maximum
reduction and that gives us um this
solution which is very nice and easy to
understand however there's a principle
in APL that if you want things to run
fast then you've got to stay flat and as
we can see here on the boxes this result
is not flat it is a list of lists rather
than a single list so we could actually
do this using a single list instead
single flat list let's take this again
and this is the point where things go
not flat when we doing So-Cal nested
arrays let's go back and look at what we
had
here all we want to do is find the
distance from the beginning of one
segment to the beginning of the next
segment so we frequent find the indices
of these ones and subtract them from
each other that would give the adjacent
ones from each other that would give us
the segment lengths the only thing
missing of course is the ending point
for the last one so let's fix that by
adding a one to the end now the same
symbol as we used before doesn't apply
the concatenation with a single argument
used on both sides rather it flips the
arguments around so this becomes the
left argument and this becomes the right
argument in effect it just as this was
preened a one this becomes end
one okay now we convert this Boolean
indicator Vector to a list of
indices these are indices of our ones we
can see that this one is in position
four five and six over here seven and so
on and when we just need to subtract
adjacent elements this time it is
important which way we do it so whereas
this will give us the opposite of what
we want actually if we negate the two on
the left then it flip flips uh the sub
vectors before we apply the reduction on
each sub Vector of length to so this
flips the sign for
us and then the only thing that remains
of course is taking the
maximum that works let's call this G and
to see what kind of difference in
performance this makes we need to have a
little bit uh of a larger data set so
let's do a
million uh
numbers from one to 10 so this is a
million reshaping a 10 get a lot of tens
and then the question mark changes each
10 into a number between one and
10 we can look at the first 10 of
them right now we can copy in the cmpx
compare execution utility from the
defense
workspace and construct a a couple of
Expressions that we want to compare in
performance against each other so we
have f with the argument of Q and we've
got G with the argument of Q then we let
that run for a little
while and we can see that with a million
elements we get a very significant speed
up thank you for watchinghi
we're going to translate telephone
numbers written as digits and letters
into their corresponding
plain numbers
so first
here is the telephone keypad
if you look at the letters they are
sequential
and they kind of split the alphabet into
the curse into groups
kind of sub alphabets
and since that's the case
then
we can see the alphabet as a range
and have some cutoff points
and then we can just say between which
cutoff points does any particular letter
occur
so
the cutoff points would be the first
letter from each key
so this is the first function and the
each operator
and then our keypad
we don't actually need this to be a
matrix anymore so we're just going to
well I can actually just flatten that
Revel it
and then we have
some
spaces in the beginning at the end
we can do the intersection
of
the alphabet and these
and that gives us just the letters that
we wanted
and we can give this a name if you want
so these are the cutoffs
okay
so
now we have the letters of the alphabet
and we can use the interval index into
these letters that we have stored in C
and these are the correct numbers for
the individual keys but offset by one
we can fix that either by adding one
or we could
add a place hold a character that
doesn't actually appear on the left so
we need to use something that keeps the
increase the increasing or at least
non-decreasing series of letters we can
use the character that in Unicode comes
right before a which is the ad symbol
okay so now we have the correct values
for the letters of the alphabet
what about the digits well the digits we
have here in in Quad D is a constant
we can look these up in itself
and even though each interval here is
just a single one that works fine
but we're off by one again we need to
subtract one and there are various ways
we could do that one thing that's
interesting to observe is a character
that appears before the first cutoff
gets an interval index of zero
so if we drop one from the alphabet
disrupt the zero then when we do the
interval index we get the correct values
okay now we can put all of this together
if we take the digits but draft one
and we concatenate it doesn't matter
when we concatenate if we concatenate
first or drop one first because it's
such a short amount of data here
um
then we have a full vocabulary of cutoff
points
anything from here is nine then this
becomes ten this becomes one oh but
there needs to be two so let's insert
yet another at symbol or some other
symbol that appears between nine and at
or a
and now we can try looking up all the
values and so these are the digits
and these are the letters
but now they are too large by 10.
we can
fix this be since everything needs to be
mapped between 0 and 10 by taking the
remainder when dividing by 10 or the
residue we could also call it so that
just takes all the tens away
this is the also known as modulus but we
take the
number we divide by on the left
so this fixes
the issue for letters and digits stay
just the same
and that's really all there is to it in
order to make this into a proper
function then we
we want to apply the static function
with a constant left argument so we can
bind that left argument to the
interval index function and then we just
assign that to f
and now
we can
see that telephone numbers get mapped
correctly
and digits as well
get mapped directly so
we get the values that we asked for
this isn't the faster thing to do
because
if we think about it this is a simple
mapping there is a mapping where we look
up a particular value and then we give
some other value
and we can Define a function that does
this as a simple mapping so let's first
generate all the values that they could
be
these are digits and these are the
characters so this gives us all the
values for all the digits and letters
that could appear
we can call that n for now
then we can look up
the input
in
the list of all digits and letters
like this and we can Define this as a
little
Lambda or defen so this just gives us
the indices and doesn't matter what
exactly they are because we take that
result
all the indices that correspond to the
input letters and characters
numbers
and we look those up in n
and then we can try that as well
Let's see we get the same result and
this of course going to be the fastest
solution because we're not Computing
anything we're just looking up
um
if we want it's self-contained solution
here then we could
take all this
um well do two parts
and put in the literal number here and
we want 999 at the end it's a bit long
but uh
it works the same
thank you for watchinghi
we're going to be given a vector of
points as X Y Pairs and we are going to
compute the area inscribed by this
polygon
we're going to use something called the
shoelace formula which briefly described
it says that the area is half the
absolute value of the difference between
the sums
of the
diagonal products and the
enter diagonal products this might sound
like a lot of steps but we'll take it
one at a time
here are some sample points
the first thing that is specified in the
instructions is to stack them on top of
each other to become a matrix here's a
little Lambda for that
and this is the mix function it's called
mix because the points you're given as
an one-dimensional array of one-dimensor
arrays the inner Dimension is hidden
inside the array
mix mixes together the outer Dimension
and the inner Dimension into a
two-dimensional array that is a matrix
Omega refers to the argument
so here's our Matrix
now
there is a slight problem that we can
also be given just a single point which
isn't a list of lists it's just a simple
list so we need to normalize the input a
bit
we can see here that it might look like
we have a table but if we ask for its
shape then it has the shape is just two
it has two elements whereas if we ask
for the shape of the mixing of this list
of points then the shape has two
elements the number of rows and number
of columns so we need to normalize and
the best way to do that in a case like
this
is
to use the in close if simple function
or Nest function guarantees that the
result is nested if at all possible
so here
this becomes a single element of two
elements
and then we Ravel that
straighten it into a list of such pairs
now we have a one element
list of spare and then we do the mix and
then we get a one row two column Matrix
which looks much the same as before the
trick here is that if we use our list of
points then this function doesn't do
anything because it only encloses if the
argument does not already have
enclosures and since we already have a
vector then reveling into a vector
doesn't do anything either so this takes
care of the normalization
now the next step is we want to get the
diagonals we want two paired up with
negative eight three paired up with two
and one paired up with four
APL works very much orthogonally with
erase rows columns layers not along
diagonals the easiest way to get to the
diagonal is to rotate things so skew the
array into place such that what was
previously diagonal is now straight
if we could only rotate up this column
one step with the four circling around
to the bottom coming in next to the one
then we have achieved
straightening out the diagonals into
horizontal rows
good thing is that we have a rotation
function which can either take a single
value to rotate the entire array here we
took the row containing 2 4 and rotate
it down to the bottom or we can give it
one row one number per column
we want the First Column to be rotated
zero steps and the second column one
step and now we have the diagonals as
rows
we also want the enter diagonals
and we can just do that by
rotating the other direction with a
negative number
now we have two paired up with two if
you look at our original array up here
two with two
and we've got three with four so that's
diagonal in the other direction and so
on
right that means we can take these two
formulas here and put them next to each
other
giving us a
Two element Vector of these rotated
matrices
you'll see that there's some code
duplication going on here this
normalization and making into a matrix
we're doing that twice
really should move that out of a
function as a kind of reprocessing
in order for this to become a proper
function in the end we need to bind
together these functions here so it's an
a sequence doing this after doing this
after doing this we can do that using
the top operator and it looks cute too
okay
the next step is that we want the
products of these diagonals pairs which
are now just rows so we can
use a multiplication reduction
horizontally
and that gives us these three products
so negative 16 is 2 times negative eight
then we need to sum them
and then finally we have to subtract one
from the other
once you have this number we just need
to take the absolute value it's negative
here so we make it positive
because the area is always positive and
then we have to divide that by two I
like to write that 2 divides so this
operator here takes the division symbol
and flips its arguments so that what
we're dividing by goes on the left
and that gives us seven which is our
correct result
this is a solution but it bothers me
that we have some duplication here we
can see the the sum of the product and
it really shouldn't be that we repeat
ourselves
what's going on here is that we have
subtraction
but we want to pre-process both
arguments to the subtraction by doing a
product and then doing a sum
so we have something called over which
is
a pre-process both arguments operator it
takes a function here on the right which
is something we're going to apply to
both arguments before we proceed to the
main function which is on the left so we
want the sum of the products
that means we can remove those over here
right we still get seven
but I'm not quite satisfied yet
because
we still have
some duplication here
all of this is really
the same two we're just talking about
the difference between in the two
arguments are just the rotation amounts
so we could put things together here
and say that the arguments are just the
rotation amounts and they will be used
to rotate
the actual argument to our function as a
whole
how do we do this
well
I mean let's put the argument name in
here and a
rotation function
now we want to bind together this
argument as a constant argument to the
function so instead of this being at the
addict function it takes an argument on
left the rotation amount and the
argument to the right what's being
rotated it now becomes a magnetic
function that's being applied to each
argument
it is a rotate
Omega function
so that means we can get rid of these
two
um the S light here up here is that this
is a tested function that we're using
and that's necessary because we want to
refer to the argument of the outer
function if we used braces here to make
a little Lambda then Omega would now
mean
the argument that's being given to this
over construct
so being that is tested we can't just
have three magnetic functions after each
other that would mean something else
but we can the same way we did over here
with the pre-processing we can glue
together these two with this top
operator
this is looking better now we're just
giving the rotation amounts as arguments
but can we go one step further yeah I
believe we can because we're not
actually interested in not needing to
rotate the First Column the only thing
that's important here is rotating the
second column
so how can we get rid of
that zero there
let's restructure what we have got in
here a little bit
we have the insert the amount being
inserted here on the left
with what's being rotated on the right
we can instead of having it the whole
thing as a compound function the product
of the rotation on
Omega
we're going to make this into a fork
construct instead
where
the right argument goes over here we
have a central function that
is applied to the result of fetching the
right argument and this constant on the
right problem is that in a tacit context
we can have a an actual constant on the
right which has to be a function on the
right so we'll use this operator again
um but now with a an array on the left
it doesn't flip around
arguments rather it changes this
constant into a constant function
so this Returns the
um other argument
and this is the rotation amount with a
post-processing of a multiplication and
this refers to
the arguments giving to the whole over
construct which is going to be negative
one on the right and one on the left
we don't want just that
one or negative one we want the
concatenation of zero
and that one or negative one so that is
zero and concatenation and just the same
way as we did before
using the the bind operator to bind a
right argument to the rotation function
we're now going to use that same binding
operator to bind the left argument to
the concatenation
so
we're going to evaluate
this constant function that gives us the
outer argument we're going to apply
the zero concatenated two function to
negative one first and then we're going
to use that the result of that for S
rotation amount
for the vertical rotation post process
using the multiplication and then we sum
up and then afterwards we're going to do
that with a 1 instead of negative 1.
and then we do the final subtraction
so this is about as
a compact and
non-repetitive as I can put it
we can give it a name
and apply it to the points or to a
single point when the area then is zero
thank you for watchingwelcome to the apl quest see apl wiki
for details
today's quest is the first from the 2015
round of the apl problem-solving
competition
we are given two character vectors
and are to check whether or not these
are anagrams
here's a simple test case
what we need to do is we want to compare
these two character vectors to see if
they're the same
but we want to ignore
a lot of aspects of the character
vectors we want to ignore capitalization
punctuation
and spacing
in other words we just want to look at
the actual letters that are present
let's start to do so by filtering
the letters so we want the letters
where
those letters are members
of
the alphabet
but
they can be members of uppercase
alphabet or lowercase alphabet so we
want to do this membership case
insensitively
finally
we also want
to paste fold these letters so that we
can compare the ones from the two
different character vectors
but we could observe that filtering by a
membership that's actually the
definition of intersection
so we can substitute this phrase
with the case insensitive intersection
and gives us the same result
now we need to
give put these letters into some given
universal order
so that if we do so with two letters
that are scrambles of each other
shuffles of each each other so sets or
letters so to say
then they end up being the same order
and we can compare them so one order is
the sort order that works fairly well so
if we call these the letters and then we
index the letters by their grade
that gives us a sort of them
and we get the same thing on x
and so we can define a function
with this definition
but we it's not enough of course to just
do this normalization we want to compare
them so we want to compare the two
arguments
pre-processed by
this normalization
x
and y are now considered the same they
are anagrams of each other
and this might well be the shortest
solution that we can come up with
however it does have some issues that we
can have a look at
for example
um
grading can be a rather expensive
operation while sorting can be done
faster in order to get the fastest sort
we want to use
one of the idioms for sorting
so here's an example of that
we can see it gets colored differently
because we
are going to use the fast algorithm for
sorting
so
this works as well
furthermore
um if there's a lot of punctuation
then we are case folding the punctuation
in order to look at the intersection
with the alphabet when it wasn't
actually necessary to case for that
so we could look at the intersection
first and only case fold afterwards
for that purpose
we would have to
look at intersection with both the
uppercase and lowercase letters and we
could do that by taking the
lowercase letters and then putting the
uppercase letters before that
and finally notice that we are computing
the
this total alphabet
of letters every time we run the
function if you were to run the function
multiple times
then it's kind of wasteful to compute
that alphabet so we might want to do
that once and for all
one way to do that is using a tested
definition
so by changing this
brace here into a
parenthesis now it's a tested function
and we have to modify a little bit
what's inside here so we don't want to
mention the argument it's tested but we
can take this
constructed alphabet and tie it as an
argument
right argument to the intersection so
this is one magnetic function that's
being applied then we have another
magnetic function being applied and the
third magnetic function being applied
you can't do three magnetic functions in
a row like this but if we
compose these two together then it will
be just fine
so this should save us a little bit of
uh of work if we're using the function
many times let's uh let's give it a try
and see how they stack up against each
other so supposedly
a b c d they should become faster and
faster if i've done the thinking
correctly okay let's start by
constructing some large test case here
um we can start off with letters the
alphabet and let's both have some
uppercase and lowercase letters so if we
if we concatenate the alphabet to its
lowercase then we get this so these are
all the letters
then we can put in some punctuation
and
that gives us that gives us this
then we're going to
have a lot of that let's do a thousand
characters in that so this just repeats
them over and over again
but we also want to shuffle them around
and we want to add some spaces as well
so we can do that with a little function
so we want to
take the argument
and add some
spaces around
so we can just overtake it by let's say
we add
20 spaces
on the length
and then
we might want to
round that off so we don't end up with
fractional characters um
this would allow us to to change this to
a number that would
cause trouble
so
this just gives us a
a bunch of non-spaces with a bunch of
spaces afterwards so now we can
um
we can make a proper anagram of those by
shuffling them so we take
the argument and then
we take all the indices but in any order
of its length
on t
and let's create something
that's not an anagram
and of it and we'll do that
by putting in the dash which is not
something we had before at the first
position and in in t
so now they are
not
and against each other
copy in cmpx from the defense workspace
for the timing comparison
and then let's construct the uh
expressions that we're going to use
so
we want to compare
we want to run these functions a lot of
times because that was one of the things
that the d was a benefit over and over c
so we can start off by saying we have a
thousand
and copies cyclically of t a and t b so
these are the endograms and the and the
nut anagrams
we want to run on each of these
and then we want to have the functions a
b c d
and concatenated to the entirety of
those that gives us these expressions
here
and then we want as left argument and
you want a constant so we can say we're
binding t
and as
left argument
to each of these it gives us these four
expressions here
and then we can run cmpx on that
and it will take a little while
but if i have done my thinking correctly
then we should get
progressively better and better
performance and that's in that indeed
what we did get so we can see that we
got
some speed ups more and more
however and
here's the thing
an anagram
is
not so obviously just looking at the
letters
it's actually over defined in the
problem specification
it says using all the letters
and it also says ignoring spacing
civilization and punctuation could have
said using only the letters or they
could have said
just
an anagram of a string
and ignores word spacing capitalization
implementation so there's actually some
freedom to interpret this whichever way
we want
but that let's uh have some
more
interesting examples
here i'm using some letters uh that are
not so in the first two
character figures here there are some
letters that are
not in the just plain latin upcase and
lowercase alphabet
as well as
writing
with some punctuation here
but the important part is that i'm
adding digits
and digits are not letters
so we could say that they shouldn't be
included because
they're not letters but if you're only
removing
spacing and
punctuation capitalization
you can't say that digits are spacing
you can't say that they're punctuation
and they're certainly not capitalization
either
so it could be
either one of these
in either one of these definitions of it
so how can we do this
right um
there are a lot
of
characters out there and we don't want
to
write a list of all of the characters
that
have different properties luckily
unicode does define a whole table of
properties for every character and we
can hook into those kind of sneakily by
using an quad r or quite s because they
allow
pcre or pearl style regex's including
character properties and those are
exactly the unicode
properties
so what we can do here is
we can say and it's nice to state it in
the negative because we want to not ex
we can't really extract the letters as
much as we can easily remove letters
so we are going to remove letters from
from say from u and we and we can remove
any character that does not have the
property of being a letter so the
uppercase p here means the opposite a
normal lowercase p is having the
property of being a letter but here
we're removing things we want to keep
the ones other letters so we are
removing anything that is not with the
property of being a letter
and we can do the same thing for b
of course
so we can see that
both the punctuation and digits are
considered not letters but the special
characters that are not in the latin
alphabet those are still considered
letters and they are being kept and we
can incorporate this into a function
similar to what we had before so we want
comparison
over and then some preprocessing so we
start off with the sorting idiom
and then we want to
case bold so that we are case and
sensitive
and sensitive but instead of doing the
intersection we are now keeping this
function here
which is
just extracting anything that's the
letters and removing everything that is
non-letters
so that's one way of
understanding it and we can try this
oops sorry we should have an each here
so what we can see is that and the first
two are obviously different because
they're using different letters
the next two
removing the punctuation
and capitalization then they are
considered the same even though they are
using letters that are
and not in the latin alphabet
and then
we have the the two that are using
digits
both of them are considered anagrams of
each other so the first one is pretty
obvious the one two three three two one
the order doesn't matter percent and
minors are considered punctuation second
one are entirely different digits and
that's because we have removed all the
none letters and all digits are not
letters and therefore the only there's
nothing remaining even the dot goes away
because as punctuation we're comparing
two empty character vectors to each
other and then they're considered the
same
but we can also define some define it
the other way where we are
not interested in actually what's a
letter what's not a letter
rather we are looking at
and what is
uh at removing certain types of
characters
so we want to remove characters of a
certain class there are multiple things
we want to remove any character that has
the property of being a
mark
and so this
is like a spacing mark things that
adjust the spacing
um so that's part of being spaces
we want to remove anything that has a
property of
being a space in itself
of course and then we want to remove
anything that has the property of being
punctuation
punctuation
and we can use look at and what happens
when
well we can we should before we run this
we should really take this and try it
out
so here we can see that we kept all the
digits for example
and now we can try it
and now we can see that the last one so
let's look at u and v again
the last ones are considered different
from each other because we now keep the
digits even though the punctation has
been removed
and i think that's all there is to say
about this problem thank you for
watchinghello and welcome to the appear Quest
see APL Wiki for details
today's Quest is the second from the
2016 round of the APL problem solving
competition
we are given
some numbers
normally as a list but it could also
just be a single number and we are to
compute the median that is the middle
element
if you order them by size
and if there isn't any middle element
then we take the two middle ones and
take the average of those
first let's start with some test data so
there's a difference here between even
and odd length lists because of there
being a middle element or no middle
element
so the first example we're going to do
is we're going to have an odd number of
elements
and here if you order them we get 1 1 3
4 5 and so the middle element would be
the three
then
in this case there is no middle element
because we have four elements so if you
order them one one three four the two
middle elements would be one of the ones
doesn't matter and a three and then the
average of that would be two
then we could also be given a single
element
in which case we're supposed to just
return that so this is not a vector
another list and we could also be given
an empty vector and the problem
specification then says that in that
case we should say that the median is
zero even though there isn't any
elements
so the empty Vector empty list numeric
one is written like this in APL and
finally we should also make sure that we
handle the one element case because
that's not empty but and there is a
middle element but you can't just go and
take two elements because there aren't
two there's only one in order to get a
one element list we take
a number and then we Revel it so this
flattens it out to be a list of all its
elements which is just that one so this
magnetic comma is called Revel and then
also note that APL denotes negative
numbers with a high minus and normal
minus is for subtraction and this
removes any ambiguity
so now we have this list
of lists and we're going to try out our
code on each of them so what we're going
to do eventually is we're going to use
the each operator if we use that to the
immediate the right of a function it
will be applied to each element
basically a map
right so how we're going to compute the
median and there are a few different
ways and and
one way we could do it is to sort
and then we can remove the elements that
are before the middle ones and the one
that's after the middle one so let's
just get started
so
we defined a function in the braces and
we're doing the each here on this
applies the function to each element so
we're trying out all the different test
cases
and then the argument inside the braces
is denoted with the Greek letter Omega
and it's because the argument is on the
right and Omega is the right most
letter in the Greek alphabet
and so the way we sort in the APL and
there's no direct sort function in most
dialects of APL but what we do have is
something called the grade so this is
the grade function and what the grade
does oops Yeah so here's a problem our
first problem is it won't grade our
arguments because we don't we one of
them is a scalar it's a single element
and it doesn't have an ordering so we
cannot error you cannot change the order
we cannot create it either
and so much like we did
um when we were to write one element and
list we use the comma function the rebel
we can do that here so we could do a
revel on each and then we could we can
apply our function here grade on each
and this will work
however we can also combine these simply
by parenthesizing them and so this is
called an atop it's a sequence of two
functions
um and we only need parentheses here
because we are calling it in in place
and we want the each to apply to both of
them together so we're grouping them
with a parenthesis and then what this
just means is apply the first function
that the one that's the right and then
on the result of that apply the second
function so now we can try this
um and that works as well
so this is great what grade means is it
gives us the list of indices that would
put the array into order
so if we have a look here the first one
three one four one five
so then if you want the smallest element
then we need to go to position two that
would be a one
and the next one because it's a stable
sort which means that if things are
equal then
um
then they they preserve their relative
ordering from from how they came so the
leftmost one becomes the first one and
then the second one which is in position
four is becomes the second one and then
we want element number one which is the
three then element number three which is
a four and then finally limit five which
is a five
as well and so too here and that means
if we take these indices
and use them to index into the original
array that will be a sort
and API allows multiple indexing in one
go so we don't need to map over the
indices and then index rather we can
just take all the indices that we want
and put them into the square bracket for
the indexing and that gives us those
elements here so now we get the sorted
list
representation of these arguments
and we should also note here that
um what we're seeing is a zero here for
the empty list but these arrows indicate
X's that are available and so there's
one axis in each there's a
one-dimensional array and this uh
Circle bar thing indicates that there is
an axis but it's an empty axis and the
zero is only here to indicate what type
of array it is so it's a numeric array
okay so now we've got uh the sorted list
and what we could do then
um is we we know that
the first and the last element are not
the ones we're looking for we want the
middle elements
so we could drop the first element so
this is one drop and we could drop the
last element so negative one drop means
drop from the rear
of course this isn't entirely correct
for our very short arguments over here
but we'll fix that in a moment
and we could keep dropping until we have
one or two elements left
so we can see here we have three
elements left so we could do this again
one drop negative one drop
and then we have the three which would
be the median and over here when we got
two elements left then we want to
average the two so all we need to do
really is keep dropping from the from
the front and from the rear uh until we
have one or two elements and then that
gives us our result
and we can do that in a recursive
function
um but before we we start with the
recursion let's just set up our stop and
condition otherwise we might end up
going Forever by mistake and so our
custom condition
um is and this is we separate the two
statements here with a diamond because
diamonds are Unbreakable
um and then the colon here is a
conditional and so we have a condition
on the left and then the immediate
result on the right of the colon and if
the condition isn't fulfilled then we
continue after the diamond with the next
statement which would be this
um and so here we're going to take the
tally of the right argument of Omega and
this looks like a Telemark so this is
counting how many elements there there
are and then we say if that is
and if 2 is greater than or equal to the
tally that means we have zero or one or
two elements then we're done we don't
want to remove anything more so then we
could return the argument as it is now
if you try this
we can see that we're preserving now we
didn't drop anything from these last
cases because they already have uh two
or less elements
of course we're not quite done yet
um and if we keep dropping we can try
this one drop negative one drop here
then
um
you can see that we don't that only
happens on the long
um and the long arguments but we don't
want to do that we only want to do one
step
and then we have a either zero elements
left or one element or two elements left
eventually once we
um we do our recursion and we'll take it
from there in a moment so how do we
recourse it's very simple we use this
upside down triangle which is actually
upside down Greek letter Delta or Del
which is like
um it's called Del or nabla
um and it's kind of like a d d stands
for definition so it kind of calls its
own definition and this allows us to
recurse in an anonymous function
Anonymous Lambda that which is what we
have here
um so here we recurse until we have the
length and less than or equal to two
and that is what we get here so you can
see then we had the odd links we're
getting just the middle element and
we're done
uh if you have even lengths we end up
having two elements left and if we and
otherwise if you start the short we just
returning the right array so now we want
to compute the average
um of these and there are a couple of
ways we could do this
um
but there's a problem with the empty
list for computing averages so a really
neat way I think is to do a cyclic
reshape of this we know that we only
have zero or one or two elements and if
we
do a this is a Greek letter rho which is
like an R stands for reshape so this
reshapes to length two and it does so
cyclically which means that if you have
one element it becomes two if we have
two elements it stays as it is if we
have no elements then it will use that
type remember this indicates the type
which is the zero that's a prototypical
number
and we will use that instead of any data
because there isn't any data there so
here we can see that we end up always
with two element
um lists or vectors and then it's very
easy to compute the average of that we
can sum them so this is a plus reduction
and then we can divide by and two
to get us our result so this is the and
these are the medians for all of our
arguments and I don't particularly like
parenthesis but we need a parenthesis
over here because APL goes from
um has a long write scope
if only we had a division function that
had swapped arguments so instead of
dividing the left argument by the right
argument it would divide the right
argument by the left argument then we
can avoid this parenthesis and while we
don't have that built in we can
construct that using the commute
operator or swap operator so this takes
the division and flips the arguments so
now the two goes on the left and then I
like the way it looks like this
so we can assign this
so this is the recursive version of
median
okay let's do it a different way this is
not a very good way because of course
We're looping over in or recursing here
over and over and over again
um you know we have tail recursion uh
telcro uh till call optimization
um still this is a bit silly to Loop
through like this and you know it should
peel off elements instead we could we we
had this one drop a negative one drop
and we don't have to use one we could
use any number so if we can compute how
many elements we need to remove that
would be much better and turns out of
course we can compute
that so if we look at number of elements
let's have a look at our original D here
so here we have a length five
and we need to remove two from the from
the beginning to from the end if it had
six there would be two middle elements
so we also needed to have two elements
from the beginning or two from the end
then four we need to remove only one
um and if we had
three we also need to only remove one
and then we'll end up with a single
element in the middle and then if we
have
two elements or less we don't need to
remove any elements at all
so clearly this is something that has
something to do with the length but
flattened down so to say to to by half
so we have and if we start making our
next longer it will be zero zero one one
two two three three and so on
and we can compute that we can try it so
if we start by generating all the
indices so this is the index generator
Greek Iota Iota is like an i i for index
generator
um then we can divide
by two
and we can kind of see it here how uh if
we round it off we would get two of each
but we are a little bit off
because this was
um this is one and two and three
and really what we need to do here is
um drop less than that so if we
if we add negative one so you can see a
case where the high minus does is good
now for one and two we want to drop zero
for three and four we want to drop one
for five and six we need to drop two and
so on and that's exactly the formula
that we want
so and we're going to use the length of
the argument
and then and this is uh yeah should be
obvious before this is round down Laura
um and then we uh this is the amount
that we want to drop
so we computed that this is we're
assigning that to D
next statement we're going to use the in
and in much the same way as before so
we're taking and and sorting
first and then we can do a d drop
and also in and negated the drop so this
drops the first and the last we can try
this on our on our arguments those is
here the scoping so even though our test
data is called the we can use the D
inside and there's no problem because
inside we're using Omega for the uh as
the name that's the special name for the
argument
oh
again we have the same problem that
we're trying to do this on a scalar so
let's do the same trick as before
and and this works very well we can see
that we get either one or two elements
which means we are almost done we just
need to do the same thing as we did
before we can do a cyclic reshape to
size two
and then we sum that
n divide by 2.
this gives us our median
so this was the median computed by
dropping and Computing the amount that
we need to drop
but in fact we don't need to modify the
data At All by dropping elements and
what we could do instead is
compute the elements that we that we
want the indices are the elements that
we want and then we can just go and pick
those out directly instead of having to
chop our way until we get to them so how
would we do this
this time let's make sure to remember to
Revel first
Okay so let's think about it here and if
we have length
three we want
element number two if we have links four
then we want element number two and
three
um and if you have five elements we want
element number three so it keeps going
um up and down like this in fact if
you're going to sum them and divide by
two we probably want them twice so if we
have three elements we want element
number two and then element number two
if we have four elements we want element
number two and number three and so again
it's going to be this kind of increase
by and half all the time let's start off
by the length
um and instead of adding and
or subtracting one as we did before
we're going to add zero and one and so
this
um this is list is being added to the
single number which is the length
and then we divide by two
and then we can almost see where we're
getting and remember the first one has
five elements we wanted element number
three element number three
and here we want uh this is with four
elements so we want element number two
and number three and we can see we just
need to round that up just like we did
the floor before corresponding
symbol going up that is the ceiling
and so these are the indices that we
want except for our short uh the two
short thing when when the length is zero
then it isn't working right in that case
and we should just return zero because
we can't get the indices in of uh in
this index number zero index number one
that doesn't work
so a couple of different ways and we
could do this we could do this before we
could say if one is well actually we
only need to do it for that and
for that is one Element so if zero is
sorry for that zero element length if
zero equals the tally of the argument
then and we return 0.
and then we need to
use these indices so this is then we're
done that's our result over here we need
to use these indices to index into our
argument so we use the indexing
and then we we just need to sum
and divide by 2.
oh something isn't right here
oh of course yes do you spot what I've
missed we're indexing into the
um
into the original data that hasn't been
sorted yet so we need to sort that first
um of course so we use the grade just
directly and index and so this is the
sorted argument and then we're indexing
into that to get an
our result so this gives us
um our result
in fact we don't need to check the
um the length at all we could just
compare to the empty list itself so if
the argument is identical to the empty
numeric list then we return a zero so
that's another way that we could write
this
and so this is the median using indices
and that's three ways of computing the
median
there are a lot of different ways and
that it could be done I'm not going to
go through anymore now I'd like to
mention
a variant of this
so far we've been sorting the numbers
and then we've been either
peeling off from the outside or we have
been dropping from the beginning uh or
from the end
and and finally we've indexed directly
into
the sorted list
a different approach a little bit in
getting the right elements out since
we're Computing the grade would be
um to index into the grade itself
and then
use that to index into the main data so
let's modify this me and this median I
and just a slight little bit
and the reason for that is because when
we are sorting here and we are
it could be that we have a data type
that's inefficient and compared to
indices for example the floats that use
of multiple bytes per element whereas
the indices themselves for at least for
small array would just be one bytes per
element or maybe two bytes per element
and so what we could do here is we could
index into
and into the grade
and then that gives us the indices that
we need to get from our full argument
like this
so we can say median I2 on each of the
data that gives us our correct result as
well similarly for the other two
solutions we could do something like
this
right that's all for today thank you for
watchingwelcome to the apl quest ca pill wiki
for details
today's quest is the first from the 2016
round of the epl problem solving
competition
we are
simply to compute the mean or
arithmetic mean the average
there are a couple of gotchas here but
for the very basic part of the problem
this is extremely simple
now the mean is defined as the sum
divided by the count
so we could define
the parts
of the mean and then combine them
for the whole thing
we could do that like this we can define
small lambda functions in apl
using curly braces
inside the curly braces the argument
is denoted omega
and then we need to actually compute the
sum
and we do that by inserting plus between
the elements also known as reducing
using plus so this is plus
and
this is a reduction
and this function then sums
let's define
so this is a list or a numeric vector
you can
sum the numbers
like this
now we want the count
and there's actually a built-in function
for the count
in apl
it's also known as tally that's why it
looks like a telemark
next we can combine these
so here we define a mean function
and we want
the sum of the argument
divided by the count of the argument
now i put parenthesis on the left here
and i didn't put parameters on the right
and this is because
apl's order of execution is such that
any function
of
these functions for example and also
built-in functions every function takes
as right argument everything to its
right as far as it can see until it gets
stopped by say the end of the expression
or the end of parenthesis
whereas as left argument it only takes
what's immediately to its left
so
we need to make some
take
as argument just
the right argument to this outer lambda
and but we and we want count to take its
argument this other argument
and then the right argument to
the division function should be
everything to its right so that's the
entire expression on the right that's
the count there so we could parenthesize
as well the count but we don't need to
we do need to parenthesize the sum of
the argument because otherwise
without this what some would take as
argument would be everything to its
right
in fact it would give the same result
because we would be dividing all the
elements by the count first and then
summing them but that's
less precise and
not less performant either
okay so now we've defined the mean and
we can
apply the mean to p and we get the mean
of these
numbers
but there are some notational niceties
we can do in api as well
there's something called tested
programming or point speed programming
which basically just is a fancy name for
meaning i'm not going to mention my
arguments
so here
we have a mention of the argument and
over here we have another mention of the
argument
and basically and
what happens if we go test it is that we
express everything in terms of functions
so we have the sum function applied to
the argument
divided by the count function applied to
the argument and this can also just be
expressed as the sum function divided by
the count function
so we can get rid of a lot of noise we
don't even need the outer braces anymore
that's the indicator that we're going to
use the
the argument name
and so we can write it just like this
the sum divided by
the count
so these two outer functions are applied
to the argument
and the middle function is applied
between their respective
results and the function still works
what's interesting here is that
we've defined sum and count in fact we
can redefine them as tested functions as
well so we can we can redefine sum
we defined it as
the plus reduction of the argument but
again we're mentioning the argument and
we could omit the mention
and remove the braces so we could write
sum like this
and we could write count
similarly just like that
and then we can redefine mean in terms
of these new sum and count
and it still works
of course this is a bit ridiculous why
would i give a name sum
to something that's shorter than the
name itself some is three characters and
we probably can't really find any
any name that would be as short as two
characters which is the definition of
some count here is five
current uh characters but we only need
one character to express it so we could
just take these
and
these values and substitute them in to
our definition for the mean
so we can just write
the sum
divided by
the tally of the count
and then we can compute it like that
in fact we don't even need the spaces so
the entire mean definition
can be written
like
this four characters
at which point you might then question
why would you even bother calling the
function mean when you could just use
the four characters
for that means the mean and then
everybody can see exactly what it means
anyway
this is a short way of defining the mean
and there's a problem
and that is that the problem
specification you can look there
and says that this also has to work on
the empty list
and if we try that so we have a symbol
for the empty list which is called zelda
because it is a combination of
a zero
and the character tilde and
you pronounce them together as zelda and
it basically means
there are no numbers it's an empty list
like that so we can see that this means
this picture here means that it has a
single axis the axis has
no elements um and
when we have it being numeric this means
the type is numeric and this is just an
example of what such an element would
look like it would be a zero if there
had been elements there but aren't any
you kind of see the zero tilde thing
now if we try to do the mean of the
empty list we get one which might be a
bit mysterious but what's actually
happening here is that when we sum it we
get zero and we count how many there are
elements there are we also get zero and
zero divided by zero is traditionally
defined not as an error but as one in
apl for consistency such that all
numbers divided by themselves
give one
however in this case that's not very
good we want the problem specification
says it has to give zero
so we can fix this because
we have only in the case where there are
zero elements we get the sum divided
which is zero and then divide by zero
which makes it too big
but if we were dividing by one instead
then we have zero divided by one
and then
that would give you zero and that's the
result that we want
so we can fix this
by
taking the maximum
of one and the count so if the count is
one or more then it doesn't make a
difference if the count is zero we get
one so we basically clamp it to become
one or
more and how can we do that well if we
go back again to our very verbose
definition of of the mean
where we had
and let's now substitute in here
the sum of the argument
divided by the count of the argument
well then we need a maximum function
which we have in apl it's denoted by the
up style
and you can kind of see that
it's like this vertical bar and then it
has a bar at the top indicating that we
want the maximum correspondingly the
minimum would be this it's a vertical
bar with a
indicator at the bottom but now we want
the maximum
and then we can put in a 1 over here and
keep in mind the order of execution in
apl every function takes as right
argument
everything to its right as far as it can
see so
maximum here takes the count of the
argument
and the omega
as its right argument and its the left
argument is to its immediate left so
that's just this one
and division takes the result of this
entire expression on its right
and now
mean works as before but if we do it on
the empty list we get 0 as required
but we can actually do this testedly as
well
again in terms of just function
application on the argument so here we
have the count
and then we do the maximum of 1 and the
count that still works like that
and then we have a division and what we
want to be divided is the sum so this
says the sum divided by
1
maximum
count and the count
we can again substitute in here
and this gives another again we could
remove spaces if we wanted to and this
gives us the mean which works
on p
and mean which works on
um
on the empty list
and this is a a very good solution to
the problem and let's just demonstrate
some features of it because actually the
problem wants us to
make this applicable even to higher rank
arrays
so apl arrays are
not just lists of things but they can
actually multi-dimensional they can be
arranged along
multiple x's
let's define a second number
so
now we have p and we have q these two
lists
um and they are one dimensional there's
only one axis that can be collapsed by
taking the average over that axis but we
can combine them
in various ways
and one way to combine them is to
combine them into a a table or a matrix
of two columns
and we can do that by making each one of
them into a
a one column matrix or a column vector
also known as that
and then
concatenate them together
so we have this
function comma bar
which is called table
and it takes an argument say q
and it makes it into
a
matrix so here this arrow indicates that
there's a single axis along which the
elements are ordered
and here we have two arrows which says
that there are two axes
along which the elements are ordered so
this is the the first x's
which are the rows and the second x's
which are
the columns and we could of course do
the same thing
for p and then we could combine the two
of them with concentration
so we can take the table of p
concatenated with
the table
of q again i don't need parenthesis on
the right because
the concatenation function takes
everything on its right as its right
argument
now we have a two column table
we could actually write this in a much
neater way because what we can see is
symmetry here
we see that we are concatenating the
tabling
of these two arguments
p and q
and we have a way to write that in apl
we can write p and q
concatenated
with each other but we don't want to
concatenate the p and the q we want to
concatenate a certain aspect of p and q
namely their table form
and for that we use what we call the
over operator
you could
see this as pre-process the arguments
as
um
in a certain way
and so this is not a function this is
called an operator that's a higher order
function it takes the concatenation on
one side and it takes the tabling on the
other side so these are two functions
and it
it combines them into a new function
which isn't concatenation it is the
concatenation
of the tables
so this does exactly the same thing as
the previous expression we wrote it does
a table on each one of them and then it
concatenates them together
and so with this new array which we can
call a
we can take the mean of a
and this gives us a two element vector
or list one per column
and what's why is it why is it doing the
average vertically so to say
because it's
the tally
counts
along the leading axis
how many
elements or sub-arrays are there along
the leading axis
and so for both of these um and it
couldn't be otherwise it can be ragged
there are five
and also the summation that we did which
was the the plus reduction so this was
the reduction symbol um which actually
also isn't a function it's an it's an
operator higher order function which
takes this plus
and modifies this
much like the over operator modifies the
concatenation
modifies plus to become a plus reduction
or a summation
and this also works
along the leading axis which is over
here
so we're summing each column and then we
are we have the two column sums we can
try this
and then we're dividing by the tally and
the number of
rows and that's why we get the two
averages apl automatically
pairs up
elements of arrays when we're doing
arithmetic so 2.8
and um
is the result of 14 divided by 5 and
3.2 is divided the result of 16 divided
by 5.
what if we wanted to
to sum
and count along
the rows
well then there's another operator a
higher order function that we could use
to modify
a function and it's not just built-in
functions that can be modified even our
and our own function mean can be
modified
so we count the number of dimensions
this has two dimensions this whole thing
but each row in itself only has one
dimension and we want to apply the mean
function not to the entire table but
to the one-dimensional
sub-arrays of this table and for that we
have
this which is called the rank operator
it takes this function on the left and
then the specification of the
dimensionality or rank
of
the argument that we want just this mean
function to see
and so
this says the mean
on each subarray of rank one that is on
each row and if we do that
then we get five results so two is the
the average of three and one and three
point five is the average of one and six
and two point five is the average of
four and one and so on
and so this by defining a function in
terms of the leading axis this allows us
later to also
have a function available that we can
apply on other axes simply by using this
rank
operator
and that's all i wanted to show for
today thank you for watchingwelcome to this second episode of the
apl quest check out apl wiki for details
today's quest is called making the grade
it's the second problem from the 2013
apl problem solving competitions phase
1. here we are to write a function which
takes a list of numbers representing the
points that people scored on some type
of test
if they scored 65 or higher then they've
passed in the test and we are to compute
the percentage of people who passed
let's start off by generating some test
data so here are 10 scores between
1 and 100 and those that's
succeeded in the test had scores 69
and 72.
so
we know how many
scores there are in total
and we can compare all these scores with
65 so
if the
test scores
are greater than or equal to 65 then
they have
succeeded and this gives us a boolean
vector indicating the ones and zeros
the ones that have
succeeded
then we can sum the boolean vector to
find out how many have succeeded
and then we can
divide that by the total number
so this gives us a fraction and we can
multiply that by 100 to get a percentage
putting all this together
we have the function f
and
and we take 100 multiplied by
the sum
of the scores that are larger
than
65 divided by the total tally of
scores that's the argument here not the
variable t
and we can try this on t and that gives
us the correct thing now there's
something here that's worth noting
and we are doing a bunch of different
operations on our data and while
mathematically equivalent it is
important which order we do this in in
order to have the maximal performance so
here are some variations of things that
we could do
in f
we started off by the comparison and
then we summed
however we could also
start off a bit differently so
let's say that we start off by doing the
comparison
and then we divide
by the total count
then we sum
and then we multiply by the 100. so this
is mathematically equivalent but we'll
see in a moment and it makes a big
difference
what we could also do
is we could start off in the same way
by computing
the numbers
greater than or equal to 65
we could divide by the total number of
numbers then we could multiply by 100
and then sum again mathematically
equivalent
but this makes a difference in
performance let's generate a bunch of
test data
so
um
here's some test data we're going to do
random numbers between 1 and 100 but
this time we're going to do a million of
them
i'm not going to print these out
let's get in the com
pair execution time utility from the
defense workspace
and
then we're going to run
f on these test scores and g on the test
scores and h on the test scores
and we'll see in a moment
that there is a
quite significant difference in the
performance here
so
what is it that's actually going on
in f
we are
doing
if we call the number of uh
of scores n we're doing n comparisons
first
and then we are doing
n minus one additions
we're doing
one
division and
one multiplication so we can write this
we're doing
n
comparisons
right like this
and then we are doing an
n minus 1
summations
and then we're doing
one division and one multiplication
in g
we again start off the same way we're
doing
n comparisons
and then but then we're dividing every
comparison with
the tally so that means we're doing n
divisions
and we're doing
the summation after that so that's n
minus 1 summations
and finally we're doing one
multiplication
and in h here we are doing starting off
the same way with
an
n
comparisons then we're doing the
n divisions
and then we're doing n multiplications
as well
and finally we're doing
n minus 1 at
additions
so
while these are mathematically
equivalent we can see that there's going
to be a big difference in the
performance and indeed an f is the one
where we're doing the least amount of
work
so
looking at
f again
we can come up with some variations and
in the live chat event that happened
last friday and there were a bunch of
variations and they were all over this
same theme and trying out various ways
of expressing this
so here we're doing dealing with a
scalar the cutoff point 65
and a vector these are all the scores
we should notice this pattern we have a
sum over a comparison of vectors so it's
two scalar functions a reduction over a
vectorized operation
and we have that and we're doing apl we
should think inner product
so we can take these and combine them
like that
and we can call this i so this is going
to be
the same
we give the same result as before the
test result here now why am i doing this
this is because this allows us to move
on to a tested solution that's really
really neat
notice that
a
tested solution
expresses everything in terms of
function application on the argument
rather than
explicitly stating the name of the
argument
so the argument here is omega
and the function that's being applied to
omega is the tally
here the function that's being applied
to omega is the inner product
with 65 as a bound constant
right argument to the inner product
and that we can express as a tested
function really neatly
so we get rid of our braces
the application of tally on the argument
becomes just tally
the application of the inner product
with a bound right argument we use the
bind operator to bind that right
argument to the inner product and that
allows us to get rid of
all the noise
right there it's going to have about the
same performance but for those that like
test programming this is very nice
but we can also spot a thing here we
bound
the argument which is the cutoff point
what if we want to generalize our our
function such that we can take the
cutoff point as an additional argument
in apl it's common to have the main data
as the right argument and various
parameters as a left argument if any
so we really want to move the 65 or
whichever number we use as the cutoff
over to the left side
of course we can easily do this
by flipping
the direction of the comparison
then the 65 can go on the left so the
same but it's a tested function
the problem is that we want the tally of
only the right argument
if we left it the way it is now it would
be
the mismatch whether or not they're
different and of course they are
different and we'll be dividing by zero
which is not what we want
so what we can do is that we add a
little construct here and a top
right
so this applies tally magnetically
on the result of choosing the right
argument
another way
that we could generalize this is by
saying the default cutoff point is 65
so we can go up and say instead of
using 65 as a constant in here we supply
it as a left argument
but if no left argument is given then we
use 65.
so now we can say
that the cutoff point
is 65 we get the same result
if instead we make the cutoff point 50
oops i made a mistake here
oh yeah of course not t 50 and apply the
function l
um
then it's 40 of the scores that are
that pass
and we have here 69 60 63
and 72
i'd like to show some some interesting
different approaches to this problem
since everything we did now was using
the same empathic method basic method
these are not efficient but nevertheless
they're kind of eye-opening in
completely different ways you can attack
the problem
the first one
makes an assumption that all our scores
are integers between 0 and 100 so we can
generate our scores
that would not pass
and then we could
remove all those scores that wouldn't
pass
leaving only those that do pass
and now
between this set difference um
the the ratio and of the length of the
set difference and the original is then
the ratio of
winners
so we can take
the winners
and the original
and
do a ratio
of
length
so this is the over operator we're
applying tally on both arguments and
then we're dividing them and that gives
us
our ratio and we can multiply by 100
so we can put this into a function
here's our argument
and a different
approach to this
is
in using the interval index function
so if we have our test scores here
then we can put some
interval cutoffs so let's say we put a
cutoff of
20 and a cutoff of
65
and this gives us the indices of the
intervals that these numbers fall in so
4 is below 20 so that's index 0. it's
before the first one
and 69 is
is after 65 so this is
one in the middle and then to the right
of the last one is number two
and 22 is right there in between
however we only want one color so we can
make a vector that has but one element
and this gives us
they're still indices but they also
happen to be boolean because either
something falls before the first cutoff
or
in the interval that's formed to the
right of that cutoff
inclusive
so now we could sum this up and divide
by uh the total number of
uh of scores
but let's do it a little bit differently
instead we can use iota algebra again
but this time magnetically and that's
where this computes the indices of those
that
fulfill the requirement of being above
65
and now we can use the same method as we
did above where we
take this result and divide
with uh
over the tallies of
the original
and then we add
the last thing so this is using
where and the interval
index
so we can say it's 100 times this
and of course
for both s and t we could
modify them to take an optional or
required left argument
so here are all the definitions that we
did today
compare them don't forget to
check out what the performance looks
like on the kind of data that you're
running with
thank you so much for watchinghi
this time we're given a list of numbers
and we are going to check if it fits
into this pattern where
we have a
non-decreasing segment followed by a
non-increasing sediment this might sound
backwards to say non-decreasing
non-increasing but that I don't really
want to say increasing and then
decreasing because plateaus are fine
it's okay if the value stays the same
as long as it's not going the opposite
direction
okay
how are we going to do this
let's have an example of something that
does go up and then down again
okay this is very simple
and a very neat way of doing it
is by
by doing a normalization we could say do
a transformation
of this
list such that it will only stay the way
it is
if it abides by the rules and if there
are any breaks to the rules then it will
be changed and then we can compare the
original list with
um the modified one
if they're the same
then it abides by the rules and if not
then it doesn't abide by the rules
okay we're going to do this test it from
the outset that means we're only
applying functions and never mentioning
our argument by a name
and so the trick here that we're going
to use is we're going to do a maximum
scan so the maximum function is a
function that takes two arguments and
Returns the larger of them and we're
going to insert it between the elements
here
but over the prefixes so we're going to
insert it first we'll have just one and
then do one and two that gives two then
two and three that gives three then two
three four or one two three four
actually and that gives us four one two
three four five gives us five one two
three four five three
now the maximum that we have seen is 5
which means that the corresponding
element of the result to 3 will be 5 and
same thing goes for one so we can try
this this is a maximum scan
so here we can see that after we hit the
highest value we don't go down again
and this is a nice way of
um expressing the idea of being
non-decreasing
what about the other way what if we're
going to
start from the right
and do the same thing that means after
we hit the highest point we stay with
the highest point going left
well we don't have a scan from the right
but we can pre-process
the scan
argument with a reversal function
so now we reversed
the argument one three five four three
two one
and then we did the scan and that gave
us and the one three five five five now
we just need to turn it around back to
its original order
and here we have a scan from the right
okay
how can we combine these two because we
want to preserve the array the way it is
if it divides for the rules there are
two parts to this
but for this particular problem
we can combine them by taking the
minimum value if we now compare
this list here and that list there
then the minimum of one and five that's
one the minimum of two and five is two
three and five four and five up until
they meet and then we go down on the
other side the minimum is not going to
be down here that's the three and the
one
so we take another maximum scan which is
the one that goes from
left to right and this is the scan that
goes from right to left and we take the
minimum of the two
but the pattern here that for tested
functions is that an outer function is
applied
and the inner function is applied to the
results of the outer functions
so that pattern is broken if we try to
put the reverse function in here this
should be the inner function altogether
but notice the pattern here is very much
like this where we want to pre-process
the right argument with a reversal
so pre-process the right argument with a
reversal that's this operator
and that gives us the back the original
array
now let's try if this indeed holes if we
make any modifications so here after the
end we go back up again
and we can see that
the
the three and the one the four got
smeared out so to say by the four coming
in from the right when we when we are
um doing the scan
the maximum scan from the right we get
four four and then five and we go from
the left we get three four five five
five and then we take the minimum of the
two that's going to be the four that
came from here and that means that
there's a difference there
we can also try doing it with a value in
the middle we can see that kind of got
painted over by the three from the right
and the four from the left and therefore
it became a three the minimum value
what if we turn the whole thing upside
down
here the five coming in from the left
with a maximum scan paints over fives
until we get to a larger value and the
Seven makes sevens all the way to the
left the minimum of that is going to be
all the fives with a single seven so
this looks good now the only step that's
missing is that we compare this to the
original argument so we need to do a
comparison of all the elements together
in one go
with the original value which we can
represent with the identity function
applied here so the way this this
executes and binds is every other
function is applied to the argument
and the intervening functions
are applied between those results so we
do scan from the right in the reverse
we do the scan from the left
and then we do the minimum of those two
but reordering the right side to become
its original order
and the result of this is compared to
the result of the identity function
which is the original argument and so
this doesn't hold
but if we did
something like this
then it does hold
and in fact we don't even need this many
spaces we can we can remove all of that
save some
horizontal screen estate
this works
very nicely
thank you for watchinghi we're going to write a cover for the
diic Iota or index of primitive in
APL which behaves exactly like the
original except one thing so when we use
D goota to look up things from the right
argument in the collection that's the
left argument and what we're looking for
isn't found it will
give the next index after the last
position to indicate that something is
not found this is a really useful
Behavior because it allows us to take
indices where things are found and use
those to index into another substitution
collection so we can do a mapping from
one thing to another and then we can add
another element at the end which all
missing elements will be mapped
to but the problem here is to change
that behavior so instead of getting the
next index um after the last element we
are getting a zero which um only makes
sense when we using one based indexing
which is what APL does by default um
because that means that zero will also
be a unique result it will indicate an
element before the first one instead of
after the last
one and there are a couple of different
ways that uh we can do this let's first
look at
just the normal behavior so here we've
got the adota we have character
vectors and we can see
that the a was found at position three
that's this one and then there are six
letters on the left we're looking for p
there aren't any so we are indicating
position seven and then position four
for the L over
here okay so there are a couple
different ways ways that we could
approach this and one of the ways is to
Simply check whether or not the
um index that we get is larger than the
length of the left
argument so we can do this if we say
that uh the index that we
got is
larger than the length of the left
argument and then we can use this to map
the seven to a zero so an easy way to do
it would be using multiplication but
then it's doing the wrong thing because
we're multiplying the three and the four
here with zeros if we instead invert
this uh conditional so instead of being
greater than and then not greater than
that's the same thing as less than or
equal to
and then we can take this and multiply
it with the indices themselves over here
so this goes from the right to left it
binds like this that is the length of
the left argument and then we have the
index and then we have the comparison
then we multiply that with the index
itself and that gives us a result that
we want however there's a bit of an
inefficiency here in that we actually
finding the indices twice and we can fix
that in various
ways one of the ways would be to take a
new function that takes as arguments the
indices and the length
of the length left argument which are
all the data we need we don't actually
need access to our original arguments
and apply a function to those
so here we have the indices and the
length of the left
argument and then we want to have the
same formulas we had above but instead
of taking the indices and the length of
the left argument we can just refer to
those arguments so here less than or
equal to that is applied between these
two arguments and then we multiply by
the left
argument so this is one way it could be
written we we could also have passed in
the left
argument directly and then we could have
this was still referred to the indices
then we could have compared the indices
which come from the left with the length
of the right argument that means we
would want to take this function and
apply it between these two arguments
versus the left argument and the indices
but pre-processing the right argument to
the comparison function with the length
so we can do that as follows and it will
still
work a whole different way to do it is
to
postprocess the indices that we
get
so essentially what we want to do here
is we want to wrap around when we hit
the limit which is the length of the
left argument and we want to wrap around
to zero and this is exactly what modulus
or division remainder
does so if we take the
indices and then we want to wrap around
where the cut off is one more than the
length of the left argument so we could
write that in a tested Form 1 plus the
length of the left
argument and this would still
work um we could also eliminate this
parenthesis by swapping the argument of
the modulus
function so this operator modifies this
function such that it takes the
arguments in reversed order and then we
take the indices like
that another way to do it is to Simply
Define this as an explicit
function and that might actually read
nicer and it's no longer
so these are some good solutions to the
problem thank you for watchingwelcome to the appeal Quest Capel Wiki
for details
this is the seventh problem
from the 2016 round of the APL problem
solving competition
where to take a list of numbers and
filter it such that the only numbers
that remain are those that can be
cleanly divided by either 3 or by five
or well by both
let's get started
first let's
create some data that we can test on
so
here's some integers
and just for the fun of it that also
have some numbers that are not whole
numbers
okay
before we go to look at what actually is
divisible by three or five and let's
have a look at a very special feature of
APL which is called the outer product
conceptually it's actually really really
simple
um and especially in its basic form
where we just give it two lists
so here on the left we have a list of
numbers and over here on the right we
have another list of numbers and all the
other product does is
make a combination
from all the combinations of every
element on the left with every possible
element on the right in other words
we're making a table of such
combinations
the most common example of such a table
would be a multiplication table
and the syntax in APL for making a table
or an outer product is this jut and then
a DOT and then we put in the function
that we want to make the table for so
multiplication multiplication table
would be jut dot times
and here we can imagine that we have the
headers going down the left side and
across on the top so one two three four
on the top and 10 20 30 we also see the
10 20 30 because we're multiplying them
by one
now instead we can use a different
function than multiplication in our case
we want divisibility
now there isn't a
divisible by function in APL but there
is a remainder that is if you divide how
many do you have left over after you try
to distribute evenly with whole numbers
and so we can take our numbers and then
we can take three and five on the list
on the left and create a divisibility
table
um that shows the remainder whenever
we're dividing
so here you can imagine three and five
going down and these numbers 1 through
16 across we can see that the remainder
is 0 1 2 0 1 2 0 and 2 because we keep I
think one for when it comes to three and
zero one two three four zero one two
three four and so on for five and then
we can see that
for numbers that are not wholly
divisible then uh the non-integer part
the fractional part is also part of what
remains because we cannot divide that
cleanly you see that the three went away
from three and a half but there's a half
missing whereas for five the whole three
and a half is the remainder
and so something is divisible if the
remainder when you try to divide it is
nothing if there's nothing left that is
if we have zero
so we can compare zero to this and APL
uses long write scope what does that
mean it means that the equality function
takes us the right argument whatever is
all everything that's under its right
all the way to the end of the expression
and so we don't need any parenthesis
here
and so and we have
a table
that shows us a one which means true in
APL
whenever something is divisible
and a zero when it's not divisible and
we're not actually interested in whether
or not it's divisible by specifically
three or five we just want to know if
it's divisible by any one of them so we
want to say yes keep this number if we
have a A1 at the top or we have a one at
the bottom or both
and we can do that by using the or
function and we're inserting that we're
using a slash bar after that it means a
vertical reduction so we are sticking a
or an or in between so to say the space
between the first row and the second row
and that reduces this two-dimensional
array which you can see is two Dimension
over these axis arrows and introduces to
a one-dimensional array so here's a mask
indicating from the numbers in this
variable D which ones are divisible by
um by three or by five
and we can use this then to filter and
we do that with a slash
so we filter d
and that gives us just the numbers that
are divisible by three or by five
we can actually get rid of the
parenthesis if only we had a function
that was like the slash but with swapped
arguments which isn't built in but we
can construct it with a higher order
function called commute
and it looks like this frown because
it's all getting confused which side is
what
and then
it modifies the function on the left to
swap its arguments so here we have
exactly the same thing
and finally we can make this into a
function which would be our solution to
the uh to the problem by substituting a
special symbol which is the Greek letter
Omega that's the right most
letter in the Greek alphabet indicating
the right argument so that's whatever is
over here on the right in this case d
and that solves our problem
like this and we don't actually need
this much white space in in our code and
so if you prefer you could get rid of
all of that of course we need a space
between three and five to separate them
so we can write it like this as well
thank you for watchinghi
we're going to take a character vector
and check if every single character in
it
is one of the letters a c g and T
here's a character vector
this one does consist of
a t g and z now
let's define a function a Lambda where
the argument is referred to as Omega
because it's on the right side and Omega
is the rightmost letter of the Greek
alphabet
we can then use membership
and then write just letters that we are
interested in looking for
and this Maps automatically so every
single element
in the left argument
is checked individually to see if it's a
member of this set on the right we treat
the array on the right as a set
and they all are
the only thing we need then to do is
ask are they all that is an end
reduction so and and then a slash means
reduce
and then that's true if we remove the
and reduction for a moment and put in a
character which is not valid
then we get a zero there and the end
reduction gives us
zero
now we can Define this as a function
and apply it
but we can actually remove
some of the syntactic elements in this
function definition
by defining it in what's called tested
or points free
how do we do that
let's observe that we have two function
applications we have first a membership
and then we have the and reduction
if you were to express this only in
terms of function application
then we would need to do something about
this function because it takes two
arguments and we only supplied one
argument
the other argument is a constant
the easiest way to do this is by binding
or carrying one argument to the
membership function
deriving a new magnetic function a
function that only takes one argument
which is then applied to the overall
argument of our function
and we do that with the bind
operator which is a jot so this derives
a new function which is membership of
acgt
now we don't need to mention
the argument and we don't need the
braces for the function definition
either we have two pure functions
the membership of a c g t derived
function and the end reduction derives
function also y derived because the
function here
the core function is and and it's the
reduced operator which then derives the
end reduction or the
wall
so we can call this G
and then we can
apply G
let's see when there's an X here and
remove that
and we get A1
thank you for watchinghi we're going
to take a character
Vector that contains a notation custom
notation for multiple key value Pairs
and then we're going to parse it and
create a matrix with a key column and a
value
column here's an example of such a
notation customized such that uh the key
value pairs like this key value pair are
separated with slashes and the keys are
separated from the slashes by
colons this really calls for a very
commonly used short uh so-called
Fork which uh Cuts text or really any
data this is how it
works let's say we want to cut on these
slashes so we have the slashes left
argument
and then we can do an unequal with this
and that gives us a Boolean mask that
has ones for all the characters that are
different from the Slash and zero for
the characters that are equal to slash
that is the slashes so these ones here
um of which we start with uh 10 it
corresponds to these 10 characters and
so on okay now we can also take in an
identity
function
this is the right function it just
returns Its Right
argument and then we can put this all
together with a partition
function so what happens here is that we
compute The Mask we compute the right
argument you can call that compute it's
just the right argument and then the
partition function isolates runs of
characters from the right
according to runs of ones from the left
and the separators that are indicated
with zero those are descried but they
still cut at that point so we can see
how that works over
here now and we're not done yet because
we also need to cut each
individual and key value
pair so we can we can copy this and
whole expression
and use a colon here but this time we
want to apply this whole thing to each
we have an each operator a higher order
function and be cutting each
one and this gives us um a vector or
list of key value pairs but it isn't
quite a matrix yet so the last step to
make it into a matrix is the so-called
mix it takes the outer axis there's one
outer axis um and it takes the inner
axis that we have here and combine them
into an overall
array uh that has two
x's and so the rank the number of
Dimensions increases which is what the
up Arrow tries to indicate that we are
upping the rank the dimensionality and
we do that by consuming inner axes and
adding them as trailing AES to the outer
axis
and that's the result we're looking for
but this isn't a function yet in order
to make it a function and we have to
take this slash and colon as our left
argument as the
specification and then we put braces
around the whole thing uh right argument
is um represented by Omega left argument
is represented by Alpha so here we want
the second element of Alpha and here we
want the first element of
Alpha and this solves the problem but it
bothers me a bit this code duplication
can you really see there's a a pattern
here that's being
repeated so what can we do about this
well isn't entirely identical because we
have the each here which we don't have
over here but but I think we can fix
that so let's for now just remove this
part we but remember we want the right
part to also have an each and still do
what it's supposed to
do so this gives us these uh key value
pairs that haven't been pared yet we
want to put an each here but really
there isn't an each to apply we don't
want to apply on each of these
characters so how can we make this work
if we enclose the entire right argument
now it's one thing but it's still a
collection of um of character vectors
it's just a collection that's Dimension
that doesn't have any dimensions and the
each will then go into this inclosure
and apply the
function and then this works but we have
this extra level of uh of enclosing that
happened now we don't want that so we
can do a disclose
and now we're back to the um original
which means we can uh we can go up and
fetch this thing that we that we removed
before and insert it
here okay now um maybe we should uh we
should give this right argument a bit uh
key value pairs so it's not so wide
okay uh let's try this again just for
good order so now we have the same
function
here um
except we we can't just apply this over
and over again because there's there's
this disclose in between
them but over here we have a mix the
funny thing actually is that this close
and mix is exactly the same when applied
to a scalar and that's exactly what we
have here we have a single thing without
any dimensions that's a scaler why is
that because dis close just takes that
first and only element and opens it up
whereas mix remember I said and it
concatenates the outer Axis or in this
case outer axis with the inner axes
which here there aren't any in AES so
that just means that we take all the
data from inside and bring it out one
level and and there aren't any more X's
being added because there were zero X's
to begin with so we can replace this uh
disclose or actually first we call it uh
with a mix and it still
works now we have exactly the same
pattern over here but it's not one
function it's two functions there's this
train within each and then there's uh
the mix and it would be nice if we could
like combine
these but we can't immediately just take
this mix and stick it in here because
then that would make the mix also
subject to the
each now the thing is that we actually
don't need the each on uh the whole
function we only really need it on uh
the partitioning function why because uh
the inequality is a so-called scalar
function it penetrates all structure and
that means that explicitly trying to go
into each element doesn't make make any
difference and the right function well
it just Returns the right argument and
it doesn't matter uh if it's each
element separately or if it's and just
the collection of and of elements so we
can move in the each into this
expression right here and it will still
work and now that the whole parenthesis
isn't subject to the each anymore we can
safely take the mixes and stick in
here now we truly have three elements
the inclosed
argument followed and on its left the
first element from the left argument and
on its left uh the second element from
the argument and we simply sticking this
function in between that looks a lot
like a
reduction so in order for this to be a
an a proper reduction we have
to to put all these elements together
first so we'll take this function make
it into a reduction now this also means
that the reduction reduces the number of
dimensions and there's one because it's
a list of the second element from left
argument the first element from the left
argument and then the enclosed right
argument and you're going to reduce that
to a scaler binding closure so we have
to disclose it as
well um so then we have the second
element and the first element and then
finally we have the
enclosed and right argument so we can
see this this also works this is of
course a bit uh silly we can uh we can
get the second element the first element
in one go and then we can concatenate
that with uh a first further enclosed
right argument enclosure of the right
argument we need a double enclos because
the element we want is the enclosed
right argument and here we're
concatenating a two element Vector with
it has to then be concatenated with one
more item and that is the enclosure uh
then of this enclosed right
argument now being that the left
argument only has two elements we can
also write this as the Reversed left and
argument and that and it's a pretty neat
solution and if I may say so
myself there is an entirely different
approach to
this which is to not do two steps of
parsing we can simply look at
directly if any of uh the left argument
elements have been
found because we know that these
separators will always occur as first a
key value separator and then a pair
separator and then a key value separator
and then a pair separator and key value
separator and so
on so um we
can use membership but membership looks
up elements from the left in the
argument on the right so we can commute
its
argument and this tells us uh where any
separator was we can let's let's print
this again just to uh to remember how it
looked so we can see there are three
characters uh that are not separators
then there's one separator then there
are six characters that are not
separators and so
on we are not actually interested in
here in which ones that are separators
we interested in the not separat
remember that's just like the uh the not
equal that we were using before so we
glue a logical knot on top of the
membership
function that inverts that and this is
the exact mass that we the type of mass
that we had before so we can use this
with the partition function and the
right argument is the data that's being
petitioned that splits into key value
key value key
value the only thing we need now is to
shape this into a
matrix so we know uh how many there
are and uh that means that if we divide
this by two so this actually two divided
by because we're commuting just like we
did over here um then this gives us how
many rows we want then we can
concatenate two two so two comma would
be two concatenated to but we are
concatenating with swapped arguments
again so it goes on the right this gives
us the shape three rows and two columns
and then we can use that to
reshape the argument to this inner
function and that gives us um our
solution but and I find this a little
bit clunky in this case when we just
want pairs there actually a neat trick
that we can use and that is uh the
stencil operator so stencil operator is
often associated with things like Game
of Life at tomons um in this case we're
using it for something very simple so
stencil with a window size of two and
all we want to do is just collect the
individual windows that gives us this
which is almost right but we can see
that the problem here is that we are
overlapping so we we correctly took the
first two elements but then we took the
the next two elements was beginning with
the second element we want to begin with
the third element
that's because there's both a window
size and the movement and the movement
is by default one but if we change the
movement by giving stencil a matrix
right upper end where the second row
specifies the
movement then we get exactly what it was
we wanted so this is another solution
and I think this one is uh pretty neat
as
well and finally uh this whole statement
we can actually it won't we can't make
it any shorter but uh there's another
elegant way to compute the same thing um
so
let's look at this
again we got this splitting done and
that was done with uh this
mask so we want a One
wherever and we have something that's
not a separator and a zero whenever
there's something that is a
separator if we take the characters from
over here instead of doing a membership
to see if they're there we can do a
lookup so this is and which position do
they occur in and that has the
interesting property that if it doesn't
occur at all like say the C here doesn't
occur in this list at all then we give
it the next index after the last index
here so anything that's a slash becomes
a one anything that's a colon becomes a
two and anything else becomes a
three you can see that here so we begin
with the two and then we have put the
threes here and then there's a one and
all we want to know here is whether or
not something and is a three so if it's
a three we want it to become a one and
if it's not then we want to become a
zero and that is simply comparing three
with that
so here's our mask and now we can use
that as before
with and this time a commuted partition
function because we have now the mask on
the right because it's a little bit more
of a involved expression not just um a
single
function and then we are petitioning the
right argument and that gives us this as
before and then we can use exact same
construct with uh with reshape as we did
or we can use a stencil as before to get
our key value pairs in a
matrix thank you for watchingwelcome to the apl quest cip wiki for
details
today's problem is the seventh from the
2015 round of the apl problem solver
competition
it's very simple we just are to extend
membership a bit so that it is case
insensitive
now let's start with two arrays let's
just take the first six letters of the
alphabet and also
some random four letters here
and if we try to do a membership here um
it doesn't work it says that none of
these members are none of these letters
are members even though clearly c and d
are and that's because they have
different
letter case
so
what we need to do is we have our two
arguments and we need to
case fold them which is a normalization
procedure done so that we can compare
kins insensitively
and so we
apply quad c which is case fault on
the left argument and also on
the right argument and now we can see
that c and d are indeed
members
but we can
make this look a whole lot nicer
let's start by
converting this to a tested function
so instead of using omega we're using
write tech instead of using alpha we're
using
left tech and that still works
but
this is a 2 train those are our tops and
we can then use the top operator instead
now we can observe that we are
we are
pre-processing
the left argument and the right argument
in exactly the same way
instead of doing of using the function
called c twice you can do it once just
using the over operator
so that's on the right and on the left
we don't need to state that
and we don't even need any parentheses
because this isn't a train anymore it's
a simple derived
function
however
the
problem statement says that
we should also it should also work for
high rank arrays
and that
doesn't work here
let's make this into a high rank array
here
three rows two columns and we also over
here two rows two columns
and now we should say that these rows
here are members
so the cd row is indeed a member of
the
matrix on the right and we should get 0
1
0
but if we try it
then we get a strange result
and that is because
membership works on element by element
basis so it says is a a member of this
matrix over here is b a member of the
matrix is c a member and it's d a member
and that's not what we wanted even
though we might think we could do an n
reduction across but that
and that doesn't work though because
that
would give us the elements even though
they're in this wrong order it would say
they're members
and that's we need the entire row to
match
what we want to do is we want to do a
membership between the major cells and
we can do that by
starting off
in isolating the members
the major cells with it over again so
we can say um membership
of
uh
case insensitively
on the enclosed major cells
and that works and there are different
ways that we could mix and match this
and
however
they're actually
a better way to do it and that is by not
using membership at all
instead
let's look at the result of tyadik iota
which is index off
with opposite
argument order
what this is saying is where do we find
the major cells from the right that is
now left on in the other argument and so
what it's saying here is that a b is
found in position three on the right
that is the next available index after
the last one meaning it isn't found and
cd is found in the first one and ef is
found well it's not found so three again
and
that means since we're not interested in
the actual position
only whether or not it's there then
if it's within the range that means it's
a member if it's outside of the range
then it's not a member and we're
interested in whether it is a
in the range what does it mean in the
range that means uh no more than the
length of
and of the element that we're looking
for so this is the length of the right
argument that's 2.
and so we can put this in and we can say
if
the index
of each one
done case insensitively is less than or
equal to
the maximum
then we know it's a member
and that gives us
our solution
we can give it a name
then we don't need parentheses
and then we can use the name in here
that's our solution thank you for
watchinghi
we're going to
find the locations of
characters in a given text
where those characters are followed by
an identical character immediately to
the right we don't want the characters
themselves we don't want the indices we
want a mask
that indicates where such pairs begin
classic example of a text processing
things in APL is using Mississippi
because it's got a lot of duplicated
characters and identical characters
spread out but it only however has two
identical characters in a row so let's
add a little bit more
where we have three in a row and we'll
have overlapping pairs what we want to
get here is
these are not the same that's a zero
these are not the same that's a zero
these are the same that's a one and so
on at the very end we want that these
two are not the same that's a zero these
two are the same one these two the same
um that's a one and then this character
is not followed by an identical element
because there are no more characters
there so we always end with a zero
let's start with Lambda and
we can refer to the functions argument
with Omega it's because the argument is
on the right and it's the rightmost
character of the Greek alphabet
and we always have the whole solution
right out of the box with an ny is
reduced this means we go over all the
windows of length 2 in this case and
reduce them using equality which
effectively just inserts the equality
between the two elements the two
characters and that gives us this which
is almost correct the only thing we're
missing is because there is no pair of
the less character with one more
character after it there's no zero at
the end
now and we might think that oh that's
that's easy to fix we can just stick a
zero on the end
and solve the problem however if the
argument is empty so it's the empty
string let's apply this Lambda on each
one of these
then we get a length error on the
invoice reduction because it cannot
find any pairs of link two
so how might we solve this instead if we
extend
the argument with a character that
doesn't appear anywhere then we can
solve the problem and we see that the
empty string indeed gave us an empty
result
however this is of course problematic if
the string ends with a plus we get the
wrong result we can never get a 1 at the
end because that last character even
though it's a plus here is not followed
by a character that's identical to it
so we need to solve this problem and
there are a couple of ways that we could
do so
um here's a little bit of a clever one
let's take the reverse of the argument
this gives us all the reverses and then
we take the first one which you can
actually see by the color here is
optimized so we're not actually
reversing and taking the first we
directly take the last one it's just a
way of expressing it
and so here we get a one
um and notice that we get a space here
and that is because the first coerces
out an element when it's there aren't
any elements it takes a prototypical one
which for text is a space
um and then uh the Plus for here
so this is the last element or a space
if there aren't any and then we can take
some filler characters that we can add
to the string to compare it just like we
did with plus before but we need a
couple of different ones because if the
last one is a plus we want a different
character
and then we can use a set difference so
this takes this set of plus and minus
and
removes all the instances of the last
character so we for the first one we
remove all the eyes then we remove there
aren't any so it doesn't sorry not the
old eyes the the ones there aren't any
so that doesn't matter the removable
spaces the holes aren't any and then
remove all the pluses and that gives us
just the minus left
and then we can select and the first one
of that
and this gives us an a filler character
that we can safely use the next
character cannot be both plus and minus
at the same time
in fact we don't actually need plus n
minus here because just like we used
first before and it coerced out a an
element when there weren't any using the
fill if we just use plus by itself
then we can see here we get plus when
plus is not the last character and we
get nothing when plus is the last
character if we do first on that then we
get a and
a space at the end and space is not
equal to the last character so it's a
safe character use even though it's hard
to see
okay so now we can take the argument and
concatenate it with this safe filler
character
and we can do the two wise reduction
and get a correct result
so this is one way to solve the problem
let's start over for a moment and try
something else
again we'll do the NYS reduction
but let's we know we want a zero at the
end
let's add a zero at the end so this is
concatenation with swapped arguments and
therefore we put it at the end we saw
before that
if you try to do this on an empty
argument
then that's not going to work we get an
error there
so
if we run the the NYS reduction here on
something with just one more character
then we get oh sorry we need to make it
into a vector and then we get an empty
result
and that would be appropriate result for
the empty case
so really all we need to do is if it's
empty we need to add one more element
and how can we do that well we can take
the length of the argument and let's go
back to the case that we had before
so here we have the length of the
argument and we don't want it to be zero
we want it to be at most at the least
one so we can clamp it using the max
function so this is the maximum of 1 and
17 and a maximum of 1 and 0. and that
gives us that this length
then we can use this to take and we need
to take it from the other side so
normally we take would take the length
on the left and the data on the right
but we want it Opposite so we swap it
around with the commute operator from
the argument itself
I know now we can see that we've added a
space only in the case where we have an
empty
okay now it is safe to do the NYS
reduction
and this gave us the correct result for
the empty case but we're still missing
the zero over here
what we can do then is to we know how
many elements we want namely the length
itself so we can take the length again
of the argument
and take with that and if take doesn't
have enough elements it will pad with
the appropriate prototype and that would
be a zero in a numeric case that we have
here
so this gives us a correct result
or both of them
now we can
this function happens to turn out really
nice if you convert it to a tested form
which means that we don't mention the
arguments explicitly rather all
arguments are the only argument here is
referred to
in terms of function application on that
argument
so it's pretty easy to see here that
what we're actually using is should say
an aspect of the argument which is its
length let's parenthesize this just for
clarity so referring to the argument in
terms of its length over here we're also
referring to the argument in terms of
its length here we're not referring to
it in terms of any function directly
applied to it and
but that would be the same thing as an
identity function applied to it and
luckily we do have an identity function
it looks like this it points as at the
argument
so now that we have
um
crystal out so to say indicated what are
indicated what are referring to the
argument looks like in terms of function
application we can then go ahead and
remove both the braces that indicate
this explicit Lambda or decent as we
call it and the actual name of the
argument
instead we're going to replace it with
round parenthesis
and so here we get rid of the names
and this works we don't actually need
these parentheses or around functions we
can just use the functions directly
this is a very nice
and clean looking train or tested
function for solving the problem
thank you for watchinghi the task here is to write justify
some
text and truncated it on the left if
it's too
wide if you want to read the full
description here then you can pause the
video okay let's start with a very
simple
example this is just a character vector
and we going to build a little Lambda a
function that takes the right argument
represented with the letter Omega that's
the right most letter of the Greek
alphabet not much going on here now the
important part is that we have to handle
a lot of different types of data so we
know need to normalize the incoming data
we can do that using very convenient
little function which is just like
inclose which wraps this simple
character Vector in an outer array but
it only does so if it's not already
nested so if we were to give multiple
elements of character vectors then uh it
wouldn't do the enclosure and we can
illustrate this so here we have it
enclosed if we give it multiple
things like this then we can see how
it's already nested and this does not do
any any further action
so let's go back to our simple character
Vector now we have this for later and we
know that we've got one level of
nesting we need to take a left argument
let's say uh five and that is the both
the the width of the final result but
that's also the how much we should
truncate
to and we need to right justify so that
means we need to um trunk it on the left
that is we want to preserve on the right
also know as to take from the right and
there's a take function in the APL in
order for it to take from the right we
need to negate the left argument so we
do that and then we need it to apply to
each of the arguments on or each of the
elements on the right so in this case
there's only one but that's fine so we
can see that gave us person and finally
we need to stack on top of each other
the very the individually trunk it
results if there are um more
so uh we do that with the mix function
that combines a nested uh array into a
flatter
array and that looks very simple if we
try it with
multiple then we can see that it it does
the right thing um as well now it's also
interesting to think about what happens
with a single and scaler because that
cannot just be enclosed but it really
works according to the spec very nicely
because it just stays the way it is and
then we take from each that makes it
into a vector um and then we remove that
enclosure if there is any so we can see
this happening
here we paded with spaces that's what
the tick function does if it if there
isn't enough data on a character data
and then the mix um takes care of that
extra enclosure and we get a vector like
we were supposed to get so this just
works this is a very nice easy to
understand Solution that's called that
F however um it isn't the most optimal
solution when it comes to Performance
because it uses these nested arrays and
modifies these nested arrays um looping
over them with the each operator and in
general that's an anti in APL let's see
if we can do better of course the
argument we get in is already
potentially nested this we can't change
that but we can try to get rid of that
nesting as soon as
possible so instead we're going to take
that
argument uh
here
we going to do the conditional nesting
again to normalize but this time we're
going to take advantage of mix padding
short
elements however the padding would
happen on the right which is not what we
want we want it on the left so we can do
this by reversing every element
first and then we do the mix which does
a p in and then we reverse the whole
result back
again and that gives us what we want but
it's not it's when it comes to
justification but not when it comes to
the truncation so all we need to do now
is the
truncation we
could negate the left
argument and then do a take this time we
don't want to take from the rows of the
result a matrix we want to take on the
individual rows um and that means we
want to apply to vectors those are rank
one so we do a take rank
one this could
work however since we
already uh doing this reversal then this
reversal happens on the entire data and
then we truncate it would be more
efficient if we could first truncate our
data and then reverse a lesser amount of
data so let's wait with that over here
now all our data is in Reverse which
means we need to take from the left
instead of from the right and then we
can do the reversal at the
end this gives us our result as well so
let's try to compare these let's call
this
G and let's copy in the cmpx the compare
ution facility from uh the defense
workspace and then we are going to
construct some sample data of course
three words is not enough to notice the
difference here so let's take the
alphabet and from the alphabet the
entire alphabet we en close that we're
going to uh to take over and over again
a prefix of the alphabet with some
random numbers so these are 100 random
numbers of length
uh of length 10 oh 100 random numbers uh
would be like this so these are 100
numbers that are 10 and then we change
them into random numbers from 1 to 10
and we use that to take from the entire
alphabet now I don't want to print all
of that to the screen uh let's get the
first 10 of that so we see some words of
various lengths of course it doesn't
matter what the actual letters are which
is why we're just using the alphabet
here good let's give this um a name
words and then we can use the compare
execution facility to do a five F words
and a five g words and see what um the
execution looks like give this a
moment and well that's significant and
we only talking about 100 words here if
you we were to increase the number of
words then and maybe their length this
would potentially give us even greater
speed
up can we do better we can but it will
get a little bit involved let's try
this so we want to take those words we
want to
normalize um normalize them into a list
of words in case there's only
one and we want to get rid of the
nesting as quickly as
possible so we want to do this
mix now however uh we have we lose the
information about how long they are they
could have potentially spaces at the end
and that information would be lost so we
do need to access the length of the
individual words in this nested list now
we know that it's uh
nested all we want to do then
is if we just take this as an
example
is we want to do a rotation you want we
need to rotate um these letters into the
right position where we can uh then chop
accordingly so how much do we want to uh
rotate them
well we want them to be in an aligned
such that the a um the longest word
stays in place and every and every
letter get sorry every word gets rotated
to the right by as much as the
difference is between its length and the
longest word's length so we can express
that rather directly
here we going to
rotate this so the way rotate works when
we already have a matrix because we're
mixed is it rotates each row separately
which is exactly what we want
and the amount that we want to rotate by
depends on the length of each word so
this is a now a fork so this gets
applied to this nested array and this
gets applied this gives us the length of
each to this nested
array and then we use the result to
rotate by of course this isn't right we
want don't want to rotate by uh the
length of each we want to rotate
by a function of the length of each
which is the density those lengths minus
the length of the longest one this is a
maximum
reduction so now we have rotated
everything to the right to WR justify
them but staying flat the only step
that's missing now is the truncation
which we know how to do
already there we have it yes it's a bit
involved
let's see if paid
off let's do
cmpx with f on the words and G on the
words and H on oh I misnamed
this should go up and fix that we still
want this
one and then this one should be
H you go h on the
words
that happens because I forgot the left
argument and we try
again now we're talking this is only for
100 words if it was larger amount we
would save a lot more so sometimes you
have to weigh off uh you want to keep
the code simple or do you want to keep
everything as flat as possible
and in order to get maximum performance
or could you find some on a balance in
between that's good enough performance
while keeping the code reasonably simple
so these were our and solutions we
had and we can see that yeah maybe maybe
this is good enough for your needs um
but with some reasoning you can find
ultimative flat solution thank you for
watchinghi and welcome to the apl quest c apl
wiki for details
today's quest
is the ninth problem from the 2013 round
of the fpl problem solving competition
the problem is to find
the average over a sub-period of a
year's worth
of data of numbers
so starting off with some data these are
some cells
the obvious approach here is to use
n-wise reduction
and maybe the simplest at least for
simple data way to visualize
invoice reduction is using the addict
reduction
using concatenation
so we have the sales
and then we can say for example a
three-wise reduction
of the sales
using concatenation where that just
concatenates together
groups of three elements moving over one
step each time
you can see we get these
little windows
and now what we want is the average of
each one of those so we can use
the very idiomatic epl expression for an
average
which is the sum divided by the length
and apply it to each one of those and
that gives us the solution where the
left argument is three and the right
argument is sales
however we should really package this as
a proper function
so we can do that these are two function
applications there's
the
comma slash using the 3s left argument
and we should probably use slash bars to
make this more general for a higher rank
in general
arrays
and then there is
the post-processing which is the
average function on each one so the
three can go outside here and then we
have on the top
the
ny's reduction is applied between these
arguments between three and sales and
then the average each is applied to the
result
of that so this is a basic solution but
by far
not the
best solution
and this is because we can actually go
in and apply
something directly to each one
because what we do when we do uh to each
sub
sequence
what we do here when we compute the
average is again and again we take
something of length three sum it
together and then divide count its
length which is always three of course
and then divide the sum by the length
instead what we could do
is we could
we could just do the
three wise reductions
and then all of those could be divided
by three
that was would give us the same
and we can express this as a little
defend
so what we want is
the left argument which is the size
that wise reduction over the right
argument
and then we divide that by the left
argument
that gives us the result and this is a
much better way to do it
and certainly much more efficient
and we can even express this as a tested
function because it comes out very
nicely that we have
a function applied diatically between
the left argument and the right argument
and
a middle function and then
a selection of the left or right
which can be expressed in terms of
function application as the left
function
applied between the left and right
argument and that is a fork so we can
simply get rid of all these mentions of
the argument
and
get this beautiful solution
and that is as as good as it gets for
the specific way that this problem has
been stated
however there's an interesting edge case
which uh
the testing framework if you look on
problems.trypl.com it does sorry
probably the tribally dot org does not
include but we could say that
the n the window size is larger than a
year
so for 12 we get the entire year
averaged for 13 we get no averages
and for 14 we get an error so how do we
handle
things that are
so window sizes that are more than one
step larger than the entire data that
we've got and there are many different
ways we could go about this i will have
a look at
some of them for this particular problem
an average obvious approach
would be to go back here and simply
clamp
the argument so we have the left
argument but the under no circumstances
will should it be larger than 13 if it's
larger than 13 then we just want it to
be 13. so we take the smallest value
of
the left argument and 13
and
and replace it with that
and
this works like normal as long as the
left argument is small
and it works fine with 13 and it works
fine with greater values
as well
now you could observe of course that
when we're dividing by a number
if ever the left argument is 13 or
greater then that
means that what's on the left of the
division sign is an empty vector in
which case it doesn't matter at all we
divide by there are no divisions going
on so we can remove this clamping from
the right and it will still work
we can also generalize this of course so
that it works on any number of
elements in cells
and we would do that by
simply adding one to the length of the
cells so this is a more
general purpose
solution
we could also use our original
formulation
and using
the
little train that we had before we
simply used the clamping size on the
left
and then
the fork which was the end wise
reduction divided by
left
and then the data on the right
and this will work as well and it works
for
these values that we have been using as
well
and we can if we want we can
get rid of this parenthesis by moving
things around
so we can put
this plane argument on over here and we
can put this formula on the right and
then we could swap here
and this would work
however um since the only thing that's
inside this train is a tech right or
left
and another function we can also move
this
over on
and
on this function and simply turn the
tech around to be on the right and that
will still work
we can also unroll the whole thing
because we can see that
what's actually happening here is that
the n-wise reduction
where this is the n
and then over this and finally we divide
by the left argument so we don't even
need a train here inside the stephen
then we can go ahead and make this tacit
if we want
and there are various different ways we
can do that but here we can say we want
the tally of the right argument
and this is the left argument
we want the n-wise reduction over the
right argument and then here's division
by the left argument and this would be
the uh that's acid equivalent
it's not necessarily better but it's
possible to write it like this
and then there is a
a code golf trick for those that want to
make the show the code as short as
possible and that is when we
add one to the length
then
we could
actually get that out here where we are
anyway applying the function
tally
atop
the selection of the right argument
we can include this one plus by
concatenating the arguments since the
left argument here is always going to be
a single number concatenating it to the
right argument gives something that's
not meaningful but it has the right
length namely one longer than the
original right argument and so we can
save a little bit of code here
by doing it this way but it's obscure
and we are and it's not efficient either
because we are
we are inserting an element at the
beginning uh of potentially a larger
amount of data um but if short code is
what you strive for and you want people
to and not understand what it is you've
written then this is the way to go
a whole different approach to dealing
with
with this problem of the length error is
to simply try it and then catch the
error when things go wrong
so we can
again write our formula as we did before
uh where we say that we
divide by the left argument and then we
have this n wise reduction on the right
argument and that works fine but when we
do something that gets too big
then we get a length error now length
error
is
error number five
and so we can say we set up an error
guard whenever any error number five
happens return the empty vector
and then it will return the empty vector
but this you might also wish for
a specialized operator
and one that allows you to choose what
happens when an error
happens how should we react to that so
here we had an explicit
guard but we could also use a
function that can't handle the error and
instead combine it together with some
kind of error handling function for an
overall function that does handle
an error
and this exists for example in the j
language where it's called adverse and
we can actually use apple cart to find a
definition for adverse
and we find this definition i have to go
into exactly what it is but we can just
give it a name
adverse
and now we can use it with any
definition that we had from before so we
can say we want the sum divided by the
left argument
but
if anything goes wrong then instead we
apply a function which returns the empty
vector
and so this works as before as long as
nowhere error happens and when an error
happens then we apply the empty vector
function
and we get an empty vector result
however
i prefer when i do apl to not rely on
catching an error and continuing rather
i test my
my input and make sure that everything
is okay with it so i would do that in
this case by writing
an
assumption that if
the left argument
is greater than
the length of the right argument
then return the empty vector
otherwise we can do whatever we've been
doing before
and that works um as well no error
handling include involved here
finally there's an issue here if
the
if the input has higher rank we're
already using slash bar instead of slash
in order to handle higher rank things
but
if the length doesn't uh is too large
and we end up with this guard the
results from the guard
then the result isn't actually correct
yes it has to be empty but not the empty
vector
say that we have the sales
in a matrix
with a single column
and then we're doing this uh
with this
end wise
average
down the columns
that means we are
reducing the number of rows in the table
but the table is still a one column
table
this means if the left argument is too
large we should be getting a zero row
table but not
a empty list
so if we make
sales into a one column table then
it might look okay
but if we look at the shape of it it
isn't quite right whereas if we do 13
here
um
yeah so this is also too large and 12
would be
a one by one table
if instead we redefined our function
such that
and
that it can be
larger than one because we know that
when it's one
one larger than so
then it's the end wise reduction still
works
if we define the function to only go
into the special guard when it is more
than one
with the left argument is more than one
larger than the length of the right
argument then we can observe here that
we get notice there's no blank line um a
zero row one column table
and that this function doesn't work work
for
the problem is of course that we
universally just return the empty vector
if
the left argument exceeds the length of
the right argument what we really should
do is preserve the entire shape of the
argument only compressing the
height of the table to have no rows
if it's a two dimensional table or if
it's a larger array we want to compress
the first axis to have no content and
the way we can do that is instead of
returning this empty vector blanket we
use zero to compress along the first
axis the leading axis and the right
argument and then we will see that
it now works even for large arguments so
this is the
ultimate
industrial solution
thank you for watchinghi
now we continue
from the previous problem where we were
making the grades and here we compile
some very simple statistics in a table
on a given set of grades
so we are supposed to have three columns
the First Column is just the grade and
that will go from a to d and then F and
then we have a column that says how many
of each there were
in the given list of grades
and finally we want the percentage but
what we do want it as a number we also
wanted to round it off to look nice
so up to a single decimal position
here are some sample grades
now it happens to be that all the grades
are present and they're all in groups
but it doesn't matter as we'll see based
on the algorithm
here's a little Lambda
a different
we can take the right argument here
with Omega the rightmost letter of the
Greek alphabet
we could also take a left argument
and if you were to do that then I would
for generality you use the alphabet of
letter grades
like this
however there is a
um so here we have the left argument and
the right argument next to each other
however there's a trick we can put in a
special little statement diamond is the
statement separator because diamonds are
Unbreakable
if we try to assign to Alpha which is
the leftmost letter of the Greek
alphabet indicating the left argument
when there is already a left argument
and then that whole statement is ignored
however if we do not supply of left
argument that statement is executed
so I think that rather than using a
regular variable to keep these letter
grades we should use Alpha because then
if you want to override it with a new
system that uses different letters that
will work too
hmm
okay now we are ready to get started
we've got our left argument which are
the letters of all the different grades
that can appear we have the right
argument which are the greatest in
question that we're going to compile
statistics on
and the first thing we want to do is
find out how many there of each then we
can use that to compute the percentages
and one way to do this is to do an outer
product well it's called Product but
it's really not a multiplication here
but an outer equality that means we take
every element on the left those are the
letter grades and compare to every
element on the right those are the
grades coming in and we get a comparison
table
so here we can see that since we begin
with a bunch of D's and each row here
but since one grade A B C D we get a
bunch of ones here and then we get a
bunch of A's they are up here
and so on
of course this means that we can do the
count of each one simply by summing and
rewrite that as a plus slash
so here are the sums or counts if you
want we can call that s
in order to compute a percentage we want
to know how many letter grades are there
in total we can use the tally mark to
tally the number of elements in the red
argument
then we can take the sums and divide by
that giving us fractions
in order to get percentages we want to
multiply by a hundred
and then we want to round off to a
single decimal and here's a neat way to
do it but maybe not the best we'll fix
that later
we can use the format function which
converts numbers into characters so this
becomes one giant character Vector with
digits
you won't be able to see a difference
because it has the same texture
representation however we can give it
the left argument which is exactly the
number of decimals
if you were using a negative left
argument it would be the number of
significant digits
we can try that for a moment so if we
say we want
two decimals
we can see that we get 9.68 but 25.81
if you do negative 2 then we get a
scaled format so that we can indicate
the Precision exactly and we say we get
exactly two but for now we just need a
single decimal
this is not a num an array of numbers
this is an array of characters so we
want to convert it back again to
numbers
and
with that we just need to construct our
table
this is a vector and we need to have a
matrix that is a table a two dimensional
array
we can use the table function to create
a table from a vector
so here we get a column vector or single
column Matrix and with that we can
concatenated together with the sums or
the counts of each one and finally we
can concatenate on the far left
the letters themselves
and this solves the problem
however
going via a character representation
seems a bit iffy just for rounding
especially since the way we're going
back again is actually execute or
evaluate so we're taking this whole
character vector
which are all these rounded numbers and
executing them as APL code
that's generally a better idea both for
performance but also for safety if
somebody were to somehow inject
something in there that's dangerous then
our whole system could fall over
let's do this the arithmetic way instead
we don't have a round to a specific
position function in APL however we do
have a flooring function we can write
rounding in terms of flooring we don't
want to run to to whole numbers we want
to round to Tenth of numbers so instead
of multiplying by 100 let's multiply by
a thousand that gives us tens of percent
now we just need to do the rounding but
flowing is not going to give us the
right result this is floor you can kind
of see there's a wall and a piece of a
floor
and that is because we need to round up
when we have seven and eight here in
fact from five and none of us we want to
round up and this just runs down its
floor
if we lift up all the numbers by a half
then anything that is ends with 0.5 or
higher will be lifted into above the
next higher number
and now we can see how
96.7 and 225.8
were rounded up whereas everything else
was rounded down so this is the type of
rounding and that we want to do but our
numbers are too big now we want to
divide them by 10.
of course this is 10 divided by but the
commute operator can swap the and the
arguments to the division function so
this is
10 into
whatever we have over here
rather than the opposite
and this solves our problem in a safe
and efficient manner
thank you for watchingwelcome to this episode of the apl quest
c apl wiki for details
today's quest is
generating an identity matrix of order n
very simple task
um but a lot of interesting ways we can
do this
and let's go get started with some
serious solutions and then look at some
more fun innovative solutions after that
so the first thing we can do
is
that we have a number n let's
for argument 6a that n is five and we
want to make a matrix that is five by
five so we can calculate n to itself
giving us five by five
next up we can generate all the indices
of an array of shape five five
and we can take these indices and look
at where the horizontal and vertical
index are the same by comparing each
this gives us our identity matrix
however we can do this in a simpler way
we only need to generate the indices
until
n
and then make
an
inequality table using the outer product
and the selfie or
commute operator to use the same indices
on both sides of the quality
and in fact this is our
simplest solution
so just
the outer product
selfie on the indices
it isn't a very efficient solution
however because we are comparing a lot
of numbers in general that we have
generated when we actually know where
the ones are going to be in advance
so what we can do is we can start off by
creating an empty matrix
of zeros so we take n
and
use that twice to reshape zero this
gives us
a big
empty vector like this an empty matrix
like this no it's not empty it has big
zero matrix like this
then we can use dyadic transpose which
selects the
um
it can collapse dimensions so that we
get diagonals we can illustrate this by
saying 5 5 reshape iota 25
and then we can use the attic transpose
mapping
both dimensions to a single dimension
and that gives us the compromise between
them diagonal
so now we can use this with a selective
assignment
we say one one
transpose of s
gates one and the one that gets
distributed over the entire s
and now s has been updated to become an
identity matrix we can put this into a
function
as
s gets
omega omega reshape zero
and then the diagonal of s gets one and
then return that s
and we can now give it the argument five
fine
and
this is verbose but it works it doesn't
have the best performance necessarily
and it's a bit awkward because we have
to have this middle statement where we
update s before we then return s
we can also use the add operator to do
something similar
we can start off by generating all the
indices that need to be set to 1. how
can we do this well if we start with
uh
with this iota n um in in our case then
we know that it is the
uh the elements of position one one two
two three three four four and
that need to be set to one
so what we can do is we concatenate
selfie concatenate to itself each one of
them and these are the indices
that we need to
set to one
and then there
we can
use this
setting one at
those
indices
in
the array
that is n and reshape zero
and that will give us
an
identity matrix
we could also use these indices in a
different way
and namely we could
say give me a boolean matrix that has
ones in those positions so
where are all the
ones in the boolean matrix is magnetic
iota underbar
and the inverse we can use power
negative one
on that and that gives us an identity
matrix as well
there are even more things that we could
do
along these lines instead of using a
matrix we can use a vector
and
the way we can do that is by observing
that this is kind of an encoding
of
in in a special radix
so
we want
ones
and then when we do things like that we
we need to see set coordinator to zero
otherwise it becomes too complicated
so what we can do is we have the indices
um iota n here
and then
we can multiply those by n
and
so this corresponds to
um
let's see number zero is this element
and number five is this element and
number ten is this element in revel
order
however we need to offset one for each
one so if you take these indices and add
them to this that gives us in revel
order
that diagonal we can actually see this
if we say 5 5 reshape by yo to 25
we can see that 0 6 12 18 24 those are
diagonals
and once we have those we can then use
the add operator as before so we can set
the ones
at that
in a vector
which is
zero
reshaped
to the shape
of n squared
and this is our flattened identity
matrix now we can take the proper shape
and reshape it and we get our identity
matrix
let's change back to quarter one index
origin one and then actually do some uh
the best performing solutions
and and that we can observe similar to
what we've done now we can see that
there are exactly n zeros onto the next
one and then again n zeros to the next
one
so what we can do is we can begin with a
one followed by n zeros
and then we can reshape that cyclically
into our full full shape we'll use n
here
and this is almost as good as
it gets there's one problem for a very
large
n
and we create a boolean vector of all
zeros and then by inserting one at the
beginning
it gives us sub-optimal performance
because we need to copy this entire
array one step over shifting everything
by one bit to insert that leading bit
how can we avoid that
well
we can use overtake so if we say n take
of one it pads with additional zeros at
the end
and the only thing we need to do here is
really adding n plus one
and this gives us the full row and now
we can reshape into that shape so this
is going to be the best it gets we can
put this into a function
as omega omega reshape
omega plus one
take one
and we can also make this into a tested
form and we can play some tricks there
so let's split up the problem omega
omega that is the self concatenation of
the argument
then we reshape that
and then we want the argument plus one
so we can tie
or bind
a 1 to plus making a magnetic function
so that's an increment function and we
use that to take from well we need a 1
here but we can't have 1 at the end of a
tested function
because it's a constant not a function
we can transform it into a function
using uh the constant operator
so we can try this as well
and that works
and then for a little bit of uh of
trickery we can actually
avoid this construct of one constant
by observing that the
sine
of five
is one
and the problem was that we needed on
the right hand
to have a function not a constant
so this is a function applied to any
number that's relevant and we get one if
we want the zero by zero it doesn't
matter that the sine of zero is zero
it will still work because we it becomes
an empty array
so it doesn't matter that we are taking
from 0 there so we can do this we can
say i5 like this another possibility
is observing that how many elements are
there in a single number there's only
one and that applies even to zero
and so we can
we can do that as well
so this is a
this is the fastest solution that we're
going to get this is a proper solution
whether you want to use a tested form or
a defend it should be about the same
performance
now onto some more fun and innovative
solutions that we could do
and remember again that we needed a
single one followed by n zeros and we
can actually do that using expand
so if we have
uh if we have a one representing that we
want
um
one one and then we have negative n
representing
n fill elements we can use that with the
expand function on a single one to get
the same thing and then we can reshape
that
to our identity matrix and we can write
this um in a tested form and so this is
again the self-concatenation
reshapes
one expanded
by
one
followed by
the negation
and it works for
zero as well
what happens in the zero case is
negation of zero is zero so we get one
zero that means we expand one as a
single one with no fill elements reshape
that to zero zero and we have an empty
numeric matrix so that works as well
um
here's one that almost always works like
there is an astronomically small
probability that it won't work but it is
rather fun
let's say we have a
matrix
of uh
random numbers so
with the zero as argument question mark
gives us random floats between zero and
one so they won't be zero they won't be
one
and it's
exceedingly unlikely that we'll have
duplicates here of course
now if this is a matrix
then
there must exist a matrix
such that
m and multiplication here means matrix
multiplication we can we can write that
as cluster times um
will give us but in traditional
mathematics just at times will give us
the matrix itself and that is the
identity matrix
now if we move things around around on
the in this equation we'll find that
dividing the matrix by itself should
give us the identity matrix and indeed
that is so
so we can do
m
matrix divide with m and that gives us
an identity matrix and we can write the
whole thing as matrix division
selfie
on
the random numbers
of the self-concatenation
of zero
so here's a constant zero again
you can try this
and it works
similar to what we did with sine and
tally to get a 1 there's also a function
which
for
a single number a scalar gives 0 and
that is the depth function
so the depth of a single number a scalar
simple scalar is zero so we can go up
and amend our function to this very
obscure looking thing
which works just fine and is very very
inefficient because api will have to
solve an equation system
every time we generate an
identity matrix but hey it's fun right
here's another one which is
very very inefficient
let's think about this we've got
the indices up to n
um if we subtract these from n itself
that gives us
descending powers
from four down to zero
raised two to the power of that
and we've got descending powers of two
and now if we go up and look in our
identity matrix then we can see that the
first column
is
16 spelled out in binary and the second
column is
8 spelled out in binary and 4 and 2 and
1.
so this means that if we represent all
these numbers
in a
in
base 2
then
we
we would get the identity matrix so we
could do something like this
which
auto sizes but we already know
that we want n bits so we can say n
nreship2
encode on that
and that works as well and then we can
make the whole thing tacit
by saying that it is the reshape of two
so this is a magnetic function which
reshapes two
encodes 2 to the power of the argument
minus
iota on the argument
so this works just fine
but again very inefficient doing base
conversions when we just want to create
um
an identity makes it but fun it's fun
okay a little bit more and of
fun
we can
um
we can generate the negative indices
and then we can overtake like we did
before
on a1 so each one of these will be used
to take
from
a1 so it takes from the rear padding
will
zero us at the front
oops that was too much
missing in each there there we go
and now we just need to stack them up on
top of each other and there are various
ways we could do that
we can mix
or we could
use
the rank operator so we want to pair
these up we need to do take
pair these up with one
and then it mixes everything together so
that works as well
and now we can
put all this together to create an um
a tested function so we have the
negation of iota take rank 0 on remember
how to get a 1 without using literal one
we could use tally for example
so this should work as well
and here's our density matrix in the
rather
roundabout way
another thing we can use is scan so we
can get normally prefixes
of
a vector
like this if we instead of concatenate
so this is a cumulative concatenation we
do a cumulative
swapped concatenation
then we get these reversed
prefixes instead
okay
so if we can have a way to get reverse
prefixes
and
we have a way to get
one followed by a bunch of zeros
then these give us our rows and we just
need
to mix
and so we can write this as an
as a function
the
conclusion
swapped scan
and off
the
take
of
one so this is an end take
one
and then
we mix that then we just need to put and
a top here so we have
two functions after each other
and here we got our identity function in
a very roundabout
manner but lots of fun again
and
now let's move over to the key operator
which we can also use for this
so we can generate our
our indices like this
and then we can ask the key operator
what are the indices so let's put it
like this
but now
so this is saying index one is found or
the number one is found at position one
the number two is filter under position
two only number three is found at
position three that means the alpha here
is one and omega is what
f plus 2 omega is 2 and so on
now we can use take
here
and that gives us
these vectors
and we can see how where we're going
with this
we can then reverse this
and now we just have the problem of the
sign
so we can take the sign of all of this
and we need to stack them on top of each
other as well
so we could mix it like this but there's
a better way but not enclosing them we
already get the mix for free and now we
just need to get the sign
here
and then we can make this tacit because
it fits very nicely it is the reversal
on top of the taking of these two
arguments
and that gives us
our
identity matrix it's not quite a
function yet
but we can make it so by combining the
key with the indices and now we have
our identity matrix generator in a
totally obscure way that nobody will be
able to understand don't do this in
production code
let's make it worse
let's start again with um
with this construct
and
here we are only interested in the right
argument
so that gives us these vectors
of
um
indices one by itself two beta three
beta four by five by itself and remember
we used the uh iota underbar the where
inverse to generate a boolean array and
that has ones in those positions there's
only one position in each one but
we can still do this
so
this gives us these vectors and yes you
recognize this remove the enclosure
and we've got our identity matrix
and we can combine this we can make the
operand
test it simply by saying that it's this
where inverse on top of the right
argument we have to have that because
there's a left argument as well
and so this is our function
and
that works
again don't do this in production code
but it sure is fun to look at and then
somebody asked during the live chat
event
if we can't use complex numbers for this
and of course we can use complex numbers
for this okay let's get started
so
we have these indices
and let's make a table of complex
numbers so we do the other product of
the real part
plus the imaginary part so we multiply
the imaginary units
with these indices oops there shouldn't
be n here it should be
that and that gives us a complex number
table so this is 1 plus 1 i 2 plus and 1
plus 2 i 1 plus 3 i next row 2 plus 1 i
and so on
and now what we need to do is we want to
find out the ones that are down the
diagonal
and both actually down the diagonal we
can kind of see the angle of them but it
also happens to be that in a complex
plane these will have an um
an angle or an also known as the
argument
which is 45 degrees or a a quarter of pi
so we can ask for the argument of that
and we can see that going down the
diagonal they all have
that
0.785 and so on
now we can multiply that
by
or
or rather sorry divide pi by that
so the same thing as taking the
reciprocal and multiplying by pi
and then you can see that gives four and
now we can say
where is 4 equal to that
and that gives us our identity
matrix so this is our full function
would be
to
we could either do iota
omega here or we could just use omega
and put iota outside that as in the top
and we've got
our identity matrix producing function
here in a terrible way using complex
numbers and as if that wasn't enough
let's go in and modify this a bit
so starting again from here with our
table of
complex numbers
we can also ask
what is the absolute value or the
magnitude of these numbers
and
since they are on the 45 degree angle
that means that
the horizontal and vertical parts
in this right angle
triangle
are
equal to each other that means that the
diagonal's length has to be a multiple
of the square root of 2.
so we can ask what is
the divisional remainder when these
numbers are divided by the square root
of 2
and if there is no remainder
then and we are at on the diagonal so we
can compare this with zero and we get
our
identity matrix using complex numbers
that's enough fun
and what you should do of course is use
the solution
where we take the argument twice reshape
with one plus the argument to take over
of
and of one or you can use the tested
version
where it's a self-concatenation
of the reshape
of the incremented number take off
one or as a constant or you can use
the sign or the tally if you really want
to go there but these would be the
industrial strength
versions you can also go up and if you
don't like parentheses like i personally
don't do
then you can swap the arguments of this
take as well
that's perfectly acceptable
as well
thank you for watchinghello and welcome to this apl quest
episode c apl wiki for details
today's quest is the last problem from
the 2013 round of the apl problem
solving competition
we are simply given a set of linear
equations
and
the values that
those equations add up to and then we
are to find the solution for the
variables
let's start by creating this
equation system
so we'll have a simple example of just
three equations with three variables
so this is saying um
four
x plus one y plus z
and
two of each and then six x plus three
y plus z
and they should add up to a result which
is two
six four
so four x plus
one y plus then 3z
equals 2 and 2x plus 2y plus 2z equals 6
and so on
and a solution to that is if
um
x is
negative one
and
y is three and z is one
and we can check this so
um
we have the matrix
and then we'll multiply
each
row
by
these values
and then we can sum them up
and we can see that
we got these results so indeed
four times and x where x is negative one
plus one times y where y is uh three
plus three times z where z is one gives
two just like we're supposed to have it
we can write this and a little bit
neater
as a
inner product
and so
the problem here is that we don't know
this result negative 1 3
1. we want to compute it what we do know
are these values
2 6 and 4.
so in other words we want to find
a v
and
such that
m plus dot times
this value
gives
2 6
and the missing right it gives 2 6 4.
yeah
so this matches an r
and luckily
we can actually
write this up so we can say we want
um
we want to apply this negative one time
to get this value
this is a
power negative one applying a function
in reverse applying it negative one
times really asks this question
what argument in this case right
argument we're giving it the left
argument over here what right argument
can we give to m plus that times
such that we get
r
and that solves the problem
now in
in the problem specification and r go is
the left argument and m is the right
argument so we can type up our solution
as plus the times
operator negative one
commute just swap the two arguments like
that and then the matrix goes on the
right and
the vector
goes on the left and that's a proper
solution
however
um
we
um and we can check this of course we
can check that that v matches uh matches
this oops
however
this matrix multiplicity multiplication
um in reverse it's actually the same as
multiplying by
the inverse
so
we can and the inverse of a matrix we
have in apl as a primitive
we can
then state this instead as multiplying
by and
the
inverse
yeah
the inverse like that and then we can
glue them together
so it's the same thing as
the explicit formula like this but for
now we'll have it in a proper assignable
function um like this so this is a
multiplication by the inverse and the
dyadic form of uh
of this character which is often
nicknamed domino it looks like a one one
domino
is actually exactly that
so the entire solution
can just be that
in other words
this problem has a one character
solution in apl
now that's of course uh lots of
and fun but it would be nice to see how
we could really solve this without apl
just doing all the work for us
and there are a couple of ways to do
this there's a really clever
way to do it
called the hoteling buddhic scheme if i
pronounce that correctly
and it states that we can do an
iterative approach to approximate better
and better uh
the correct solution to an inverse
of a matrix and as we had before if we
it's easy to do matrix multiplication so
if you have the inverse then the problem
is basically solved
and it states like this
that
we're going to
to iterate
um
with
this um
result
where every iteration depends on the
previous value
and the previous and
we are going and and the formula looks
like this i'm not going to go into
exactly
how
why this works but this is what they
state you can see look up their paper
so this is um this is what they say
that
the next iteration is the previous
iteration
matrix multiplied by
two times the
identity matrix minus um
the
the
grand matrix that the original matrix um
that has been multiplied by the previous
iteration
and we can rearrange this
formula a little bit
and we can
take this vi here and so to say multiply
into the um into the parenthesis
so that gives us
2vi
because the vi multiplied by the
identity matrix is
just vi of course minus and then and
vi times
a which is the original matrix times
v i again
and we can then state this in apl the
way we would write that is it's we can
write 2vi or
we can
so
2 times
vi
minus vi
plus dot times which is the matrix
multiplication
and a
plot plus times
and vi
and we can
break this
avoid the parenthesis simply by having
two v i's here instead
it'll be the same thing as multiplying
it by two
and now we can make this a function of
the original matrix on
one side so we have a
and then we make a function and we have
the previous iteration as the right
argument so we'll do it as a test
function so we start from the right here
build it up first we want the matrix
multiplication of them plus the times
and then we want to multiply by vi again
so vi is the right argument plus that
times that
and then we want to subtract this from
vi that's the right argument minus that
and then we add another one of the right
arguments we can write it up like this
so here's a
a tested way to compute this and this is
one iteration of it
um
however we actually want to keep doing
this until it becomes stable
and the way we would then
write that
we could take it as a function
where the right argument function of the
original matrix here called a so that
becomes
fed into
our
inner function as a left argument and
then we keep iterating
with the power operator until two
consecutive iterations are the same
and so we then we just need to apply
this whole thing uh on our initial guess
and that's the next problem so
the problem is it's kind of hard to find
an initial guess which will
work out for us but recently someone
named solemani came up with a surefire
way to determine
an initial guess
and
what he stated was that
transpose of the array divided by the
trace
of
of the matrix
times its transpose is a good starting
guess that will always come up and again
see his paper if you want the details of
how exactly that works out
so
we
again the trace
of the
matrix times its transpose and then we
divide the transpose
by that so first we do the trace of the
matrix times its transpose
we can
have this matrix m
and
we can transpose it
and then we can
do it matrix multiplication with itself
and then we want the trace the trace is
the sum of the major diagonal from top
left to bottom right and that we can do
as a 1 1 transpose that's the trace of
that
and then we sum
sum that up so for our matrix m here
that magic value that we want to divide
by is 84 and then we would go ahead and
and divide the transpose of
of m by 84 and that would be a good
starting value now
this can be we could use this but it can
actually be simplified a little bit and
for that we need to observe some
characteristics of doing exactly this
the trace of the um
of the matrix multiplied by its
transpose
so what we're going to do is we'll start
with a um a matrix that is easy to
recognize where the bits and pieces are
going
and instead of doing an actual
multiplication with itself
we are going to
to take
and
model the plus and
the times as functions that are just
saying what they would do
rather than actually
doing them
oops there should be a times over here
okay so so this is
this will show us that we give great
little boxes are showing us what's going
on and we need to multiply
it with itself with the right argument
to the matrix multiplication being
transposed
so here
we can see
all the results that we're getting but
we're only interested in the diagonal
so um
we're taking the one one transpose of
that
and now we can observe exactly what's
going on right and remember we the trace
is the
is the sum of these so really what will
happen is we're going to add all these
together all these little boxes and
notice that is
1 1
multiplied by each other and 2 2 3 3 and
so on
that means
every element of the entire matrix
gets
multiplied by itself squared
and then
we just sum all these
squares together
which means we can state this much
easier we can just
revel the uh the matrix
square it
and sum it or we could
we could of course square it first revel
at the summit um
many different ways
of doing that
we can also combine
this
summing and the multiplication
into an inner product
and that means that if we're doing going
to write in the training we want this as
short as possible then we can write the
revel cluster times the revel of the
matrix and that gives us that and um and
now
we just need to take the transpose of
the matrix and divide by that
so we can take the transpose divide by
this and that gives us
our starting value which isn't
very interesting
to look at but let's put all of this
together
so what we
let's go up in and get it from up here
we had this formula right here
and we stick it in here
and this is
then the inverse
that we get we can compare this
with the inverse primitive and see we
got the exact same value
and now remember how we solve this with
with v
so we can go in and
say
[Music]
v plus that times
this inverse
oops sorry
it should be must be like the other way
around
what am i doing wrong
here oh
here we go
um or instead
and this is a solution but it we want to
glue these two things together to be a
single function so this is this right
part here is the inversion of the matrix
and the left part is the
um
is the matrix multiplication so we
multiply with the uh
with the inverse and that gives us our
solution
and we can and remember this is an
iterative thing so here inside here is
the uh the power match which just runs
over and over again until two
consecutive things and match each other
it would actually be neat to see how
this
would look
we can do that by doing each iteration
separately now i happen to know that we
only need to go through 11 iterations so
on
for every one of
numbers from
1 to 11 we're going to apply it that
many times
and that then we can see the progression
of better and better values for x y and
z
to solve this system until
we're done it becomes
stable
so this is a a modern computational
approach to this
traditional way that you might have
learned in school
is the ghost jordan method
and you can find it in the defense
workspace
here is an adapted
version of what you found what you can
find there
i'll try to explain it a little bit
what it's doing here it
if you learned in the school you would
have learned that um
there are these various actions you can
take on your matrix together with uh the
the result values
to slowly uh
build up diagonal matrix and then you
um
have the solution
when we running it as computer code then
we we don't can't go by by a feeling of
what's in what's easier instead we just
go through all the steps every time so
what we're building up here
at the bottom is this is our equation
system these are the uh the final values
that we're putting next to it and then
these are the reversed indices because
uh reduction runs from the right to left
so that's what this comment is trying to
say that this is what we're going to
to reduce over so this just eliminate
here eliminate here eliminate here in
this order
and every time we eliminate
we choose before precision reasons
we choose
the row that have has the largest
magnitude so this gives us
a specific column and we start so
because we don't going down diagonals so
first we start the first column
and then
we get rid of the the first few elements
that have already been
those for those columns that have
already been
taken care of
of course with the first one that means
we're dropping zero notice that the
index origin is zero up here
and then we look at the magnitudes and
choose the largest one and that's what
we call our pivot row
and then we swap things around so where
we're up to in the nth row and the pivot
row
we're taking those and just flipping
them there's just two of them
so then reverse just swaps the two
around
and now we've got um
a matrix that's modified by having these
two uh swapped around
and then we want to um to normalize such
that in that corner or should we say of
of the
sub matrix missing rows and columns that
is uh on the
intersection of the nth column and the
negan's
row that's why we have alpha semicolon
alpha here and we we divide that we
divide all the other values
there so that
we get a 1.
and then finally we we have the step of
adding or subtracting
and the way it's been done implemented
here is we are adding subtracting not
just for that single
for single row but we're doing the
entire
matrix so it's built up using masks
essentially
we when we add or subtract
0
then
nothing happens and we're using a mask
so
2
that's right here these are all the
indices for all the
all the rows and then we have a specific
row number here which gets uh
so wherever it's different from we get
zeros and that means we only get one on
this
uh single uh single row
the then we pick out from the uh from
that column there
and uh and create a matrix
with
all the values that are in this
particular row
and then that effectively just we have a
bunch of zeros and we subtract the right
values in the right place
once that that's done since we've done a
reduction we have enclosed so we open
that up
and we're not we're not interested in
the entire matrix with uh result values
rather we can chop those away
so that's what this is doing
and
then just in case they were all
identical we used a single value we just
reshape it to have the right shape
and that's how the gauss jordan method
works we can try that it solves the
whole thing immediately and like this in
exactly the same way
and then i i happened to look up in an
old uh the old paper on apl 360
and
it was actually interesting it brought
us an example of of code and this
function which is a inversion of a
matrix
but implemented in um in old style apr
i'm not going to go
through and explain this you can do it
on your own it's really very much it is
the ghost jordan method it's very much
the same but in a
you know old style without using any of
the new and new operators i've altered
one slight thing you can see a capital a
in there
and that was an original function in apl
360. they it had some functions called
alpha and omega which were prefix and
suffix vectors so uh
alpha or which i've changed to an a here
because alpha is now meaning something
else
and you can define it like this
in the in our case here
where it's so the left argument is the
length of the vector and the right
argument is the number of leading
ones in that boolean vector
in our case it could just be a take but
i suppose uh overtake meaning you can
take more elements than there are in
array wasn't uh supported yet in at that
time
so you can actually replace these a's
just with an up arrow
and this gives us our an
inverted matrix as we can see from
before
same thing as the primitive
and that means that we could
we can do the same thing
here
with uh
multiplying the result of the inversion
with
our result
our desired result values
and that gives us our values for x y
and z in the very oldest of fashions
so this concludes the first
year of
apl problem solving competitions
and we're now going to continue next
time with the problems from 2014.
thank you for watchinghello and welcome to the apl quest see
apl wiki for details
today's quest is called floaty boat
we are to select
the numbers from a vector of numbers
that are floating point or none integers
and this is problem seven from the 2013
apl problem solving competition
it's a bit of an interesting
thing
that it's not well defined what exactly
constitutes a floating point number or a
non-integer number
because in apl a number is a number
there's not really any good distinction
but we'll do our best and any of these
solutions would be considered correct
let's start off by creating some data
for ourselves
what constitutes a and a number that
isn't an integer well
there are various ways to approach this
a very simple one and probably the best
method really um is to compare the
number to what would happen to it if we
were to round it so any number that's
integer stays the same when rounded and
any number that isn't integer would
change
so
the floor
of this vector
gives us these integers
and then we can compare
and these gives us
the integers but we're actually
interested in the non-integers so let's
go change
that and then we can use this
to filter
and this gives us the non-integers we
can put this into a function let's call
that f
and use the
name of the argument
and there you go
somebody who participated in the live
chat event
noticed that this can actually be
written as an entirely derived function
not even a train but a tested derived
function that is a function that
entirely com composed of
operators and
functions together
and we can see how we can transform f
into such a thing so let's
have this tested form
first we want to compare the argument
with
its own floor
so the way we can do it is we want to
use the function
unequal dyadically using the same
argument
on both sides so that means we need a
selfie or
commute
operator here
and let's get rid of some of this noise
um and then
we want to pre-process the right
argument to unequal using the floor
keeping the left argument just
the
the outer argument itself so this places
the same argument on both sides and we
flow the right side and then we feed it
into
unequal i like to think of the
jot or compose or beside and as
preprocessed the right argument so this
is unequal while pre-processing the
right argument
with a floor
using the same argument on both sides
and we can use that
to filter and so this is the same
pattern again
we have this
filtering function
and we want to use the same argument
but the right side is preprocessed by
this function
and the left argument is just the way it
is so we can do the same thing again so
we use the preprocessing
the right argument operator with
parentheses like that and then use
commute to
put the same argument over on both sides
so this is a fully tested
version of
f
however i don't consider this very
readable it's perfectly correct it's
more for exercise sake that we do this
conversion
now as i mentioned there are some
interesting questions regards to what
exactly is considered a non-integer and
what exactly do we mean by floating
point let's create some interesting data
let's say we take a very small value
1 times 10 to the power of negative 13
and we add it to the numbers 1 through
15.
if we print these numbers then they look
like integers and that is because by
default apl will round to
about 10 digits of precision
and then
because we've only added 10 to the power
of negative 13 to each one of these we
don't notice this however if we
format using
14 decimals
then we can see that there is actually
more to it
we could also of course say
and w minus the floor of w
and then we can see that there's a bit
of a difference there it isn't exactly
ones 1 times 10 to the power of and
and that is because
um
there are some floating point
inaccuracies at that level
and this is where things gotta be
interesting should these numbers in w be
considered floating point or not well if
you try double to apply a function f on
w
then you can see it says oh the numbers
1 through 9 are considered non-integers
but the numbers 10 through 15
are considered integers which is of
course
interesting and and odd the reason is
that apl by default has something called
the comparison tolerance which
is a multiplicative fuzz factor allowing
comparison as long as
the ratio to each other does not differ
by
more than uh
1 to the power of negative 14 or 1 plus
1 to the time 10 to the power of
negative 14. this
first factor can be set the comparison
tolerance but this is the default value
um and that is why i chose uh 1 times 10
to the power of negative 13. so as soon
as we hit 10 or more then we have we now
reached the factor of
14 orders of magnitude and their numbers
are considered equal so when we're
comparing the floor with the original
number they are now considered equal and
therefore they are filtered
away
now we can counteract that by sending
making a version of f say let's say the
comparison tolerance
including version and where we
temporarily locally set the comparison
tolerance to zero
and after that we
use the formula as before
now when we use fc on w then all 15
numbers are considered to be floating
point because we are now exact in what
we're doing
so this is the one definition that they
compare to each other another definition
is the internal representation normally
in apl you don't care much about how
things are represented internally unless
possibly you're doing some performance
optimizations but usually not for the
values themselves but we can actually
ask apl what is the data representation
of
such values and then if we go back to v
we can see that
v which we have here is stored as a
six four five six four five and the six
four means the 64 bit per element and
five means it's floating point a binary
floating point so this is a 64 bit
binary float array however quad dr also
tries to compact every argument you give
it before it tells you what the data
type is and if we apply
quite the r on each of these
then we can see that trying separately
on each element to compact them as much
as possible
the first number can fit in a 64-bit
float only and the second number 4 can
fit in 8-3 that means 8-bit and 3 means
integer so that's an 8 bit integer or 1
byte integer
and we can exploit this then we can
create a function g that selects the
argument
filtered by whether or not 645 is equal
to the data representation of each
element
and this will work on
on v
and if we try it on w
then we'll see that it also considers
all these numbers to be
flowing point values because they're in
fact restored as floating point even
when they're compacted the most because
they have this additional
1 times 10 to the power of negative 13
added to them so here comparison
tolerance doesn't matter at all
and let's make an if an interesting
one
if we take the values from v and we also
add
a very large value and it should be
noted that if i ask what is the data
representation of 1 times 10 to the
power of 400
it answers 1287.
this is not a 64-bit float because
64-bit floats do not reach such large
magnitudes instead it is a 128-bit
float and the 7 here indicates that it's
not a binary that would be 5 and 3 is
integer
but rather a decimal float so this is
using a 128-bit decimal float
representation for the large magnitude
and of course this gives a problem so
now we have we have our x
and if we try to run g on x
then
things fail spectacularly
and the reason is
that apl will internally upgrade all of
these numbers to be decimal floats and
then they get stuck there and we compare
them
so if you say the data representation of
each one of x
then
we can see that the floats all became
decimal floats and the integers are
filtered away of course and then since
we're only looking for binary floats
we're not finding anything
but we can amend
this function so let's say we have a g
which is also children for decimal
values and for that we just check for
membership in 645 or 1287
and
now we can run gd on x
and it
matches all of these so this considers 1
times 10 to the power 400
floating point which is correct as to
the internal representation however the
problem specification also said none
integer
and i'm sure you'll agree that 1 times
10 to the power 400 is very much an
integer
not in non-integer but this is depends
on how exactly you understand
the problem so a very simplistic
understanding would be
from a human perspective well it's an
integer if it's just a bunch of digits
together possibly negative and it's not
an integer if you need a decimal point
in order to write out the number and we
can write this in apl as well
so
what we'll do is we'll format each
number to a character vector
and then and we can look whether or not
there is a dot
in each of these
and if there's a dot in the character
representation of the number then it
would be a
non-integer number this is not going to
work when you use this
scaled format with an e inside but for
normal numbers it's going to work you
can also combine these two instead of
running two loops we can fuse the loops
by saying we want membership but we want
the right argument to membership to be
preprocessed with format so this is is a
dot member of the format for each one of
the numbers
and
if there's a dot then we want them
otherwise we discard them so we simply
filter by that
and and now we can try this on x and we
can see that
the 1 times 10 to the power 400 is going
to be filtered away
however if we run x on our w from before
remember w where these numbers from 1 to
15 were a little bit added and it
considers none of them to be
non-integers so it's in a way it's more
tolerant
of being close to integer
and the reason for that is because when
we format the numbers
in w they they look like this
but we can actually give a left argument
to the format function which is the
number of
decimals to add so if we add say 14
decimals to it then we can see that
we get this one at
inside the decimals
so we could depend uh amend uh the
function to do this
um if we ask for too much then it's
going to add some underscores
for digits that it cannot figure out
based on the internal representation
another way is using something called
the print precision which by default is
10 which is why we by default we'll get
10
significant digits in
in our printouts and if we change quad
pp to something large say 17 then doing
the same expression will give us more so
there's an implicit argument
to the format function let's change that
back to 10 here and
then we can
write our function h as before but this
time we make a local change to pp and
i'll set it to the maximum value that's
allowed even for decimal floats it would
be 34 digits so we take omega filter
that with whether or not a dot is a
member in the format of each of the
argument
and
now we can try it on w and now it
considers all these
near integers to be non-integers
i should probably have
given this a new name i'll do that in
the in the code that i post
okay and so much for regular ways let's
let's look at a little bit more exotic
ways of
of solving this problem
and here's one
let's say we have these these numbers v
we can take the division remainder
with
one so this is also known as modulus one
or what is left over if i do if i was to
try to
create this number just by adding ones
together and that is um a non-integer uh
if the number is non-integer and zero if
it is an integer because you can create
any zero any integer by
multiplying an integer
with one
of course that same number
and that means
that we can
compare with zero so wherever we have
zero we want to get rid of that and
whenever we have a positive value and
none nonzero then we want to keep it
so we could com you do just a comparison
with zero however we can also just take
the sign
or signum of this because we'll never
have any negative results from
the division remainder or modulus
and so this gives us our mask and we can
select
the values based on that
let's put this into a function
i
there we go
and now we can try it
um on these values so here we can see we
hit hit this problem again with
near integers
um and we could solve this by changing
the comparison tolerance locally so
let's do
ic
with comparison tolerance
so we can set that to zero
and then we have the same form as before
ic and w and now it works for all these
values and then there is a tricky thing
um which is
the represent
or
um
encode
and in code with a
takes a
so encourages is the downtake it takes a
possibly mixed radix as on the left and
represents the number or numbers on the
right as
um
in this base
however here we're not actually
interested in a full representation
we're not even interested in um
in any representation the only thing we
want to to know is that if
um
if the smallest unit in the base is a
one then would there or would there not
be a
one there and how many
ones would there be it's a bit
interesting to explain like this but
let's have a look at what it looks like
with v
and you can
notice that this is exactly the same as
division remainder which is
it actually makes sense because when
you're trying to convert to a base then
you keep subtracting as large units as
possible and then
the remainder is left over here so
what's happening here is that
we end we how many
ones are there that cannot be
represented in the larger unit um and
then we end up with a division remainder
now what's interesting with and with
encode is that it doesn't care about
comparison tolerance it's always precise
so we could actually
um
use
abuse
this
and
write it exactly the same way
without specifying comparison tolerance
and then
it would work even for these
near integers
however um i don't think this is very
clear don't write this in your
production code it's much better to set
quad ct to zero to tell the reader
what is you're actually trying to do
another way to work around it is
remember i mentioned that quad ct is
like a multiplicative uh
fuzz factor
and it's it's used to measure
relative difference between things now
if you multiply by zero of course you
get zero and the consequence of this is
that any comparison with a true zero
it the comparison tolerance doesn't
matter so even a value that is very very
small say 1 times 10 to the power of
negative 300 is not going to be
considered the same as 0.
how can we use this well if we take
these values and we subtract
their floor like we
spoke about in the beginning
and
then we can compare this to zero
and this gives us also a true comparison
so we can write now a
subtraction based version of f
that uses this system
and we can try fs on our special w and
uh
oops sorry this is wrong this should be
an unequal of course we want the ones
that are on floats there we go
and we can see that all of these near
integers are now considered
um to be
non-integers and that is because the
difference between them and
their
their floor is
very small but
it but is not equal to zero
and finally just for a bit of a joke
solution
um
if we
try to use the argument as left argument
to replicate but we're not actually
interested in using
any value so we can just replicate the
empty vector which will always give the
empty vector
then the function is subject to the
limitations in domain of the replicate
function
now the replicate function can take any
integer
positive or negative including 0 as
argument
this means that it will error if any
element
is
not an integer and that's exactly what
we're looking for so we can set up
a
error guard that says that if any error
happens it's really the main error but
let's just do any error for now
if any error happens
that means that the test
that the
argument is
non-integer and we want it
otherwise we replicate the empty vector
which gives us the empty vector
let's let's try this first so if we do
this on on v
then we get we can see the gap here so
we get an empty vector for every um
for every integer and we get the integer
and they get the number itself for
numbers that are not integers
and all we need to do now
is enlist
and that
collapses all the empty vectors away and
we just get the result we want
so
this solution also works it has horrible
performance it's completely abusing the
system
and it fails on numbers of very large
magnitude
but well
it works
subject to comparison tolerance again
like before and we now know how we can
deal with that if we want to
but that's it joking solution please
don't do thishi
we're going to check if a particular set
of bits are set in a given state of bits
this would be really trivial if not for
the fact that we're given our query bits
and our state bits as integers
so we have some conversion to do
let's take the bits that we're asking
about
um as three
and the state as 10. it'll be apparent
in a moment why I want these particular
example arguments
now these are then encoded
as normal numbers but we need to know
what the individual bits are in the
binary representation
in order for all the bits to line up
being that 10 would otherwise be a wider
number than three it's important that we
convert them together so
together let's concatenate them together
and now we can convert them to binary
we could
take a fixed with representation
and convert them to that but we can also
let APL determine how many bits are
necessary for the widest one of the two
bit patterns
we do that by using the opposite
function the the one that would converge
from the bit patterns two numbers and
running it in reverse that is applying
it negative one times so this is the
power operator applies functions
n times and this is applying it negative
one times
and we are and the way this parses out
is it's a called a fork
it means we apply this function to the
arguments 3 and 10 that gives us the
vector 3 10. and then we are applying
this function
which is the inverse base evaluation
that is an encoding two base
two
and what we get here
is one column per number so this is our
three which fits this is one times one
plus one times
two
that's three and ten is one is zero
times one plus one times two plus zero
times four plus one times eight so two
plus eight is ten
and now you can see why I chose these
particular arguments it's because then
we have all the different combinations
of bits on the left and bits on the
right represented
here we have zero with one and zero with
zero one will one and one with zero
and what does this mean that we're
querying whether these bits are set
it means we aren't interested in all the
bits on the right
we're only interested in the bits that
have a one on the left
and in that case we must also have a one
on the right
so if we go through all these these
possibilities we can see that a zero on
the left and a one on the right that is
fine that is okay
a zero on the left and a zero on the
right that is also okay
because it doesn't matter if there is
more State than what we are querying
and one on the left and one on the right
that is also okay
but a one on the left and a zero on the
right that's not okay because that means
we're querying a bit and the bit isn't
set so the answer is no
our requirements haven't been met
so
now we need to find some way to
process this Matrix
to figure out if our requirements are
met
and I think maybe the easiest way to
reason about this is to do the opposite
and say let's
look at when our requirements are not
met and that was only in this case
so being that our domain is restricted
to the booleans ones and zero
this is the only case where the left
side is greater than the right side see
here they're equal to each other and
here they're equal to each other and
here the left is less than the right
so it's only the case where the left is
greater than the right that is
problematic
which means conversely that
all the cases where it's not less than
sorry when it's not greater than and
so all the cases where left is not
greater than the right those are okay so
what is not greater than
that is less than or equal to
um let's verify this zero is less than
one
zero is well not less than but equal to
zero one is equal to one right but one
is not
less than or equal to zero it's not less
than zero it's not equal to zero
so the next step is going to be to
reduce over these rows that is we are
inserting and less than or equal to
between
the elements on each row
and we can do that with a last axis
reduction so we have less than or equal
to reduction
and this tells us that for the first
three bits our conditions have been met
Zone actually only a condition in the
third bit here
but the last one is a failure
that doesn't really matter here because
all we need to do now is to check if
they are all met we're not interested in
the individual bits so instead of doing
a single reduction we're doing two
reductions
an end reduction after we've done the
less than reduction
that tells us that the requirements are
not fully met here
okay
um this is our solution let's give it a
name
and now we can try it
do is three myth in 11.
yes it is and that's because 11 is just
like 10 but with an extra 1 bit at the
end so both of these required bits
I'm at what about 4 and 11
nope because well we have a one here
we now have in four we have one zero
zero here so that one lines up with zero
over here and then it isn't true
and that's all
thank you for watchinghi we have to count how many of each of
the letters a c g t there are in a given
character vector or scaler that's
important
here so I've redefined uh this sample
DNA string
and this is actually very simple a c GT
we want to compare each one of them with
the entire string so this is an outer
product so this does a all combinations
of elements from the left with elements
from the right this gives us this
Boolean table and all we need to know is
how many ones are there in each row so
we can just reduce here now there is a
problem um and that is if we just have a
single letter say a single C then this
outo product gives us a vector not a
matrix and then when we sum them uh then
we get a single number instead of one
number for all of them so we can fix
this by reveling this forces the scaler
to become a vector and it has no effect
on a vector and that gives us the result
that we
wanted so we can make this whole thing
into a single tested function uh like
this and it also works on our DNA
string another way we could do this is
using the key operator but that one has
a problem that things might not come out
in the right order so if you try this
with a key operator the way it works is
that it
returns uh for every element unique
element the element as a left argument
to the to the Opera function and then
the indices on the right so that means
we can count the indices and find out
how many of each there are and we can
see this is is almost right except for
the ordering here and in fact if there
weren't all the
letters then we would be missing things
so how can we fix this well if we insert
acgt before our data then we know that
they will be encountered in the right
order and we know there will be at least
one of
each and all we need to do then
is
subtract one from oops subtract one from
the result of course uh not from the
with the letters we to get rid of those
um and that gives us our right result so
here's another way that we could write
this bonus I actually have an idea for
an extension to key such that we would
be able to write this much
neater and we can import the model for
this as follows we want to get from from
GitHub from my
account you want this dialogue
vision and the symbol that we want the
model for is quad
equal it's an
operator okay now let's rename that a
bit to something that looks a little bit
more like a symbol
and now we can try it so the way it
works is that instead of taking a
um function as upper end it takes a
vocabulary as upper end so AC
GT is our
vocabulary and then
key on the DNA and it Returns the lists
of
indices just like this would have
returned if we didn't count them inside
the upper end which means we just need
to get the length of each list of
indices that would be the whole thing if
key was extended like I think it should
be thank you for watchinghi we are going to compute the next
Double critical
day um according to this bthm thing um
and all it means really is that we have
three cycles of 23 28 and 33 days and if
two of them meet each other uh then it's
called a double critical thing
um we start counting from a birthday and
then we it has to be the first time they
they meet uh any two of them meet after
a given date supposedly like the day's
date or something um and then there's a
red herring here it says the triple
critical day which you're also supposed
to check but it doesn't matter because a
triple critical day is of course a
double critical day as well there there
two and there's one more um of these
Cycles
meet we supposed to take input and give
output as year month d vectors and
that's really all does to
it so the Cycles are stated in as 23 28
and 33 days
but think of a sign curve after the
whole
period then we cross the x-axis again in
the same direction but we've already
crossed in the opposite direction once
so the actual cycle we're interested in
is um actually has half the the period
of the given
periods now let's find out uh
What uh number of days we have to
progress before we have two of these and
we can do that by finding the least
common multiple so let's make a least
common multiple table um of these of
course we're not interested in when a
cycle meets itself it does that every
time it it crosses over and we've got
the duplicates because it doesn't matter
which one comes first so we just need
the upper right corner here and then we
can we can do that so let's drain the
vectors from one to three and then we
make a comparison table and for that and
that gives us an upper right Matrix and
that's a good mask for the Matrix on the
right so we can use filtering or
compress um or replicate if you want to
call it that we just need to flatten
both first and then we get these these
these numbers are stated in the problem
statement as well um but now we know why
it is exactly these
numbers so we can uh we can call these
the the periods I
guess an example uh input
1962 uh October
31st and uh 2023 three the 1st of
January and now uh we can start coding
the first thing we need to do is we need
to transform these dates into a serial
number of dates so that we can do
computations on them um so for now let's
just say we concatenate them together
but we pre-process uh both arguments
with uh the conversion and for that we
have to treat each one as a whole we
call the datetime conversion function
and it assumes that it's a time stamp
like this so we don't have to tell it
what the input type is we just need to
tell it the output type and type one is
uh a day count from the beginning of 199
uh of
1900 so that gives us uh these and that
means we can find the difference here
between them with minus instead of
concatenation um this is negative of
course because we have a larger number
last we could swap the arguments uh to
get the positive uh difference between
them and now uh we need to find out when
the next day is so um we need to find a
whole
multiple U of these
Cycles from the first date so we can see
how how many of these Cycles are there
from and and from the first date to the
second date and then we need one uh like
how many whole Cycles are there and then
we need one more date and this calls for
a modulus operation so if we take and P
here and modulus so this means the
remainder when with this over here when
the difference rum is divided by uh
these
periods uh that gives us these values
but this is how much is left up
until the
and the last chance before the second
date and that's what remainder means
there's a clever thing in the definition
of of the remainder in APL and that is
if you negate the right argument then
instead of stopping right before the cut
off we stop right after the cut
off um we
can can't really tell that immediately
here but if we try it we can see if you
call this one b
and and this one
a then if we add
together A and
B that gives
us uh the P that we have from up here so
we can see that by negating on the right
we get one more cycle so just uh after
the cut
off so that is actually what we uh what
we after
now what
remains is that we we don't want to know
how many days after the the current date
the date on the right and it happens we
want to know the actual date so we take
the date on the right and we add that
offset we need to do go beyond that date
we need to find the first thing which
could be zero if it's evenly
divisible now we have the State numbers
and all the remains is to convert the
other way so that's negative one so
we're converting two a time
stamp and oh we forgot one thing we have
to uh we have to find the first one of
them it doesn't matter which one so we
can before we go here we want to take
this the lowest one and then it will
make the formulation easier to realize
that we're doing a reduction over Vector
uh of on a scalar function's result that
can be combined into an inner product is
exactly the same thing okay now we can
convert uh to
date and it's enclosed remember we
enclosed this to treat it as a whole and
that's the same thing over here so we're
going to disclose here uh for that
effect to get the whole thing and then
it has date and time and we're not
interested in the time so we just need
to take the first three oh first three
elements uh from that I'm binding these
two together because we have a Mantic
function here so it fits in the in the
trainer
form and uh now we
can actually go and Define our function
directly we could so we can put in the
actual value of uh over here and get rid
of these given
arguments you still need parenthesis
over
here and we have our function and then
we can call our function with these
arguments and just for good order let's
see what happens if we give it the same
argument both sides then it should say
that that date itself is uh its own
critical date because all the curves
start there so they kind of intersect
there and that's really all there's to
it thank you for
watchinghi
we're going to convert the labels that
you see at the top of the columns in for
example Excel or any other spreadsheet
manager to the number from that
of that column in the whole sheet
it might sound straightforward a to the
end of the alphabet is
1 to 26 and then you go to a a for 27
and then a b and so on
is actually deceptively simple and the
solution is also simple
but what's actually going on is
interesting
so let's start off with
um
then a and and then
those are really easy we if we look now
up in the alphabet we get 1 and then
26.
then it gets more interesting because
the next one after Z is a a
that's one one but it's supposed to be
27.
clearly this is kind of a positional
system the further left a character is
the
more significance it has but it's not
just base 26 because there's no zero
here
it does however work
if we say this is in one one base 26
because that's
1 times 26 to the power 1 plus 1 that's
27 so if you evaluate this in in base 26
we get the right result
where things get really interesting is
what actually happens when you have a z
so this gives us a 26 26 is not a valid
digit number in base 26 just like 10 is
not a digit in our normal Decimal System
we only have from zero to nine
zeros are skipped here because we never
get anything that has the index 0
in the alphabet
so what's actually happening here when
you evaluate this in base 26 is that API
allows
digit position values to have a number
that is higher than the base
and it just uh overflows with a carry to
the next position so when we have 26
ones
then that overflows to become well 26
plus 1 times 26.
um in in if it was 126 here it's
implicitly 0 26 so that overflows and
just becomes zero plus twenty and six
um and so that actually works
nope
and if we do this also with say a z
where we get 126
then this means there are 26 ones
and 126 so that's
we just add them together
um
and we get 52.
and if we had a b here we would add that
together again
um
so there's one 26 and then
226s
and if you go up to even larger numbers
here then we'll see how the the carry is
going to carry over so there are 26
plus 26 26s
and so on it doesn't matter that it will
overflow to the next position we just
add them all up we do the multiplication
with the powers and then we add it all
up so we can write our full solution to
the problem
as with binding
the alphabet as left argument to the
lookup function Iota and then we
evaluate in base 26. so that's that's
our solution we can put in anything
um here and get the right result
to really understand what's going on it
might be a good idea to you know emulate
the functionality of the base evaluation
here also known as decode
so what's actually happening let's uh go
back to these numbers for a moment
is we get these three values here and
this is all base 26. so these are the
these are the ones these are the 26s and
these are the 26 squareds
that means we can get the powers
by
starting off with
three numbers like this we can reverse
them because we have descending Powers
these are the the highest one and then
they are too high by one so we can
subtract one
here
and then we have 26 to the power of that
that gives us the weights for the
positions and then we can multiply by
our numbers
and sum that
or alternatively we could use an inner
product
to do this
and that is actually what's happening
here that we're taking
the length of the argument and finding
those powers and then just adding it all
up and it doesn't matter that they are
too large they overflow and they
couldn't really represent it in that in
that system
so we can write this here as
quad a
be looking up the right argument and
over here instead of
Iota and three we have the tally of an
argument so now we can do APL over here
of course there's no reason to actually
write this because we have the Primitive
that does this but this could help give
an understanding about why this works
even though we're using digit position
values that are actually too high for
the number system
thank you for watchingwelcome to the appeal Quest see APL Wiki
for details
today's Quest is the fifth from the 2016
round of the APL problem solving
competition
we are to find the elements of a list
that only once in that list that is
those that have no duplicates
let's start by defining a function it's
an anonymous function we're giving it a
name right now but we're going to apply
it to an argument
a very simple way to go about this is to
compare every element in this array
let's say list a vector a one a
one-dimensional array
to every element that is we're making a
comparison table
so we take
the argument
and compared to the argument but we want
to do all combinations so not just
equality
but this jut dot together makes a table
so this is a quality table
so imagine that we have the letters of
hello world going down
on the left and going across on the
right
and we can see which elements match
which elements so of course the diagonal
is all ones because elements match
themselves
but we can see that there are duplicates
when they match multiple
and so and by counting how many matches
there are for each element then we can
see which ones only appear once
and we can do so by summing so
if we Sum along the columns or along the
rows it doesn't really matter but let's
just do the columns for now then we can
get a count per element
and sum is a reduction using plus so we
use plus and this slash bar means
reduction
and you can see here that each number
corresponds to
how many ones there are in the column
above
now we want only the numbers
that are 1 so
we can compare one to all of that
and we can see here that the ones
compare we get a one true
where we have L1 and then we just need
to filter
the argument using this bit mask so we
take this bit mask and use it to filter
we can do that again with a slash bar
but this time we have a mask on the left
so now it doesn't mean reduced now it
means filtering also known as compress
on the argument itself
and we get H and E that only appear once
the L's are two of those the two o's we
skip that there's a single space w
appears once and so on
so this is one solution albeit n not
very good one because it does a lot of
computation that is unnecessary for
example this table is way bigger than it
needs to be
we don't need to compare every element
to every element we could compare just
to the unique elements
so how can we find the unique elements
well we can use the unique function
which looks like an A U
and this gives us just the unique
elements
now we can compare to those
and this gives us
a smaller table
and if we now
count how many they are of each of the
unique we get a mask we can then apply
to the unique
and we get the same result with a little
bit less computation
wait we are Computing the unique twice
that seems a bit wasteful as well so we
give the compute computed unique value
and a name U and then we can use that
over here
which is a bit better
that said API can actually do a lot of
this for you and it will do so more
efficiently by using the built-in that's
made exactly for this kind of work
so let's remove everything here we have
the argument and there's a special
operator it's called which is a higher
order function called key and it takes a
function on the left and applies this
function to
some properties of the argument on the
right
it's applying it this function over and
over again once for each unique element
so there we have it inside the unique
elements
um and the unique elements are given as
left argument whenever we apply so Alpha
is the the left argument being the
leftmost character in the Greek alphabet
and as right argument
Omega
Omega being the right most character in
the Greek alphabet
it gives all the indices where these
this unique element occurs
so we can see that the H appears only in
position one e position in only in
position two L appears and three four
and also 10 over here and O at 5 and 8.
now we're not actually interested in
where they are we're only interested in
how many there are
so
we can get rid of the left argument
and it gives us just the indices and
we're not even interested in what
exactly indices are but just how many so
we use tally which looks like a tally
marker like a counting stick
and this gives us the counts for each
one so this was the same we got before
when we made the table and summed the
columns
and then we can take it from here we can
compare
to one
and use this as a mask
on the unique elements
and this solves the problem but
this key operator actually computes the
unique Elements by itself and we're also
Computing the unique elements outside
which isn't the best
remember we can get the unique elements
as left argument in this function which
means the information is actually
available we just need to change the
structure of the result coming back so
that we can get all the information we
need and apply it
so let's try that
we have the count over here
and we can actually do the comparison
with one in here as well
then we get this mask directly
and then we can concatenate
the left argument which is the unique
element
so comma is concatenate
and we can see we get this table of
which ones are the ones that that we
want which means we really have a mask
here
and we have the Theta over here we just
need to apply this mask this column to
the column on the left
as we saw before
the the filtering function was known as
compress
takes the mask on the left and the data
on the right so we really want to have
the unique elements on the right and
this mask generating expression on the
left
we could put parenthesis around this
expression and move the comma over on
the side but we can also use a special
higher order function or operator
called commute which takes this function
on the left much like key takes this
user-defined function on the left
and the only thing it does to it is it
changes the order of the argument so the
left argument becomes left the right
argument the right argument comes
becomes the left argument and this just
gives us the two columns in opposite
order
foreign
this
a two column table or Matrix into two
vectors and we can do that by
concatenating vertically so we're
concatenating the first element over
here with the first element over here
and so on and concatening the second
element of the second elements
so we want to concatenate vertically so
just like we used the slash bar as a
vertical sum now we're using it for
vertical concatenation and that gives us
these two elements which are the mask
and the data that we want to apply the
mask to
before we use compress infix we use the
between two arguments
but now we have the two arguments in a
list next to each other so we need to
insert
the compression function
in between the elements which is again a
type of reduction but just over two
elements so slash bar here means the
um the filtering or compress and then
slash bar again because it has a
function next to it it means insert or
reduce
now there's one little issue here you
can see this box around the result and
that is because we start off with a
vector a list of two elements which has
a single Dimension we're counting one
element and then two elements and reduce
the name implies that it needs to reduce
the rank the number of Dimensions so it
goes from one dimension to zero
Dimensions how can it have a
multi-element array in zero Dimensions
so it packages it up in an enclosure
that's this box we're seeing but we can
this close that we open it up so this
kind of looks like a a mouth that uh is
away from the array and it opens it up
that gives us our result so this is
another solution
and finally a really clever solution
that somebody came up with
there is a function called unique mask
which instead of returning to the unique
elements
it returns a mask indicating the first
occurrence of every unique element
that's this equal sign with only one an
unequal sign with only one argument on
the right
so this says that H is the first
uh
and the first a the first H is the first
is H and this this e is the first e and
the this L is the first L and this L is
not the first of its type
now
what we're actually interested in here
is to remove all the elements that are
duplicate
so which elements are the ones that
are have duplicates well that would be
the opposite of the ones
that are the first so if we use logical
negation here
then yes we need to remove all the else
and this
if you use this mask it would not give
us an L but this would give us an L so
we guaranteed
for every element that has every unique
element that has duplicates we are
guaranteed to get at least one
element from this mask
and so we can apply this
to the argument itself so we're using
this compressed function but the math
needs to be on the left so we commute
the arguments
and this gives us all the elements that
we want to all the types of elements
universe that we want to remove
it doesn't matter that there are
duplicates
now we can take the argument itself
and then we use set difference so if you
use the tilde with both the left and the
right argument it doesn't mean not the
Boolean not it means but not or except
so it's set difference it's everything
here on the left but not those things
that are on the right
and that gives us
the elements that appear on new ones
thank you for watchinghi we have to compare two version
numbers each version number has three
parts and then we have to answer whether
the left one is an earlier version the
same version or a later version than the
right
one so let's have an example
here one two
3 and 1
32 now as a human I can immediately see
that the one on the right is the newer
one but it's actually a little bit
involved uh what's happening here
because I must be scanning from the
beginning to see what the first part is
that differs so the first one is
irrelevant they're the same only the
second part is important and that means
that the third part isn't important the
fact that this one has a higher number
here um this one over here has a lower
number it doesn't matter because an
earlier number is more
important so let's make a tested
solution to
this we need to compare corresponding
elements and the comparison of size that
we can do with a
subtraction and so here we can see that
this part is an earlier number than this
part and this one is a later number than
this one um that corresponds to the
negative one and one here and then the
first digit the first number is the same
that's why we get a
zero we're not actually interested in
um the the difference itself so let's
say uh that over here we had a
four then we had a difference of and of
two and we're not actually interested in
the zeros
either so
and what we can do is we can remove the
zeros so we can use a set difference
with zero and because we doing
everything in a functional uh style
everything in terms of fun uh functions
we have to mark this zero as being a
constant function so this zero is a
actually a function uh zero with this
symbol to DS is actually a function that
takes these two arguments and and value
is to Z and then we use that with as
with set subtraction from the
differences between these numbers and
these
numbers and that gives
us-12 so we've gotten rid of uh one part
that we're not interested in second part
we're not interested in is the actual
magnitude of differences we only want to
know which one it is so we use uh the
multiplication symbol with only one ARG
argument that is the Signum the sign and
that will convert any number that's
larger than uh in magnitude than one so
one or anything beyond one or negative 1
or
zero leaves them down at one or negative
one or
zero and finally we want to prioritize
the first difference right the anything
that is the same we already eliminated
with removing the zeros
um but we want the first one so we have
a first function that we glue together
with the Signum function so this is a
new function that we have composed and
we applying that to the result of this
set difference between the subtraction
and the
zero and that gives
US1 but uh we can actually do this in a
little bit different way as well that I
think is really cleverly thought
out let's go back to the Set uh to the
difference between these version
numbers and we are not interested in the
magnitude so we apply this time the
Signum function glue together composed
with this
difference and instead of trying to
eliminate the zeros and then finding the
first one
then we can uh evaluate this in base two
as a binary
number now if the magnitude in if there
were multiple differences then this
could be a larger number we can take an
example of uh of that so let's backtrack
a moment and do 625 over here and 713
over here so now
we have two differences over here where
and where the left one is larger and one
where the left one is
smaller and now we evaluate this in
binary
and we we
get um ne1 because this and and this is
a bit interesting what's happening here
because I'm saying I'm evaluating in in
as binary
but normally you use the binary being
only digits zero and
one but here we also have negative ones
so what does this mean it's actually
really not that
complicated uh what's happening is we
have these uh these numbers and they are
just values for the digit positions so
digit positions in a binary system with
three bits so to say bits not really
bits because they can be negative one
well the first one is four the second
one is two and the third one is uh one
the last one is one so we could multiply
that that gives us our total and
amount and then we just need to sum it
all up to get the final result so we can
add a plus reduction here in the front
and that gives
US-1 um of course if we had the same
value at the end then we would get
something with a larger magnitude
so uh we at the very end we need to
again take the Signum the sign um
because we don't want a larger number
than uh than negative one or larger
magnitude than negative one and
one and let's go back to how we actually
spell that so this is the the binary
evaluation of that and then we can take
the Signum of that for the actual
solution
and yeah this seems clever but do we
really understand what's going on
here it works but why is it that it
works let's go back to this example we
had before with
625 and think about it for a
moment here we have basically the worst
case um possible what we should be
afraid of is that maybe uh a lot of
trailing numbers that are greater here
on the left but smaller on the right
would weigh out they would add up to so
much that even though the first number
is smaller than the than the um first
one on the right it would still
overweigh it so we would consider this
to be a larger number what if we had a
lot of huge numbers on the left and and
a lot of smaller numbers and on the
right and the um the important thing
here to understand is that the binary
system is exactly
this it it has the property that if you
add up all the fully set bits
and trailing bits then they add up to
exactly one less than uh the next larger
bit well that's nice we know that about
a normal binary system but what about uh
we have these negative numbers well that
can never make it any
worse
because if we have any zeros on on um
negative 1es here of course that adds up
to even
less um and over here we
[Music]
and
the the negative value here is well in
in in magnitude larger than the sum of
anything that could be here so it all
works out to reevaluate in binary um
even though it's not actually true bits
it's can also be negative and then we
take the sign of that um and we get the
correct
result thank you for watching
